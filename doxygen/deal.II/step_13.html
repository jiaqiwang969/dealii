<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_13.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-13 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-13 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_6.html">step-6</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Backgroundandpurpose">Background and purpose</a>
        <li><a href="#Whattheprogramdoes">What the program does</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Evaluationofthesolution">Evaluation of the solution</a>
      <ul>
        <li><a href="#Pointevaluation">%Point evaluation</a>
        <li><a href="#Generatingoutput">Generating output</a>
        <li><a href="#Otherevaluations">Other evaluations</a>
      </ul>
        <li><a href="#TheLaplacesolverclasses">The Laplace solver classes</a>
      <ul>
        <li><a href="#Anabstractbaseclass">An abstract base class</a>
        <li><a href="#Ageneralsolverclass">A general solver class</a>
        <li><a href="#Aprimalsolver">A primal solver</a>
        <li><a href="#Globalrefinement">Global refinement</a>
        <li><a href="#LocalrefinementbytheKellyerrorindicator">Local refinement by the Kelly error indicator</a>
      </ul>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#Thedriverroutines">The driver routines</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Backgroundandpurpose"></a></p><h3>Background and purpose</h3>
<p>In this example program, we will not so much be concerned with describing new ways how to use deal.II and its facilities, but rather with presenting methods of writing modular and extensible finite element programs. The main reason for this is the size and complexity of modern research software: applications implementing modern error estimation concepts and adaptive solution methods tend to become rather large. For example, when this program was written in 2002, the three largest applications by the main authors of deal.II, are at the time of writing of this example program: </p><ol>
<li>
a program for solving conservation hyperbolic equations by the Discontinuous Galerkin Finite Element method: 33,775 lines of code; </li>
<li>
a parameter estimation program: 28,980 lines of code; </li>
<li>
a wave equation solver: 21,020 lines of code. </li>
</ol>
<p>(The library proper - without example programs and test suite - has slightly more than 150,000 lines of code as of spring 2002. It is of course several times larger now.) The sizes of these applications are at the edge of what one person, even an experienced programmer, can manage.</p>
<p>The numbers above make one thing rather clear: monolithic programs that are not broken up into smaller, mostly independent pieces have no way of surviving, since even the author will quickly lose the overview of the various dependencies between different parts of a program. Only data encapsulation, for example using object oriented programming methods, and modularization by defining small but fixed interfaces can help structure data flow and mutual interdependencies. It is also an absolute prerequisite if more than one person is developing a program, since otherwise confusion will quickly prevail as one developer would need to know if another changed something about the internals of a different module if they were not cleanly separated.</p>
<p>In previous examples, you have seen how the library itself is broken up into several complexes each building atop the underlying ones, but relatively independent of the other ones: </p><ol>
<li>
the triangulation class complex, with associated iterator classes; </li>
<li>
the finite element classes; </li>
<li>
the <a class="el" href="classDoFHandler.html">DoFHandler</a> class complex, with associated iterators, built on the triangulation and finite element classes; </li>
<li>
the classes implementing mappings between unit and real cells; </li>
<li>
the <a class="el" href="classFEValues.html">FEValues</a> class complex, built atop the finite elements and mappings. </li>
</ol>
<p>Besides these, and a large number of smaller classes, there are of course the following "tool" modules: </p><ol>
<li>
output in various graphical formats; </li>
<li>
linear algebra classes. </li>
</ol>
<p>These complexes can also be found as a flow chart on the front page of the deal.II manual website.</p>
<p>The goal of this program is now to give an example of how a relatively simple finite element program could be structured such that we end up with a set of modules that are as independent of each other as possible. This allows to change the program at one end, without having to worry that it might break at the other, as long as we do not touch the interface through which the two ends communicate. The interface in C++, of course, is the declaration of abstract base classes.</p>
<p>Here, we will implement (again) a Laplace solver, although with a number of differences compared to previous example programs: </p><ol>
<li>
The classes that implement the process of numerically solving the equation are no more responsible for driving the process of "solving-estimating error-refining-solving again", but we delegate this to external functions. This allows first to use it as a building block in a larger context, where the solution of a Laplace equation might only be one part (for example, in a nonlinear problem, where Laplace equations might have to be solved in each nonlinear step). It would also allow to build a framework around this class that would allow using solvers for other equations (but with the same external interface) instead, in case some techniques shall be evaluated for different types of partial differential equations. </li>
<li>
It splits the process of evaluating the computed solution to a separate set of classes. The reason is that one is usually not interested in the solution of a PDE per se, but rather in certain aspects of it. For example, one might wish to compute the traction at a certain boundary in elastic computations, or in the signal of a seismic wave at a receiver position at a given location. Sometimes, one might have an interest in several of these aspects. Since the evaluation of a solution is something that does not usually affect the process of solution, we split it off into a separate module, to allow for the development of such evaluation filters independently of the development of the solver classes. </li>
<li>
Separate the classes that implement mesh refinement from the classes that compute the solution. </li>
<li>
Separate the description of the test case with which we will present the program, from the rest of the program. </li>
<li>
Parallelize the assembly of linear systems using the <a class="el" href="namespaceWorkStream.html">WorkStream</a> facilities. This follows the extensive description that can be found in the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a> documentation module. The implementation essentially follows what has already been described in <a class="el" href="step_9.html">step-9</a>. </li>
</ol>
<p>The things the program does are not new. In fact, this is more like a melange of previous programs, cannibalizing various parts and functions from earlier examples. It is the way they are arranged in this program that should be the focus of the reader, i.e. the software design techniques used in the program to achieve the goal of implementing the desired mathematical method. However, we must stress that software design is in part also a subjective matter: different persons have different programming backgrounds and have different opinions about the "right" style of programming; this program therefore expresses only what the author considers useful practice, and is not necessarily a style that you have to adopt in order to write successful numerical software if you feel uncomfortable with the chosen ways. It should serve as a case study, however, inspiring the reader with ideas to the desired end.</p>
<p>Once you have worked through the program, you will remark that it is already somewhat complex in its structure. Nevertheless, it only has about 850 lines of code, without comments. In real applications, there would of course be comments and class documentation, which would bring that to maybe 1200 lines. Yet, compared to the applications listed above, this is still small, as they are 20 to 25 times as large. For programs as large, a proper design right from the start is thus indispensable. Otherwise, it will have to be redesigned at one point in its life, once it becomes too large to be manageable.</p>
<p>Despite of this, all three programs listed above have undergone major revisions, or even rewrites. The wave program, for example, was once entirely teared to parts when it was still significantly smaller, just to assemble it again in a more modular form. By that time, it had become impossible to add functionality without affecting older parts of the code (the main problem with the code was the data flow: in time dependent application, the major concern is when to store data to disk and when to reload it again; if this is not done in an organized fashion, then you end up with data released too early, loaded too late, or not released at all). Although the present example program thus draws from several years of experience, it is certainly not without flaws in its design, and in particular might not be suited for an application where the objective is different. It should serve as an inspiration for writing your own application in a modular way, to avoid the pitfalls of too closely coupled codes.</p>
<p><a class="anchor" id="Whattheprogramdoes"></a></p><h3>What the program does</h3>
<p>What the program actually does is not even the main point of this program, the structure of the program is more important. However, in a few words, a description would be: solve the Laplace equation for a given right hand side such that the solution is the function \(u(x,t)=\exp(x+\sin(10y+5x^2))\). The goal of the computation is to get the value of the solution at the point \(x_0=(0.5,0.5)\), and to compare the accuracy with which we resolve this value for two refinement criteria, namely global refinement and refinement by the error indicator by Kelly et al. which we have already used in previous examples.</p>
<p>The results will, as usual, be discussed in the respective section of this document. In doing so, we will find a slightly irritating observation about the relative performance of the two refinement criteria. In a later example program, building atop this one, we will devise a different method that should hopefully perform better than the techniques discussed here.</p>
<p>So much now for all the theoretical and anecdotal background. The best way of learning about a program is to look at it, so here it is:</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>As in all programs, we start with a list of include files from the library, and as usual they are in the standard order which is <code>base</code> &ndash; <code>lac</code> &ndash; <code>grid</code> &ndash; <code>dofs</code> &ndash; <code>fe</code> &ndash; <code>numerics</code> (as each of these categories roughly builds upon previous ones), then C++ standard headers:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="table__handler_8h.html">deal.II/base/table_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="thread__management_8h.html">deal.II/base/thread_management.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div></div><!-- fragment --><p>Now for the C++ standard headers:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step13</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Evaluationofthesolution"></a> </p><h3>Evaluation of the solution</h3>
<p>As for the program itself, we first define classes that evaluate the solutions of a Laplace equation. In fact, they can evaluate every kind of solution, as long as it is described by a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object, and a solution vector. We define them here first, even before the classes that actually generate the solution to be evaluated, since we need to declare an abstract base class that the solver classes can refer to.</p>
<p>From an abstract point of view, we declare a pure base class that provides an evaluation operator() which will do the evaluation of the solution (whatever derived classes might consider an <code>evaluation</code>). Since this is the only real function of this base class (except for some bookkeeping machinery), one usually terms such a class that only has an <code>operator()</code> a <code>functor</code> in C++ terminology, since it is used just like a function object.</p>
<p>Objects of this functor type will then later be passed to the solver object, which applies it to the solution just computed. The evaluation objects may then extract any quantity they like from the solution. The advantage of putting these evaluation functions into a separate hierarchy of classes is that by design they cannot use the internals of the solver object and are therefore independent of changes to the way the solver works. Furthermore, it is trivial to write another evaluation class without modifying the solver class, which speeds up programming (not being able to use internals of another class also means that you do not have to worry about them &ndash; programming evaluators is usually a rather quickly done task), as well as compilation (if solver and evaluation classes are put into different files: the solver only needs to see the declaration of the abstract base class, and therefore does not need to be recompiled upon addition of a new evaluation class, or modification of an old one). On a related note, you can reuse the evaluation classes for other projects, solving different equations.</p>
<p>In order to improve separation of code into different modules, we put the evaluation classes into a namespace of their own. This makes it easier to actually solve different equations in the same program, by assembling it from existing building blocks. The reason for this is that classes for similar purposes tend to have the same name, although they were developed in different contexts. In order to be able to use them together in one program, it is necessary that they are placed in different namespaces. This we do here:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Evaluation</div><div class="line">{</div></div><!-- fragment --><p>Now for the abstract base class of evaluation classes: its main purpose is to declare a pure virtual function <code>operator()</code> taking a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object, and the solution vector. In order to be able to use pointers to this base class only, it also has to declare a virtual destructor, which however does nothing. Besides this, it only provides for a little bit of bookkeeping: since we usually want to evaluate solutions on subsequent refinement levels, we store the number of the present refinement cycle, and provide a function to change this number.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>EvaluationBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~EvaluationBase() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution) <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> EvaluationBase&lt;dim&gt;::set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step)</div><div class="line">{</div><div class="line">  refinement_cycle = step;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Pointevaluation"></a> </p><h4>Point evaluation</h4>
<p>The next thing is to implement actual evaluation classes. As noted in the introduction, we'd like to extract a point value from the solution, so the first class does this in its <code>operator()</code>. The actual point is given to this class through the constructor, as well as a table object into which it will put its findings.</p>
<p>Finding out the value of a finite element field at an arbitrary point is rather difficult, if we cannot rely on knowing the actual finite element used, since then we cannot, for example, interpolate between nodes. For simplicity, we therefore assume here that the point at which we want to evaluate the field is actually a node. If, in the process of evaluating the solution, we find that we did not encounter this point upon looping over all vertices, we then have to throw an exception in order to signal to the calling functions that something has gone wrong, rather than silently ignore this error.</p>
<p>In the <a class="el" href="step_9.html">step-9</a> example program, we have already seen how such an exception class can be declared, using the <code>DeclExceptionN</code> macros. We use this mechanism here again.</p>
<p>From this, the actual declaration of this class should be evident. Note that of course even if we do not list a destructor explicitly, an implicit destructor is generated from the compiler, and it is virtual just as the one of the base class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PointValueEvaluation : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PointValueEvaluation(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point,</div><div class="line">                       <a class="code" href="classTableHandler.html">TableHandler</a> &amp;    results_table);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a>(</div><div class="line">    ExcEvaluationPointNotFound,</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div><div class="line">  <a class="code" href="classTableHandler.html">TableHandler</a> &amp;   results_table;</div><div class="line">};</div></div><!-- fragment --><p>As for the definition, the constructor is trivial, just taking data and storing it in object-local ones:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">PointValueEvaluation&lt;dim&gt;::PointValueEvaluation(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point,</div><div class="line">  <a class="code" href="classTableHandler.html">TableHandler</a> &amp;    results_table)</div><div class="line">  : evaluation_point(evaluation_point)</div><div class="line">  , results_table(results_table)</div><div class="line">{}</div></div><!-- fragment --><p>Now for the function that is mainly of interest in this class, the computation of the point value:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PointValueEvaluation&lt;dim&gt;::</div><div class="line">     operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>First allocate a variable that will hold the point value. Initialize it with a value that is clearly bogus, so that if we fail to set it to a reasonable value, we will note at once. This may not be necessary in a function as small as this one, since we can easily see all possible paths of execution here, but it proved to be helpful for more complex cases, and so we employ this strategy here as well.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a> = 1e20;</div></div><!-- fragment --><p>Then loop over all cells and all their vertices, and check whether a vertex matches the evaluation point. If this is the case, then extract the point value, set a flag that we have found the point of interest, and exit the loop.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> evaluation_point_found = <span class="keyword">false</span>;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (!evaluation_point_found)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex : cell-&gt;vertex_indices())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;vertex(vertex) == evaluation_point)</div><div class="line">        {</div></div><!-- fragment --><p>In order to extract the point value from the global solution vector, pick that component that belongs to the vertex of interest, and, in case the solution is vector-valued, take the first component of it:</p>
<div class="fragment"><div class="line">point_value = solution(cell-&gt;vertex_dof_index(vertex, 0));</div></div><!-- fragment --><p>Note that by this we have made an assumption that is not valid always and should be documented in the class declaration if this were code for a real application rather than a tutorial program: we assume that the finite element used for the solution we try to evaluate actually has degrees of freedom associated with vertices. This, for example, does not hold for discontinuous elements, were the support points for the shape functions happen to be located at the vertices, but are not associated with the vertices but rather with the cell interior, since association with vertices would imply continuity there. It would also not hold for edge oriented elements, and the like.</p>
<p>Ideally, we would check this at the beginning of the function, for example by a statement like <code>Assert (dof_handler.get_fe().dofs_per_vertex &gt; 0, <a class="el" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented()</a>)</code>, which should make it quite clear what is going wrong when the exception is triggered. In this case, we omit it (which is indeed bad style), but knowing that that does not hurt here, since the statement <code>cell-&gt;vertex_dof_index(vertex,0)</code> would fail if we asked it to give us the DoF index of a vertex if there were none.</p>
<p>We stress again that this restriction on the allowed finite elements should be stated in the class documentation.</p>
<p>Since we found the right point, we now set the respective flag and exit the innermost loop. The outer loop will also be terminated due to the set flag.</p>
<div class="fragment"><div class="line">  evaluation_point_found = <span class="keyword">true</span>;</div><div class="line">  <span class="keywordflow">break</span>;</div><div class="line">};</div></div><!-- fragment --><p>Finally, we'd like to make sure that we have indeed found the evaluation point, since if that were not so we could not give a reasonable value of the solution there and the rest of the computations were useless anyway. So make sure through the <code>AssertThrow</code> macro already used in the <a class="el" href="step_9.html">step-9</a> program that we have indeed found this point. If this is not so, the macro throws an exception of the type that is given to it as second argument, but compared to a straightforward <code>throw</code> statement, it fills the exception object with a set of additional information, for example the source file and line number where the exception was generated, and the condition that failed. If you have a <code>catch</code> clause in your main function (as this program has), you will catch all exceptions that are not caught somewhere in between and thus already handled, and this additional information will help you find out what happened and where it went wrong.</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_point_found,</div><div class="line">            ExcEvaluationPointNotFound(evaluation_point));</div></div><!-- fragment --><p>Note that we have used the <code>Assert</code> macro in other example programs as well. It differed from the <code>AssertThrow</code> macro used here in that it simply aborts the program, rather than throwing an exception, and that it did so only in debug mode. It was the right macro to use to check about the size of vectors passed as arguments to functions, and the like.</p>
<p>However, here the situation is different: whether we find the evaluation point or not may change from refinement to refinement (for example, if the four cells around point are coarsened away, then the point may vanish after refinement and coarsening). This is something that cannot be predicted from a few number of runs of the program in debug mode, but should be checked always, also in production runs. Thus the use of the <code>AssertThrow</code> macro here.</p>
<p>Now, if we are sure that we have found the evaluation point, we can add the results into the table of results:</p>
<div class="fragment"><div class="line">  results_table.add_value(<span class="stringliteral">&quot;DoFs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  results_table.add_value(<span class="stringliteral">&quot;u(x_0)&quot;</span>, point_value);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Generatingoutput"></a> </p><h4>Generating output</h4>
<p>A different, maybe slightly odd kind of <code>evaluation</code> of a solution is to output it to a file in a graphical format. Since in the evaluation functions we are given a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object and the solution vector, we have all we need to do this, so we can do it in an evaluation class. The reason for actually doing so instead of putting it into the class that computed the solution is that this way we have more flexibility: if we choose to only output certain aspects of it, or not output it at all. In any case, we do not need to modify the solver class, we just have to modify one of the modules out of which we build this program. This form of encapsulation, as above, helps us to keep each part of the program rather simple as the interfaces are kept simple, and no access to hidden data is possible.</p>
<p>Since this class which generates the output is derived from the common <code>EvaluationBase</code> base class, its main interface is the <code>operator()</code> function. Furthermore, it has a constructor taking a string that will be used as the base part of the file name to which output will be sent (we will augment it by a number indicating the number of the refinement cycle &ndash; the base class has this information at hand &ndash;, and a suffix), and the constructor also takes a value that indicates which format is requested, i.e. for which graphics program we shall generate output (from this we will then also generate the suffix of the filename to which we write).</p>
<p>Regarding the output format, the <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> namespace provides an enumeration field <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> which lists names for all supported output formats. At the time of writing of this program, the supported graphics formats are represented by the enum values <code>ucd</code>, <code>gnuplot</code>, <code>povray</code>, <code>eps</code>, <code>gmv</code>, <code>tecplot</code>, <code>tecplot_binary</code>, <code>dx</code>, <code>vtk</code>, etc, but this list will certainly grow over time. Now, within various functions of that base class, you can use values of this type to get information about these graphics formats (for example the default suffix used for files of each format), and you can call a generic <code>write</code> function, which then branches to the <code>write_gnuplot</code>, <code>write_ucd</code>, etc functions which we have used in previous examples already, based on the value of a second argument given to it denoting the required output format. This mechanism makes it simple to write an extensible program that can decide which output format to use at runtime, and it also makes it rather simple to write the program in a way such that it takes advantage of newly implemented output formats, without the need to change the application program.</p>
<p>Of these two fields, the base name and the output format descriptor, the constructor takes values and stores them for later use by the actual evaluation function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SolutionOutput : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SolutionOutput(<span class="keyword">const</span> std::string &amp;             output_name_base,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> std::string               output_name_base;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">SolutionOutput&lt;dim&gt;::SolutionOutput(</div><div class="line">  <span class="keyword">const</span> std::string &amp;             output_name_base,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format)</div><div class="line">  : output_name_base(output_name_base)</div><div class="line">  , output_format(output_format)</div><div class="line">{}</div></div><!-- fragment --><p>Following the description above, the function generating the actual output is now relatively straightforward. The only particularly interesting feature over previous example programs is the use of the <a class="el" href="namespaceDataOutBase.html#aed25a6ddf928a6904fd1ac942125ec86">DataOutBase::default_suffix</a> function, returning the usual suffix for files of a given format (e.g. ".eps" for encapsulated postscript files, ".gnuplot" for Gnuplot files), and of the generic <a class="el" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">DataOut::write()</a> function with a second argument, which internally branches to the actual output functions for the different graphics formats, based on the value of the format descriptor passed as second argument.</p>
<p>Also note that we have to prefix <code>this-&gt;</code> to access a member variable of the template dependent base class. The reason here, and further down in the program is the same as the one described in the <a class="el" href="step_7.html">step-7</a> example program (look for <code>two-stage name lookup</code> there).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SolutionOutput&lt;dim&gt;::operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                     <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream out(output_name_base + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                    <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(this-&gt;refinement_cycle) +</div><div class="line">                    data_out.<a class="code" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a>(output_format));</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a>(out, output_format);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Otherevaluations"></a> </p><h4>Other evaluations</h4>
<p>In practical applications, one would add here a list of other possible evaluation classes, representing quantities that one may be interested in. For this example, that much shall be sufficient, so we close the namespace.</p>
<div class="fragment"><div class="line">} <span class="comment">// namespace Evaluation</span></div></div><!-- fragment --><p><a class="anchor" id="TheLaplacesolverclasses"></a> </p><h3>The Laplace solver classes</h3>
<p>After defining what we want to know of the solution, we should now care how to get at it. We will pack everything we need into a namespace of its own, for much the same reasons as for the evaluations above.</p>
<p>Since we have discussed Laplace solvers already in considerable detail in previous examples, there is not much new stuff following. Rather, we have to a great extent cannibalized previous examples and put them, in slightly different form, into this example program. We will therefore mostly be concerned with discussing the differences to previous examples.</p>
<p>Basically, as already said in the introduction, the lack of new stuff in this example is deliberate, as it is more to demonstrate software design practices, rather than mathematics. The emphasis in explanations below will therefore be more on the actual implementation.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>LaplaceSolver</div><div class="line">{</div></div><!-- fragment --><p><a class="anchor" id="Anabstractbaseclass"></a> </p><h4>An abstract base class</h4>
<p>In defining a Laplace solver, we start out by declaring an abstract base class, that has no functionality itself except for taking and storing a pointer to the triangulation to be used later.</p>
<p>This base class is very general, and could as well be used for any other stationary problem. It provides declarations of functions that shall, in derived classes, solve a problem, postprocess the solution with a list of evaluation objects, and refine the grid, respectively. None of these functions actually does something itself in the base class.</p>
<p>Due to the lack of actual functionality, the programming style of declaring very abstract base classes is similar to the style used in Smalltalk or Java programs, where all classes are derived from entirely abstract classes <code>Object</code>, even number representations. The author admits that he does not particularly like the use of such a style in C++, as it puts style over reason. Furthermore, it promotes the use of virtual functions for everything (for example, in Java, all functions are virtual per se), which, however, has proven to be rather inefficient in many applications where functions are often only accessing data, not doing computations, and therefore quickly return; the overhead of virtual functions can then be significant. The opinion of the author is to have abstract base classes wherever at least some part of the code of actual implementations can be shared and thus separated into the base class.</p>
<p>Besides all these theoretical questions, we here have a good reason, which will become clearer to the reader below. Basically, we want to be able to have a family of different Laplace solvers that differ so much that no larger common subset of functionality could be found. We therefore just declare such an abstract base class, taking a pointer to a triangulation in the constructor and storing it henceforth. Since this triangulation will be used throughout all computations, we have to make sure that the triangulation is valid until it is last used. We do this by keeping a <code><a class="el" href="classSmartPointer.html">SmartPointer</a></code> to this triangulation, as explained in <a class="el" href="step_7.html">step-7</a>.</p>
<p>Note that while the pointer itself is declared constant (i.e. throughout the lifetime of this object, the pointer points to the same object), it is not declared as a pointer to a constant triangulation. In fact, by this we allow that derived classes refine or coarsen the triangulation within the <code>refine_grid</code> function.</p>
<p>Finally, we have a function <code>n_dofs</code> is only a tool for the driver functions to decide whether we want to go on with mesh refinement or not. It returns the number of degrees of freedom the present simulation has.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Base</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid);</div><div class="line">  <span class="keyword">virtual</span> ~Base() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> solve_problem() = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div><div class="line">    <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const</span> = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span>         refine_grid()                            = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const</span>                           = 0;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;Triangulation&lt;dim&gt;</a>&gt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">};</div></div><!-- fragment --><p>The implementation of the only two non-abstract functions is then rather boring:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Base&lt;dim&gt;::Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid)</div><div class="line">  : triangulation(&amp;coarse_grid)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="Ageneralsolverclass"></a> </p><h4>A general solver class</h4>
<p>Following now the main class that implements assembling the matrix of the linear system, solving it, and calling the postprocessor objects on the solution. It implements the <code>solve_problem</code> and <code>postprocess</code> functions declared in the base class. It does not, however, implement the <code>refine_grid</code> method, as mesh refinement will be implemented in a number of derived classes.</p>
<p>It also declares a new abstract virtual function, <code>assemble_rhs</code>, that needs to be overloaded in subclasses. The reason is that we will implement two different classes that will implement different methods to assemble the right hand side vector. This function might also be interesting in cases where the right hand side depends not simply on a continuous function, but on something else as well, for example the solution of another discretized problem, etc. The latter happens frequently in non-linear problems.</p>
<p>As we mentioned previously, the actual content of this class is not new, but a mixture of various techniques already used in previous examples. We will therefore not discuss them in detail, but refer the reader to these programs.</p>
<p>Basically, in a few words, the constructor of this class takes pointers to a triangulation, a finite element, and a function object representing the boundary values. These are either passed down to the base class's constructor, or are stored and used to generate a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object later. Since finite elements and quadrature formula should match, it is also passed a quadrature object.</p>
<p>The <code>solve_problem</code> sets up the data structures for the actual solution, calls the functions to assemble the linear system, and solves it.</p>
<p>The <code>postprocess</code> function finally takes an evaluation object and applies it to the computed solution.</p>
<p>The <code>n_dofs</code> function finally implements the pure virtual function of the base class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Solver : <span class="keyword">public</span> <span class="keyword">virtual</span> Base&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">         <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">         <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">         <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line">  <span class="keyword">virtual</span> ~Solver() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> solve_problem() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div><div class="line">    <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const override</span>;</div></div><!-- fragment --><p>In the protected section of this class, we first have a number of member variables, of which the use should be clear from the previous examples:</p>
<div class="fragment"><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const FiniteElement&lt;dim&gt;</a>&gt; fe;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Quadrature&lt;dim&gt;</a>&gt;    quadrature;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                              dof_handler;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                               solution;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt;      boundary_values;</div></div><!-- fragment --><p>Then we declare an abstract function that will be used to assemble the right hand side. As explained above, there are various cases for which this action differs strongly in what is necessary, so we defer this to derived classes:</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;rhs) <span class="keyword">const</span> = 0;</div></div><!-- fragment --><p>Next, in the private section, we have a small class which represents an entire linear system, i.e. a matrix, a right hand side, and a solution vector, as well as the constraints that are applied to it, such as those due to hanging nodes. Its constructor initializes the various subobjects, and there is a function that implements a conjugate gradient method as solver.</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">struct </span>LinearSystem</div><div class="line">  {</div><div class="line">    LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>           sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>      <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            rhs;</div><div class="line">  };</div></div><!-- fragment --><p>Finally, there is a set of functions which will be used to assemble the actual system matrix. The main function of this group, <code>assemble_linear_system()</code> computes the matrix in parallel on multicore systems, using the following two helper functions. The mechanism for doing so is the same as in the <a class="el" href="step_9.html">step-9</a> example program and follows the <a class="el" href="namespaceWorkStream.html">WorkStream</a> concept outlined in <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> . The main function also calls the virtual function assembling the right hand side.</p>
<div class="fragment"><div class="line">  <span class="keyword">struct </span>AssemblyScratchData</div><div class="line">  {</div><div class="line">    AssemblyScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature);</div><div class="line">    AssemblyScratchData(<span class="keyword">const</span> AssemblyScratchData &amp;scratch_data);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">struct </span>AssemblyCopyData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_linear_system(LinearSystem &amp;linear_system);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> local_assemble_matrix(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">    AssemblyScratchData &amp;                                 scratch_data,</div><div class="line">    AssemblyCopyData &amp;                                    copy_data) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div><div class="line">                            LinearSystem &amp;          linear_system) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>Now here comes the constructor of the class. It does not do much except store pointers to the objects given, and generate <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object initialized with the given pointer to a triangulation. This causes the DoF handler to store that pointer, but does not already generate a finite element numbering (we only ask for that in the <code>solve_problem</code> function).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solver&lt;dim&gt;::Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">  : Base&lt;dim&gt;(triangulation)</div><div class="line">  , fe(&amp;fe)</div><div class="line">  , quadrature(&amp;quadrature)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , boundary_values(&amp;boundary_values)</div><div class="line">{}</div></div><!-- fragment --><p>The destructor is simple, it only clears the information stored in the DoF handler object to release the memory.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solver&lt;dim&gt;::~Solver()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">}</div></div><!-- fragment --><p>The next function is the one which delegates the main work in solving the problem: it sets up the DoF handler object with the finite element given to the constructor of this object, the creates an object that denotes the linear system (i.e. the matrix, the right hand side vector, and the solution vector), calls the function to assemble it, and finally solves it:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::solve_problem()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(*fe);</div><div class="line">  solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  LinearSystem linear_system(dof_handler);</div><div class="line">  assemble_linear_system(linear_system);</div><div class="line">  linear_system.solve(solution);</div><div class="line">}</div></div><!-- fragment --><p>As stated above, the <code>postprocess</code> function takes an evaluation object, and applies it to the computed solution. This function may be called multiply, once for each evaluation of the solution which the user required.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::postprocess(</div><div class="line">  <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  postprocessor(dof_handler, solution);</div><div class="line">}</div></div><!-- fragment --><p>The <code>n_dofs</code> function should be self-explanatory:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Solver&lt;dim&gt;::n_dofs()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>();</div><div class="line">}</div></div><!-- fragment --><p>The following function assembles matrix and right hand side of the linear system to be solved in each step. We will do things in parallel at a couple of levels. First, note that we need to assemble both the matrix and the right hand side. These are independent operations, and we should do this in parallel. To this end, we use the concept of "tasks" that is discussed in the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> documentation module. In essence, what we want to say "here is something that needs to be worked on, go do it
 whenever a CPU core is available", then do something else, and when we need the result of the first operation wait for its completion. At the second level, we want to assemble the matrix using the exact same strategy we have already used in <a class="el" href="step_9.html">step-9</a>, namely the <a class="el" href="namespaceWorkStream.html">WorkStream</a> concept.</p>
<p>While we could consider either assembling the right hand side or assembling the matrix as the thing to do in the background while doing the other, we will opt for the former approach simply because the call to <code>Solver::assemble_rhs</code> is so much simpler to write than the call to <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> with its many arguments. In any case, the code then looks like this to assemble the entire linear system:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::assemble_linear_system(LinearSystem &amp;linear_system)</div><div class="line">{</div><div class="line">  <a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> rhs_task =</div><div class="line">    <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a>(&amp;Solver&lt;dim&gt;::assemble_rhs, *<span class="keyword">this</span>, linear_system.rhs);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> worker =</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">           AssemblyScratchData &amp;scratch_data,</div><div class="line">           AssemblyCopyData &amp;   copy_data) {</div><div class="line">      this-&gt;local_assemble_matrix(cell, scratch_data, copy_data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> copier = [<span class="keyword">this</span>, &amp;linear_system](<span class="keyword">const</span> AssemblyCopyData &amp;copy_data) {</div><div class="line">    this-&gt;copy_local_to_global(copy_data, linear_system);</div><div class="line">  };</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                  dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                  worker,</div><div class="line">                  copier,</div><div class="line">                  AssemblyScratchData(*fe, *quadrature),</div><div class="line">                  AssemblyCopyData());</div><div class="line">  linear_system.hanging_node_constraints.condense(linear_system.matrix);</div></div><!-- fragment --><p>The syntax above requires some explanation. There are multiple version of <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> that expect different arguments. In <a class="el" href="step_9.html">step-9</a>, we used one version that took a pair of iterators, a pair of pointers to member functions with very specific argument lists, a pointer or reference to the object on which these member functions have to work, and a scratch and copy data object. This is a bit restrictive since the member functions called this way have to have an argument list that exactly matches what <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> expects: the local assembly function needs to take an iterator, a scratch object and a copy object; and the copy-local-to-global function needs to take exactly a copy object. But, what if we want something that's slightly more general? For example, in the current program, the copy-local-to-global function needs to know which linear system object to write the local contributions into, i.e., it also has to take a <code>LinearSystem</code> argument. That won't work with the approach using member function pointers.</p>
<p>Fortunately, C++ offers a way out. These are called function objects. In essence, what <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> wants to do is not call a member function. It wants to call some function that takes an iterator, a scratch object and a copy object in the first case, and a copy object in the second case. Whether these are member functions, global functions, or something else, is really not of much concern to <a class="el" href="namespaceWorkStream.html">WorkStream</a>. Consequently, there is a second version of the function that just takes function objects &ndash; objects that have an <code>operator()</code> and that consequently can be called like functions, whatever they really represent. The typical way to generate such function objects is using a <a href="http://en.wikipedia.org/wiki/Anonymous_function">lambda function</a> that wraps the function call including the individual arguments with fixed values. All the arguments that are part of the outer function signature are specified as regular function arguments in the lambda function. The fixed values are passed into the lambda function using the capture list (<code>[...]</code>). It is possible to use a capture default or to list all the variables that are to be bound to the lambda explicitly. For the sake of clarity we decided to omit the capture default here, but that capture list could equally well be <code>[&amp;]</code>, meaning that all used variables are copied into the lambda by reference.</p>
<p>At this point, we have assembled the matrix and condensed it. The right hand side may or may not have been completely assembled, but we would like to condense the right hand side vector next. We can only do this if the assembly of this vector has finished, so we have to wait for the task to finish; in computer science, waiting for a task is typically called "joining" the task, explaining the name of the function we call below.</p>
<p>Since that task may or may not have finished, and since we may have to wait for it to finish, we may as well try to pack other things that need to be done anyway into this gap. Consequently, we first interpolate boundary values before we wait for the right hand side. Of course, another possibility would have been to also interpolate the boundary values on a separate task since doing so is independent of the other things we have done in this function so far. Feel free to find the correct syntax to also create a task for this interpolation and start it at the top of this function, along with the assembly of the right hand side. (You will find that this is slightly more complicated since there are multiple versions of <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a>, and so simply taking the address <code>&amp;<a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a></code> produces a set of overloaded functions that can't be passed to <a class="el" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task()</a> right away &ndash; you have to select which element of this overload set you want by casting the address expression to a function pointer type that is specific to the version of the function that you want to call on the task.)</p>
<div class="fragment"><div class="line">std::map&lt;types::global_dof_index, double&gt; boundary_value_map;</div><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                         0,</div><div class="line">                                         *boundary_values,</div><div class="line">                                         boundary_value_map);</div><div class="line"></div><div class="line">rhs_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div><div class="line">linear_system.hanging_node_constraints.condense(linear_system.rhs);</div></div><!-- fragment --><p>Now that we have the complete linear system, we can also treat boundary values, which need to be eliminated from both the matrix and the right hand side:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_value_map,</div><div class="line">                                     linear_system.matrix,</div><div class="line">                                     solution,</div><div class="line">                                     linear_system.rhs);</div><div class="line">}</div></div><!-- fragment --><p>The second half of this set of functions deals with the local assembly on each cell and copying local contributions into the global matrix object. This works in exactly the same way as described in <a class="el" href="step_9.html">step-9</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature)</div><div class="line">  : fe_values(fe, quadrature, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div><div class="line">  <span class="keyword">const</span> AssemblyScratchData &amp;scratch_data)</div><div class="line">  : fe_values(scratch_data.fe_values.get_fe(),</div><div class="line">              scratch_data.fe_values.get_quadrature(),</div><div class="line">              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::local_assemble_matrix(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  AssemblyScratchData &amp;                                 scratch_data,</div><div class="line">  AssemblyCopyData &amp;                                    copy_data)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe-&gt;<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature-&gt;size();</div><div class="line"></div><div class="line">  copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  copy_data.local_dof_indices.resize(dofs_per_cell);</div><div class="line"></div><div class="line">  scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        copy_data.cell_matrix(i, j) +=</div><div class="line">          (scratch_data.fe_values.shape_grad(i, q_point) *</div><div class="line">           scratch_data.fe_values.shape_grad(j, q_point) *</div><div class="line">           scratch_data.fe_values.JxW(q_point));</div><div class="line"></div><div class="line">  cell-&gt;get_dof_indices(copy_data.local_dof_indices);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div><div class="line">                                       LinearSystem &amp;linear_system)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; copy_data.local_dof_indices.size(); ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; copy_data.local_dof_indices.size(); ++j)</div><div class="line">      linear_system.matrix.add(copy_data.local_dof_indices[i],</div><div class="line">                               copy_data.local_dof_indices[j],</div><div class="line">                               copy_data.cell_matrix(i, j));</div><div class="line">}</div></div><!-- fragment --><p>Now for the functions that implement actions in the linear system class. First, the constructor initializes all data elements to their correct sizes, and sets up a number of additional data structures, such as constraints due to hanging nodes. Since setting up the hanging nodes and finding out about the nonzero elements of the matrix is independent, we do that in parallel (if the library was configured to use concurrency, at least; otherwise, the actions are performed sequentially). Note that we start only one thread, and do the second action in the main thread. Since only one task is generated, we don't use the <code><a class="el" href="classThreads_1_1TaskGroup.html">Threads::TaskGroup</a></code> class here, but rather use the one created task object directly to wait for this particular task's exit.</p>
<p>Note that taking up the address of the <code><a class="el" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a></code> function is a little tricky, since there are actually three of them, one for each supported space dimension. Taking addresses of overloaded functions is somewhat complicated in C++, since the address-of operator <code>&amp;</code> in that case returns more like a set of values (the addresses of all functions with that name), and selecting the right one is then the next step. If the context dictates which one to take (for example by assigning to a function pointer of known type), then the compiler can do that by itself, but if this set of pointers shall be given as the argument to a function that takes a template, the compiler could choose all without having a preference for one. We therefore have to make it clear to the compiler which one we would like to have; for this, we could use a cast, but for more clarity, we assign it to a temporary <code>mhnc_p</code> (short for <code>pointer to make_hanging_node_constraints</code>) with the right type, and using this pointer instead.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solver&lt;dim&gt;::LinearSystem::LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  hanging_node_constraints.clear();</div><div class="line"></div><div class="line">  void (*mhnc_p)(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;, <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;) =</div><div class="line">    &amp;<a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>;</div></div><!-- fragment --><p>Start a side task then continue on the main thread</p>
<div class="fragment"><div class="line"><a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> side_task =</div><div class="line">  <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a>(mhnc_p, dof_handler, hanging_node_constraints);</div><div class="line"></div><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div></div><!-- fragment --><p>Wait for the side task to be done before going further</p>
<div class="fragment"><div class="line">side_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div><div class="line"></div><div class="line">hanging_node_constraints.close();</div><div class="line">hanging_node_constraints.condense(dsp);</div><div class="line">sparsity_pattern.copy_from(dsp);</div></div><!-- fragment --><p>Finally initialize the matrix and right hand side vector</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>.reinit(sparsity_pattern);</div><div class="line">  rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p>The second function of this class simply solves the linear system by a preconditioned conjugate gradient method. This has been extensively discussed before, so we don't dwell into it any more.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::LinearSystem::solve(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, 1.2);</div><div class="line"></div><div class="line">  cg.solve(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, solution, rhs, preconditioner);</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Aprimalsolver"></a> </p><h4>A primal solver</h4>
<p>In the previous section, a base class for Laplace solvers was implemented, that lacked the functionality to assemble the right hand side vector, however, for reasons that were explained there. Now we implement a corresponding class that can do this for the case that the right hand side of a problem is given as a function object.</p>
<p>The actions of the class are rather what you have seen already in previous examples already, so a brief explanation should suffice: the constructor takes the same data as does that of the underlying class (to which it passes all information) except for one function object that denotes the right hand side of the problem. A pointer to this object is stored (again as a <code><a class="el" href="classSmartPointer.html">SmartPointer</a></code>, in order to make sure that the function object is not deleted as long as it is still used by this class).</p>
<p>The only functional part of this class is the <code>assemble_rhs</code> method that does what its name suggests.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PrimalSolver : <span class="keyword">public</span> Solver&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt; rhs_function;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;rhs) <span class="keyword">const override</span>;</div><div class="line">};</div></div><!-- fragment --><p>The constructor of this class basically does what it is announced to do above...</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">PrimalSolver&lt;dim&gt;::PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">  : Base&lt;dim&gt;(triangulation)</div><div class="line">  , Solver&lt;dim&gt;(triangulation, fe, quadrature, boundary_values)</div><div class="line">  , rhs_function(&amp;rhs_function)</div><div class="line">{}</div></div><!-- fragment --><p>... as does the <code>assemble_rhs</code> function. Since this is explained in several of the previous example programs, we leave it at that.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PrimalSolver&lt;dim&gt;::assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;rhs)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(*this-&gt;fe,</div><div class="line">                          *this-&gt;quadrature,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = this-&gt;fe-&gt;<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = this-&gt;quadrature-&gt;size();</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       cell_rhs(dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt;                  rhs_values(n_q_points);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : this-&gt;dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_rhs = 0;</div><div class="line">      fe_values.reinit(cell);</div><div class="line">      rhs_function-&gt;value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                               rhs_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * </div><div class="line">                         rhs_values[q_point] *               </div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Globalrefinement"></a> </p><h4>Global refinement</h4>
<p>By now, all functions of the abstract base class except for the <code>refine_grid</code> function have been implemented. We will now have two classes that implement this function for the <code>PrimalSolver</code> class, one doing global refinement, one a form of local refinement.</p>
<p>The first, doing global refinement, is rather simple: its main function just calls <code>triangulation-&gt;refine_global (1);</code>, which does all the work.</p>
<p>Note that since the <code>Base</code> base class of the <code>Solver</code> class is virtual, we have to declare a constructor that initializes the immediate base class as well as the abstract virtual one.</p>
<p>Apart from this technical complication, the class is probably simple enough to be left without further comments.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RefinementGlobal : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  RefinementGlobal(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">RefinementGlobal&lt;dim&gt;::RefinementGlobal(</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">  : Base&lt;dim&gt;(coarse_grid)</div><div class="line">  , PrimalSolver&lt;dim&gt;(coarse_grid,</div><div class="line">                      fe,</div><div class="line">                      quadrature,</div><div class="line">                      rhs_function,</div><div class="line">                      boundary_values)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> RefinementGlobal&lt;dim&gt;::refine_grid()</div><div class="line">{</div><div class="line">  this-&gt;triangulation-&gt;<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LocalrefinementbytheKellyerrorindicator"></a> </p><h4>Local refinement by the Kelly error indicator</h4>
<p>The second class implementing refinement strategies uses the Kelly refinement indicator used in various example programs before. Since this indicator is already implemented in a class of its own inside the deal.II library, there is not much t do here except cal the function computing the indicator, then using it to select a number of cells for refinement and coarsening, and refinement the mesh accordingly.</p>
<p>Again, this should now be sufficiently standard to allow the omission of further comments.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RefinementKelly : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  RefinementKelly&lt;dim&gt;::RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;rhs_function,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;boundary_values)</div><div class="line">    : Base&lt;dim&gt;(coarse_grid)</div><div class="line">    , PrimalSolver&lt;dim&gt;(coarse_grid,</div><div class="line">                        fe,</div><div class="line">                        quadrature,</div><div class="line">                        rhs_function,</div><div class="line">                        boundary_values)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> RefinementKelly&lt;dim&gt;::refine_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(</div><div class="line">      this-&gt;triangulation-&gt;<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      this-&gt;dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(this-&gt;fe-&gt;<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      this-&gt;solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(*this-&gt;triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line">    this-&gt;triangulation-&gt;<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace LaplaceSolver</span></div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>As this is one more academic example, we'd like to compare exact and computed solution against each other. For this, we need to declare function classes representing the exact solution (for comparison and for the Dirichlet boundary values), as well as a class that denotes the right hand side of the equation (this is simply the Laplace operator applied to the exact solution we'd like to recover).</p>
<p>For this example, let us choose as exact solution the function \(u(x,y)=exp(x+sin(10y+5x^2))\). In more than two dimensions, simply repeat the sine-factor with <code>y</code> replaced by <code>z</code> and so on. Given this, the following two classes are probably straightforward from the previous examples.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Solution&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void)component;</div><div class="line">  <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">  <span class="keywordtype">double</span> q = p(0);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">    q += std::sin(10 * p(i) + 5 * p(0) * p(0));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> exponential = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(q);</div><div class="line">  <span class="keywordflow">return</span> exponential;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void)component;</div><div class="line">  <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">  <span class="keywordtype">double</span> q = p(0);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">    q += std::sin(10 * p(i) + 5 * p(0) * p(0));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> u  = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(q);</div><div class="line">  <span class="keywordtype">double</span>       t1 = 1, t2 = 0, t3 = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      t1 += <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) * 10 * p(0);</div><div class="line">      t2 += 10 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) -</div><div class="line">            100 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(10 * p(i) + 5 * p(0) * p(0)) * p(0) * p(0);</div><div class="line">      t3 += 100 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) *</div><div class="line">              <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) -</div><div class="line">            100 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(10 * p(i) + 5 * p(0) * p(0));</div><div class="line">    };</div><div class="line">  t1 = t1 * t1;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> -u * (t1 + t2 + t3);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thedriverroutines"></a> </p><h3>The driver routines</h3>
<p>What is now missing are only the functions that actually select the various options, and run the simulation on successively finer grids to monitor the progress as the mesh is refined.</p>
<p>This we do in the following function: it takes a solver object, and a list of postprocessing (evaluation) objects, and runs them with intermittent mesh refinement:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> run_simulation(</div><div class="line">  LaplaceSolver::Base&lt;dim&gt; &amp;                          solver,</div><div class="line">  <span class="keyword">const</span> std::list&lt;Evaluation::EvaluationBase&lt;dim&gt; *&gt; &amp;postprocessor_list)</div><div class="line">{</div></div><!-- fragment --><p>We will give an indicator of the step we are presently computing, in order to keep the user informed that something is still happening, and that the program is not in an endless loop. This is the head of this status line:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle: &quot;</span>;</div></div><!-- fragment --><p>Then start a loop which only terminates once the number of degrees of freedom is larger than 20,000 (you may of course change this limit, if you need more &ndash; or less &ndash; accuracy from your program).</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; <span class="keyword">true</span>; ++step)</div><div class="line">  {</div></div><!-- fragment --><p>Then give the <code>alive</code> indication for this iteration. Note that the <code>std::flush</code> is needed to have the text actually appear on the screen, rather than only in some buffer that is only flushed the next time we issue an end-line.</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; step &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::flush;</div></div><!-- fragment --><p>Now solve the problem on the present grid, and run the evaluators on it. The long type name of iterators into the list is a little annoying, but could be shortened by an alias, if so desired.</p>
<div class="fragment"><div class="line">solver.solve_problem();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;postprocessor : postprocessor_list)</div><div class="line">  {</div><div class="line">    postprocessor-&gt;set_refinement_cycle(step);</div><div class="line">    solver.postprocess(*postprocessor);</div><div class="line">  };</div></div><!-- fragment --><p>Now check whether more iterations are required, or whether the loop shall be ended:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">if</span> (solver.n_dofs() &lt; 20000)</div><div class="line">    solver.refine_grid();</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">};</div></div><!-- fragment --><p>Finally end the line in which we displayed status reports:</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>The final function is one which takes the name of a solver (presently "kelly" and "global" are allowed), creates a solver object out of it using a coarse grid (in this case the ubiquitous unit square) and a finite element object (here the likewise ubiquitous bilinear one), and uses that solver to ask for the solution of the problem on a sequence of successively refined grids.</p>
<p>The function also sets up two of evaluation functions, one evaluating the solution at the point (0.5,0.5), the other writing out the solution to a file.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> solve_problem(<span class="keyword">const</span> std::string &amp;solver_name)</div><div class="line">{</div></div><!-- fragment --><p>First minor task: tell the user what is going to happen. Thus write a header line, and a line with all '-' characters of the same length as the first one right below.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string header =</div><div class="line">  <span class="stringliteral">&quot;Running tests with \&quot;&quot;</span> + solver_name + <span class="stringliteral">&quot;\&quot; refinement criterion:&quot;</span>;</div><div class="line">std::cout &lt;&lt; header &lt;&lt; std::endl</div><div class="line">          &lt;&lt; std::string(header.size(), <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div></div><!-- fragment --><p>Then set up triangulation, finite element, etc.</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>    fe(1);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature(4);</div><div class="line">RightHandSide&lt;dim&gt; rhs_function;</div><div class="line">Solution&lt;dim&gt;      boundary_values;</div></div><!-- fragment --><p>Create a solver object of the kind indicated by the argument to this function. If the name is not recognized, throw an exception! The respective solver object is stored in a <code>std::unique_ptr</code> to avoid having to delete the pointer after use.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;LaplaceSolver::Base&lt;dim&gt;&gt; solver;</div><div class="line"><span class="keywordflow">if</span> (solver_name == <span class="stringliteral">&quot;global&quot;</span>)</div><div class="line">  solver = std::make_unique&lt;LaplaceSolver::RefinementGlobal&lt;dim&gt;&gt;(</div><div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, rhs_function, boundary_values);</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (solver_name == <span class="stringliteral">&quot;kelly&quot;</span>)</div><div class="line">  solver = std::make_unique&lt;LaplaceSolver::RefinementKelly&lt;dim&gt;&gt;(</div><div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, rhs_function, boundary_values);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div></div><!-- fragment --><p>Next create a table object in which the values of the numerical solution at the point (0.5,0.5) will be stored, and create a respective evaluation object:</p>
<div class="fragment"><div class="line"><a class="code" href="classTableHandler.html">TableHandler</a>                          results_table;</div><div class="line">Evaluation::PointValueEvaluation&lt;dim&gt; postprocessor1(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5),</div><div class="line">                                                     results_table);</div></div><!-- fragment --><p>Also generate an evaluator which writes out the solution:</p>
<div class="fragment"><div class="line">Evaluation::SolutionOutput&lt;dim&gt; postprocessor2(std::string(<span class="stringliteral">&quot;solution-&quot;</span>) +</div><div class="line">                                                 solver_name,</div><div class="line">                                               <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">DataOutBase::gnuplot</a>);</div></div><!-- fragment --><p>Take these two evaluation objects and put them in a list...</p>
<div class="fragment"><div class="line">std::list&lt;Evaluation::EvaluationBase&lt;dim&gt; *&gt; postprocessor_list;</div><div class="line">postprocessor_list.push_back(&amp;postprocessor1);</div><div class="line">postprocessor_list.push_back(&amp;postprocessor2);</div></div><!-- fragment --><p>... which we can then pass on to the function that actually runs the simulation on successively refined grids:</p>
<div class="fragment"><div class="line">run_simulation(*solver, postprocessor_list);</div></div><!-- fragment --><p>When this all is done, write out the results of the point evaluations:</p>
<div class="fragment"><div class="line">results_table.<a class="code" href="classTableHandler.html#a45c4ec9981f3880c6c852ed3aceb08fe">write_text</a>(std::cout);</div></div><!-- fragment --><p>And one blank line after all results:</p>
<div class="fragment"><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step13</span></div></div><!-- fragment --><p>There is not much to say about the main function. It follows the same pattern as in all previous examples, with attempts to catch thrown exceptions, and displaying as much information as possible if we should get some. The rest is self-explanatory.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step13::solve_problem&lt;2&gt;(<span class="stringliteral">&quot;global&quot;</span>);</div><div class="line">      Step13::solve_problem&lt;2&gt;(<span class="stringliteral">&quot;kelly&quot;</span>);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The results of this program are not that interesting - after all its purpose was not to demonstrate some new mathematical idea, and also not how to program with deal.II, but rather to use the material which we have developed in the previous examples to form something which demonstrates a way to build modern finite element software in a modular and extensible way.</p>
<p>Nevertheless, we of course show the results of the program. Of foremost interest is the point value computation, for which we had implemented the corresponding evaluation class. The results (i.e. the output) of the program looks as follows: </p><div class="fragment"><div class="line">Running tests with <span class="stringliteral">&quot;global&quot;</span> refinement criterion:</div><div class="line">-------------------------------------------------</div><div class="line">Refinement cycle: 0 1 2 3 4 5 6</div><div class="line">DoFs  u(x_0)</div><div class="line">   25 1.2868</div><div class="line">   81 1.6945</div><div class="line">  289 1.4658</div><div class="line"> 1089 1.5679</div><div class="line"> 4225 1.5882</div><div class="line">16641 1.5932</div><div class="line">66049 1.5945</div><div class="line"></div><div class="line">Running tests with <span class="stringliteral">&quot;kelly&quot;</span> refinement criterion:</div><div class="line">------------------------------------------------</div><div class="line">Refinement cycle: 0 1 2 3 4 5 6 7 8 9 10 11</div><div class="line">DoFs  u(x_0)</div><div class="line">   25 1.2868</div><div class="line">   47 0.8775</div><div class="line">   89 1.5365</div><div class="line">  165 1.2974</div><div class="line">  316 1.6442</div><div class="line">  589 1.5221</div><div class="line"> 1093 1.5724</div><div class="line"> 2042 1.5627</div><div class="line"> 3766 1.5916</div><div class="line"> 7124 1.5876</div><div class="line">13111 1.5942</div><div class="line">24838 1.5932</div></div><!-- fragment --><p>What surprises here is that the exact value is 1.59491554..., and that it is apparently surprisingly complicated to compute the solution even to only one per cent accuracy, although the solution is smooth (in fact infinitely often differentiable). This smoothness is shown in the graphical output generated by the program, here coarse grid and the first 9 refinement steps of the Kelly refinement indicator:</p>
<table width="80%" align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-0.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-1.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-2.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-3.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-4.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-5.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-6.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-7.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-8.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-9.png"/>
</div>
   </td></tr>
</table>
<p>While we're already at watching pictures, this is the eighth grid, as viewed from top:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.grid-kelly-8.png"/>
</div>
<p>However, we are not yet finished with evaluation the point value computation. In fact, plotting the error \(e=|u(x_0)-u_h(x_0)|\) for the two refinement criteria yields the following picture:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.error.png"/>
</div>
<p>What <em>is</em> disturbing about this picture is that not only is the adaptive mesh refinement not better than global refinement as one would usually expect, it is even significantly worse since its convergence is irregular, preventing all extrapolation techniques when using the values of subsequent meshes! On the other hand, global refinement provides a perfect \(1/N\) or \(h^{-2}\) convergence history and provides every opportunity to even improve on the point values by extrapolation. Global mesh refinement must therefore be considered superior in this example! This is even more surprising as the evaluation point is not somewhere in the left part where the mesh is coarse, but rather to the right and the adaptive refinement should refine the mesh around the evaluation point as well.</p>
<p>We thus close the discussion of this example program with a question:</p>
<p><b><em>What is wrong with adaptivity if it is not better than global refinement?</em></b></p>
<p><em>Exercise at the end of this example:</em> There is a simple reason for the bad and irregular behavior of the adapted mesh solutions. It is simple to find out by looking at the mesh around the evaluation point in each of the steps - the data for this is in the output files of the program. An exercise would therefore be to modify the mesh refinement routine such that the problem (once you remark it) is avoided. The second exercise is to check whether the results are then better than global refinement, and if so if even a better order of convergence (in terms of the number of degrees of freedom) is achieved, or only by a better constant.</p>
<p>(<em>Very brief answers for the impatient:</em> at steps with larger errors, the mesh is not regular at the point of evaluation, i.e. some of the adjacent cells have hanging nodes; this destroys some superapproximation effects of which the globally refined mesh can profit. Answer 2: this quick hack </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> refinement_indicated = <span class="keyword">false</span>;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;vertex(v) == <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(.5,.5))</div><div class="line">          {</div><div class="line">            cell-&gt;clear_coarsen_flag();</div><div class="line">            refinement_indicated |= cell-&gt;refine_flag_set();</div><div class="line">          }</div><div class="line"><span class="keywordflow">if</span> (refinement_indicated)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;vertex(v) == <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(.5,.5))</div><div class="line">            cell-&gt;set_refine_flag ();</div></div><!-- fragment --><p> in the refinement function of the Kelly refinement class right before executing refinement would improve the results (exercise: what does the code do?), making them consistently better than global refinement. Behavior is still irregular, though, so no results about an order of convergence are possible.)</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2001 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, University of Heidelberg, 2001, 2002</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="table__handler_8h.html">deal.II/base/table_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="thread__management_8h.html">deal.II/base/thread_management.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step13</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>Evaluation</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>EvaluationBase</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      <span class="keyword">virtual</span> ~EvaluationBase() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                              <span class="keyword">const</span> Vector&lt;double&gt; &amp; solution) <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> EvaluationBase&lt;dim&gt;::set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step)</div><div class="line">    {</div><div class="line">      refinement_cycle = step;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>PointValueEvaluation : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      PointValueEvaluation(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point,</div><div class="line">                           <a class="code" href="classTableHandler.html">TableHandler</a> &amp;    results_table);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                              <span class="keyword">const</span> Vector&lt;double&gt; &amp; solution) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a>(</div><div class="line">        ExcEvaluationPointNotFound,</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div><div class="line">      <a class="code" href="classTableHandler.html">TableHandler</a> &amp;   results_table;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    PointValueEvaluation&lt;dim&gt;::PointValueEvaluation(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point,</div><div class="line">      <a class="code" href="classTableHandler.html">TableHandler</a> &amp;    results_table)</div><div class="line">      : evaluation_point(evaluation_point)</div><div class="line">      , results_table(results_table)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> PointValueEvaluation&lt;dim&gt;::</div><div class="line">         operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">               <span class="keyword">const</span> Vector&lt;double&gt; &amp; solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordtype">double</span> point_value = 1e20;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> evaluation_point_found = <span class="keyword">false</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">if</span> (!evaluation_point_found)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex : cell-&gt;vertex_indices())</div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;vertex(vertex) == evaluation_point)</div><div class="line">              {</div><div class="line">                point_value = solution(cell-&gt;vertex_dof_index(vertex, 0));</div><div class="line"></div><div class="line">                evaluation_point_found = <span class="keyword">true</span>;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">              };</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_point_found,</div><div class="line">                  ExcEvaluationPointNotFound(evaluation_point));</div><div class="line"></div><div class="line">      results_table.<a class="code" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a>(<span class="stringliteral">&quot;DoFs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      results_table.<a class="code" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a>(<span class="stringliteral">&quot;u(x_0)&quot;</span>, point_value);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>SolutionOutput : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      SolutionOutput(<span class="keyword">const</span> std::string &amp;             output_name_base,</div><div class="line">                     <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                              <span class="keyword">const</span> Vector&lt;double&gt; &amp; solution) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> std::string               output_name_base;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    SolutionOutput&lt;dim&gt;::SolutionOutput(</div><div class="line">      <span class="keyword">const</span> std::string &amp;             output_name_base,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format)</div><div class="line">      : output_name_base(output_name_base)</div><div class="line">      , output_format(output_format)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> SolutionOutput&lt;dim&gt;::operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                         <span class="keyword">const</span> Vector&lt;double&gt; &amp; solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">      data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">      std::ofstream out(output_name_base + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                        <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(this-&gt;refinement_cycle) +</div><div class="line">                        data_out.<a class="code" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a>(output_format));</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a>(out, output_format);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  } <span class="comment">// namespace Evaluation</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>LaplaceSolver</div><div class="line">  {</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Base</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid);</div><div class="line">      <span class="keyword">virtual</span> ~Base() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> solve_problem() = 0;</div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div><div class="line">        <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const</span> = 0;</div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span>         refine_grid()                            = 0;</div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const</span>                           = 0;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;Triangulation&lt;dim&gt;</a>&gt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Base&lt;dim&gt;::Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid)</div><div class="line">      : triangulation(&amp;coarse_grid)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Solver : <span class="keyword">public</span> <span class="keyword">virtual</span> Base&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line">      <span class="keyword">virtual</span> ~Solver() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> solve_problem() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div><div class="line">        <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const FiniteElement&lt;dim&gt;</a>&gt; fe;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Quadrature&lt;dim&gt;</a>&gt;    quadrature;</div><div class="line">      <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                              dof_handler;</div><div class="line">      Vector&lt;double&gt;                               solution;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt;      boundary_values;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(Vector&lt;double&gt; &amp;rhs) <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">struct </span>LinearSystem</div><div class="line">      {</div><div class="line">        LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler);</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> solve(Vector&lt;double&gt; &amp;solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">        <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line">        <a class="code" href="classSparsityPattern.html">SparsityPattern</a>           sparsity_pattern;</div><div class="line">        <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>      <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">        Vector&lt;double&gt;            rhs;</div><div class="line">      };</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">struct </span>AssemblyScratchData</div><div class="line">      {</div><div class="line">        AssemblyScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature);</div><div class="line">        AssemblyScratchData(<span class="keyword">const</span> AssemblyScratchData &amp;scratch_data);</div><div class="line"></div><div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keyword">struct </span>AssemblyCopyData</div><div class="line">      {</div><div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">        std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> assemble_linear_system(LinearSystem &amp;linear_system);</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> local_assemble_matrix(</div><div class="line">        <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">        AssemblyScratchData &amp;                                 scratch_data,</div><div class="line">        AssemblyCopyData &amp;                                    copy_data) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div><div class="line">                                LinearSystem &amp;          linear_system) <span class="keyword">const</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Solver&lt;dim&gt;::Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">      : Base&lt;dim&gt;(triangulation)</div><div class="line">      , fe(&amp;fe)</div><div class="line">      , quadrature(&amp;quadrature)</div><div class="line">      , dof_handler(triangulation)</div><div class="line">      , boundary_values(&amp;boundary_values)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Solver&lt;dim&gt;::~Solver()</div><div class="line">    {</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::solve_problem()</div><div class="line">    {</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(*fe);</div><div class="line">      solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">      LinearSystem linear_system(dof_handler);</div><div class="line">      assemble_linear_system(linear_system);</div><div class="line">      linear_system.solve(solution);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::postprocess(</div><div class="line">      <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      postprocessor(dof_handler, solution);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Solver&lt;dim&gt;::n_dofs()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::assemble_linear_system(LinearSystem &amp;linear_system)</div><div class="line">    {</div><div class="line">      <a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> rhs_task =</div><div class="line">        <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a>(&amp;Solver&lt;dim&gt;::assemble_rhs, *<span class="keyword">this</span>, linear_system.rhs);</div><div class="line"></div><div class="line">      <span class="keyword">auto</span> worker =</div><div class="line">        [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">               AssemblyScratchData &amp;scratch_data,</div><div class="line">               AssemblyCopyData &amp;   copy_data) {</div><div class="line">          this-&gt;local_assemble_matrix(cell, scratch_data, copy_data);</div><div class="line">        };</div><div class="line"></div><div class="line">      <span class="keyword">auto</span> copier = [<span class="keyword">this</span>, &amp;linear_system](<span class="keyword">const</span> AssemblyCopyData &amp;copy_data) {</div><div class="line">        this-&gt;copy_local_to_global(copy_data, linear_system);</div><div class="line">      };</div><div class="line"></div><div class="line">      <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                      dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                      worker,</div><div class="line">                      copier,</div><div class="line">                      AssemblyScratchData(*fe, *quadrature),</div><div class="line">                      AssemblyCopyData());</div><div class="line">      linear_system.hanging_node_constraints.condense(linear_system.matrix);</div><div class="line"></div><div class="line">      std::map&lt;types::global_dof_index, double&gt; boundary_value_map;</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               0,</div><div class="line">                                               *boundary_values,</div><div class="line">                                               boundary_value_map);</div><div class="line"></div><div class="line">      rhs_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div><div class="line">      linear_system.hanging_node_constraints.condense(linear_system.rhs);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_value_map,</div><div class="line">                                         linear_system.matrix,</div><div class="line">                                         solution,</div><div class="line">                                         linear_system.rhs);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature)</div><div class="line">      : fe_values(fe, quadrature, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div><div class="line">      <span class="keyword">const</span> AssemblyScratchData &amp;scratch_data)</div><div class="line">      : fe_values(scratch_data.fe_values.get_fe(),</div><div class="line">                  scratch_data.fe_values.get_quadrature(),</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::local_assemble_matrix(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">      AssemblyScratchData &amp;                                 scratch_data,</div><div class="line">      AssemblyCopyData &amp;                                    copy_data)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe-&gt;n_dofs_per_cell();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature-&gt;size();</div><div class="line"></div><div class="line">      copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">      copy_data.local_dof_indices.resize(dofs_per_cell);</div><div class="line"></div><div class="line">      scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            copy_data.cell_matrix(i, j) +=</div><div class="line">              (scratch_data.fe_values.shape_grad(i, q_point) *</div><div class="line">               scratch_data.fe_values.shape_grad(j, q_point) *</div><div class="line">               scratch_data.fe_values.JxW(q_point));</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(copy_data.local_dof_indices);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div><div class="line">                                           LinearSystem &amp;linear_system)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; copy_data.local_dof_indices.size(); ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; copy_data.local_dof_indices.size(); ++j)</div><div class="line">          linear_system.matrix.add(copy_data.local_dof_indices[i],</div><div class="line">                                   copy_data.local_dof_indices[j],</div><div class="line">                                   copy_data.cell_matrix(i, j));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Solver&lt;dim&gt;::LinearSystem::LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler)</div><div class="line">    {</div><div class="line">      hanging_node_constraints.clear();</div><div class="line"></div><div class="line">      void (*mhnc_p)(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;, <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;) =</div><div class="line">        &amp;<a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>;</div><div class="line"></div><div class="line">      <a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> side_task =</div><div class="line">        <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a>(mhnc_p, dof_handler, hanging_node_constraints);</div><div class="line"></div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">      side_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div><div class="line"></div><div class="line">      hanging_node_constraints.close();</div><div class="line">      hanging_node_constraints.condense(dsp);</div><div class="line">      sparsity_pattern.copy_from(dsp);</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>.reinit(sparsity_pattern);</div><div class="line">      rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::LinearSystem::solve(Vector&lt;double&gt; &amp;solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">      <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">      preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, 1.2);</div><div class="line"></div><div class="line">      cg.solve(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, solution, rhs, preconditioner);</div><div class="line"></div><div class="line">      hanging_node_constraints.distribute(solution);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>PrimalSolver : <span class="keyword">public</span> Solver&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt; rhs_function;</div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(Vector&lt;double&gt; &amp;rhs) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    PrimalSolver&lt;dim&gt;::PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">      : Base&lt;dim&gt;(triangulation)</div><div class="line">      , Solver&lt;dim&gt;(triangulation, fe, quadrature, boundary_values)</div><div class="line">      , rhs_function(&amp;rhs_function)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> PrimalSolver&lt;dim&gt;::assemble_rhs(Vector&lt;double&gt; &amp;rhs)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(*this-&gt;fe,</div><div class="line">                              *this-&gt;quadrature,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = this-&gt;fe-&gt;n_dofs_per_cell();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = this-&gt;quadrature-&gt;size();</div><div class="line"></div><div class="line">      Vector&lt;double&gt;                       cell_rhs(dofs_per_cell);</div><div class="line">      std::vector&lt;double&gt;                  rhs_values(n_q_points);</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : this-&gt;dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          cell_rhs = 0;</div><div class="line">          fe_values.reinit(cell);</div><div class="line">          rhs_function-&gt;value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                   rhs_values);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * </div><div class="line">                             rhs_values[q_point] *               </div><div class="line">                             fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        };</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>RefinementGlobal : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      RefinementGlobal(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                       <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                       <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                       <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                       <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    RefinementGlobal&lt;dim&gt;::RefinementGlobal(</div><div class="line">      <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">      : Base&lt;dim&gt;(coarse_grid)</div><div class="line">      , PrimalSolver&lt;dim&gt;(coarse_grid,</div><div class="line">                          fe,</div><div class="line">                          quadrature,</div><div class="line">                          rhs_function,</div><div class="line">                          boundary_values)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> RefinementGlobal&lt;dim&gt;::refine_grid()</div><div class="line">    {</div><div class="line">      this-&gt;triangulation-&gt;refine_global(1);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>RefinementKelly : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    RefinementKelly&lt;dim&gt;::RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;rhs_function,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;boundary_values)</div><div class="line">      : Base&lt;dim&gt;(coarse_grid)</div><div class="line">      , PrimalSolver&lt;dim&gt;(coarse_grid,</div><div class="line">                          fe,</div><div class="line">                          quadrature,</div><div class="line">                          rhs_function,</div><div class="line">                          boundary_values)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> RefinementKelly&lt;dim&gt;::refine_grid()</div><div class="line">    {</div><div class="line">      Vector&lt;float&gt; estimated_error_per_cell(</div><div class="line">        this-&gt;triangulation-&gt;n_active_cells());</div><div class="line">      <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">        this-&gt;dof_handler,</div><div class="line">        <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(this-&gt;fe-&gt;degree + 1),</div><div class="line">        std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">        this-&gt;solution,</div><div class="line">        estimated_error_per_cell);</div><div class="line">      <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(*this-&gt;triangulation,</div><div class="line">                                                      estimated_error_per_cell,</div><div class="line">                                                      0.3,</div><div class="line">                                                      0.03);</div><div class="line">      this-&gt;triangulation-&gt;execute_coarsening_and_refinement();</div><div class="line">    }</div><div class="line"></div><div class="line">  } <span class="comment">// namespace LaplaceSolver</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Solution&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">    <span class="keywordtype">double</span> q = p(0);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">      q += std::sin(10 * p(i) + 5 * p(0) * p(0));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> exponential = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(q);</div><div class="line">    <span class="keywordflow">return</span> exponential;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">    <span class="keywordtype">double</span> q = p(0);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">      q += std::sin(10 * p(i) + 5 * p(0) * p(0));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> u  = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(q);</div><div class="line">    <span class="keywordtype">double</span>       t1 = 1, t2 = 0, t3 = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        t1 += <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) * 10 * p(0);</div><div class="line">        t2 += 10 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) -</div><div class="line">              100 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(10 * p(i) + 5 * p(0) * p(0)) * p(0) * p(0);</div><div class="line">        t3 += 100 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) *</div><div class="line">                <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) -</div><div class="line">              100 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(10 * p(i) + 5 * p(0) * p(0));</div><div class="line">      };</div><div class="line">    t1 = t1 * t1;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> -u * (t1 + t2 + t3);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> run_simulation(</div><div class="line">    LaplaceSolver::Base&lt;dim&gt; &amp;                          solver,</div><div class="line">    <span class="keyword">const</span> std::list&lt;Evaluation::EvaluationBase&lt;dim&gt; *&gt; &amp;postprocessor_list)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle: &quot;</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; <span class="keyword">true</span>; ++step)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; step &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">        solver.solve_problem();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;postprocessor : postprocessor_list)</div><div class="line">          {</div><div class="line">            postprocessor-&gt;set_refinement_cycle(step);</div><div class="line">            solver.postprocess(*postprocessor);</div><div class="line">          };</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (solver.n_dofs() &lt; 20000)</div><div class="line">          solver.refine_grid();</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">      };</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> solve_problem(<span class="keyword">const</span> std::string &amp;solver_name)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> std::string header =</div><div class="line">      <span class="stringliteral">&quot;Running tests with \&quot;&quot;</span> + solver_name + <span class="stringliteral">&quot;\&quot; refinement criterion:&quot;</span>;</div><div class="line">    std::cout &lt;&lt; header &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::string(header.size(), <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">    triangulation.refine_global(2);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>    fe(1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature(4);</div><div class="line">    RightHandSide&lt;dim&gt; rhs_function;</div><div class="line">    Solution&lt;dim&gt;      boundary_values;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;LaplaceSolver::Base&lt;dim&gt;&gt; solver;</div><div class="line">    <span class="keywordflow">if</span> (solver_name == <span class="stringliteral">&quot;global&quot;</span>)</div><div class="line">      solver = std::make_unique&lt;LaplaceSolver::RefinementGlobal&lt;dim&gt;&gt;(</div><div class="line">        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, rhs_function, boundary_values);</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (solver_name == <span class="stringliteral">&quot;kelly&quot;</span>)</div><div class="line">      solver = std::make_unique&lt;LaplaceSolver::RefinementKelly&lt;dim&gt;&gt;(</div><div class="line">        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, rhs_function, boundary_values);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classTableHandler.html">TableHandler</a>                          results_table;</div><div class="line">    Evaluation::PointValueEvaluation&lt;dim&gt; postprocessor1(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5),</div><div class="line">                                                         results_table);</div><div class="line"></div><div class="line">    Evaluation::SolutionOutput&lt;dim&gt; postprocessor2(std::string(<span class="stringliteral">&quot;solution-&quot;</span>) +</div><div class="line">                                                     solver_name,</div><div class="line">                                                   <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">DataOutBase::gnuplot</a>);</div><div class="line"></div><div class="line">    std::list&lt;Evaluation::EvaluationBase&lt;dim&gt; *&gt; postprocessor_list;</div><div class="line">    postprocessor_list.push_back(&amp;postprocessor1);</div><div class="line">    postprocessor_list.push_back(&amp;postprocessor2);</div><div class="line"></div><div class="line">    run_simulation(*solver, postprocessor_list);</div><div class="line"></div><div class="line">    results_table.<a class="code" href="classTableHandler.html#a45c4ec9981f3880c6c852ed3aceb08fe">write_text</a>(std::cout);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step13</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step13::solve_problem&lt;2&gt;(<span class="stringliteral">&quot;global&quot;</span>);</div><div class="line">      Step13::solve_problem&lt;2&gt;(<span class="stringliteral">&quot;kelly&quot;</span>);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_6.html">step-6</a> . <table class="tutorial"
 width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#Backgroundandpurpose">Background and purpose</a><a
 href="#Backgroundandpurpose">Background and purpose</a>
 <li><a href="#Whattheprogramdoes">What the program does</a><a
 href="#Whattheprogramdoes">What the program does</a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Evaluationofthesolution">Evaluation of the solution</a><a
 href="#Evaluationofthesolution">Evaluation of the solution</a>
 <ul>
 <li><a href="#Pointevaluation">%Point evaluation</a><a
 href="#Pointevaluation">%Point evaluation</a>
 <li><a href="#Generatingoutput">Generating output</a><a
 href="#Generatingoutput">Generating output</a>
 <li><a href="#Otherevaluations">Other evaluations</a><a
 href="#Otherevaluations">Other evaluations</a>
 </ul>
 <li><a href="#TheLaplacesolverclasses">The Laplace solver classes</a><a
 href="#TheLaplacesolverclasses">The Laplace solver classes</a>
 <ul>
 <li><a href="#Anabstractbaseclass">An abstract base class</a><a
 href="#Anabstractbaseclass">An abstract base class</a>
 <li><a href="#Ageneralsolverclass">A general solver class</a><a
 href="#Ageneralsolverclass">A general solver class</a>
 <li><a href="#Aprimalsolver">A primal solver</a><a href="#Aprimalsolver">A
 primal solver</a>
 <li><a href="#Globalrefinement">Global refinement</a><a
 href="#Globalrefinement">Global refinement</a>
 <li><a href="#LocalrefinementbytheKellyerrorindicator">Local refinement by
 the Kelly error indicator</a><a
 href="#LocalrefinementbytheKellyerrorindicator">Local refinement by the
 Kelly error indicator</a>
 </ul>
 <li><a href="#Equationdata">Equation data</a><a
 href="#Equationdata">Equation data</a>
 <li><a href="#Thedriverroutines">The driver routines</a><a
 href="#Thedriverroutines">The driver routines</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Backgroundandpurpose"></a></p><h3>Background and purpose</h3>
<p>In this example program, we will not so much be concerned withdescribing new ways how to use deal.II and its facilities, but ratherwith presenting methods of writing modular and extensible finiteelement programs. The main reason for this is the size and complexityof modern research software: applications implementing modern errorestimation concepts and adaptive solution methods tend to becomerather large. For example, when this program was written in 2002, thethree largest applications by the mainauthors of deal.II, are at the time of writing of this exampleprogram: </p><ol>
<li>
a program for solving conservation hyperbolic equations by the Discontinuous Galerkin Finite Element method: 33,775 lines of code; </li>
<li>
a parameter estimation program: 28,980 lines of code; </li>
<li>
a wave equation solver: 21,020 lines of code. </li>
</ol>
<p>(The library proper</p>
<ul>
<li>without example programs and test suite</li>
<li>has slightlymore than 150,000 lines of code as of spring 2002. It is of course severaltimes larger now.) The sizes of these applications are at the edge of whatone person, even an experienced programmer, can manage.</li>
</ul>
<p>The numbers above make one thing rather clear: monolithic programs thatare not broken up into smaller, mostly independent pieces have no wayof surviving, since even the author will quickly lose the overview ofthe various dependencies between different parts of a program. Onlydata encapsulation, for example using object oriented programmingmethods, and modularization by defining small but fixed interfaces canhelp structure data flow and mutual interdependencies. It is also anabsolute prerequisite if more than one person is developing a program,since otherwise confusion will quickly prevail as one developerwould need to know if another changed something about the internals ofa different module if they were not cleanly separated.</p>
<p>In previous examples, you have seen how the library itself is brokenup into several complexes each building atop the underlying ones, butrelatively independent of the other ones: </p><ol>
<li>
the triangulation class complex, with associated iterator classes; </li>
<li>
the finite element classes; </li>
<li>
the <a class="el" href="classDoFHandler.html">DoFHandler</a> class complex, with associated iterators, built on the triangulation and finite element classes; </li>
<li>
the classes implementing mappings between unit and real cells; </li>
<li>
the <a class="el" href="classFEValues.html">FEValues</a> class complex, built atop the finite elements and mappings. </li>
</ol>
<p>Besides these, and a large number of smaller classes, there are ofcourse the following "tool" modules: </p><ol>
<li>
output in various graphical formats; </li>
<li>
linear algebra classes. </li>
</ol>
<p>These complexes can also be found as a flow chart on the front page ofthe deal.II manual website.</p>
<p>The goal of this program is now to give an example of how a relativelysimple finite element program could be structured such that we end upwith a set of modules that are as independent of each other aspossible. This allows to change the program at one end, without having toworry that it might break at the other, as long as we do not touch theinterface through which the two ends communicate. The interface inC++, of course, is the declaration of abstract base classes.</p>
<p>Here, we will implement (again) a Laplace solver, although with anumber of differences compared to previous example programs: </p><ol>
<li>
The classes that implement the process of numerically solving the equation are no more responsible for driving the process of "solving-estimating error-refining-solving again", but we delegate this to external functions. This allows first to use it as a building block in a larger context, where the solution of a Laplace equation might only be one part (for example, in a nonlinear problem, where Laplace equations might have to be solved in each nonlinear step). It would also allow to build a framework around this class that would allow using solvers for other equations (but with the same external interface) instead, in case some techniques shall be evaluated for different types of partial differential equations. </li>
<li>
It splits the process of evaluating the computed solution to a separate set of classes. The reason is that one is usually not interested in the solution of a PDE per se, but rather in certain aspects of it. For example, one might wish to compute the traction at a certain boundary in elastic computations, or in the signal of a seismic wave at a receiver position at a given location. Sometimes, one might have an interest in several of these aspects. Since the evaluation of a solution is something that does not usually affect the process of solution, we split it off into a separate module, to allow for the development of such evaluation filters independently of the development of the solver classes. </li>
<li>
Separate the classes that implement mesh refinement from the classes that compute the solution. </li>
<li>
Separate the description of the test case with which we will present the program, from the rest of the program. </li>
<li>
Parallelize the assembly of linear systems using the <a class="el" href="namespaceWorkStream.html">WorkStream</a> facilities. This follows the extensive description that can be found in the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a> documentation module. The implementation essentially follows what has already been described in <a class="el" href="step_9.html">step-9</a> . </li>
</ol>
<p>The things the program does are not new. In fact, this is more like amelange of previous programs, cannibalizing various parts andfunctions from earlier examples. It is the way they are arranged inthis program that should be the focus of the reader, i.e. the softwaredesign techniques used in the program to achieve the goal ofimplementing the desired mathematical method. However, we muststress that software design is in part also a subjective matter:different persons have different programming backgrounds and havedifferent opinions about the "right" style of programming; thisprogram therefore expresses only what the author considers usefulpractice, and is not necessarily a style that you have to adopt inorder to write successful numerical software if you feel uncomfortablewith the chosen ways. It should serve as a case study, however,inspiring the reader with ideas to the desired end.</p>
<p>Once you have worked through the program, you will remark that it isalready somewhat complex in its structure. Nevertheless, itonly has about 850 lines of code, without comments. In realapplications, there would of course be comments and classdocumentation, which would bring that to maybe 1200 lines. Yet, compared tothe applications listed above, this is still small, as they are 20 to25 times as large. For programs as large, a proper design right fromthe start is thus indispensable. Otherwise, it will have to beredesigned at one point in its life, once it becomes too large to bemanageable.</p>
<p>Despite of this, all three programs listed above have undergone majorrevisions, or even rewrites. The wave program, for example, was onceentirely teared to parts when it was still significantly smaller, justto assemble it again in a more modular form. By that time, it hadbecome impossible to add functionality without affecting older partsof the code (the main problem with the code was the data flow: in timedependent application, the major concern is when to store data to diskand when to reload it again; if this is not done in an organizedfashion, then you end up with data released too early, loaded toolate, or not released at all). Although the present example programthus draws from several years of experience, it is certainly notwithout flaws in its design, and in particular might not be suited foran application where the objective is different. It should serve as aninspiration for writing your own application in a modular way, toavoid the pitfalls of too closely coupled codes.</p>
<p><a class="anchor" id="Whattheprogramdoes"></a></p><h3>What the program does</h3>
<p>What the program actually does is not even the main point of thisprogram, the structure of the program is more important. However, in afew words, a description would be: solve the Laplace equation for agiven right hand side such that the solution is the function \(u(x,t)=\exp(x+\sin(10y+5x^2))\) . The goal of thecomputation is to get the value of the solution at the point \(x_0=(0.5,0.5)\) , and to compare the accuracy withwhich we resolve this value for two refinement criteria, namely globalrefinement and refinement by the error indicator by Kelly et al. whichwe have already used in previous examples.</p>
<p>The results will, as usual, be discussed in the respective section ofthis document. In doing so, we will find a slightly irritatingobservation about the relative performance of the two refinementcriteria. In a later example program, building atop this one, we willdevise a different method that should hopefully perform better thanthe techniques discussed here.</p>
<p>So much now for all the theoretical and anecdotal background. The bestway of learning about a program is to look at it, so here it is:</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>As in all programs, we start with a list of include files from the library, and as usual they are in the standard order which is <code>base</code></p>
<ul>
<li><code>lac</code></li>
<li><code>grid</code></li>
<li><code>dofs</code></li>
<li><code>fe</code></li>
<li><code>numerics</code> (as each of these categories roughly builds upon previous ones), then C++ standard headers:</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="table__handler_8h.html">deal.II/base/table_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="thread__management_8h.html">deal.II/base/thread_management.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div></div><!-- fragment --><p>Now for the C++ standard headers:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step13</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Evaluationofthesolution"></a> </p><h3>Evaluation of the solution</h3>
<p>As for the program itself, we first define classes that evaluate the solutions of a Laplace equation. In fact, they can evaluate every kind of solution, as long as it is described by a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object, and a solution vector. We define them here first, even before the classes that actually generate the solution to be evaluated, since we need to declare an abstract base class that the solver classes can refer to. From an abstract point of view, we declare a pure base class that provides an evaluation operator() which will do the evaluation of the solution (whatever derived classes might consider an <code>evaluation</code> ). Since this is the only real function of this base class (except for some bookkeeping machinery), one usually terms such a class that only has an <code>operator()</code> a <code>functor</code> in C++ terminology, since it is used just like a function object. Objects of this functor type will then later be passed to the solver object, which applies it to the solution just computed. The evaluation objects may then extract any quantity they like from the solution. The advantage of putting these evaluation functions into a separate hierarchy of classes is that by design they cannot use the internals of the solver object and are therefore independent of changes to the way the solver works. Furthermore, it is trivial to write another evaluation class without modifying the solver class, which speeds up programming (not being able to use internals of another class also means that you do not have to worry about them</p>
<ul>
<li>programming evaluators is usually a rather quickly done task), as well as compilation (if solver and evaluation classes are put into different files: the solver only needs to see the declaration of the abstract base class, and therefore does not need to be recompiled upon addition of a new evaluation class, or modification of an old one). On a related note, you can reuse the evaluation classes for other projects, solving different equations. In order to improve separation of code into different modules, we put the evaluation classes into a namespace of their own. This makes it easier to actually solve different equations in the same program, by assembling it from existing building blocks. The reason for this is that classes for similar purposes tend to have the same name, although they were developed in different contexts. In order to be able to use them together in one program, it is necessary that they are placed in different namespaces. This we do here:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Evaluation</div><div class="line">{</div></div><!-- fragment --><p>Now for the abstract base class of evaluation classes: its main purpose is to declare a pure virtual function <code>operator()</code> taking a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object, and the solution vector. In order to be able to use pointers to this base class only, it also has to declare a virtual destructor, which however does nothing. Besides this, it only provides for a little bit of bookkeeping: since we usually want to evaluate solutions on subsequent refinement levels, we store the number of the present refinement cycle, and provide a function to change this number.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>EvaluationBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~EvaluationBase() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution) <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> EvaluationBase&lt;dim&gt;::set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step)</div><div class="line">{</div><div class="line">  refinement_cycle = step;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Pointevaluation"></a> </p><h4>Point evaluation</h4>
<p>The next thing is to implement actual evaluation classes. As noted in the introduction, we'd like to extract a point value from the solution, so the first class does this in its <code>operator()</code> . The actual point is given to this class through the constructor, as well as a table object into which it will put its findings. Finding out the value of a finite element field at an arbitrary point is rather difficult, if we cannot rely on knowing the actual finite element used, since then we cannot, for example, interpolate between nodes. For simplicity, we therefore assume here that the point at which we want to evaluate the field is actually a node. If, in the process of evaluating the solution, we find that we did not encounter this point upon looping over all vertices, we then have to throw an exception in order to signal to the calling functions that something has gone wrong, rather than silently ignore this error. In the <a class="el" href="step_9.html">step-9</a> example program, we have already seen how such an exception class can be declared, using the <code>DeclExceptionN</code> macros. We use this mechanism here again. From this, the actual declaration of this class should be evident. Note that of course even if we do not list a destructor explicitly, an implicit destructor is generated from the compiler, and it is virtual just as the one of the base class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PointValueEvaluation : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PointValueEvaluation(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point,</div><div class="line">                       <a class="code" href="classTableHandler.html">TableHandler</a> &amp;    results_table);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a>(</div><div class="line">    ExcEvaluationPointNotFound,</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div><div class="line">  <a class="code" href="classTableHandler.html">TableHandler</a> &amp;   results_table;</div><div class="line">};</div></div><!-- fragment --><p>As for the definition, the constructor is trivial, just taking data and storing it in object-local ones:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">PointValueEvaluation&lt;dim&gt;::PointValueEvaluation(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point,</div><div class="line">  <a class="code" href="classTableHandler.html">TableHandler</a> &amp;    results_table)</div><div class="line">  : evaluation_point(evaluation_point)</div><div class="line">  , results_table(results_table)</div><div class="line">{}</div></div><!-- fragment --><p>Now for the function that is mainly of interest in this class, the computation of the point value:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PointValueEvaluation&lt;dim&gt;::</div><div class="line">     operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>First allocate a variable that will hold the point value. Initialize it with a value that is clearly bogus, so that if we fail to set it to a reasonable value, we will note at once. This may not be necessary in a function as small as this one, since we can easily see all possible paths of execution here, but it proved to be helpful for more complex cases, and so we employ this strategy here as well.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> point_value = 1e20;</div></div><!-- fragment --><p>Then loop over all cells and all their vertices, and check whether a vertex matches the evaluation point. If this is the case, then extract the point value, set a flag that we have found the point of interest, and exit the loop.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> evaluation_point_found = <span class="keyword">false</span>;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (!evaluation_point_found)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex : cell-&gt;vertex_indices())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;vertex(vertex) == evaluation_point)</div><div class="line">        {</div></div><!-- fragment --><p>In order to extract the point value from the global solution vector, pick that component that belongs to the vertex of interest, and, in case the solution is vector-valued, take the first component of it:</p>
<div class="fragment"><div class="line">point_value = solution(cell-&gt;vertex_dof_index(vertex, 0));</div></div><!-- fragment --><p>Note that by this we have made an assumption that is not valid always and should be documented in the class declaration if this were code for a real application rather than a tutorial program: we assume that the finite element used for the solution we try to evaluate actually has degrees of freedom associated with vertices. This, for example, does not hold for discontinuous elements, were the support points for the shape functions happen to be located at the vertices, but are not associated with the vertices but rather with the cell interior, since association with vertices would imply continuity there. It would also not hold for edge oriented elements, and the like. Ideally, we would check this at the beginning of the function, for example by a statement like <code>Assert (dof_handler.get_fe().dofs_per_vertex &gt; 0, <a class="el" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented()</a>)</code>, which should make it quite clear what is going wrong when the exception is triggered. In this case, we omit it (which is indeed bad style), but knowing that that does not hurt here, since the statement <code>cell-&gt;vertex_dof_index(vertex,0)</code> would fail if we asked it to give us the DoF index of a vertex if there were none. We stress again that this restriction on the allowed finite elements should be stated in the class documentation.</p>
<p>Since we found the right point, we now set the respective flag and exit the innermost loop. The outer loop will also be terminated due to the set flag.</p>
<div class="fragment"><div class="line">  evaluation_point_found = <span class="keyword">true</span>;</div><div class="line">  <span class="keywordflow">break</span>;</div><div class="line">};</div></div><!-- fragment --><p>Finally, we'd like to make sure that we have indeed found the evaluation point, since if that were not so we could not give a reasonable value of the solution there and the rest of the computations were useless anyway. So make sure through the <code>AssertThrow</code> macro already used in the <a class="el" href="step_9.html">step-9</a> program that we have indeed found this point. If this is not so, the macro throws an exception of the type that is given to it as second argument, but compared to a straightforward <code>throw</code> statement, it fills the exception object with a set of additional information, for example the source file and line number where the exception was generated, and the condition that failed. If you have a <code>catch</code> clause in your main function (as this program has), you will catch all exceptions that are not caught somewhere in between and thus already handled, and this additional information will help you find out what happened and where it went wrong.</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_point_found,</div><div class="line">            ExcEvaluationPointNotFound(evaluation_point));</div></div><!-- fragment --><p>Note that we have used the <code>Assert</code> macro in other example programs as well. It differed from the <code>AssertThrow</code> macro used here in that it simply aborts the program, rather than throwing an exception, and that it did so only in debug mode. It was the right macro to use to check about the size of vectors passed as arguments to functions, and the like. However, here the situation is different: whether we find the evaluation point or not may change from refinement to refinement (for example, if the four cells around point are coarsened away, then the point may vanish after refinement and coarsening). This is something that cannot be predicted from a few number of runs of the program in debug mode, but should be checked always, also in production runs. Thus the use of the <code>AssertThrow</code> macro here.</p>
<p>Now, if we are sure that we have found the evaluation point, we can add the results into the table of results:</p>
<div class="fragment"><div class="line">  results_table.<a class="code" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a>(<span class="stringliteral">&quot;DoFs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  results_table.<a class="code" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a>(<span class="stringliteral">&quot;u(x_0)&quot;</span>, point_value);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Generatingoutput"></a> </p><h4>Generating output</h4>
<p>A different, maybe slightly odd kind of <code>evaluation</code> of a solution is to output it to a file in a graphical format. Since in the evaluation functions we are given a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object and the solution vector, we have all we need to do this, so we can do it in an evaluation class. The reason for actually doing so instead of putting it into the class that computed the solution is that this way we have more flexibility: if we choose to only output certain aspects of it, or not output it at all. In any case, we do not need to modify the solver class, we just have to modify one of the modules out of which we build this program. This form of encapsulation, as above, helps us to keep each part of the program rather simple as the interfaces are kept simple, and no access to hidden data is possible. Since this class which generates the output is derived from the common <code>EvaluationBase</code> base class, its main interface is the <code>operator()</code> function. Furthermore, it has a constructor taking a string that will be used as the base part of the file name to which output will be sent (we will augment it by a number indicating the number of the refinement cycle</p>
<ul>
<li>the base class has this information at hand</li>
<li>, and a suffix), and the constructor also takes a value that indicates which format is requested, i.e. for which graphics program we shall generate output (from this we will then also generate the suffix of the filename to which we write). Regarding the output format, the <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> namespace provides an enumeration field <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> which lists names for all supported output formats. At the time of writing of this program, the supported graphics formats are represented by the enum values <code>ucd</code> , <code>gnuplot</code>, <code>povray</code>, <code>eps</code> , <code>gmv</code>, <code>tecplot</code>, <code>tecplot_binary</code> , <code>dx</code>, <code>vtk</code> , etc, but this list will certainly grow over time. Now, within various functions of that base class, you can use values of this type to get information about these graphics formats (for example the default suffix used for files of each format), and you can call a generic <code>write</code> function, which then branches to the <code>write_gnuplot</code>, <code>write_ucd</code> , etc functions which we have used in previous examples already, based on the value of a second argument given to it denoting the required output format. This mechanism makes it simple to write an extensible program that can decide which output format to use at runtime, and it also makes it rather simple to write the program in a way such that it takes advantage of newly implemented output formats, without the need to change the application program. Of these two fields, the base name and the output format descriptor, the constructor takes values and stores them for later use by the actual evaluation function.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SolutionOutput : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SolutionOutput(<span class="keyword">const</span> std::string &amp;             output_name_base,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> std::string               output_name_base;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">SolutionOutput&lt;dim&gt;::SolutionOutput(</div><div class="line">  <span class="keyword">const</span> std::string &amp;             output_name_base,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format)</div><div class="line">  : output_name_base(output_name_base)</div><div class="line">  , output_format(output_format)</div><div class="line">{}</div></div><!-- fragment --><p>Following the description above, the function generating the actual output is now relatively straightforward. The only particularly interesting feature over previous example programs is the use of the <a class="el" href="namespaceDataOutBase.html#aed25a6ddf928a6904fd1ac942125ec86">DataOutBase::default_suffix</a> function, returning the usual suffix for files of a given format (e.g. ".eps" for encapsulated postscript files, ".gnuplot" for Gnuplot files), and of the generic <a class="el" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">DataOut::write()</a> function with a second argument, which internally branches to the actual output functions for the different graphics formats, based on the value of the format descriptor passed as second argument. Also note that we have to prefix <code>this-&gt;</code> to access a member variable of the template dependent base class. The reason here, and further down in the program is the same as the one described in the <a class="el" href="step_7.html">step-7</a> example program (look for <code>two-stage name lookup</code> there).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SolutionOutput&lt;dim&gt;::operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                     <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream out(output_name_base + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                    <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(this-&gt;refinement_cycle) +</div><div class="line">                    data_out.<a class="code" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a>(output_format));</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a>(out, output_format);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Otherevaluations"></a> </p><h4>Other evaluations</h4>
<p>In practical applications, one would add here a list of other possible evaluation classes, representing quantities that one may be interested in. For this example, that much shall be sufficient, so we close the namespace.</p>
<div class="fragment"><div class="line">} <span class="comment">// namespace Evaluation</span></div></div><!-- fragment --><p><a class="anchor" id="TheLaplacesolverclasses"></a> </p><h3>The Laplace solver classes</h3>
<p>After defining what we want to know of the solution, we should now care how to get at it. We will pack everything we need into a namespace of its own, for much the same reasons as for the evaluations above. Since we have discussed Laplace solvers already in considerable detail in previous examples, there is not much new stuff following. Rather, we have to a great extent cannibalized previous examples and put them, in slightly different form, into this example program. We will therefore mostly be concerned with discussing the differences to previous examples. Basically, as already said in the introduction, the lack of new stuff in this example is deliberate, as it is more to demonstrate software design practices, rather than mathematics. The emphasis in explanations below will therefore be more on the actual implementation.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>LaplaceSolver</div><div class="line">{</div></div><!-- fragment --><p><a class="anchor" id="Anabstractbaseclass"></a> </p><h4>An abstract base class</h4>
<p>In defining a Laplace solver, we start out by declaring an abstract base class, that has no functionality itself except for taking and storing a pointer to the triangulation to be used later. This base class is very general, and could as well be used for any other stationary problem. It provides declarations of functions that shall, in derived classes, solve a problem, postprocess the solution with a list of evaluation objects, and refine the grid, respectively. None of these functions actually does something itself in the base class. Due to the lack of actual functionality, the programming style of declaring very abstract base classes is similar to the style used in Smalltalk or Java programs, where all classes are derived from entirely abstract classes <code>Object</code> , even number representations. The author admits that he does not particularly like the use of such a style in C++, as it puts style over reason. Furthermore, it promotes the use of virtual functions for everything (for example, in Java, all functions are virtual per se), which, however, has proven to be rather inefficient in many applications where functions are often only accessing data, not doing computations, and therefore quickly return; the overhead of virtual functions can then be significant. The opinion of the author is to have abstract base classes wherever at least some part of the code of actual implementations can be shared and thus separated into the base class. Besides all these theoretical questions, we here have a good reason, which will become clearer to the reader below. Basically, we want to be able to have a family of different Laplace solvers that differ so much that no larger common subset of functionality could be found. We therefore just declare such an abstract base class, taking a pointer to a triangulation in the constructor and storing it henceforth. Since this triangulation will be used throughout all computations, we have to make sure that the triangulation is valid until it is last used. We do this by keeping a <code><a class="el" href="classSmartPointer.html">SmartPointer</a></code> to this triangulation, as explained in <a class="el" href="step_7.html">step-7</a> . Note that while the pointer itself is declared constant (i.e. throughout the lifetime of this object, the pointer points to the same object), it is not declared as a pointer to a constant triangulation. In fact, by this we allow that derived classes refine or coarsen the triangulation within the <code>refine_grid</code> function. Finally, we have a function <code>n_dofs</code> is only a tool for the driver functions to decide whether we want to go on with mesh refinement or not. It returns the number of degrees of freedom the present simulation has.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Base</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid);</div><div class="line">  <span class="keyword">virtual</span> ~Base() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> solve_problem() = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div><div class="line">    <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const</span> = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span>         refine_grid()                            = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const</span>                           = 0;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;Triangulation&lt;dim&gt;</a>&gt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">};</div></div><!-- fragment --><p>The implementation of the only two non-abstract functions is then rather boring:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Base&lt;dim&gt;::Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid)</div><div class="line">  : triangulation(&amp;coarse_grid)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="Ageneralsolverclass"></a> </p><h4>A general solver class</h4>
<p>Following now the main class that implements assembling the matrix of the linear system, solving it, and calling the postprocessor objects on the solution. It implements the <code>solve_problem</code> and <code>postprocess</code> functions declared in the base class. It does not, however, implement the <code>refine_grid</code> method, as mesh refinement will be implemented in a number of derived classes. It also declares a new abstract virtual function, <code>assemble_rhs</code> , that needs to be overloaded in subclasses. The reason is that we will implement two different classes that will implement different methods to assemble the right hand side vector. This function might also be interesting in cases where the right hand side depends not simply on a continuous function, but on something else as well, for example the solution of another discretized problem, etc. The latter happens frequently in non-linear problems. As we mentioned previously, the actual content of this class is not new, but a mixture of various techniques already used in previous examples. We will therefore not discuss them in detail, but refer the reader to these programs. Basically, in a few words, the constructor of this class takes pointers to a triangulation, a finite element, and a function object representing the boundary values. These are either passed down to the base class's constructor, or are stored and used to generate a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object later. Since finite elements and quadrature formula should match, it is also passed a quadrature object. The <code>solve_problem</code> sets up the data structures for the actual solution, calls the functions to assemble the linear system, and solves it. The <code>postprocess</code> function finally takes an evaluation object and applies it to the computed solution. The <code>n_dofs</code> function finally implements the pure virtual function of the base class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Solver : <span class="keyword">public</span> <span class="keyword">virtual</span> Base&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">         <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">         <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">         <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line">  <span class="keyword">virtual</span> ~Solver() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> solve_problem() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div><div class="line">    <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const override</span>;</div></div><!-- fragment --><p>In the protected section of this class, we first have a number of member variables, of which the use should be clear from the previous examples:</p>
<div class="fragment"><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const FiniteElement&lt;dim&gt;</a>&gt; fe;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Quadrature&lt;dim&gt;</a>&gt;    quadrature;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                              dof_handler;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                               solution;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt;      boundary_values;</div></div><!-- fragment --><p>Then we declare an abstract function that will be used to assemble the right hand side. As explained above, there are various cases for which this action differs strongly in what is necessary, so we defer this to derived classes:</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;rhs) <span class="keyword">const</span> = 0;</div></div><!-- fragment --><p>Next, in the private section, we have a small class which represents an entire linear system, i.e. a matrix, a right hand side, and a solution vector, as well as the constraints that are applied to it, such as those due to hanging nodes. Its constructor initializes the various subobjects, and there is a function that implements a conjugate gradient method as solver.</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">struct </span>LinearSystem</div><div class="line">  {</div><div class="line">    LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>           sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>      <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            rhs;</div><div class="line">  };</div></div><!-- fragment --><p>Finally, there is a set of functions which will be used to assemble the actual system matrix. The main function of this group, <code>assemble_linear_system()</code> computes the matrix in parallel on multicore systems, using the following two helper functions. The mechanism for doing so is the same as in the <a class="el" href="step_9.html">step-9</a> example program and follows the <a class="el" href="namespaceWorkStream.html">WorkStream</a> concept outlined in <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> . The main function also calls the virtual function assembling the right hand side.</p>
<div class="fragment"><div class="line">  <span class="keyword">struct </span>AssemblyScratchData</div><div class="line">  {</div><div class="line">    AssemblyScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature);</div><div class="line">    AssemblyScratchData(<span class="keyword">const</span> AssemblyScratchData &amp;scratch_data);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">struct </span>AssemblyCopyData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_linear_system(LinearSystem &amp;linear_system);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> local_assemble_matrix(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">    AssemblyScratchData &amp;                                 scratch_data,</div><div class="line">    AssemblyCopyData &amp;                                    copy_data) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div><div class="line">                            LinearSystem &amp;          linear_system) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>Now here comes the constructor of the class. It does not do much except store pointers to the objects given, and generate <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object initialized with the given pointer to a triangulation. This causes the DoF handler to store that pointer, but does not already generate a finite element numbering (we only ask for that in the <code>solve_problem</code> function).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solver&lt;dim&gt;::Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">  : Base&lt;dim&gt;(triangulation)</div><div class="line">  , fe(&amp;fe)</div><div class="line">  , quadrature(&amp;quadrature)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , boundary_values(&amp;boundary_values)</div><div class="line">{}</div></div><!-- fragment --><p>The destructor is simple, it only clears the information stored in the DoF handler object to release the memory.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solver&lt;dim&gt;::~Solver()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">}</div></div><!-- fragment --><p>The next function is the one which delegates the main work in solving the problem: it sets up the DoF handler object with the finite element given to the constructor of this object, the creates an object that denotes the linear system (i.e. the matrix, the right hand side vector, and the solution vector), calls the function to assemble it, and finally solves it:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::solve_problem()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(*fe);</div><div class="line">  solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  LinearSystem linear_system(dof_handler);</div><div class="line">  assemble_linear_system(linear_system);</div><div class="line">  linear_system.solve(solution);</div><div class="line">}</div></div><!-- fragment --><p>As stated above, the <code>postprocess</code> function takes an evaluation object, and applies it to the computed solution. This function may be called multiply, once for each evaluation of the solution which the user required.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::postprocess(</div><div class="line">  <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  postprocessor(dof_handler, solution);</div><div class="line">}</div></div><!-- fragment --><p>The <code>n_dofs</code> function should be self-explanatory:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Solver&lt;dim&gt;::n_dofs()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>();</div><div class="line">}</div></div><!-- fragment --><p>While we could consider either assembling the right hand side or assembling the matrix as the thing to do in the background while doing the other, we will opt for the former approach simply because the call to <code>Solver::assemble_rhs</code> is so much simpler to write than the call to <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> with its many arguments. In any case, the code then looks like this to assemble the entire linear system:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::assemble_linear_system(LinearSystem &amp;linear_system)</div><div class="line">{</div><div class="line">  <a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> rhs_task =</div><div class="line">    <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a>(&amp;Solver&lt;dim&gt;::assemble_rhs,<span class="keyword">this</span>, linear_system.rhs);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> worker =</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">           AssemblyScratchData &amp;scratch_data,</div><div class="line">           AssemblyCopyData &amp;   copy_data) {</div><div class="line">      this-&gt;local_assemble_matrix(cell, scratch_data, copy_data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> copier = [<span class="keyword">this</span>, &amp;linear_system](<span class="keyword">const</span> AssemblyCopyData &amp;copy_data) {</div><div class="line">    this-&gt;copy_local_to_global(copy_data, linear_system);</div><div class="line">  };</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                  dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                  worker,</div><div class="line">                  copier,</div><div class="line">                  AssemblyScratchData(*fe,quadrature),</div><div class="line">                  AssemblyCopyData());</div><div class="line">  linear_system.hanging_node_constraints.condense(linear_system.matrix);</div></div><!-- fragment --><p>The syntax above requires some explanation. There are multiple version of <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> that expect different arguments. In <a class="el" href="step_9.html">step-9</a> , we used one version that took a pair of iterators, a pair of pointers to member functions with very specific argument lists, a pointer or reference to the object on which these member functions have to work, and a scratch and copy data object. This is a bit restrictive since the member functions called this way have to have an argument list that exactly matches what <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> expects: the local assembly function needs to take an iterator, a scratch object and a copy object; and the copy-local-to-global function needs to take exactly a copy object. But, what if we want something that's slightly more general? For example, in the current program, the copy-local-to-global function needs to know which linear system object to write the local contributions into, i.e., it also has to take a <code>LinearSystem</code> argument. That won't work with the approach using member function pointers. Fortunately, C++ offers a way out. These are called function objects. In essence, what <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> wants to do is not call a member function. It wants to call some function that takes an iterator, a scratch object and a copy object in the first case, and a copy object in the second case. Whether these are member functions, global functions, or something else, is really not of much concern to <a class="el" href="namespaceWorkStream.html">WorkStream</a>. Consequently, there is a second version of the function that just takes function objects</p>
<ul>
<li>objects that have an <code>operator()</code> and that consequently can be called like functions, whatever they really represent. The typical way to generate such function objects is using a <a href="http://en.wikipedia.org/wiki/Anonymous_function">lambda function</a> that wraps the function call including the individual arguments with fixed values. All the arguments that are part of the outer function signature are specified as regular function arguments in the lambda function. The fixed values are passed into the lambda function using the capture list (<code>[...]</code>). It is possible to use a capture default or to list all the variables that are to be bound to the lambda explicitly. For the sake of clarity we decided to omit the capture default here, but that capture list could equally well be <code>[&amp;]</code>, meaning that all used variables are copied into the lambda by reference. At this point, we have assembled the matrix and condensed it. The right hand side may or may not have been completely assembled, but we would like to condense the right hand side vector next. We can only do this if the assembly of this vector has finished, so we have to wait for the task to finish; in computer science, waiting for a task is typically called "joining" the task, explaining the name of the function we call below. Since that task may or may not have finished, and since we may have to wait for it to finish, we may as well try to pack other things that need to be done anyway into this gap. Consequently, we first interpolate boundary values before we wait for the right hand side. Of course, another possibility would have been to also interpolate the boundary values on a separate task since doing so is independent of the other things we have done in this function so far. Feel free to find the correct syntax to also create a task for this interpolation and start it at the top of this function, along with the assembly of the right hand side. (You will find that this is slightly more complicated since there are multiple versions of <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a>, and so simply taking the address <code>&amp;<a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a></code> produces a set of overloaded functions that can't be passed to <a class="el" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task()</a> right away</li>
<li>you have to select which element of this overload set you want by casting the address expression to a function pointer type that is specific to the version of the function that you want to call on the task.)</li>
</ul>
<div class="fragment"><div class="line">std::map&lt;types::global_dof_index, double&gt; boundary_value_map;</div><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                         0,</div><div class="line">                                        boundary_values,</div><div class="line">                                         boundary_value_map);</div><div class="line"></div><div class="line">rhs_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div><div class="line">linear_system.hanging_node_constraints.condense(linear_system.rhs);</div></div><!-- fragment --><p>Now that we have the complete linear system, we can also treat boundary values, which need to be eliminated from both the matrix and the right hand side:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_value_map,</div><div class="line">                                     linear_system.matrix,</div><div class="line">                                     solution,</div><div class="line">                                     linear_system.rhs);</div><div class="line">}</div></div><!-- fragment --><p>The second half of this set of functions deals with the local assembly on each cell and copying local contributions into the global matrix object. This works in exactly the same way as described in <a class="el" href="step_9.html">step-9</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature)</div><div class="line">  : fe_values(fe, quadrature, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div><div class="line">  <span class="keyword">const</span> AssemblyScratchData &amp;scratch_data)</div><div class="line">  : fe_values(scratch_data.fe_values.get_fe(),</div><div class="line">              scratch_data.fe_values.get_quadrature(),</div><div class="line">              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::local_assemble_matrix(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  AssemblyScratchData &amp;                                 scratch_data,</div><div class="line">  AssemblyCopyData &amp;                                    copy_data)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe-&gt;n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature-&gt;size();</div><div class="line"></div><div class="line">  copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  copy_data.local_dof_indices.resize(dofs_per_cell);</div><div class="line"></div><div class="line">  scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        copy_data.cell_matrix(i, j) +=</div><div class="line">          (scratch_data.fe_values.shape_grad(i, q_point)</div><div class="line">           scratch_data.fe_values.shape_grad(j, q_point)</div><div class="line">           scratch_data.fe_values.JxW(q_point));</div><div class="line"></div><div class="line">  cell-&gt;get_dof_indices(copy_data.local_dof_indices);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div><div class="line">                                       LinearSystem &amp;linear_system)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; copy_data.local_dof_indices.size(); ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; copy_data.local_dof_indices.size(); ++j)</div><div class="line">      linear_system.matrix.add(copy_data.local_dof_indices[i],</div><div class="line">                               copy_data.local_dof_indices[j],</div><div class="line">                               copy_data.cell_matrix(i, j));</div><div class="line">}</div></div><!-- fragment --><p>Now for the functions that implement actions in the linear system class. First, the constructor initializes all data elements to their correct sizes, and sets up a number of additional data structures, such as constraints due to hanging nodes. Since setting up the hanging nodes and finding out about the nonzero elements of the matrix is independent, we do that in parallel (if the library was configured to use concurrency, at least; otherwise, the actions are performed sequentially). Note that we start only one thread, and do the second action in the main thread. Since only one task is generated, we don't use the <code><a class="el" href="classThreads_1_1TaskGroup.html">Threads::TaskGroup</a></code> class here, but rather use the one created task object directly to wait for this particular task's exit. Note that taking up the address of the <code><a class="el" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a></code> function is a little tricky, since there are actually three of them, one for each supported space dimension. Taking addresses of overloaded functions is somewhat complicated in C++, since the address-of operator <code>&amp;</code> in that case returns more like a set of values (the addresses of all functions with that name), and selecting the right one is then the next step. If the context dictates which one to take (for example by assigning to a function pointer of known type), then the compiler can do that by itself, but if this set of pointers shall be given as the argument to a function that takes a template, the compiler could choose all without having a preference for one. We therefore have to make it clear to the compiler which one we would like to have; for this, we could use a cast, but for more clarity, we assign it to a temporary <code>mhnc_p</code> (short for <code>pointer to make_hanging_node_constraints</code>) with the right type, and using this pointer instead.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solver&lt;dim&gt;::LinearSystem::LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  hanging_node_constraints.clear();</div><div class="line"></div><div class="line">  void (*mhnc_p)(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;, <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;) =</div><div class="line">    &amp;<a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>;</div></div><!-- fragment --><p>Start a side task then continue on the main thread</p>
<div class="fragment"><div class="line"><a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> side_task =</div><div class="line">  <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a>(mhnc_p, dof_handler, hanging_node_constraints);</div><div class="line"></div><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div></div><!-- fragment --><p>Wait for the side task to be done before going further</p>
<div class="fragment"><div class="line">side_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div><div class="line"></div><div class="line">hanging_node_constraints.close();</div><div class="line">hanging_node_constraints.condense(dsp);</div><div class="line">sparsity_pattern.copy_from(dsp);</div></div><!-- fragment --><p>Finally initialize the matrix and right hand side vector</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>.reinit(sparsity_pattern);</div><div class="line">  rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p>The second function of this class simply solves the linear system by a preconditioned conjugate gradient method. This has been extensively discussed before, so we don't dwell into it any more.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::LinearSystem::solve(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, 1.2);</div><div class="line"></div><div class="line">  cg.solve(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, solution, rhs, preconditioner);</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Aprimalsolver"></a> </p><h4>A primal solver</h4>
<p>In the previous section, a base class for Laplace solvers was implemented, that lacked the functionality to assemble the right hand side vector, however, for reasons that were explained there. Now we implement a corresponding class that can do this for the case that the right hand side of a problem is given as a function object. The actions of the class are rather what you have seen already in previous examples already, so a brief explanation should suffice: the constructor takes the same data as does that of the underlying class (to which it passes all information) except for one function object that denotes the right hand side of the problem. A pointer to this object is stored (again as a <code><a class="el" href="classSmartPointer.html">SmartPointer</a></code> , in order to make sure that the function object is not deleted as long as it is still used by this class). The only functional part of this class is the <code>assemble_rhs</code> method that does what its name suggests.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PrimalSolver : <span class="keyword">public</span> Solver&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt; rhs_function;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;rhs) <span class="keyword">const override</span>;</div><div class="line">};</div></div><!-- fragment --><p>The constructor of this class basically does what it is announced to do above...</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">PrimalSolver&lt;dim&gt;::PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">  : Base&lt;dim&gt;(triangulation)</div><div class="line">  , Solver&lt;dim&gt;(triangulation, fe, quadrature, boundary_values)</div><div class="line">  , rhs_function(&amp;rhs_function)</div><div class="line">{}</div></div><!-- fragment --><p>... as does the <code>assemble_rhs</code> function. Since this is explained in several of the previous example programs, we leave it at that.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PrimalSolver&lt;dim&gt;::assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;rhs)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(*this-&gt;fe,</div><div class="line">                         this-&gt;quadrature,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = this-&gt;fe-&gt;n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = this-&gt;quadrature-&gt;size();</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       cell_rhs(dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt;                  rhs_values(n_q_points);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : this-&gt;dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_rhs = 0;</div><div class="line">      fe_values.reinit(cell);</div><div class="line">      rhs_function-&gt;value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                               rhs_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point)</div><div class="line">                         rhs_values[q_point]</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Globalrefinement"></a> </p><h4>Global refinement</h4>
<p>By now, all functions of the abstract base class except for the <code>refine_grid</code> function have been implemented. We will now have two classes that implement this function for the <code>PrimalSolver</code> class, one doing global refinement, one a form of local refinement. The first, doing global refinement, is rather simple: its main function just calls <code>triangulation-&gt;refine_global (1);</code> , which does all the work. Note that since the <code>Base</code> base class of the <code>Solver</code> class is virtual, we have to declare a constructor that initializes the immediate base class as well as the abstract virtual one. Apart from this technical complication, the class is probably simple enough to be left without further comments.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RefinementGlobal : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  RefinementGlobal(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">RefinementGlobal&lt;dim&gt;::RefinementGlobal(</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">  : Base&lt;dim&gt;(coarse_grid)</div><div class="line">  , PrimalSolver&lt;dim&gt;(coarse_grid,</div><div class="line">                      fe,</div><div class="line">                      quadrature,</div><div class="line">                      rhs_function,</div><div class="line">                      boundary_values)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> RefinementGlobal&lt;dim&gt;::refine_grid()</div><div class="line">{</div><div class="line">  this-&gt;triangulation-&gt;refine_global(1);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LocalrefinementbytheKellyerrorindicator"></a> </p><h4>Local refinement by the Kelly error indicator</h4>
<p>The second class implementing refinement strategies uses the Kelly refinement indicator used in various example programs before. Since this indicator is already implemented in a class of its own inside the deal.II library, there is not much t do here except cal the function computing the indicator, then using it to select a number of cells for refinement and coarsening, and refinement the mesh accordingly. Again, this should now be sufficiently standard to allow the omission of further comments.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RefinementKelly : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  RefinementKelly&lt;dim&gt;::RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;rhs_function,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;boundary_values)</div><div class="line">    : Base&lt;dim&gt;(coarse_grid)</div><div class="line">    , PrimalSolver&lt;dim&gt;(coarse_grid,</div><div class="line">                        fe,</div><div class="line">                        quadrature,</div><div class="line">                        rhs_function,</div><div class="line">                        boundary_values)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> RefinementKelly&lt;dim&gt;::refine_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(</div><div class="line">      this-&gt;triangulation-&gt;n_active_cells());</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      this-&gt;dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt;(this-&gt;fe-&gt;degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>&gt;(),</div><div class="line">      this-&gt;solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(*this-&gt;triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line">    this-&gt;triangulation-&gt;execute_coarsening_and_refinement();</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace LaplaceSolver</span></div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>As this is one more academic example, we'd like to compare exact and computed solution against each other. For this, we need to declare function classes representing the exact solution (for comparison and for the Dirichlet boundary values), as well as a class that denotes the right hand side of the equation (this is simply the Laplace operator applied to the exact solution we'd like to recover). For this example, let us choose as exact solution the function \(u(x,y)=exp(x+sin(10y+5x^2))\) . In more than two dimensions, simply repeat the sine-factor with <code>y</code> replaced by <code>z</code> and so on. Given this, the following two classes are probably straightforward from the previous examples.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Solution&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void)component;</div><div class="line">  <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">  <span class="keywordtype">double</span> q = p(0);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">    q += std::sin(10 p(i) + 5 p(0) p(0));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> exponential = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(q);</div><div class="line">  <span class="keywordflow">return</span> exponential;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void)component;</div><div class="line">  <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">  <span class="keywordtype">double</span> q = p(0);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">    q += std::sin(10 p(i) + 5 p(0) p(0));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> u  = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(q);</div><div class="line">  <span class="keywordtype">double</span>       t1 = 1, t2 = 0, t3 = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      t1 += <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 p(i) + 5 p(0) p(0)) 10 p(0);</div><div class="line">      t2 += 10 <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 p(i) + 5 p(0) p(0))</div><div class="line"></div><div class="line">-</div><div class="line">            100 <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(10 p(i) + 5 p(0) p(0)) p(0) p(0);</div><div class="line">      t3 += 100 <a class="code" href="namespacestd.html">std</a>::cos(10 p(i) + 5 p(0) p(0))</div><div class="line">              <a class="code" href="namespacestd.html">std</a>::cos(10 p(i) + 5 p(0) p(0))</div><div class="line"></div><div class="line">-</div><div class="line">            100 <a class="code" href="namespacestd.html">std</a>::sin(10 p(i) + 5 p(0) p(0));</div><div class="line">    };</div><div class="line">  t1 = t1 t1;</div><div class="line"></div><div class="line">  return</div><div class="line"></div><div class="line">-u (t1 + t2 + t3);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thedriverroutines"></a> </p><h3>The driver routines</h3>
<p>What is now missing are only the functions that actually select the various options, and run the simulation on successively finer grids to monitor the progress as the mesh is refined. This we do in the following function: it takes a solver object, and a list of postprocessing (evaluation) objects, and runs them with intermittent mesh refinement:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> run_simulation(</div><div class="line">  LaplaceSolver::Base&lt;dim&gt; &amp;                          solver,</div><div class="line">  <span class="keyword">const</span> std::list&lt;Evaluation::EvaluationBase&lt;dim&gt;&gt; &amp;postprocessor_list)</div><div class="line">{</div></div><!-- fragment --><p>We will give an indicator of the step we are presently computing, in order to keep the user informed that something is still happening, and that the program is not in an endless loop. This is the head of this status line:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle: &quot;</span>;</div></div><!-- fragment --><p>Then start a loop which only terminates once the number of degrees of freedom is larger than 20,000 (you may of course change this limit, if you need more</p>
<ul>
<li>or less</li>
<li>accuracy from your program).</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; <span class="keyword">true</span>; ++step)</div><div class="line">  {</div></div><!-- fragment --><p>Then give the <code>alive</code> indication for this iteration. Note that the <code>std::flush</code> is needed to have the text actually appear on the screen, rather than only in some buffer that is only flushed the next time we issue an end-line.</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; step &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::flush;</div></div><!-- fragment --><p>Now solve the problem on the present grid, and run the evaluators on it. The long type name of iterators into the list is a little annoying, but could be shortened by an alias, if so desired.</p>
<div class="fragment"><div class="line">solver.solve_problem();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;postprocessor : postprocessor_list)</div><div class="line">  {</div><div class="line">    postprocessor-&gt;set_refinement_cycle(step);</div><div class="line">    solver.postprocess(*postprocessor);</div><div class="line">  };</div></div><!-- fragment --><p>Now check whether more iterations are required, or whether the loop shall be ended:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">if</span> (solver.n_dofs() &lt; 20000)</div><div class="line">    solver.refine_grid();</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">};</div></div><!-- fragment --><p>Finally end the line in which we displayed status reports:</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>The final function is one which takes the name of a solver (presently "kelly" and "global" are allowed), creates a solver object out of it using a coarse grid (in this case the ubiquitous unit square) and a finite element object (here the likewise ubiquitous bilinear one), and uses that solver to ask for the solution of the problem on a sequence of successively refined grids. The function also sets up two of evaluation functions, one evaluating the solution at the point (0.5,0.5), the other writing out the solution to a file.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> solve_problem(<span class="keyword">const</span> std::string &amp;solver_name)</div><div class="line">{</div></div><!-- fragment --><p>First minor task: tell the user what is going to happen. Thus write a header line, and a line with all '-' characters of the same length as the first one right below.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string header =</div><div class="line">  <span class="stringliteral">&quot;Running tests with \&quot;&quot;</span> + solver_name + <span class="stringliteral">&quot;\&quot; refinement criterion:&quot;</span>;</div><div class="line">std::cout &lt;&lt; header &lt;&lt; std::endl</div><div class="line">          &lt;&lt; std::string(header.size(), <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div></div><!-- fragment --><p>Then set up triangulation, finite element, etc.</p>
<div class="fragment"><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation,</div><div class="line"></div><div class="line">-1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>    fe(1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature(4);</div><div class="line">  RightHandSide&lt;dim&gt; rhs_function;</div><div class="line">  Solution&lt;dim&gt;      boundary_values;</div></div><!-- fragment --><p>Create a solver object of the kind indicated by the argument to this function. If the name is not recognized, throw an exception! The respective solver object is stored in a <code>std::unique_ptr</code> to avoid having to delete the pointer after use.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;LaplaceSolver::Base&lt;dim&gt;&gt; solver;</div><div class="line"><span class="keywordflow">if</span> (solver_name == <span class="stringliteral">&quot;global&quot;</span>)</div><div class="line">  solver = std::make_unique&lt;LaplaceSolver::RefinementGlobal&lt;dim&gt;&gt;(</div><div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, rhs_function, boundary_values);</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (solver_name == <span class="stringliteral">&quot;kelly&quot;</span>)</div><div class="line">  solver = std::make_unique&lt;LaplaceSolver::RefinementKelly&lt;dim&gt;&gt;(</div><div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, rhs_function, boundary_values);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div></div><!-- fragment --><p>Next create a table object in which the values of the numerical solution at the point (0.5,0.5) will be stored, and create a respective evaluation object:</p>
<div class="fragment"><div class="line"><a class="code" href="classTableHandler.html">TableHandler</a>                          results_table;</div><div class="line">Evaluation::PointValueEvaluation&lt;dim&gt; postprocessor1(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5),</div><div class="line">                                                     results_table);</div></div><!-- fragment --><p>Also generate an evaluator which writes out the solution:</p>
<div class="fragment"><div class="line">Evaluation::SolutionOutput&lt;dim&gt; postprocessor2(std::string(<span class="stringliteral">&quot;solution-&quot;</span>) +</div><div class="line">                                                 solver_name,</div><div class="line">                                               <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">DataOutBase::gnuplot</a>);</div></div><!-- fragment --><p>Take these two evaluation objects and put them in a list...</p>
<div class="fragment"><div class="line">std::list&lt;Evaluation::EvaluationBase&lt;dim&gt;&gt; postprocessor_list;</div><div class="line">postprocessor_list.push_back(&amp;postprocessor1);</div><div class="line">postprocessor_list.push_back(&amp;postprocessor2);</div></div><!-- fragment --><p>... which we can then pass on to the function that actually runs the simulation on successively refined grids:</p>
<div class="fragment"><div class="line">run_simulation(*solver, postprocessor_list);</div></div><!-- fragment --><p>When this all is done, write out the results of the point evaluations:</p>
<div class="fragment"><div class="line">results_table.<a class="code" href="classTableHandler.html#a45c4ec9981f3880c6c852ed3aceb08fe">write_text</a>(std::cout);</div></div><!-- fragment --><p>And one blank line after all results:</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">}</div><div class="line">} <span class="comment">// namespace Step13</span></div></div><!-- fragment --><p>There is not much to say about the main function. It follows the same pattern as in all previous examples, with attempts to catch thrown exceptions, and displaying as much information as possible if we should get some. The rest is self-explanatory.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    Step13::solve_problem&lt;2&gt;(<span class="stringliteral">&quot;global&quot;</span>);</div><div class="line">    Step13::solve_problem&lt;2&gt;(<span class="stringliteral">&quot;kelly&quot;</span>);</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  };</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The results of this program are not that interesting</p>
<ul>
<li>after allits purpose was not to demonstrate some new mathematical idea, andalso not how to program with deal.II, but rather to use the materialwhich we have developed in the previous examples to form somethingwhich demonstrates a way to build modern finite element software in amodular and extensible way.</li>
</ul>
<p>Nevertheless, we of course show the results of the program. Offoremost interest is the point value computation, for which we hadimplemented the corresponding evaluation class. The results (i.e. theoutput) of the program looks as follows: </p><div class="fragment"><div class="line">Running tests with <span class="stringliteral">&quot;global&quot;</span> refinement criterion:</div><div class="line"></div><div class="line">-------------------------------------------------</div><div class="line">Refinement cycle: 0 1 2 3 4 5 6</div><div class="line">DoFs  u(x_0)</div><div class="line">25 1.2868</div><div class="line">81 1.6945</div><div class="line">289 1.4658</div><div class="line">1089 1.5679</div><div class="line">4225 1.5882</div><div class="line">16641 1.5932</div><div class="line">66049 1.5945</div><div class="line"></div><div class="line">Running tests with <span class="stringliteral">&quot;kelly&quot;</span> refinement criterion:</div><div class="line"></div><div class="line">------------------------------------------------</div><div class="line">Refinement cycle: 0 1 2 3 4 5 6 7 8 9 10 11</div><div class="line">DoFs  u(x_0)</div><div class="line">25 1.2868</div><div class="line">47 0.8775</div><div class="line">89 1.5365</div><div class="line">165 1.2974</div><div class="line">316 1.6442</div><div class="line">589 1.5221</div><div class="line">1093 1.5724</div><div class="line">2042 1.5627</div><div class="line">3766 1.5916</div><div class="line">7124 1.5876</div><div class="line">13111 1.5942</div><div class="line">24838 1.5932</div></div><!-- fragment --><p>What surprises here is that the exact value is 1.59491554..., and thatit is apparently surprisingly complicated to compute the solution even toonly one per cent accuracy, although the solution is smooth (in factinfinitely often differentiable). This smoothness is shown in thegraphical output generated by the program, here coarse grid and thefirst 9 refinement steps of the Kelly refinement indicator:</p>
<table width="80%" align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-0.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-1.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-2.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-3.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-4.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-5.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-6.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-7.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-8.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-9.png"/>
</div>
   </td></tr>
</table>
<p>While we're already at watching pictures, this is the eighth grid, asviewed from top:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.grid-kelly-8.png"/>
</div>
<p>However, we are not yet finished with evaluation the point valuecomputation. In fact, plotting the error \(e=|u(x_0)-u_h(x_0)|\) for the tworefinement criteria yields the following picture:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.error.png"/>
</div>
<p>What <em> is </em> disturbing about this picture is that not only is theadaptive mesh refinement not better than global refinement as onewould usually expect, it is even significantly worse since itsconvergence is irregular, preventing all extrapolation techniques whenusing the values of subsequent meshes! On the other hand, globalrefinement provides a perfect \(1/N\) or \(h^{-2}\) convergence history and provides every opportunity to even improve onthe point values by extrapolation. Global mesh refinement musttherefore be considered superior in this example! This is even moresurprising as the evaluation point is not somewhere in the left partwhere the mesh is coarse, but rather to the right and the adaptiverefinement should refine the mesh around the evaluation point as well.</p>
<p>We thus close the discussion of this example program with a question: </p>
<p><b> <em> What is wrong with adaptivity if it is not better than global refinement? </em> </b></p>
<p><em> Exercise at the end of this example: </em> There is a simple reasonfor the bad and irregular behavior of the adapted mesh solutions. Itis simple to find out by looking at the mesh around the evaluationpoint in each of the steps</p>
<ul>
<li>the data for this is in the output filesof the program. An exercise would therefore be to modify the meshrefinement routine such that the problem (once you remark it) isavoided. The second exercise is to check whether the results are thenbetter than global refinement, and if so if even a better order ofconvergence (in terms of the number of degrees of freedom) isachieved, or only by a better constant.</li>
</ul>
<p>( <em> Very brief answers for the impatient: </em> at steps with largererrors, the mesh is not regular at the point of evaluation, i.e. someof the adjacent cells have hanging nodes; this destroys somesuperapproximation effects of which the globally refined mesh canprofit. Answer 2: this quick hack </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> refinement_indicated = <span class="keyword">false</span>;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line"> <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line"><span class="keywordflow">if</span> (cell-&gt;vertex(v) == <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(.5,.5))</div><div class="line">  {</div><div class="line">    cell-&gt;clear_coarsen_flag();</div><div class="line">    refinement_indicated |= cell-&gt;refine_flag_set();</div><div class="line">  }</div><div class="line"><span class="keywordflow">if</span> (refinement_indicated)</div><div class="line"> <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">   <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;vertex(v) == <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(.5,.5))</div><div class="line">    cell-&gt;set_refine_flag ();</div></div><!-- fragment --><p> in the refinement function of the Kelly refinement class right beforeexecuting refinement would improve the results (exercise: what doesthe code do?), making them consistently better than globalrefinement. Behavior is still irregular, though, so no results aboutan order of convergence are possible.)</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2001 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, University of Heidelberg, 2001, 2002</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="table__handler_8h.html">deal.II/base/table_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="thread__management_8h.html">deal.II/base/thread_management.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step13</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>Evaluation</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>EvaluationBase</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      <span class="keyword">virtual</span> ~EvaluationBase() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                              <span class="keyword">const</span> Vector&lt;double&gt; &amp; solution) <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> EvaluationBase&lt;dim&gt;::set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step)</div><div class="line">    {</div><div class="line">      refinement_cycle = step;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>PointValueEvaluation : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      PointValueEvaluation(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point,</div><div class="line">                           <a class="code" href="classTableHandler.html">TableHandler</a> &amp;    results_table);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                              <span class="keyword">const</span> Vector&lt;double&gt; &amp; solution) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a>(</div><div class="line">        ExcEvaluationPointNotFound,</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div><div class="line">      <a class="code" href="classTableHandler.html">TableHandler</a> &amp;   results_table;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    PointValueEvaluation&lt;dim&gt;::PointValueEvaluation(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point,</div><div class="line">      <a class="code" href="classTableHandler.html">TableHandler</a> &amp;    results_table)</div><div class="line">      : evaluation_point(evaluation_point)</div><div class="line">      , results_table(results_table)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> PointValueEvaluation&lt;dim&gt;::</div><div class="line">         operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">               <span class="keyword">const</span> Vector&lt;double&gt; &amp; solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordtype">double</span> point_value = 1e20;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> evaluation_point_found = <span class="keyword">false</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">if</span> (!evaluation_point_found)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex : cell-&gt;vertex_indices())</div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;vertex(vertex) == evaluation_point)</div><div class="line">              {</div><div class="line">                point_value = solution(cell-&gt;vertex_dof_index(vertex, 0));</div><div class="line"></div><div class="line">                evaluation_point_found = <span class="keyword">true</span>;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">              };</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_point_found,</div><div class="line">                  ExcEvaluationPointNotFound(evaluation_point));</div><div class="line"></div><div class="line">      results_table.<a class="code" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a>(<span class="stringliteral">&quot;DoFs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      results_table.<a class="code" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a>(<span class="stringliteral">&quot;u(x_0)&quot;</span>, point_value);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>SolutionOutput : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      SolutionOutput(<span class="keyword">const</span> std::string &amp;             output_name_base,</div><div class="line">                     <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                              <span class="keyword">const</span> Vector&lt;double&gt; &amp; solution) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> std::string               output_name_base;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    SolutionOutput&lt;dim&gt;::SolutionOutput(</div><div class="line">      <span class="keyword">const</span> std::string &amp;             output_name_base,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format)</div><div class="line">      : output_name_base(output_name_base)</div><div class="line">      , output_format(output_format)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> SolutionOutput&lt;dim&gt;::operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                         <span class="keyword">const</span> Vector&lt;double&gt; &amp; solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">      data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">      std::ofstream out(output_name_base + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                        <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(this-&gt;refinement_cycle) +</div><div class="line">                        data_out.<a class="code" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a>(output_format));</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a>(out, output_format);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  } <span class="comment">// namespace Evaluation</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>LaplaceSolver</div><div class="line">  {</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Base</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid);</div><div class="line">      <span class="keyword">virtual</span> ~Base() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> solve_problem() = 0;</div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div><div class="line">        <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const</span> = 0;</div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span>         refine_grid()                            = 0;</div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const</span>                           = 0;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;Triangulation&lt;dim&gt;</a>&gt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Base&lt;dim&gt;::Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid)</div><div class="line">      : triangulation(&amp;coarse_grid)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Solver : <span class="keyword">public</span> <span class="keyword">virtual</span> Base&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line">      <span class="keyword">virtual</span> ~Solver() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> solve_problem() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div><div class="line">        <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const FiniteElement&lt;dim&gt;</a>&gt; fe;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Quadrature&lt;dim&gt;</a>&gt;    quadrature;</div><div class="line">      <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                              dof_handler;</div><div class="line">      Vector&lt;double&gt;                               solution;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt;      boundary_values;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(Vector&lt;double&gt; &amp;rhs) <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">struct </span>LinearSystem</div><div class="line">      {</div><div class="line">        LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler);</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> solve(Vector&lt;double&gt; &amp;solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">        <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line">        <a class="code" href="classSparsityPattern.html">SparsityPattern</a>           sparsity_pattern;</div><div class="line">        <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>      <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">        Vector&lt;double&gt;            rhs;</div><div class="line">      };</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">struct </span>AssemblyScratchData</div><div class="line">      {</div><div class="line">        AssemblyScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature);</div><div class="line">        AssemblyScratchData(<span class="keyword">const</span> AssemblyScratchData &amp;scratch_data);</div><div class="line"></div><div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keyword">struct </span>AssemblyCopyData</div><div class="line">      {</div><div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">        std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> assemble_linear_system(LinearSystem &amp;linear_system);</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> local_assemble_matrix(</div><div class="line">        <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">        AssemblyScratchData &amp;                                 scratch_data,</div><div class="line">        AssemblyCopyData &amp;                                    copy_data) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div><div class="line">                                LinearSystem &amp;          linear_system) <span class="keyword">const</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Solver&lt;dim&gt;::Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">      : Base&lt;dim&gt;(triangulation)</div><div class="line">      , fe(&amp;fe)</div><div class="line">      , quadrature(&amp;quadrature)</div><div class="line">      , dof_handler(triangulation)</div><div class="line">      , boundary_values(&amp;boundary_values)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Solver&lt;dim&gt;::~Solver()</div><div class="line">    {</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::solve_problem()</div><div class="line">    {</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(*fe);</div><div class="line">      solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">      LinearSystem linear_system(dof_handler);</div><div class="line">      assemble_linear_system(linear_system);</div><div class="line">      linear_system.solve(solution);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::postprocess(</div><div class="line">      <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      postprocessor(dof_handler, solution);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Solver&lt;dim&gt;::n_dofs()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::assemble_linear_system(LinearSystem &amp;linear_system)</div><div class="line">    {</div><div class="line">      <a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> rhs_task =</div><div class="line">        <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a>(&amp;Solver&lt;dim&gt;::assemble_rhs, *<span class="keyword">this</span>, linear_system.rhs);</div><div class="line"></div><div class="line">      <span class="keyword">auto</span> worker =</div><div class="line">        [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">               AssemblyScratchData &amp;scratch_data,</div><div class="line">               AssemblyCopyData &amp;   copy_data) {</div><div class="line">          this-&gt;local_assemble_matrix(cell, scratch_data, copy_data);</div><div class="line">        };</div><div class="line"></div><div class="line">      <span class="keyword">auto</span> copier = [<span class="keyword">this</span>, &amp;linear_system](<span class="keyword">const</span> AssemblyCopyData &amp;copy_data) {</div><div class="line">        this-&gt;copy_local_to_global(copy_data, linear_system);</div><div class="line">      };</div><div class="line"></div><div class="line">      <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                      dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                      worker,</div><div class="line">                      copier,</div><div class="line">                      AssemblyScratchData(*fe, *quadrature),</div><div class="line">                      AssemblyCopyData());</div><div class="line">      linear_system.hanging_node_constraints.condense(linear_system.matrix);</div><div class="line"></div><div class="line">      std::map&lt;types::global_dof_index, double&gt; boundary_value_map;</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               0,</div><div class="line">                                               *boundary_values,</div><div class="line">                                               boundary_value_map);</div><div class="line"></div><div class="line">      rhs_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div><div class="line">      linear_system.hanging_node_constraints.condense(linear_system.rhs);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_value_map,</div><div class="line">                                         linear_system.matrix,</div><div class="line">                                         solution,</div><div class="line">                                         linear_system.rhs);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature)</div><div class="line">      : fe_values(fe, quadrature, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div><div class="line">      <span class="keyword">const</span> AssemblyScratchData &amp;scratch_data)</div><div class="line">      : fe_values(scratch_data.fe_values.get_fe(),</div><div class="line">                  scratch_data.fe_values.get_quadrature(),</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::local_assemble_matrix(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">      AssemblyScratchData &amp;                                 scratch_data,</div><div class="line">      AssemblyCopyData &amp;                                    copy_data)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe-&gt;n_dofs_per_cell();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature-&gt;size();</div><div class="line"></div><div class="line">      copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">      copy_data.local_dof_indices.resize(dofs_per_cell);</div><div class="line"></div><div class="line">      scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            copy_data.cell_matrix(i, j) +=</div><div class="line">              (scratch_data.fe_values.shape_grad(i, q_point) *</div><div class="line">               scratch_data.fe_values.shape_grad(j, q_point) *</div><div class="line">               scratch_data.fe_values.JxW(q_point));</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(copy_data.local_dof_indices);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div><div class="line">                                           LinearSystem &amp;linear_system)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; copy_data.local_dof_indices.size(); ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; copy_data.local_dof_indices.size(); ++j)</div><div class="line">          linear_system.matrix.add(copy_data.local_dof_indices[i],</div><div class="line">                                   copy_data.local_dof_indices[j],</div><div class="line">                                   copy_data.cell_matrix(i, j));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Solver&lt;dim&gt;::LinearSystem::LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler)</div><div class="line">    {</div><div class="line">      hanging_node_constraints.clear();</div><div class="line"></div><div class="line">      void (*mhnc_p)(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;, <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;) =</div><div class="line">        &amp;<a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>;</div><div class="line"></div><div class="line">      <a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> side_task =</div><div class="line">        <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a>(mhnc_p, dof_handler, hanging_node_constraints);</div><div class="line"></div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">      side_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div><div class="line"></div><div class="line">      hanging_node_constraints.close();</div><div class="line">      hanging_node_constraints.condense(dsp);</div><div class="line">      sparsity_pattern.copy_from(dsp);</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>.reinit(sparsity_pattern);</div><div class="line">      rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::LinearSystem::solve(Vector&lt;double&gt; &amp;solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">      <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">      preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, 1.2);</div><div class="line"></div><div class="line">      cg.solve(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, solution, rhs, preconditioner);</div><div class="line"></div><div class="line">      hanging_node_constraints.distribute(solution);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>PrimalSolver : <span class="keyword">public</span> Solver&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt; rhs_function;</div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(Vector&lt;double&gt; &amp;rhs) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    PrimalSolver&lt;dim&gt;::PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">      : Base&lt;dim&gt;(triangulation)</div><div class="line">      , Solver&lt;dim&gt;(triangulation, fe, quadrature, boundary_values)</div><div class="line">      , rhs_function(&amp;rhs_function)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> PrimalSolver&lt;dim&gt;::assemble_rhs(Vector&lt;double&gt; &amp;rhs)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(*this-&gt;fe,</div><div class="line">                              *this-&gt;quadrature,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = this-&gt;fe-&gt;n_dofs_per_cell();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = this-&gt;quadrature-&gt;size();</div><div class="line"></div><div class="line">      Vector&lt;double&gt;                       cell_rhs(dofs_per_cell);</div><div class="line">      std::vector&lt;double&gt;                  rhs_values(n_q_points);</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : this-&gt;dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          cell_rhs = 0;</div><div class="line">          fe_values.reinit(cell);</div><div class="line">          rhs_function-&gt;value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                   rhs_values);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * </div><div class="line">                             rhs_values[q_point] *               </div><div class="line">                             fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        };</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>RefinementGlobal : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      RefinementGlobal(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                       <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                       <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                       <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                       <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    RefinementGlobal&lt;dim&gt;::RefinementGlobal(</div><div class="line">      <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">      : Base&lt;dim&gt;(coarse_grid)</div><div class="line">      , PrimalSolver&lt;dim&gt;(coarse_grid,</div><div class="line">                          fe,</div><div class="line">                          quadrature,</div><div class="line">                          rhs_function,</div><div class="line">                          boundary_values)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> RefinementGlobal&lt;dim&gt;::refine_grid()</div><div class="line">    {</div><div class="line">      this-&gt;triangulation-&gt;refine_global(1);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>RefinementKelly : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    RefinementKelly&lt;dim&gt;::RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;rhs_function,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;boundary_values)</div><div class="line">      : Base&lt;dim&gt;(coarse_grid)</div><div class="line">      , PrimalSolver&lt;dim&gt;(coarse_grid,</div><div class="line">                          fe,</div><div class="line">                          quadrature,</div><div class="line">                          rhs_function,</div><div class="line">                          boundary_values)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> RefinementKelly&lt;dim&gt;::refine_grid()</div><div class="line">    {</div><div class="line">      Vector&lt;float&gt; estimated_error_per_cell(</div><div class="line">        this-&gt;triangulation-&gt;n_active_cells());</div><div class="line">      <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">        this-&gt;dof_handler,</div><div class="line">        <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(this-&gt;fe-&gt;degree + 1),</div><div class="line">        std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">        this-&gt;solution,</div><div class="line">        estimated_error_per_cell);</div><div class="line">      <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(*this-&gt;triangulation,</div><div class="line">                                                      estimated_error_per_cell,</div><div class="line">                                                      0.3,</div><div class="line">                                                      0.03);</div><div class="line">      this-&gt;triangulation-&gt;execute_coarsening_and_refinement();</div><div class="line">    }</div><div class="line"></div><div class="line">  } <span class="comment">// namespace LaplaceSolver</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Solution&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">    <span class="keywordtype">double</span> q = p(0);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">      q += std::sin(10 * p(i) + 5 * p(0) * p(0));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> exponential = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(q);</div><div class="line">    <span class="keywordflow">return</span> exponential;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">    <span class="keywordtype">double</span> q = p(0);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">      q += std::sin(10 * p(i) + 5 * p(0) * p(0));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> u  = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(q);</div><div class="line">    <span class="keywordtype">double</span>       t1 = 1, t2 = 0, t3 = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        t1 += <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) * 10 * p(0);</div><div class="line">        t2 += 10 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) -</div><div class="line">              100 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(10 * p(i) + 5 * p(0) * p(0)) * p(0) * p(0);</div><div class="line">        t3 += 100 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) *</div><div class="line">                <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) -</div><div class="line">              100 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(10 * p(i) + 5 * p(0) * p(0));</div><div class="line">      };</div><div class="line">    t1 = t1 * t1;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> -u * (t1 + t2 + t3);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> run_simulation(</div><div class="line">    LaplaceSolver::Base&lt;dim&gt; &amp;                          solver,</div><div class="line">    <span class="keyword">const</span> std::list&lt;Evaluation::EvaluationBase&lt;dim&gt; *&gt; &amp;postprocessor_list)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle: &quot;</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; <span class="keyword">true</span>; ++step)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; step &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">        solver.solve_problem();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;postprocessor : postprocessor_list)</div><div class="line">          {</div><div class="line">            postprocessor-&gt;set_refinement_cycle(step);</div><div class="line">            solver.postprocess(*postprocessor);</div><div class="line">          };</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (solver.n_dofs() &lt; 20000)</div><div class="line">          solver.refine_grid();</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">      };</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> solve_problem(<span class="keyword">const</span> std::string &amp;solver_name)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> std::string header =</div><div class="line">      <span class="stringliteral">&quot;Running tests with \&quot;&quot;</span> + solver_name + <span class="stringliteral">&quot;\&quot; refinement criterion:&quot;</span>;</div><div class="line">    std::cout &lt;&lt; header &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::string(header.size(), <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">    triangulation.refine_global(2);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>    fe(1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature(4);</div><div class="line">    RightHandSide&lt;dim&gt; rhs_function;</div><div class="line">    Solution&lt;dim&gt;      boundary_values;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;LaplaceSolver::Base&lt;dim&gt;&gt; solver;</div><div class="line">    <span class="keywordflow">if</span> (solver_name == <span class="stringliteral">&quot;global&quot;</span>)</div><div class="line">      solver = std::make_unique&lt;LaplaceSolver::RefinementGlobal&lt;dim&gt;&gt;(</div><div class="line">        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, rhs_function, boundary_values);</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (solver_name == <span class="stringliteral">&quot;kelly&quot;</span>)</div><div class="line">      solver = std::make_unique&lt;LaplaceSolver::RefinementKelly&lt;dim&gt;&gt;(</div><div class="line">        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, rhs_function, boundary_values);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classTableHandler.html">TableHandler</a>                          results_table;</div><div class="line">    Evaluation::PointValueEvaluation&lt;dim&gt; postprocessor1(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5),</div><div class="line">                                                         results_table);</div><div class="line"></div><div class="line">    Evaluation::SolutionOutput&lt;dim&gt; postprocessor2(std::string(<span class="stringliteral">&quot;solution-&quot;</span>) +</div><div class="line">                                                     solver_name,</div><div class="line">                                                   <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">DataOutBase::gnuplot</a>);</div><div class="line"></div><div class="line">    std::list&lt;Evaluation::EvaluationBase&lt;dim&gt; *&gt; postprocessor_list;</div><div class="line">    postprocessor_list.push_back(&amp;postprocessor1);</div><div class="line">    postprocessor_list.push_back(&amp;postprocessor2);</div><div class="line"></div><div class="line">    run_simulation(*solver, postprocessor_list);</div><div class="line"></div><div class="line">    results_table.<a class="code" href="classTableHandler.html#a45c4ec9981f3880c6c852ed3aceb08fe">write_text</a>(std::cout);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step13</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step13::solve_problem&lt;2&gt;(<span class="stringliteral">&quot;global&quot;</span>);</div><div class="line">      Step13::solve_problem&lt;2&gt;(<span class="stringliteral">&quot;kelly&quot;</span>);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_6.html">step-6</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Backgroundandpurpose">Background and purpose</a>
        <li><a href="#Whattheprogramdoes">What the program does</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Evaluationofthesolution">Evaluation of the solution</a>
      <ul>
        <li><a href="#Pointevaluation">%Point evaluation</a>
        <li><a href="#Generatingoutput">Generating output</a>
        <li><a href="#Otherevaluations">Other evaluations</a>
      </ul>
        <li><a href="#TheLaplacesolverclasses">The Laplace solver classes</a>
      <ul>
        <li><a href="#Anabstractbaseclass">An abstract base class</a>
        <li><a href="#Ageneralsolverclass">A general solver class</a>
        <li><a href="#Aprimalsolver">A primal solver</a>
        <li><a href="#Globalrefinement">Global refinement</a>
        <li><a href="#LocalrefinementbytheKellyerrorindicator">Local refinement by the Kelly error indicator</a>
      </ul>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#Thedriverroutines">The driver routines</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-13/doc/intro.dox</p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Backgroundandpurpose"></a></p><h3>Background and purpose</h3>
<p>在这个例子程序中，我们将不太关注描述如何使用deal.II及其设施的新方法，而是介绍编写模块化和可扩展有限元程序的方法。其主要原因是现代研究软件的规模和复杂性：实现现代误差估计概念和自适应求解方法的应用程序往往变得相当大。例如，当这个程序是在2002年写的时候，deal.II的主要作者的三个最大的应用程序，在写这个例子程序的时候。&lt;ol&gt;  一个用非连续加尔金有限元法求解守恒双曲方程的程序。33,775行代码；  一个参数估计程序。28,980行代码；  一个波浪方程求解器：21,020行代码。 </p>
<p>这个库本身&ndash;不包括示例程序和测试套件&ndash;在2002年春天有略多于15万行的代码。当然，现在已经大了好几倍了）。)这些应用程序的规模是一个人，甚至是一个有经验的程序员，所能处理的边缘。</p>
<p>上面的数字相当清楚地说明了一件事：没有被分解成较小的、大部分独立的片段的单体程序是没有办法生存的，因为即使是作者也会很快失去对程序不同部分之间各种依赖关系的概述。只有数据封装，例如使用面向对象的编程方法，以及通过定义小而固定的接口来实现模块化，才能帮助构建数据流和相互依赖。如果一个以上的人在开发一个程序，这也是一个绝对的先决条件，因为否则的话，混乱会很快出现，因为如果一个开发人员需要知道另一个人是否改变了不同模块的内部结构，如果它们没有被干净地分开的话。</p>
<p>在前面的例子中，你已经看到了库本身是如何被分成几个复合体的，每个复合体都建立在底层复合体之上，但相对独立于其他复合体。</p><ol>
<li>
三角形类复合物，以及相关的迭代器类； </li>
<li>
有限元类； </li>
<li>
DoFHandler类复合物，以及相关的迭代器，建立在三角形和有限元类之上； </li>
<li>
实现单元和实数单元间映射的类； </li>
<li>
FEValues类复合物，建立在有限元和映射之上。 </li>
</ol>
<p>除了这些，还有大量的小类，当然还有以下的 "工具 "模块。</p><ol>
<li>
以各种图形格式输出； </li>
<li>
线性代数类。 </li>
</ol>
<p>这些复数也可以在deal.II手册网站的首页上以流程图的形式找到。</p>
<p>这个程序的目标是给出一个例子，说明一个相对简单的有限元程序的结构，使我们最终得到一组尽可能相互独立的模块。这使得我们可以在一端改变程序，而不必担心另一端的程序会被破坏，只要我们不触及两端交流的接口。当然，C++中的接口是抽象基类的声明。</p>
<p>在这里，我们将（再次）实现一个拉普拉斯求解器，尽管与之前的例子程序相比有一些不同。</p><ol>
<li>
实现数值求解方程过程的类不再负责驱动 "求解-估计误差-再求解 "的过程，而是将其委托给外部函数。这首先允许在更大的范围内将其作为一个构件，在这里拉普拉斯方程的解可能只是其中的一部分（例如，在非线性问题中，拉普拉斯方程可能要在每个非线性步骤中解决）。它还允许围绕该类建立一个框架，允许使用其他方程的求解器（但具有相同的外部接口），以备对不同类型的偏微分方程评估一些技术。 </li>
<li>
它将评估计算出的解的过程分割成一组单独的类。原因是，人们通常对偏微分方程的解本身不感兴趣，而是对它的某些方面感兴趣。例如，人们可能希望在弹性计算中计算某一边界的牵引力，或者在某一位置的接收器上计算地震波的信号。有时，人们可能对这些方面中的几个方面感兴趣。由于解的评估是通常不影响解的过程，我们把它拆成一个单独的模块，以便独立于解算器类的开发来开发这种评估过滤器。 </li>
<li>
将实现网格细化的类与计算解的类分开。 </li>
<li>
将我们要介绍的测试案例的描述与程序的其他部分分开。 </li>
<li>
使用WorkStream设施对线性系统的装配进行并行化。这是在 <a class="el" href="group__threads.html">多处理器访问共享内存的并行计算 </a>文档模块中可以找到的广泛描述。该实现基本上遵循步骤9中已经描述过的内容。 </li>
</ol>
<p>该程序所做的事情并不新鲜。事实上，这更像是以前程序的混合体，从以前的例子中拆解了各种部分和功能。读者应该关注的是它们在这个程序中的安排方式，即程序中使用的软件设计技术，以达到实现所需数学方法的目的。然而，我们必须强调，软件设计在某种程度上也是一个主观的问题：不同的人有不同的编程背景，对编程的 "正确 "风格有不同的看法；因此，这个程序只表达了作者认为有用的做法，如果你对所选择的方式感到不舒服，不一定要采用这种风格来编写成功的数值软件。不过，它应该作为一个案例研究，用启发读者的想法来达到理想的目的。</p>
<p>一旦你完成了这个程序，你会注意到它的结构已经有些复杂了。然而，它只有大约850行代码，没有注释。在真正的应用程序中，当然会有注释和类文件，这将使其达到1200行。然而，与上面列出的应用程序相比，这仍然是很小的，因为它们的规模是它们的20到25倍。对于这么大的程序，从一开始就进行适当的设计是不可缺少的。否则，一旦它变得过于庞大而无法管理，就必须在其生命中的某一时刻重新设计它。</p>
<p>尽管如此，上面列出的三个程序都经历了重大的修改，甚至是重写。例如，波浪程序，在它还明显较小的时候，曾经被完全撕成了碎片，只是为了以更模块化的形式再次组装。那时，已经不可能在不影响代码的旧部分的情况下增加功能了（代码的主要问题是数据流：在时间依赖的应用中，主要的问题是什么时候把数据存储到磁盘，什么时候再重新加载；如果这不是以一种有组织的方式进行的，那么你最终会发现数据释放得太早，加载得太晚，或者根本没有释放）。尽管本例程序因此吸取了几年的经验，但它的设计肯定不是没有缺陷的，特别是可能不适合目标不同的应用。它应该作为一个灵感，让你以模块化的方式编写自己的应用程序，以避免过于紧密耦合的代码的陷阱。</p>
<p><a class="anchor" id="Whattheprogramdoes"></a></p><h3>What the program does</h3>
<p>程序实际做什么甚至不是这个程序的重点，程序的结构更重要。然而，用几句话来描述就是：求解给定右手边的拉普拉斯方程，使其解为函数 \(u(x,t)=\exp(x+\sin(10y+5x^2))\) 。计算的目标是得到解在点 \(x_0=(0.5,0.5)\) 处的值，并比较我们在两种细化标准下解决这个值的准确性，即全局细化和通过Kelly等人的误差指标细化，我们已经在以前的例子中使用过。</p>
<p>像往常一样，这些结果将在本文件的相应部分进行讨论。在这样做的过程中，我们将发现一个关于两个细化标准的相对性能的略微令人恼火的观察。在以后的例子程序中，在这个程序的基础上，我们将设计一个不同的方法，希望它能比这里讨论的技术表现更好。</p>
<p>现在，所有的理论和传闻背景都说了这么多。了解一个项目的最好方法是看它，所以它就在这里。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>As in all programs, we start with a list of include files from the library, and as usual they are in the standard order which is <code>base</code> &ndash; <code>lac</code> &ndash; <code>grid</code> &ndash; <code>dofs</code> &ndash; <code>fe</code> &ndash; <code>numerics</code> (as each of these categories roughly builds upon previous ones), then C++ standard headers:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="table__handler_8h.html">deal.II/base/table_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="thread__management_8h.html">deal.II/base/thread_management.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div></div><!-- fragment --><p>Now for the C++ standard headers:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div></div><!-- fragment --><p>The last step is as in all previous programs:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step13</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Evaluationofthesolution"></a> </p><h3>Evaluation of the solution</h3>
<p>As for the program itself, we first define classes that evaluate the solutions of a Laplace equation. In fact, they can evaluate every kind of solution, as long as it is described by a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object, and a solution vector. We define them here first, even before the classes that actually generate the solution to be evaluated, since we need to declare an abstract base class that the solver classes can refer to.</p>
<p>From an abstract point of view, we declare a pure base class that provides an evaluation operator() which will do the evaluation of the solution (whatever derived classes might consider an <code>evaluation</code>). Since this is the only real function of this base class (except for some bookkeeping machinery), one usually terms such a class that only has an <code>operator()</code> a <code>functor</code> in C++ terminology, since it is used just like a function object.</p>
<p>Objects of this functor type will then later be passed to the solver object, which applies it to the solution just computed. The evaluation objects may then extract any quantity they like from the solution. The advantage of putting these evaluation functions into a separate hierarchy of classes is that by design they cannot use the internals of the solver object and are therefore independent of changes to the way the solver works. Furthermore, it is trivial to write another evaluation class without modifying the solver class, which speeds up programming (not being able to use internals of another class also means that you do not have to worry about them &ndash; programming evaluators is usually a rather quickly done task), as well as compilation (if solver and evaluation classes are put into different files: the solver only needs to see the declaration of the abstract base class, and therefore does not need to be recompiled upon addition of a new evaluation class, or modification of an old one). On a related note, you can reuse the evaluation classes for other projects, solving different equations.</p>
<p>In order to improve separation of code into different modules, we put the evaluation classes into a namespace of their own. This makes it easier to actually solve different equations in the same program, by assembling it from existing building blocks. The reason for this is that classes for similar purposes tend to have the same name, although they were developed in different contexts. In order to be able to use them together in one program, it is necessary that they are placed in different namespaces. This we do here:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Evaluation</div><div class="line">{</div></div><!-- fragment --><p>Now for the abstract base class of evaluation classes: its main purpose is to declare a pure virtual function <code>operator()</code> taking a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object, and the solution vector. In order to be able to use pointers to this base class only, it also has to declare a virtual destructor, which however does nothing. Besides this, it only provides for a little bit of bookkeeping: since we usually want to evaluate solutions on subsequent refinement levels, we store the number of the present refinement cycle, and provide a function to change this number.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>EvaluationBase</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~EvaluationBase() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution) <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> EvaluationBase&lt;dim&gt;::set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step)</div><div class="line">{</div><div class="line">  refinement_cycle = step;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Pointevaluation"></a> </p><h4>Point evaluation</h4>
<p>The next thing is to implement actual evaluation classes. As noted in the introduction, we'd like to extract a point value from the solution, so the first class does this in its <code>operator()</code>. The actual point is given to this class through the constructor, as well as a table object into which it will put its findings.</p>
<p>Finding out the value of a finite element field at an arbitrary point is rather difficult, if we cannot rely on knowing the actual finite element used, since then we cannot, for example, interpolate between nodes. For simplicity, we therefore assume here that the point at which we want to evaluate the field is actually a node. If, in the process of evaluating the solution, we find that we did not encounter this point upon looping over all vertices, we then have to throw an exception in order to signal to the calling functions that something has gone wrong, rather than silently ignore this error.</p>
<p>In the <a class="el" href="step_9.html">step-9</a> example program, we have already seen how such an exception class can be declared, using the <code>DeclExceptionN</code> macros. We use this mechanism here again.</p>
<p>From this, the actual declaration of this class should be evident. Note that of course even if we do not list a destructor explicitly, an implicit destructor is generated from the compiler, and it is virtual just as the one of the base class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PointValueEvaluation : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PointValueEvaluation(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point,</div><div class="line">                       <a class="code" href="classTableHandler.html">TableHandler</a> &amp;    results_table);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a>(</div><div class="line">    ExcEvaluationPointNotFound,</div><div class="line">    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div><div class="line">    &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div><div class="line">  <a class="code" href="classTableHandler.html">TableHandler</a> &amp;   results_table;</div><div class="line">};</div></div><!-- fragment --><p>As for the definition, the constructor is trivial, just taking data and storing it in object-local ones:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">PointValueEvaluation&lt;dim&gt;::PointValueEvaluation(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point,</div><div class="line">  <a class="code" href="classTableHandler.html">TableHandler</a> &amp;    results_table)</div><div class="line">  : evaluation_point(evaluation_point)</div><div class="line">  , results_table(results_table)</div><div class="line">{}</div></div><!-- fragment --><p>Now for the function that is mainly of interest in this class, the computation of the point value:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PointValueEvaluation&lt;dim&gt;::</div><div class="line">     operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div></div><!-- fragment --><p>First allocate a variable that will hold the point value. Initialize it with a value that is clearly bogus, so that if we fail to set it to a reasonable value, we will note at once. This may not be necessary in a function as small as this one, since we can easily see all possible paths of execution here, but it proved to be helpful for more complex cases, and so we employ this strategy here as well.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> point_value = 1e20;</div></div><!-- fragment --><p>Then loop over all cells and all their vertices, and check whether a vertex matches the evaluation point. If this is the case, then extract the point value, set a flag that we have found the point of interest, and exit the loop.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> evaluation_point_found = <span class="keyword">false</span>;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (!evaluation_point_found)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex : cell-&gt;vertex_indices())</div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;vertex(vertex) == evaluation_point)</div><div class="line">        {</div></div><!-- fragment --><p>In order to extract the point value from the global solution vector, pick that component that belongs to the vertex of interest, and, in case the solution is vector-valued, take the first component of it:</p>
<div class="fragment"><div class="line">point_value = solution(cell-&gt;vertex_dof_index(vertex, 0));</div></div><!-- fragment --><p>Note that by this we have made an assumption that is not valid always and should be documented in the class declaration if this were code for a real application rather than a tutorial program: we assume that the finite element used for the solution we try to evaluate actually has degrees of freedom associated with vertices. This, for example, does not hold for discontinuous elements, were the support points for the shape functions happen to be located at the vertices, but are not associated with the vertices but rather with the cell interior, since association with vertices would imply continuity there. It would also not hold for edge oriented elements, and the like.</p>
<p>Ideally, we would check this at the beginning of the function, for example by a statement like <code>Assert (dof_handler.get_fe().dofs_per_vertex &gt; 0, <a class="el" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented()</a>)</code>, which should make it quite clear what is going wrong when the exception is triggered. In this case, we omit it (which is indeed bad style), but knowing that that does not hurt here, since the statement <code>cell-&gt;vertex_dof_index(vertex,0)</code> would fail if we asked it to give us the DoF index of a vertex if there were none.</p>
<p>We stress again that this restriction on the allowed finite elements should be stated in the class documentation.</p>
<p>Since we found the right point, we now set the respective flag and exit the innermost loop. The outer loop will also be terminated due to the set flag.</p>
<div class="fragment"><div class="line">  evaluation_point_found = <span class="keyword">true</span>;</div><div class="line">  <span class="keywordflow">break</span>;</div><div class="line">};</div></div><!-- fragment --><p>Finally, we'd like to make sure that we have indeed found the evaluation point, since if that were not so we could not give a reasonable value of the solution there and the rest of the computations were useless anyway. So make sure through the <code>AssertThrow</code> macro already used in the <a class="el" href="step_9.html">step-9</a> program that we have indeed found this point. If this is not so, the macro throws an exception of the type that is given to it as second argument, but compared to a straightforward <code>throw</code> statement, it fills the exception object with a set of additional information, for example the source file and line number where the exception was generated, and the condition that failed. If you have a <code>catch</code> clause in your main function (as this program has), you will catch all exceptions that are not caught somewhere in between and thus already handled, and this additional information will help you find out what happened and where it went wrong.</p>
<div class="fragment"><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_point_found,</div><div class="line">            ExcEvaluationPointNotFound(evaluation_point));</div></div><!-- fragment --><p>Note that we have used the <code>Assert</code> macro in other example programs as well. It differed from the <code>AssertThrow</code> macro used here in that it simply aborts the program, rather than throwing an exception, and that it did so only in debug mode. It was the right macro to use to check about the size of vectors passed as arguments to functions, and the like.</p>
<p>However, here the situation is different: whether we find the evaluation point or not may change from refinement to refinement (for example, if the four cells around point are coarsened away, then the point may vanish after refinement and coarsening). This is something that cannot be predicted from a few number of runs of the program in debug mode, but should be checked always, also in production runs. Thus the use of the <code>AssertThrow</code> macro here.</p>
<p>Now, if we are sure that we have found the evaluation point, we can add the results into the table of results:</p>
<div class="fragment"><div class="line">  results_table.<a class="code" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a>(<span class="stringliteral">&quot;DoFs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  results_table.<a class="code" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a>(<span class="stringliteral">&quot;u(x_0)&quot;</span>, point_value);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Generatingoutput"></a> </p><h4>Generating output</h4>
<p>A different, maybe slightly odd kind of <code>evaluation</code> of a solution is to output it to a file in a graphical format. Since in the evaluation functions we are given a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object and the solution vector, we have all we need to do this, so we can do it in an evaluation class. The reason for actually doing so instead of putting it into the class that computed the solution is that this way we have more flexibility: if we choose to only output certain aspects of it, or not output it at all. In any case, we do not need to modify the solver class, we just have to modify one of the modules out of which we build this program. This form of encapsulation, as above, helps us to keep each part of the program rather simple as the interfaces are kept simple, and no access to hidden data is possible.</p>
<p>Since this class which generates the output is derived from the common <code>EvaluationBase</code> base class, its main interface is the <code>operator()</code> function. Furthermore, it has a constructor taking a string that will be used as the base part of the file name to which output will be sent (we will augment it by a number indicating the number of the refinement cycle &ndash; the base class has this information at hand &ndash;, and a suffix), and the constructor also takes a value that indicates which format is requested, i.e. for which graphics program we shall generate output (from this we will then also generate the suffix of the filename to which we write).</p>
<p>Regarding the output format, the <a class="el" href="namespaceDataOutBase.html">DataOutBase</a> namespace provides an enumeration field <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> which lists names for all supported output formats. At the time of writing of this program, the supported graphics formats are represented by the enum values <code>ucd</code>, <code>gnuplot</code>, <code>povray</code>, <code>eps</code>, <code>gmv</code>, <code>tecplot</code>, <code>tecplot_binary</code>, <code>dx</code>, <code>vtk</code>, etc, but this list will certainly grow over time. Now, within various functions of that base class, you can use values of this type to get information about these graphics formats (for example the default suffix used for files of each format), and you can call a generic <code>write</code> function, which then branches to the <code>write_gnuplot</code>, <code>write_ucd</code>, etc functions which we have used in previous examples already, based on the value of a second argument given to it denoting the required output format. This mechanism makes it simple to write an extensible program that can decide which output format to use at runtime, and it also makes it rather simple to write the program in a way such that it takes advantage of newly implemented output formats, without the need to change the application program.</p>
<p>Of these two fields, the base name and the output format descriptor, the constructor takes values and stores them for later use by the actual evaluation function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SolutionOutput : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SolutionOutput(<span class="keyword">const</span> std::string &amp;             output_name_base,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> std::string               output_name_base;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">SolutionOutput&lt;dim&gt;::SolutionOutput(</div><div class="line">  <span class="keyword">const</span> std::string &amp;             output_name_base,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format)</div><div class="line">  : output_name_base(output_name_base)</div><div class="line">  , output_format(output_format)</div><div class="line">{}</div></div><!-- fragment --><p>Following the description above, the function generating the actual output is now relatively straightforward. The only particularly interesting feature over previous example programs is the use of the <a class="el" href="namespaceDataOutBase.html#aed25a6ddf928a6904fd1ac942125ec86">DataOutBase::default_suffix</a> function, returning the usual suffix for files of a given format (e.g. ".eps" for encapsulated postscript files, ".gnuplot" for Gnuplot files), and of the generic <a class="el" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">DataOut::write()</a> function with a second argument, which internally branches to the actual output functions for the different graphics formats, based on the value of the format descriptor passed as second argument.</p>
<p>Also note that we have to prefix <code>this-&gt;</code> to access a member variable of the template dependent base class. The reason here, and further down in the program is the same as the one described in the <a class="el" href="step_7.html">step-7</a> example program (look for <code>two-stage name lookup</code> there).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SolutionOutput&lt;dim&gt;::operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                     <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp; solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream out(output_name_base + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                    <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(this-&gt;refinement_cycle) +</div><div class="line">                    data_out.<a class="code" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a>(output_format));</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a>(out, output_format);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Otherevaluations"></a> </p><h4>Other evaluations</h4>
<p>In practical applications, one would add here a list of other possible evaluation classes, representing quantities that one may be interested in. For this example, that much shall be sufficient, so we close the namespace.</p>
<div class="fragment"><div class="line">} <span class="comment">// namespace Evaluation</span></div></div><!-- fragment --><p><a class="anchor" id="TheLaplacesolverclasses"></a> </p><h3>The Laplace solver classes</h3>
<p>After defining what we want to know of the solution, we should now care how to get at it. We will pack everything we need into a namespace of its own, for much the same reasons as for the evaluations above.</p>
<p>Since we have discussed Laplace solvers already in considerable detail in previous examples, there is not much new stuff following. Rather, we have to a great extent cannibalized previous examples and put them, in slightly different form, into this example program. We will therefore mostly be concerned with discussing the differences to previous examples.</p>
<p>Basically, as already said in the introduction, the lack of new stuff in this example is deliberate, as it is more to demonstrate software design practices, rather than mathematics. The emphasis in explanations below will therefore be more on the actual implementation.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>LaplaceSolver</div><div class="line">{</div></div><!-- fragment --><p><a class="anchor" id="Anabstractbaseclass"></a> </p><h4>An abstract base class</h4>
<p>In defining a Laplace solver, we start out by declaring an abstract base class, that has no functionality itself except for taking and storing a pointer to the triangulation to be used later.</p>
<p>This base class is very general, and could as well be used for any other stationary problem. It provides declarations of functions that shall, in derived classes, solve a problem, postprocess the solution with a list of evaluation objects, and refine the grid, respectively. None of these functions actually does something itself in the base class.</p>
<p>Due to the lack of actual functionality, the programming style of declaring very abstract base classes is similar to the style used in Smalltalk or Java programs, where all classes are derived from entirely abstract classes <code>Object</code>, even number representations. The author admits that he does not particularly like the use of such a style in C++, as it puts style over reason. Furthermore, it promotes the use of virtual functions for everything (for example, in Java, all functions are virtual per se), which, however, has proven to be rather inefficient in many applications where functions are often only accessing data, not doing computations, and therefore quickly return; the overhead of virtual functions can then be significant. The opinion of the author is to have abstract base classes wherever at least some part of the code of actual implementations can be shared and thus separated into the base class.</p>
<p>Besides all these theoretical questions, we here have a good reason, which will become clearer to the reader below. Basically, we want to be able to have a family of different Laplace solvers that differ so much that no larger common subset of functionality could be found. We therefore just declare such an abstract base class, taking a pointer to a triangulation in the constructor and storing it henceforth. Since this triangulation will be used throughout all computations, we have to make sure that the triangulation is valid until it is last used. We do this by keeping a <code><a class="el" href="classSmartPointer.html">SmartPointer</a></code> to this triangulation, as explained in <a class="el" href="step_7.html">step-7</a>.</p>
<p>Note that while the pointer itself is declared constant (i.e. throughout the lifetime of this object, the pointer points to the same object), it is not declared as a pointer to a constant triangulation. In fact, by this we allow that derived classes refine or coarsen the triangulation within the <code>refine_grid</code> function.</p>
<p>Finally, we have a function <code>n_dofs</code> is only a tool for the driver functions to decide whether we want to go on with mesh refinement or not. It returns the number of degrees of freedom the present simulation has.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Base</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid);</div><div class="line">  <span class="keyword">virtual</span> ~Base() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> solve_problem() = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div><div class="line">    <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const</span> = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span>         refine_grid()                            = 0;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const</span>                           = 0;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;Triangulation&lt;dim&gt;</a>&gt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">};</div></div><!-- fragment --><p>The implementation of the only two non-abstract functions is then rather boring:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Base&lt;dim&gt;::Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid)</div><div class="line">  : triangulation(&amp;coarse_grid)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="Ageneralsolverclass"></a> </p><h4>A general solver class</h4>
<p>Following now the main class that implements assembling the matrix of the linear system, solving it, and calling the postprocessor objects on the solution. It implements the <code>solve_problem</code> and <code>postprocess</code> functions declared in the base class. It does not, however, implement the <code>refine_grid</code> method, as mesh refinement will be implemented in a number of derived classes.</p>
<p>It also declares a new abstract virtual function, <code>assemble_rhs</code>, that needs to be overloaded in subclasses. The reason is that we will implement two different classes that will implement different methods to assemble the right hand side vector. This function might also be interesting in cases where the right hand side depends not simply on a continuous function, but on something else as well, for example the solution of another discretized problem, etc. The latter happens frequently in non-linear problems.</p>
<p>As we mentioned previously, the actual content of this class is not new, but a mixture of various techniques already used in previous examples. We will therefore not discuss them in detail, but refer the reader to these programs.</p>
<p>Basically, in a few words, the constructor of this class takes pointers to a triangulation, a finite element, and a function object representing the boundary values. These are either passed down to the base class's constructor, or are stored and used to generate a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object later. Since finite elements and quadrature formula should match, it is also passed a quadrature object.</p>
<p>The <code>solve_problem</code> sets up the data structures for the actual solution, calls the functions to assemble the linear system, and solves it.</p>
<p>The <code>postprocess</code> function finally takes an evaluation object and applies it to the computed solution.</p>
<p>The <code>n_dofs</code> function finally implements the pure virtual function of the base class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Solver : <span class="keyword">public</span> <span class="keyword">virtual</span> Base&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">         <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">         <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">         <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line">  <span class="keyword">virtual</span> ~Solver() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> solve_problem() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div><div class="line">    <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const override</span>;</div></div><!-- fragment --><p>In the protected section of this class, we first have a number of member variables, of which the use should be clear from the previous examples:</p>
<div class="fragment"><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const FiniteElement&lt;dim&gt;</a>&gt; fe;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Quadrature&lt;dim&gt;</a>&gt;    quadrature;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                              dof_handler;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                               solution;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt;      boundary_values;</div></div><!-- fragment --><p>Then we declare an abstract function that will be used to assemble the right hand side. As explained above, there are various cases for which this action differs strongly in what is necessary, so we defer this to derived classes:</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;rhs) <span class="keyword">const</span> = 0;</div></div><!-- fragment --><p>Next, in the private section, we have a small class which represents an entire linear system, i.e. a matrix, a right hand side, and a solution vector, as well as the constraints that are applied to it, such as those due to hanging nodes. Its constructor initializes the various subobjects, and there is a function that implements a conjugate gradient method as solver.</p>
<div class="fragment"><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">struct </span>LinearSystem</div><div class="line">  {</div><div class="line">    LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>           sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>      <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>            rhs;</div><div class="line">  };</div></div><!-- fragment --><p>Finally, there is a set of functions which will be used to assemble the actual system matrix. The main function of this group, <code>assemble_linear_system()</code> computes the matrix in parallel on multicore systems, using the following two helper functions. The mechanism for doing so is the same as in the <a class="el" href="step_9.html">step-9</a> example program and follows the <a class="el" href="namespaceWorkStream.html">WorkStream</a> concept outlined in <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> . The main function also calls the virtual function assembling the right hand side.</p>
<div class="fragment"><div class="line">  <span class="keyword">struct </span>AssemblyScratchData</div><div class="line">  {</div><div class="line">    AssemblyScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature);</div><div class="line">    AssemblyScratchData(<span class="keyword">const</span> AssemblyScratchData &amp;scratch_data);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">struct </span>AssemblyCopyData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_linear_system(LinearSystem &amp;linear_system);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> local_assemble_matrix(</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">    AssemblyScratchData &amp;                                 scratch_data,</div><div class="line">    AssemblyCopyData &amp;                                    copy_data) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div><div class="line">                            LinearSystem &amp;          linear_system) <span class="keyword">const</span>;</div><div class="line">};</div></div><!-- fragment --><p>Now here comes the constructor of the class. It does not do much except store pointers to the objects given, and generate <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object initialized with the given pointer to a triangulation. This causes the DoF handler to store that pointer, but does not already generate a finite element numbering (we only ask for that in the <code>solve_problem</code> function).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solver&lt;dim&gt;::Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">  : Base&lt;dim&gt;(triangulation)</div><div class="line">  , fe(&amp;fe)</div><div class="line">  , quadrature(&amp;quadrature)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , boundary_values(&amp;boundary_values)</div><div class="line">{}</div></div><!-- fragment --><p>The destructor is simple, it only clears the information stored in the DoF handler object to release the memory.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solver&lt;dim&gt;::~Solver()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">}</div></div><!-- fragment --><p>The next function is the one which delegates the main work in solving the problem: it sets up the DoF handler object with the finite element given to the constructor of this object, the creates an object that denotes the linear system (i.e. the matrix, the right hand side vector, and the solution vector), calls the function to assemble it, and finally solves it:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::solve_problem()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(*fe);</div><div class="line">  solution.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  LinearSystem linear_system(dof_handler);</div><div class="line">  assemble_linear_system(linear_system);</div><div class="line">  linear_system.solve(solution);</div><div class="line">}</div></div><!-- fragment --><p>As stated above, the <code>postprocess</code> function takes an evaluation object, and applies it to the computed solution. This function may be called multiply, once for each evaluation of the solution which the user required.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::postprocess(</div><div class="line">  <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  postprocessor(dof_handler, solution);</div><div class="line">}</div></div><!-- fragment --><p>The <code>n_dofs</code> function should be self-explanatory:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Solver&lt;dim&gt;::n_dofs()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>();</div><div class="line">}</div></div><!-- fragment --><p>The following function assembles matrix and right hand side of the linear system to be solved in each step. We will do things in parallel at a couple of levels. First, note that we need to assemble both the matrix and the right hand side. These are independent operations, and we should do this in parallel. To this end, we use the concept of "tasks" that is discussed in the <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing</a> documentation module. In essence, what we want to say "here is something that needs to be worked on, go do it
   whenever a CPU core is available", then do something else, and when we need the result of the first operation wait for its completion. At the second level, we want to assemble the matrix using the exact same strategy we have already used in <a class="el" href="step_9.html">step-9</a>, namely the <a class="el" href="namespaceWorkStream.html">WorkStream</a> concept.</p>
<p>While we could consider either assembling the right hand side or assembling the matrix as the thing to do in the background while doing the other, we will opt for the former approach simply because the call to <code>Solver::assemble_rhs</code> is so much simpler to write than the call to <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> with its many arguments. In any case, the code then looks like this to assemble the entire linear system:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::assemble_linear_system(LinearSystem &amp;linear_system)</div><div class="line">{</div><div class="line">  <a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> rhs_task =</div><div class="line">    <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a>(&amp;Solver&lt;dim&gt;::assemble_rhs, *<span class="keyword">this</span>, linear_system.rhs);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> worker =</div><div class="line">    [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">           AssemblyScratchData &amp;scratch_data,</div><div class="line">           AssemblyCopyData &amp;   copy_data) {</div><div class="line">      this-&gt;local_assemble_matrix(cell, scratch_data, copy_data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> copier = [<span class="keyword">this</span>, &amp;linear_system](<span class="keyword">const</span> AssemblyCopyData &amp;copy_data) {</div><div class="line">    this-&gt;copy_local_to_global(copy_data, linear_system);</div><div class="line">  };</div><div class="line"></div><div class="line">  <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                  dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                  worker,</div><div class="line">                  copier,</div><div class="line">                  AssemblyScratchData(*fe, *quadrature),</div><div class="line">                  AssemblyCopyData());</div><div class="line">  linear_system.hanging_node_constraints.condense(linear_system.matrix);</div></div><!-- fragment --><p>The syntax above requires some explanation. There are multiple version of <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> that expect different arguments. In <a class="el" href="step_9.html">step-9</a>, we used one version that took a pair of iterators, a pair of pointers to member functions with very specific argument lists, a pointer or reference to the object on which these member functions have to work, and a scratch and copy data object. This is a bit restrictive since the member functions called this way have to have an argument list that exactly matches what <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> expects: the local assembly function needs to take an iterator, a scratch object and a copy object; and the copy-local-to-global function needs to take exactly a copy object. But, what if we want something that's slightly more general? For example, in the current program, the copy-local-to-global function needs to know which linear system object to write the local contributions into, i.e., it also has to take a <code>LinearSystem</code> argument. That won't work with the approach using member function pointers.</p>
<p>Fortunately, C++ offers a way out. These are called function objects. In essence, what <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a> wants to do is not call a member function. It wants to call some function that takes an iterator, a scratch object and a copy object in the first case, and a copy object in the second case. Whether these are member functions, global functions, or something else, is really not of much concern to <a class="el" href="namespaceWorkStream.html">WorkStream</a>. Consequently, there is a second version of the function that just takes function objects &ndash; objects that have an <code>operator()</code> and that consequently can be called like functions, whatever they really represent. The typical way to generate such function objects is using a <a href="http://en.wikipedia.org/wiki/Anonymous_function">lambda function</a> that wraps the function call including the individual arguments with fixed values. All the arguments that are part of the outer function signature are specified as regular function arguments in the lambda function. The fixed values are passed into the lambda function using the capture list (<code>[...]</code>). It is possible to use a capture default or to list all the variables that are to be bound to the lambda explicitly. For the sake of clarity we decided to omit the capture default here, but that capture list could equally well be <code>[&amp;]</code>, meaning that all used variables are copied into the lambda by reference.</p>
<p>At this point, we have assembled the matrix and condensed it. The right hand side may or may not have been completely assembled, but we would like to condense the right hand side vector next. We can only do this if the assembly of this vector has finished, so we have to wait for the task to finish; in computer science, waiting for a task is typically called "joining" the task, explaining the name of the function we call below.</p>
<p>Since that task may or may not have finished, and since we may have to wait for it to finish, we may as well try to pack other things that need to be done anyway into this gap. Consequently, we first interpolate boundary values before we wait for the right hand side. Of course, another possibility would have been to also interpolate the boundary values on a separate task since doing so is independent of the other things we have done in this function so far. Feel free to find the correct syntax to also create a task for this interpolation and start it at the top of this function, along with the assembly of the right hand side. (You will find that this is slightly more complicated since there are multiple versions of <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a>, and so simply taking the address <code>&amp;<a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a></code> produces a set of overloaded functions that can't be passed to <a class="el" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task()</a> right away &ndash; you have to select which element of this overload set you want by casting the address expression to a function pointer type that is specific to the version of the function that you want to call on the task.)</p>
<div class="fragment"><div class="line">std::map&lt;types::global_dof_index, double&gt; boundary_value_map;</div><div class="line"><a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                         0,</div><div class="line">                                         *boundary_values,</div><div class="line">                                         boundary_value_map);</div><div class="line"></div><div class="line">rhs_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div><div class="line">linear_system.hanging_node_constraints.condense(linear_system.rhs);</div></div><!-- fragment --><p>Now that we have the complete linear system, we can also treat boundary values, which need to be eliminated from both the matrix and the right hand side:</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_value_map,</div><div class="line">                                     linear_system.matrix,</div><div class="line">                                     solution,</div><div class="line">                                     linear_system.rhs);</div><div class="line">}</div></div><!-- fragment --><p>The second half of this set of functions deals with the local assembly on each cell and copying local contributions into the global matrix object. This works in exactly the same way as described in <a class="el" href="step_9.html">step-9</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature)</div><div class="line">  : fe_values(fe, quadrature, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div><div class="line">  <span class="keyword">const</span> AssemblyScratchData &amp;scratch_data)</div><div class="line">  : fe_values(scratch_data.fe_values.get_fe(),</div><div class="line">              scratch_data.fe_values.get_quadrature(),</div><div class="line">              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::local_assemble_matrix(</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">  AssemblyScratchData &amp;                                 scratch_data,</div><div class="line">  AssemblyCopyData &amp;                                    copy_data)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe-&gt;n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature-&gt;size();</div><div class="line"></div><div class="line">  copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  copy_data.local_dof_indices.resize(dofs_per_cell);</div><div class="line"></div><div class="line">  scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        copy_data.cell_matrix(i, j) +=</div><div class="line">          (scratch_data.fe_values.shape_grad(i, q_point) *</div><div class="line">           scratch_data.fe_values.shape_grad(j, q_point) *</div><div class="line">           scratch_data.fe_values.JxW(q_point));</div><div class="line"></div><div class="line">  cell-&gt;get_dof_indices(copy_data.local_dof_indices);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div><div class="line">                                       LinearSystem &amp;linear_system)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; copy_data.local_dof_indices.size(); ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; copy_data.local_dof_indices.size(); ++j)</div><div class="line">      linear_system.matrix.add(copy_data.local_dof_indices[i],</div><div class="line">                               copy_data.local_dof_indices[j],</div><div class="line">                               copy_data.cell_matrix(i, j));</div><div class="line">}</div></div><!-- fragment --><p>Now for the functions that implement actions in the linear system class. First, the constructor initializes all data elements to their correct sizes, and sets up a number of additional data structures, such as constraints due to hanging nodes. Since setting up the hanging nodes and finding out about the nonzero elements of the matrix is independent, we do that in parallel (if the library was configured to use concurrency, at least; otherwise, the actions are performed sequentially). Note that we start only one thread, and do the second action in the main thread. Since only one task is generated, we don't use the <code><a class="el" href="classThreads_1_1TaskGroup.html">Threads::TaskGroup</a></code> class here, but rather use the one created task object directly to wait for this particular task's exit.</p>
<p>Note that taking up the address of the <code><a class="el" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a></code> function is a little tricky, since there are actually three of them, one for each supported space dimension. Taking addresses of overloaded functions is somewhat complicated in C++, since the address-of operator <code>&amp;</code> in that case returns more like a set of values (the addresses of all functions with that name), and selecting the right one is then the next step. If the context dictates which one to take (for example by assigning to a function pointer of known type), then the compiler can do that by itself, but if this set of pointers shall be given as the argument to a function that takes a template, the compiler could choose all without having a preference for one. We therefore have to make it clear to the compiler which one we would like to have; for this, we could use a cast, but for more clarity, we assign it to a temporary <code>mhnc_p</code> (short for <code>pointer to make_hanging_node_constraints</code>) with the right type, and using this pointer instead.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">Solver&lt;dim&gt;::LinearSystem::LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  hanging_node_constraints.clear();</div><div class="line"></div><div class="line">  void (*mhnc_p)(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;, <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;) =</div><div class="line">    &amp;<a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>;</div></div><!-- fragment --><p>Start a side task then continue on the main thread</p>
<div class="fragment"><div class="line"><a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> side_task =</div><div class="line">  <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a>(mhnc_p, dof_handler, hanging_node_constraints);</div><div class="line"></div><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div></div><!-- fragment --><p>Wait for the side task to be done before going further</p>
<div class="fragment"><div class="line">side_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div><div class="line"></div><div class="line">hanging_node_constraints.close();</div><div class="line">hanging_node_constraints.condense(dsp);</div><div class="line">sparsity_pattern.copy_from(dsp);</div></div><!-- fragment --><p>Finally initialize the matrix and right hand side vector</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>.reinit(sparsity_pattern);</div><div class="line">  rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p>The second function of this class simply solves the linear system by a preconditioned conjugate gradient method. This has been extensively discussed before, so we don't dwell into it any more.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Solver&lt;dim&gt;::LinearSystem::solve(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, 1.2);</div><div class="line"></div><div class="line">  cg.solve(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, solution, rhs, preconditioner);</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Aprimalsolver"></a> </p><h4>A primal solver</h4>
<p>In the previous section, a base class for Laplace solvers was implemented, that lacked the functionality to assemble the right hand side vector, however, for reasons that were explained there. Now we implement a corresponding class that can do this for the case that the right hand side of a problem is given as a function object.</p>
<p>The actions of the class are rather what you have seen already in previous examples already, so a brief explanation should suffice: the constructor takes the same data as does that of the underlying class (to which it passes all information) except for one function object that denotes the right hand side of the problem. A pointer to this object is stored (again as a <code><a class="el" href="classSmartPointer.html">SmartPointer</a></code>, in order to make sure that the function object is not deleted as long as it is still used by this class).</p>
<p>The only functional part of this class is the <code>assemble_rhs</code> method that does what its name suggests.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PrimalSolver : <span class="keyword">public</span> Solver&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt; rhs_function;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;rhs) <span class="keyword">const override</span>;</div><div class="line">};</div></div><!-- fragment --><p>The constructor of this class basically does what it is announced to do above...</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">PrimalSolver&lt;dim&gt;::PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                                <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">  : Base&lt;dim&gt;(triangulation)</div><div class="line">  , Solver&lt;dim&gt;(triangulation, fe, quadrature, boundary_values)</div><div class="line">  , rhs_function(&amp;rhs_function)</div><div class="line">{}</div></div><!-- fragment --><p>... as does the <code>assemble_rhs</code> function. Since this is explained in several of the previous example programs, we leave it at that.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> PrimalSolver&lt;dim&gt;::assemble_rhs(<a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;rhs)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(*this-&gt;fe,</div><div class="line">                          *this-&gt;quadrature,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = this-&gt;fe-&gt;n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = this-&gt;quadrature-&gt;size();</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       cell_rhs(dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt;                  rhs_values(n_q_points);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : this-&gt;dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_rhs = 0;</div><div class="line">      fe_values.reinit(cell);</div><div class="line">      rhs_function-&gt;value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                               rhs_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * </div><div class="line">                         rhs_values[q_point] *               </div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">    };</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Globalrefinement"></a> </p><h4>Global refinement</h4>
<p>By now, all functions of the abstract base class except for the <code>refine_grid</code> function have been implemented. We will now have two classes that implement this function for the <code>PrimalSolver</code> class, one doing global refinement, one a form of local refinement.</p>
<p>The first, doing global refinement, is rather simple: its main function just calls <code>triangulation-&gt;refine_global (1);</code>, which does all the work.</p>
<p>Note that since the <code>Base</code> base class of the <code>Solver</code> class is virtual, we have to declare a constructor that initializes the immediate base class as well as the abstract virtual one.</p>
<p>Apart from this technical complication, the class is probably simple enough to be left without further comments.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RefinementGlobal : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  RefinementGlobal(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">RefinementGlobal&lt;dim&gt;::RefinementGlobal(</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">  : Base&lt;dim&gt;(coarse_grid)</div><div class="line">  , PrimalSolver&lt;dim&gt;(coarse_grid,</div><div class="line">                      fe,</div><div class="line">                      quadrature,</div><div class="line">                      rhs_function,</div><div class="line">                      boundary_values)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> RefinementGlobal&lt;dim&gt;::refine_grid()</div><div class="line">{</div><div class="line">  this-&gt;triangulation-&gt;refine_global(1);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LocalrefinementbytheKellyerrorindicator"></a> </p><h4>Local refinement by the Kelly error indicator</h4>
<p>The second class implementing refinement strategies uses the Kelly refinement indicator used in various example programs before. Since this indicator is already implemented in a class of its own inside the deal.II library, there is not much t do here except cal the function computing the indicator, then using it to select a number of cells for refinement and coarsening, and refinement the mesh accordingly.</p>
<p>Again, this should now be sufficiently standard to allow the omission of further comments.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RefinementKelly : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  RefinementKelly&lt;dim&gt;::RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;rhs_function,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;boundary_values)</div><div class="line">    : Base&lt;dim&gt;(coarse_grid)</div><div class="line">    , PrimalSolver&lt;dim&gt;(coarse_grid,</div><div class="line">                        fe,</div><div class="line">                        quadrature,</div><div class="line">                        rhs_function,</div><div class="line">                        boundary_values)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> RefinementKelly&lt;dim&gt;::refine_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(</div><div class="line">      this-&gt;triangulation-&gt;n_active_cells());</div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      this-&gt;dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(this-&gt;fe-&gt;degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      this-&gt;solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(*this-&gt;triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line">    this-&gt;triangulation-&gt;execute_coarsening_and_refinement();</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace LaplaceSolver</span></div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>As this is one more academic example, we'd like to compare exact and computed solution against each other. For this, we need to declare function classes representing the exact solution (for comparison and for the Dirichlet boundary values), as well as a class that denotes the right hand side of the equation (this is simply the Laplace operator applied to the exact solution we'd like to recover).</p>
<p>For this example, let us choose as exact solution the function \(u(x,y)=exp(x+sin(10y+5x^2))\). In more than two dimensions, simply repeat the sine-factor with <code>y</code> replaced by <code>z</code> and so on. Given this, the following two classes are probably straightforward from the previous examples.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> Solution&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void)component;</div><div class="line">  <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">  <span class="keywordtype">double</span> q = p(0);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">    q += std::sin(10 * p(i) + 5 * p(0) * p(0));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> exponential = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(q);</div><div class="line">  <span class="keywordflow">return</span> exponential;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void)component;</div><div class="line">  <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">  <span class="keywordtype">double</span> q = p(0);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">    q += std::sin(10 * p(i) + 5 * p(0) * p(0));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> u  = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(q);</div><div class="line">  <span class="keywordtype">double</span>       t1 = 1, t2 = 0, t3 = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      t1 += <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) * 10 * p(0);</div><div class="line">      t2 += 10 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) -</div><div class="line">            100 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(10 * p(i) + 5 * p(0) * p(0)) * p(0) * p(0);</div><div class="line">      t3 += 100 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) *</div><div class="line">              <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) -</div><div class="line">            100 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(10 * p(i) + 5 * p(0) * p(0));</div><div class="line">    };</div><div class="line">  t1 = t1 * t1;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> -u * (t1 + t2 + t3);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Thedriverroutines"></a> </p><h3>The driver routines</h3>
<p>What is now missing are only the functions that actually select the various options, and run the simulation on successively finer grids to monitor the progress as the mesh is refined.</p>
<p>This we do in the following function: it takes a solver object, and a list of postprocessing (evaluation) objects, and runs them with intermittent mesh refinement:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> run_simulation(</div><div class="line">  LaplaceSolver::Base&lt;dim&gt; &amp;                          solver,</div><div class="line">  <span class="keyword">const</span> std::list&lt;Evaluation::EvaluationBase&lt;dim&gt; *&gt; &amp;postprocessor_list)</div><div class="line">{</div></div><!-- fragment --><p>We will give an indicator of the step we are presently computing, in order to keep the user informed that something is still happening, and that the program is not in an endless loop. This is the head of this status line:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle: &quot;</span>;</div></div><!-- fragment --><p>Then start a loop which only terminates once the number of degrees of freedom is larger than 20,000 (you may of course change this limit, if you need more &ndash; or less &ndash; accuracy from your program).</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; <span class="keyword">true</span>; ++step)</div><div class="line">  {</div></div><!-- fragment --><p>Then give the <code>alive</code> indication for this iteration. Note that the <code>std::flush</code> is needed to have the text actually appear on the screen, rather than only in some buffer that is only flushed the next time we issue an end-line.</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; step &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::flush;</div></div><!-- fragment --><p>Now solve the problem on the present grid, and run the evaluators on it. The long type name of iterators into the list is a little annoying, but could be shortened by an alias, if so desired.</p>
<div class="fragment"><div class="line">solver.solve_problem();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;postprocessor : postprocessor_list)</div><div class="line">  {</div><div class="line">    postprocessor-&gt;set_refinement_cycle(step);</div><div class="line">    solver.postprocess(*postprocessor);</div><div class="line">  };</div></div><!-- fragment --><p>Now check whether more iterations are required, or whether the loop shall be ended:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">if</span> (solver.n_dofs() &lt; 20000)</div><div class="line">    solver.refine_grid();</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">break</span>;</div><div class="line">};</div></div><!-- fragment --><p>Finally end the line in which we displayed status reports:</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>The final function is one which takes the name of a solver (presently "kelly" and "global" are allowed), creates a solver object out of it using a coarse grid (in this case the ubiquitous unit square) and a finite element object (here the likewise ubiquitous bilinear one), and uses that solver to ask for the solution of the problem on a sequence of successively refined grids.</p>
<p>The function also sets up two of evaluation functions, one evaluating the solution at the point (0.5,0.5), the other writing out the solution to a file.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> solve_problem(<span class="keyword">const</span> std::string &amp;solver_name)</div><div class="line">{</div></div><!-- fragment --><p>First minor task: tell the user what is going to happen. Thus write a header line, and a line with all '-' characters of the same length as the first one right below.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::string header =</div><div class="line">  <span class="stringliteral">&quot;Running tests with \&quot;&quot;</span> + solver_name + <span class="stringliteral">&quot;\&quot; refinement criterion:&quot;</span>;</div><div class="line">std::cout &lt;&lt; header &lt;&lt; std::endl</div><div class="line">          &lt;&lt; std::string(header.size(), <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div></div><!-- fragment --><p>Then set up triangulation, finite element, etc.</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>    fe(1);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature(4);</div><div class="line">RightHandSide&lt;dim&gt; rhs_function;</div><div class="line">Solution&lt;dim&gt;      boundary_values;</div></div><!-- fragment --><p>Create a solver object of the kind indicated by the argument to this function. If the name is not recognized, throw an exception! The respective solver object is stored in a <code>std::unique_ptr</code> to avoid having to delete the pointer after use.</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;LaplaceSolver::Base&lt;dim&gt;&gt; solver;</div><div class="line"><span class="keywordflow">if</span> (solver_name == <span class="stringliteral">&quot;global&quot;</span>)</div><div class="line">  solver = std::make_unique&lt;LaplaceSolver::RefinementGlobal&lt;dim&gt;&gt;(</div><div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, rhs_function, boundary_values);</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (solver_name == <span class="stringliteral">&quot;kelly&quot;</span>)</div><div class="line">  solver = std::make_unique&lt;LaplaceSolver::RefinementKelly&lt;dim&gt;&gt;(</div><div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, rhs_function, boundary_values);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div></div><!-- fragment --><p>Next create a table object in which the values of the numerical solution at the point (0.5,0.5) will be stored, and create a respective evaluation object:</p>
<div class="fragment"><div class="line"><a class="code" href="classTableHandler.html">TableHandler</a>                          results_table;</div><div class="line">Evaluation::PointValueEvaluation&lt;dim&gt; postprocessor1(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5),</div><div class="line">                                                     results_table);</div></div><!-- fragment --><p>Also generate an evaluator which writes out the solution:</p>
<div class="fragment"><div class="line">Evaluation::SolutionOutput&lt;dim&gt; postprocessor2(std::string(<span class="stringliteral">&quot;solution-&quot;</span>) +</div><div class="line">                                                 solver_name,</div><div class="line">                                               <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">DataOutBase::gnuplot</a>);</div></div><!-- fragment --><p>Take these two evaluation objects and put them in a list...</p>
<div class="fragment"><div class="line">std::list&lt;Evaluation::EvaluationBase&lt;dim&gt; *&gt; postprocessor_list;</div><div class="line">postprocessor_list.push_back(&amp;postprocessor1);</div><div class="line">postprocessor_list.push_back(&amp;postprocessor2);</div></div><!-- fragment --><p>... which we can then pass on to the function that actually runs the simulation on successively refined grids:</p>
<div class="fragment"><div class="line">run_simulation(*solver, postprocessor_list);</div></div><!-- fragment --><p>When this all is done, write out the results of the point evaluations:</p>
<div class="fragment"><div class="line">results_table.<a class="code" href="classTableHandler.html#a45c4ec9981f3880c6c852ed3aceb08fe">write_text</a>(std::cout);</div></div><!-- fragment --><p>And one blank line after all results:</p>
<div class="fragment"><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step13</span></div></div><!-- fragment --><p>There is not much to say about the main function. It follows the same pattern as in all previous examples, with attempts to catch thrown exceptions, and displaying as much information as possible if we should get some. The rest is self-explanatory.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step13::solve_problem&lt;2&gt;(<span class="stringliteral">&quot;global&quot;</span>);</div><div class="line">      Step13::solve_problem&lt;2&gt;(<span class="stringliteral">&quot;kelly&quot;</span>);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-13/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>这个程序的结果并不那么有趣&ndash;毕竟它的目的不是为了演示一些新的数学思想，也不是为了演示如何用deal.II编程，而是为了利用我们在前面的例子中所开发的材料，形成一些演示以模块化和可扩展的方式建立现代有限元软件的方法。</p>
<p>尽管如此，我们当然会展示程序的结果。最感兴趣的是点值计算，为此我们实现了相应的评估类。该程序的结果（即输出）看起来如下。</p>
<div class="fragment"><div class="line">Running tests with <span class="stringliteral">&quot;global&quot;</span> refinement criterion:</div><div class="line"></div><div class="line"></div><div class="line">-------------------------------------------------</div><div class="line">Refinement cycle: 0 1 2 3 4 5 6</div><div class="line">DoFs  u(x_0)</div><div class="line">   25 1.2868</div><div class="line">   81 1.6945</div><div class="line">  289 1.4658</div><div class="line"> 1089 1.5679</div><div class="line"> 4225 1.5882</div><div class="line">16641 1.5932</div><div class="line">66049 1.5945</div><div class="line"></div><div class="line"></div><div class="line">Running tests with <span class="stringliteral">&quot;kelly&quot;</span> refinement criterion:</div><div class="line"></div><div class="line"></div><div class="line">------------------------------------------------</div><div class="line">Refinement cycle: 0 1 2 3 4 5 6 7 8 9 10 11</div><div class="line">DoFs  u(x_0)</div><div class="line">   25 1.2868</div><div class="line">   47 0.8775</div><div class="line">   89 1.5365</div><div class="line">  165 1.2974</div><div class="line">  316 1.6442</div><div class="line">  589 1.5221</div><div class="line"> 1093 1.5724</div><div class="line"> 2042 1.5627</div><div class="line"> 3766 1.5916</div><div class="line"> 7124 1.5876</div><div class="line">13111 1.5942</div><div class="line">24838 1.5932</div></div><!-- fragment --><p>这里令人惊讶的是，精确的数值是1.59491554...，而且计算该解显然出奇的复杂，甚至只达到百分之一的精度，尽管该解是平滑的（事实上是无限常可微）。这种平滑性显示在程序生成的图形输出中，这里是粗网格和凯利细化指标的前9个细化步骤。</p>
<table width="80%" align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-0.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-1.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-2.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-3.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-4.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-5.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-6.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-7.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-8.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.solution-kelly-9.png"/>
</div>
   </td></tr>
</table>
<p>当我们已经在观看图片时，这是第八个网格，从顶部看。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.grid-kelly-8.png"/>
</div>
<p>然而，我们还没有完成对点值计算的评估。事实上，将两个细化标准的误差 \(e=|u(x_0)-u_h(x_0)|\) 绘制成图，可以得到下面的图片。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-13.error.png"/>
</div>
<p>这幅图 <em> 令人不安的是，自适应网格细化不仅没有像人们通常期望的那样比全局细化好，甚至明显更差，因为它的收敛是不规则的，在使用后续网格的值时，阻止了所有的外推技术!另一方面，全局细化提供了一个完美的 \(1/N\) 或 \(h^{-2}\) 收敛历史，并提供了各种机会，甚至可以通过外推法来改善点值。因此，在这个例子中，全局网格细化必须被认为是优越的!这更令人惊讶，因为评估点不是在左边的某个地方，那里的网格是粗糙的，而是在右边，自适应细化也应该细化评估点周围的网格。</em></p>
<p><em>因此，我们以一个问题来结束对这个例子程序的讨论。</em></p>
<p><em></em></p>
<p><em> <b> <em> 如果适应性不比全局细化好，那么它有什么问题？ </em> </b></em></p>
<p><em> <em> 在这个例子的结尾处进行练习。 </em> 有一个简单的原因导致适应性网格解决方案的不良和不规则行为。通过观察每个步骤中评估点周围的网格，可以很简单地找到这个原因&ndash;这个数据在程序的输出文件中。因此，一个练习是修改网格细化程序，使问题（一旦你注意到它）得以避免。第二个练习是检查结果是否比全局细化要好，如果是的话，是否能达到更好的收敛顺序（就自由度数而言），或者只达到一个更好的常数。</em></p>
<p><em>( <em> 对于没有耐心的人来说，非常简短的回答。 </em> 在误差较大的步骤中，网格在评估点上是不规则的，即一些相邻的单元有悬空的节点；这破坏了一些超级近似的效果，而全局细化的网格可以从中受益。答案2：这个快速黑客</em></p>
<p><em></p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> refinement_indicated = <span class="keyword">false</span>;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;vertex(v) == <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(.5,.5))</div><div class="line">          {</div><div class="line">            cell-&gt;clear_coarsen_flag();</div><div class="line">            refinement_indicated |= cell-&gt;refine_flag_set();</div><div class="line">          }</div><div class="line"><span class="keywordflow">if</span> (refinement_indicated)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">          <span class="keywordflow">if</span> (cell-&gt;vertex(v) == <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(.5,.5))</div><div class="line">            cell-&gt;set_refine_flag ();</div></div><!-- fragment --><p></em></p>
<p><em>在执行细化之前，在Kelly细化类的细化函数中，将改善结果（练习：代码是怎么做的？不过，行为仍然是不规则的，所以不可能有关于收敛顺序的结果）。)</em></p>
<p><em><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<p></em></p>
<p><em> </p><div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2001 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, University of Heidelberg, 2001, 2002</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="table__handler_8h.html">deal.II/base/table_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="thread__management_8h.html">deal.II/base/thread_management.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="work__stream_8h.html">deal.II/base/work_stream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step13</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>Evaluation</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>EvaluationBase</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      <span class="keyword">virtual</span> ~EvaluationBase() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                              <span class="keyword">const</span> Vector&lt;double&gt; &amp; solution) <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> EvaluationBase&lt;dim&gt;::set_refinement_cycle(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step)</div><div class="line">    {</div><div class="line">      refinement_cycle = step;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>PointValueEvaluation : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      PointValueEvaluation(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point,</div><div class="line">                           <a class="code" href="classTableHandler.html">TableHandler</a> &amp;    results_table);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                              <span class="keyword">const</span> Vector&lt;double&gt; &amp; solution) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gad107d8d5ae0baa7083cd2e932f9056dd">DeclException1</a>(</div><div class="line">        ExcEvaluationPointNotFound,</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>,</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;The evaluation point &quot;</span> &lt;&lt; arg1</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot; was not found among the vertices of the present grid.&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> evaluation_point;</div><div class="line">      <a class="code" href="classTableHandler.html">TableHandler</a> &amp;   results_table;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    PointValueEvaluation&lt;dim&gt;::PointValueEvaluation(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;evaluation_point,</div><div class="line">      <a class="code" href="classTableHandler.html">TableHandler</a> &amp;    results_table)</div><div class="line">      : evaluation_point(evaluation_point)</div><div class="line">      , results_table(results_table)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> PointValueEvaluation&lt;dim&gt;::</div><div class="line">         operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">               <span class="keyword">const</span> Vector&lt;double&gt; &amp; solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordtype">double</span> point_value = 1e20;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> evaluation_point_found = <span class="keyword">false</span>;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">if</span> (!evaluation_point_found)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> vertex : cell-&gt;vertex_indices())</div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;vertex(vertex) == evaluation_point)</div><div class="line">              {</div><div class="line">                point_value = solution(cell-&gt;vertex_dof_index(vertex, 0));</div><div class="line"></div><div class="line">                evaluation_point_found = <span class="keyword">true</span>;</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">              };</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(evaluation_point_found,</div><div class="line">                  ExcEvaluationPointNotFound(evaluation_point));</div><div class="line"></div><div class="line">      results_table.<a class="code" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a>(<span class="stringliteral">&quot;DoFs&quot;</span>, dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      results_table.<a class="code" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a>(<span class="stringliteral">&quot;u(x_0)&quot;</span>, point_value);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>SolutionOutput : <span class="keyword">public</span> EvaluationBase&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      SolutionOutput(<span class="keyword">const</span> std::string &amp;             output_name_base,</div><div class="line">                     <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                              <span class="keyword">const</span> Vector&lt;double&gt; &amp; solution) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> std::string               output_name_base;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    SolutionOutput&lt;dim&gt;::SolutionOutput(</div><div class="line">      <span class="keyword">const</span> std::string &amp;             output_name_base,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format)</div><div class="line">      : output_name_base(output_name_base)</div><div class="line">      , output_format(output_format)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> SolutionOutput&lt;dim&gt;::operator()(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler,</div><div class="line">                                         <span class="keyword">const</span> Vector&lt;double&gt; &amp; solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">      data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">      std::ofstream out(output_name_base + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                        <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(this-&gt;refinement_cycle) +</div><div class="line">                        data_out.<a class="code" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a>(output_format));</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a>(out, output_format);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  } <span class="comment">// namespace Evaluation</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>LaplaceSolver</div><div class="line">  {</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Base</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid);</div><div class="line">      <span class="keyword">virtual</span> ~Base() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> solve_problem() = 0;</div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div><div class="line">        <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const</span> = 0;</div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span>         refine_grid()                            = 0;</div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const</span>                           = 0;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;Triangulation&lt;dim&gt;</a>&gt; <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Base&lt;dim&gt;::Base(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;coarse_grid)</div><div class="line">      : triangulation(&amp;coarse_grid)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>Solver : <span class="keyword">public</span> <span class="keyword">virtual</span> Base&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line">      <span class="keyword">virtual</span> ~Solver() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> solve_problem() <span class="keyword">override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> postprocess(</div><div class="line">        <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs() <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const FiniteElement&lt;dim&gt;</a>&gt; fe;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Quadrature&lt;dim&gt;</a>&gt;    quadrature;</div><div class="line">      <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>                              dof_handler;</div><div class="line">      Vector&lt;double&gt;                               solution;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt;      boundary_values;</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(Vector&lt;double&gt; &amp;rhs) <span class="keyword">const</span> = 0;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">struct </span>LinearSystem</div><div class="line">      {</div><div class="line">        LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler);</div><div class="line"></div><div class="line">        <span class="keywordtype">void</span> solve(Vector&lt;double&gt; &amp;solution) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">        <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line">        <a class="code" href="classSparsityPattern.html">SparsityPattern</a>           sparsity_pattern;</div><div class="line">        <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>      <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">        Vector&lt;double&gt;            rhs;</div><div class="line">      };</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">struct </span>AssemblyScratchData</div><div class="line">      {</div><div class="line">        AssemblyScratchData(<span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature);</div><div class="line">        AssemblyScratchData(<span class="keyword">const</span> AssemblyScratchData &amp;scratch_data);</div><div class="line"></div><div class="line">        <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keyword">struct </span>AssemblyCopyData</div><div class="line">      {</div><div class="line">        <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">        std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">      };</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> assemble_linear_system(LinearSystem &amp;linear_system);</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> local_assemble_matrix(</div><div class="line">        <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">        AssemblyScratchData &amp;                                 scratch_data,</div><div class="line">        AssemblyCopyData &amp;                                    copy_data) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div><div class="line">                                LinearSystem &amp;          linear_system) <span class="keyword">const</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Solver&lt;dim&gt;::Solver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">      : Base&lt;dim&gt;(triangulation)</div><div class="line">      , fe(&amp;fe)</div><div class="line">      , quadrature(&amp;quadrature)</div><div class="line">      , dof_handler(triangulation)</div><div class="line">      , boundary_values(&amp;boundary_values)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Solver&lt;dim&gt;::~Solver()</div><div class="line">    {</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#ad316958f8045d9a48094335b23a03a53">clear</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::solve_problem()</div><div class="line">    {</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(*fe);</div><div class="line">      solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">      LinearSystem linear_system(dof_handler);</div><div class="line">      assemble_linear_system(linear_system);</div><div class="line">      linear_system.solve(solution);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::postprocess(</div><div class="line">      <span class="keyword">const</span> Evaluation::EvaluationBase&lt;dim&gt; &amp;postprocessor)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      postprocessor(dof_handler, solution);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Solver&lt;dim&gt;::n_dofs()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::assemble_linear_system(LinearSystem &amp;linear_system)</div><div class="line">    {</div><div class="line">      <a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> rhs_task =</div><div class="line">        <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a>(&amp;Solver&lt;dim&gt;::assemble_rhs, *<span class="keyword">this</span>, linear_system.rhs);</div><div class="line"></div><div class="line">      <span class="keyword">auto</span> worker =</div><div class="line">        [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">               AssemblyScratchData &amp;scratch_data,</div><div class="line">               AssemblyCopyData &amp;   copy_data) {</div><div class="line">          this-&gt;local_assemble_matrix(cell, scratch_data, copy_data);</div><div class="line">        };</div><div class="line"></div><div class="line">      <span class="keyword">auto</span> copier = [<span class="keyword">this</span>, &amp;linear_system](<span class="keyword">const</span> AssemblyCopyData &amp;copy_data) {</div><div class="line">        this-&gt;copy_local_to_global(copy_data, linear_system);</div><div class="line">      };</div><div class="line"></div><div class="line">      <a class="code" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                      dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                      worker,</div><div class="line">                      copier,</div><div class="line">                      AssemblyScratchData(*fe, *quadrature),</div><div class="line">                      AssemblyCopyData());</div><div class="line">      linear_system.hanging_node_constraints.condense(linear_system.matrix);</div><div class="line"></div><div class="line">      std::map&lt;types::global_dof_index, double&gt; boundary_value_map;</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               0,</div><div class="line">                                               *boundary_values,</div><div class="line">                                               boundary_value_map);</div><div class="line"></div><div class="line">      rhs_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div><div class="line">      linear_system.hanging_node_constraints.condense(linear_system.rhs);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_value_map,</div><div class="line">                                         linear_system.matrix,</div><div class="line">                                         solution,</div><div class="line">                                         linear_system.rhs);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature)</div><div class="line">      : fe_values(fe, quadrature, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Solver&lt;dim&gt;::AssemblyScratchData::AssemblyScratchData(</div><div class="line">      <span class="keyword">const</span> AssemblyScratchData &amp;scratch_data)</div><div class="line">      : fe_values(scratch_data.fe_values.get_fe(),</div><div class="line">                  scratch_data.fe_values.get_quadrature(),</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::local_assemble_matrix(</div><div class="line">      <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">      AssemblyScratchData &amp;                                 scratch_data,</div><div class="line">      AssemblyCopyData &amp;                                    copy_data)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe-&gt;n_dofs_per_cell();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature-&gt;size();</div><div class="line"></div><div class="line">      copy_data.cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">      copy_data.local_dof_indices.resize(dofs_per_cell);</div><div class="line"></div><div class="line">      scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            copy_data.cell_matrix(i, j) +=</div><div class="line">              (scratch_data.fe_values.shape_grad(i, q_point) *</div><div class="line">               scratch_data.fe_values.shape_grad(j, q_point) *</div><div class="line">               scratch_data.fe_values.JxW(q_point));</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(copy_data.local_dof_indices);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::copy_local_to_global(<span class="keyword">const</span> AssemblyCopyData &amp;copy_data,</div><div class="line">                                           LinearSystem &amp;linear_system)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; copy_data.local_dof_indices.size(); ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; copy_data.local_dof_indices.size(); ++j)</div><div class="line">          linear_system.matrix.add(copy_data.local_dof_indices[i],</div><div class="line">                                   copy_data.local_dof_indices[j],</div><div class="line">                                   copy_data.cell_matrix(i, j));</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    Solver&lt;dim&gt;::LinearSystem::LinearSystem(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;dof_handler)</div><div class="line">    {</div><div class="line">      hanging_node_constraints.clear();</div><div class="line"></div><div class="line">      void (*mhnc_p)(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;, <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;) =</div><div class="line">        &amp;<a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>;</div><div class="line"></div><div class="line">      <a class="code" href="classThreads_1_1Task.html">Threads::Task&lt;void&gt;</a> side_task =</div><div class="line">        <a class="code" href="group__threads.html#ga8c1e15b84e1bb58a8029fc6d6ddf3cbf">Threads::new_task</a>(mhnc_p, dof_handler, hanging_node_constraints);</div><div class="line"></div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">      side_task.<a class="code" href="classThreads_1_1Task.html#a9aed8f99d2b88bd0d6cfff95e38c3ac7">join</a>();</div><div class="line"></div><div class="line">      hanging_node_constraints.close();</div><div class="line">      hanging_node_constraints.condense(dsp);</div><div class="line">      sparsity_pattern.copy_from(dsp);</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>.reinit(sparsity_pattern);</div><div class="line">      rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> Solver&lt;dim&gt;::LinearSystem::solve(Vector&lt;double&gt; &amp;solution)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; cg(solver_control);</div><div class="line"></div><div class="line">      <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line">      preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, 1.2);</div><div class="line"></div><div class="line">      cg.solve(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, solution, rhs, preconditioner);</div><div class="line"></div><div class="line">      hanging_node_constraints.distribute(solution);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>PrimalSolver : <span class="keyword">public</span> Solver&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                   <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line">    <span class="keyword">protected</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const Function&lt;dim&gt;</a>&gt; rhs_function;</div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> assemble_rhs(Vector&lt;double&gt; &amp;rhs) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    PrimalSolver&lt;dim&gt;::PrimalSolver(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      triangulation,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">      : Base&lt;dim&gt;(triangulation)</div><div class="line">      , Solver&lt;dim&gt;(triangulation, fe, quadrature, boundary_values)</div><div class="line">      , rhs_function(&amp;rhs_function)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> PrimalSolver&lt;dim&gt;::assemble_rhs(Vector&lt;double&gt; &amp;rhs)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(*this-&gt;fe,</div><div class="line">                              *this-&gt;quadrature,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = this-&gt;fe-&gt;n_dofs_per_cell();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = this-&gt;quadrature-&gt;size();</div><div class="line"></div><div class="line">      Vector&lt;double&gt;                       cell_rhs(dofs_per_cell);</div><div class="line">      std::vector&lt;double&gt;                  rhs_values(n_q_points);</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : this-&gt;dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          cell_rhs = 0;</div><div class="line">          fe_values.reinit(cell);</div><div class="line">          rhs_function-&gt;value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                   rhs_values);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              cell_rhs(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * </div><div class="line">                             rhs_values[q_point] *               </div><div class="line">                             fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line">        };</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>RefinementGlobal : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      RefinementGlobal(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                       <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                       <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                       <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                       <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    RefinementGlobal&lt;dim&gt;::RefinementGlobal(</div><div class="line">      <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values)</div><div class="line">      : Base&lt;dim&gt;(coarse_grid)</div><div class="line">      , PrimalSolver&lt;dim&gt;(coarse_grid,</div><div class="line">                          fe,</div><div class="line">                          quadrature,</div><div class="line">                          rhs_function,</div><div class="line">                          boundary_values)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> RefinementGlobal&lt;dim&gt;::refine_grid()</div><div class="line">    {</div><div class="line">      this-&gt;triangulation-&gt;refine_global(1);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>RefinementKelly : <span class="keyword">public</span> PrimalSolver&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     rhs_function,</div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;     boundary_values);</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> refine_grid() <span class="keyword">override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    RefinementKelly&lt;dim&gt;::RefinementKelly(<a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;      coarse_grid,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;   quadrature,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;rhs_function,</div><div class="line">                                          <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> &amp;boundary_values)</div><div class="line">      : Base&lt;dim&gt;(coarse_grid)</div><div class="line">      , PrimalSolver&lt;dim&gt;(coarse_grid,</div><div class="line">                          fe,</div><div class="line">                          quadrature,</div><div class="line">                          rhs_function,</div><div class="line">                          boundary_values)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> RefinementKelly&lt;dim&gt;::refine_grid()</div><div class="line">    {</div><div class="line">      Vector&lt;float&gt; estimated_error_per_cell(</div><div class="line">        this-&gt;triangulation-&gt;n_active_cells());</div><div class="line">      <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">        this-&gt;dof_handler,</div><div class="line">        <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(this-&gt;fe-&gt;degree + 1),</div><div class="line">        std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">        this-&gt;solution,</div><div class="line">        estimated_error_per_cell);</div><div class="line">      <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(*this-&gt;triangulation,</div><div class="line">                                                      estimated_error_per_cell,</div><div class="line">                                                      0.3,</div><div class="line">                                                      0.03);</div><div class="line">      this-&gt;triangulation-&gt;execute_coarsening_and_refinement();</div><div class="line">    }</div><div class="line"></div><div class="line">  } <span class="comment">// namespace LaplaceSolver</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Solution : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> Solution&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">    <span class="keywordtype">double</span> q = p(0);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">      q += std::sin(10 * p(i) + 5 * p(0) * p(0));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> exponential = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(q);</div><div class="line">    <span class="keywordflow">return</span> exponential;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">    <span class="keywordtype">double</span> q = p(0);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">      q += std::sin(10 * p(i) + 5 * p(0) * p(0));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> u  = <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(q);</div><div class="line">    <span class="keywordtype">double</span>       t1 = 1, t2 = 0, t3 = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        t1 += <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) * 10 * p(0);</div><div class="line">        t2 += 10 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) -</div><div class="line">              100 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(10 * p(i) + 5 * p(0) * p(0)) * p(0) * p(0);</div><div class="line">        t3 += 100 * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) *</div><div class="line">                <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(10 * p(i) + 5 * p(0) * p(0)) -</div><div class="line">              100 * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(10 * p(i) + 5 * p(0) * p(0));</div><div class="line">      };</div><div class="line">    t1 = t1 * t1;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> -u * (t1 + t2 + t3);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> run_simulation(</div><div class="line">    LaplaceSolver::Base&lt;dim&gt; &amp;                          solver,</div><div class="line">    <span class="keyword">const</span> std::list&lt;Evaluation::EvaluationBase&lt;dim&gt; *&gt; &amp;postprocessor_list)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Refinement cycle: &quot;</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; <span class="keyword">true</span>; ++step)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; step &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">        solver.solve_problem();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;postprocessor : postprocessor_list)</div><div class="line">          {</div><div class="line">            postprocessor-&gt;set_refinement_cycle(step);</div><div class="line">            solver.postprocess(*postprocessor);</div><div class="line">          };</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (solver.n_dofs() &lt; 20000)</div><div class="line">          solver.refine_grid();</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">      };</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> solve_problem(<span class="keyword">const</span> std::string &amp;solver_name)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> std::string header =</div><div class="line">      <span class="stringliteral">&quot;Running tests with \&quot;&quot;</span> + solver_name + <span class="stringliteral">&quot;\&quot; refinement criterion:&quot;</span>;</div><div class="line">    std::cout &lt;&lt; header &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::string(header.size(), <span class="charliteral">&#39;-&#39;</span>) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">    triangulation.refine_global(2);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>    fe(1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature(4);</div><div class="line">    RightHandSide&lt;dim&gt; rhs_function;</div><div class="line">    Solution&lt;dim&gt;      boundary_values;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;LaplaceSolver::Base&lt;dim&gt;&gt; solver;</div><div class="line">    <span class="keywordflow">if</span> (solver_name == <span class="stringliteral">&quot;global&quot;</span>)</div><div class="line">      solver = std::make_unique&lt;LaplaceSolver::RefinementGlobal&lt;dim&gt;&gt;(</div><div class="line">        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, rhs_function, boundary_values);</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (solver_name == <span class="stringliteral">&quot;kelly&quot;</span>)</div><div class="line">      solver = std::make_unique&lt;LaplaceSolver::RefinementKelly&lt;dim&gt;&gt;(</div><div class="line">        <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, fe, quadrature, rhs_function, boundary_values);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classTableHandler.html">TableHandler</a>                          results_table;</div><div class="line">    Evaluation::PointValueEvaluation&lt;dim&gt; postprocessor1(<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0.5, 0.5),</div><div class="line">                                                         results_table);</div><div class="line"></div><div class="line">    Evaluation::SolutionOutput&lt;dim&gt; postprocessor2(std::string(<span class="stringliteral">&quot;solution-&quot;</span>) +</div><div class="line">                                                     solver_name,</div><div class="line">                                                   <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">DataOutBase::gnuplot</a>);</div><div class="line"></div><div class="line">    std::list&lt;Evaluation::EvaluationBase&lt;dim&gt; *&gt; postprocessor_list;</div><div class="line">    postprocessor_list.push_back(&amp;postprocessor1);</div><div class="line">    postprocessor_list.push_back(&amp;postprocessor2);</div><div class="line"></div><div class="line">    run_simulation(*solver, postprocessor_list);</div><div class="line"></div><div class="line">    results_table.<a class="code" href="classTableHandler.html#a45c4ec9981f3880c6c852ed3aceb08fe">write_text</a>(std::cout);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step13</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step13::solve_problem&lt;2&gt;(<span class="stringliteral">&quot;global&quot;</span>);</div><div class="line">      Step13::solve_problem&lt;2&gt;(<span class="stringliteral">&quot;kelly&quot;</span>);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> </em></p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
