<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_60.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-60 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-60 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_6.html">step-6</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#NonmatchinggridconstraintsthroughdistributedLagrangemultipliers">Non-matching grid constraints through distributed Lagrange multipliers</a>
        <li><a href="#Thetestcase">The testcase</a>
        <li><a href="#References">References</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#DistributedLagrangeProblem">DistributedLagrangeProblem</a>
        <li><a href="#DistributedLagrangeProblemParameters">DistributedLagrangeProblem::Parameters</a>
        <li><a href="#Setup">Set up</a>
        <li><a href="#Assembly">Assembly</a>
        <li><a href="#Solve">Solve</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Testcase1"> Test case 1: </a>
        <li><a href="#Testcase2and3"> Test case 2 and 3: </a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Runningwithspacedimequaltothree"> Running with `spacedim` equal to three</a>
        <li><a href="#Moregeneraldomains"> More general domains </a>
        <li><a href="#Preconditioner"> Preconditioner</a>
        <li><a href="#ParallelCode"> Parallel Code </a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Luca Heltai and Giovanni Alzetta, SISSA, Trieste. </em></p>
<dl class="section note"><dt>Note</dt><dd>If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.1243280"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.1243280.svg" alt="10.5281/zenodo.1243280"/></a> </dd></dl>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="NonmatchinggridconstraintsthroughdistributedLagrangemultipliers"></a></p><h3>Non-matching grid constraints through distributed Lagrange multipliers</h3>
<p>In this tutorial we consider the case of two domains, \(\Omega\) in \(R^{\text{spacedim}}\) and \(\Gamma\) in \(R^{\text{dim}}\), where \(\Gamma\) is embedded in \(\Omega\) ( \(\Gamma \subseteq \Omega\)). We want to solve a partial differential equation on \(\Omega\), enforcing some conditions on the solution of the problem <em>on the embedded domain</em> \(\Gamma\).</p>
<p>There are two interesting scenarios:</p>
<ul>
<li>the geometrical dimension <code>dim</code> of the embedded domain \(\Gamma\) is the same of the domain \(\Omega\) (<code>spacedim</code>), that is, the spacedim-dimensional measure of \(\Gamma\) is not zero, or</li>
<li>the embedded domain \(\Gamma\) has an intrinsic dimension <code>dim</code> which is smaller than that of \(\Omega\) (<code>spacedim</code>), thus its spacedim-dimensional measure is zero; for example it is a curve embedded in a two dimensional domain, or a surface embedded in a three-dimensional domain.</li>
</ul>
<p>In both cases define the restriction operator \(\gamma\) as the operator that, given a continuous function on \(\Omega\), returns its (continuous) restriction on \(\Gamma\), i.e.,</p>
<p class="formulaDsp">
\[ \gamma : C^0(\Omega) \mapsto C^0(\Gamma), \quad \text{ s.t. } \gamma u = u|_{\Gamma} \in C^0(\Gamma), \quad \forall u \in C^0(\Omega). \]
</p>
<p>It is well known that the operator \(\gamma\) can be extended to a continuous operator on \(H^1(\Omega)\), mapping functions in \(H^1(\Omega)\) to functions in \(H^1(\Gamma)\) when the intrinsic dimension of \(\Gamma\) is the same of \(\Omega\).</p>
<p>The same is true, with a less regular range space (namely \(H^{1/2}(\Gamma)\)), when the dimension of \(\Gamma\) is one less with respect to \(\Omega\), and \(\Gamma\) does not have a boundary. In this second case, the operator \(\gamma\) is also known as the <em>trace</em> operator, and it is well defined for Lipschitz co-dimension one curves and surfaces \(\Gamma\) embedded in \(\Omega\) (read <a href="https://en.wikipedia.org/wiki/Trace_operator">this wikipedia article</a> for further details on the trace operator).</p>
<p>The co-dimension two case is a little more complicated, and in general it is not possible to construct a continuous trace operator, not even from \(H^1(\Omega)\) to \(L^2(\Gamma)\), when the dimension of \(\Gamma\) is zero or one respectively in two and three dimensions.</p>
<p>In this tutorial program we're not interested in further details on \(\gamma\): we take the extension \(\gamma\) for granted, assuming that the dimension of the embedded domain (<code>dim</code>) is always smaller by one or equal with respect to the dimension of the embedding domain \(\Omega\) (<code>spacedim</code>).</p>
<p>We are going to solve the following differential problem: given a sufficiently regular function \(g\) on \(\Gamma\), find the solution \(u\) to</p>
<p class="formulaDsp">
\begin{eqnarray*} - \Delta u + \gamma^T \lambda &amp;=&amp; 0 \text{ in } \Omega\\ \gamma u &amp;=&amp; g \text{ in } \Gamma \\ u &amp; = &amp; 0 \text{ on } \partial\Omega. \end{eqnarray*}
</p>
<p>This is a constrained problem, where we are looking for a harmonic function \(u\) that satisfies homogeneous boundary conditions on \(\partial\Omega\), subject to the constraint \(\gamma u = g\) using a Lagrange multiplier.</p>
<p>This problem has a physical interpretation: harmonic functions, i.e., functions that satisfy the Laplace equation, can be thought of as the displacements of a membrane whose boundary values are prescribed. The current situation then corresponds to finding the shape of a membrane for which not only the displacement at the boundary, but also on \(\Gamma\) is prescribed. For example, if \(\Gamma\) is a closed curve in 2d space, then that would model a soap film that is held in place by a wire loop along \(\partial \Omega\) as well as a second loop along \(\Gamma\). In cases where \(\Gamma\) is a whole area, you can think of this as a membrane that is stretched over an obstacle where \(\Gamma\) is the contact area. (If the contact area is not known we have a different problem &ndash; called the "obstacle problem" &ndash; which is modeled in <a class="el" href="step_41.html">step-41</a>.)</p>
<p>As a first example we study the zero Dirichlet boundary condition on \(\partial\Omega\). The same equations apply if we apply zero Neumann boundary conditions on \(\partial\Omega\) or a mix of the two.</p>
<p>The variational formulation can be derived by introducing two infinite dimensional spaces \(V(\Omega)\) and \(Q^*(\Gamma)\), respectively for the solution \(u\) and for the Lagrange multiplier \(\lambda\).</p>
<p>Multiplying the first equation by \(v \in V(\Omega)\) and the second by \(q \in Q(\Gamma)\), integrating by parts when possible, and exploiting the boundary conditions on \(\partial\Omega\), we obtain the following variational problem:</p>
<p>Given a sufficiently regular function \(g\) on \(\Gamma\), find the solution \(u\) to </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla u, \nabla v)_{\Omega} + (\lambda, \gamma v)_{\Gamma} &amp;=&amp; 0 \qquad \forall v \in V(\Omega) \\ (\gamma u, q)_{\Gamma} &amp;=&amp; (g,q)_{\Gamma} \qquad \forall q \in Q(\Gamma), \end{eqnarray*}
</p>
<p>where \((\cdot, \cdot)_{\Omega}\) and \((\cdot, \cdot)_{\Gamma}\) represent, respectively, \(L^2\) scalar products in \(\Omega\) and in \(\Gamma\).</p>
<p>Inspection of the variational formulation tells us that the space \(V(\Omega)\) can be taken to be \(H^1_0(\Omega)\). The space \(Q(\Gamma)\), in the co-dimension zero case, should be taken as \(H^1(\Gamma)\), while in the co-dimension one case should be taken as \(H^{1/2}(\Gamma)\).</p>
<p>The function \(g\) should therefore be either in \(H^1(\Gamma)\) (for the co-dimension zero case) or \(H^{1/2}(\Gamma)\) (for the co-dimension one case). This leaves us with a Lagrange multiplier \(\lambda\) in \(Q^*(\Gamma)\), which is either \(H^{-1}(\Gamma)\) or \(H^{-1/2}(\Gamma)\).</p>
<p>There are two options for the discretization of the problem above. One could choose matching discretizations, where the <a class="el" href="classTriangulation.html">Triangulation</a> for \(\Gamma\) is aligned with the <a class="el" href="classTriangulation.html">Triangulation</a> for \(\Omega\), or one could choose to discretize the two domains in a completely independent way.</p>
<p>The first option is clearly more indicated for the simple problem we proposed above: it is sufficient to use a single <a class="el" href="classTriangulation.html">Triangulation</a> for \(\Omega\) and then impose certain constraints depending \(\Gamma\). An example of this approach is studied in <a class="el" href="step_40.html">step-40</a>, where the solution has to stay above an obstacle and this is achieved imposing constraints on \(\Omega\).</p>
<p>To solve more complex problems, for example one where the domain \(\Gamma\) is time dependent, the second option could be a more viable solution. Handling non aligned meshes is complex by itself: to illustrate how is done we study a simple problem.</p>
<p>The technique we describe here is presented in the literature using one of many names: the <b>immersed finite element method</b>, the <b>fictitious boundary method</b>, the <b>distributed Lagrange multiplier method</b>, and others. The main principle is that the discretization of the two grids and of the two finite element spaces are kept completely independent. This technique is particularly efficient for the simulation of fluid-structure interaction problems, where the configuration of the embedded structure is part of the problem itself, and one solves a (possibly non-linear) elastic problem to determine the (time dependent) configuration of \(\Gamma\), and a (possibly non-linear) flow problem in \(\Omega \setminus \Gamma\), plus coupling conditions on the interface between the fluid and the solid.</p>
<p>In this tutorial program we keep things a little simpler, and we assume that the configuration of the embedded domain is given in one of two possible ways:</p>
<ul>
<li>as a deformation mapping \(\psi: \Gamma_0 \mapsto \Gamma \subseteq \Omega\), defined on a continuous finite dimensional space on \(\Gamma_0\) and representing, for any point \(x \in \Gamma_0\), its coordinate \(\psi(x)\) in \(\Omega\);</li>
<li>as a displacement mapping \(\delta \psi(x) = \psi(x)-x\) for \(x\in \Gamma_0\), representing for any point \(x\) the displacement vector applied in order to deform \(x\) to its actual configuration \(\psi(x) = x +\delta\psi(x)\).</li>
</ul>
<p>We define the embedded reference domain \(\Gamma_0\) <code>embedded_grid</code>: on this triangulation we construct a finite dimensional space (<code>embedded_configuration_dh</code>) to describe either the deformation or the displacement through a <a class="el" href="classFiniteElement.html">FiniteElement</a> system of <a class="el" href="classFE__Q.html">FE_Q</a> objects (<code>embedded_configuration_fe</code>). This finite dimensional space is used only to interpolate a user supplied function (<code>embedded_configuration_function</code>) representing either \(\psi\) (if the parameter <code>use_displacement</code> is set to <code>false</code>) or \(\delta\psi\) (if the parameter <code>use_displacement</code> is set to <code>true</code>).</p>
<p>The Lagrange multiplier \(\lambda\) and the user supplied function \(g\) are defined through another finite dimensional space <code>embedded_dh</code>, and through another <a class="el" href="classFiniteElement.html">FiniteElement</a> <code>embedded_fe</code>, using the same reference domain. In order to take into account the deformation of the domain, either a <a class="el" href="classMappingFEField.html">MappingFEField</a> or a <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> object are initialized with the <code>embedded_configuration</code> vector.</p>
<p>In the embedding space, a standard finite dimensional space <code>space_dh</code> is constructed on the embedding grid <code>space_grid</code>, using the <a class="el" href="classFiniteElement.html">FiniteElement</a> <code>space_fe</code>, following almost verbatim the approach taken in <a class="el" href="step_6.html">step-6</a>.</p>
<p>We represent the discretizations of the spaces \(V\) and \(Q\) with </p><p class="formulaDsp">
\[ V_h(\Omega) = \text{span} \{v_i\}_{i=1}^n \]
</p>
<p> and </p><p class="formulaDsp">
\[ Q_h(\Gamma) = \text{span} \{q_i\}_{i=1}^m \]
</p>
<p> respectively, where \(n\) is the dimension of <code>space_dh</code>, and \(m\) the dimension of <code>embedded_dh</code>.</p>
<p>Once all the finite dimensional spaces are defined, the variational formulation of the problem above leaves us with the following finite dimensional system of equations:</p>
<p class="formulaDsp">
\[ \begin{pmatrix} K &amp; C^T \\ C &amp; 0 \end{pmatrix} \begin{pmatrix} u \\ \lambda \end{pmatrix} = \begin{pmatrix} 0 \\ G \end{pmatrix} \]
</p>
<p>where</p>
<p class="formulaDsp">
\begin{eqnarray*} K_{ij} &amp;\dealcoloneq&amp; (\nabla v_j, \nabla v_i)_\Omega \qquad i,j=1,\dots,n \\ C_{\alpha j} &amp;\dealcoloneq&amp; (v_j, q_\alpha)_\Gamma \qquad j=1,\dots,n, \alpha = 1,\dots, m \\\\ G_{\alpha} &amp;\dealcoloneq&amp; (g, q_\alpha)_\Gamma \qquad \alpha = 1,\dots, m. \end{eqnarray*}
</p>
<p>While the matrix \(K\) is the standard stiffness matrix for the Poisson problem on \(\Omega\), and the vector \(G\) is a standard right-hand-side vector for a finite element problem with forcing term \(g\) on \(\Gamma\), (see, for example, <a class="el" href="step_3.html">step-3</a>), the matrix \(C\) or its transpose \(C^T\) are non-standard since they couple information on two non-matching grids.</p>
<p>In particular, the integral that appears in the computation of a single entry of \(C\), is computed on \(\Gamma\). As usual in finite elements we split this integral into contributions from all cells of the triangulation used to discretize \(\Gamma\), we transform the integral on \(K\) to an integral on the reference element \(\hat K\), where \(F_{K}\) is the mapping from \(\hat K\) to \(K\), and compute the integral on \(\hat K\) using a quadrature formula:</p>
<p class="formulaDsp">
\[ C_{\alpha j} \dealcoloneq (v_j, q_\alpha)_\Gamma = \sum_{K\in \Gamma} \int_{\hat K} \hat q_\alpha(\hat x) (v_j \circ F_{K}) (\hat x) J_K (\hat x) \mathrm{d} \hat x = \sum_{K\in \Gamma} \sum_{i=1}^{n_q} \big(\hat q_\alpha(\hat x_i) (v_j \circ F_{K}) (\hat x_i) J_K (\hat x_i) w_i \big) \]
</p>
<p>Computing this sum is non-trivial because we have to evaluate \((v_j \circ F_{K}) (\hat x_i)\). In general, if \(\Gamma\) and \(\Omega\) are not aligned, the point \(F_{K}(\hat x_i)\) is completely arbitrary with respect to \(\Omega\), and unless we figure out a way to interpolate all basis functions of \(V_h(\Omega)\) on an arbitrary point on \(\Omega\), we cannot compute the integral needed for an entry of the matrix \(C\).</p>
<p>To evaluate \((v_j \circ F_{K}) (\hat x_i)\) the following steps needs to be taken (as shown in the picture below):</p>
<ul>
<li>For a given cell \(K\) in \(\Gamma\) compute the real point \(y_i \dealcoloneq F_{K} (\hat x_i)\), where \(x_i\) is one of the quadrature points used for the integral on \(K \subseteq \Gamma\).</li>
<li>Find the cell of \(\Omega\) in which \(y_i\) lies. We shall call this element \(T\).</li>
<li>To evaluate the basis function use the inverse of the mapping \(G_T\) that transforms the reference element \(\hat T\) into the element \(T\): \(v_j(y_i) = \hat v_j \circ G^{-1}_{T} (y_i)\).</li>
</ul>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.C_interpolation.png"/>
</div>
 <p>The three steps above can be computed by calling, in turn,</p>
<ul>
<li><a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point()</a>, followed by</li>
<li><a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a>. We then</li>
<li>construct a custom <a class="el" href="classQuadrature.html">Quadrature</a> formula, containing the point in the reference cell and then</li>
<li>construct an <a class="el" href="classFEValues.html">FEValues</a> object, with the given quadrature formula, and initialized with the cell obtained in the first step.</li>
</ul>
<p>This is what the deal.II function <a class="el" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value()</a> does when evaluating a finite element field (not just a single shape function) at an arbitrary point; but this would be inefficient in this case.</p>
<p>A better solution is to use a convenient wrapper to perform the first three steps on a collection of points: <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations()</a>. If one is actually interested in computing the full coupling matrix, then it is possible to call the method <a class="el" href="namespaceNonMatching.html#ac3821491559b8a76af0be66736fe4c6f">NonMatching::create_coupling_mass_matrix()</a>, that performs the above steps in an efficient way, reusing all possible data structures, and gathering expensive steps together. This is the function we'll be using later in this tutorial.</p>
<p>We solve the final saddle point problem by an iterative solver, applied to the Schur complement \(S\) (whose construction is described, for example, in <a class="el" href="step_20.html">step-20</a>), and we construct \(S\) using <a class="el" href="classLinearOperator.html">LinearOperator</a> classes.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>The problem we solve here is identical to <a class="el" href="step_4.html">step-4</a>, with the difference that we impose some constraints on an embedded domain \(\Gamma\). The tutorial is written in a dimension independent way, and in the results section we show how to vary both <code>dim</code> and <code>spacedim</code>.</p>
<p>The tutorial is compiled for <code>dim</code> equal to one and <code>spacedim</code> equal to two. If you want to run the program in embedding dimension <code>spacedim</code> equal to three, you will most likely want to change the reference domain for \(\Gamma\) to be, for example, something you read from file, or a closed sphere that you later deform to something more interesting.</p>
<p>In the default scenario, \(\Gamma\) has co-dimension one, and this tutorial program implements the Fictitious Boundary Method. As it turns out, the same techniques are used in the Variational Immersed Finite Element Method, and the coupling operator \(C\) defined above is the same in almost all of these non-matching methods.</p>
<p>The embedded domain is assumed to be included in \(\Omega\), which we take as the unit square \([0,1]^2\). The definition of the fictitious domain \(\Gamma\) can be modified through the parameter file, and can be given as a mapping from the reference interval \([0,1]\) to a curve in \(\Omega\).</p>
<p>If the curve is closed, then the results will be similar to running the same problem on a grid whose boundary is \(\Gamma\). The program will happily run also with a non-closed \(\Gamma\), although in those cases the mathematical formulation of the problem is more difficult, since \(\Gamma\) will have a boundary by itself that has co-dimension two with respect to the domain \(\Omega\).</p>
<p><a class="anchor" id="References"></a></p><h3>References</h3>
<ul>
<li>
<p class="startli">Glowinski, R., T.-W. Pan, T.I. Hesla, and D.D. Joseph. 1999. “A Distributed Lagrange Multiplier/fictitious Domain Method for Particulate Flows.” International Journal of Multiphase Flow 25 (5). Pergamon: 755–94.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Boffi, D., L. Gastaldi, L. Heltai, and C.S. Peskin. 2008. “On the Hyper-Elastic Formulation of the Immersed Boundary Method.” Computer Methods in Applied Mechanics and Engineering 197 (25–28).</p>
<p class="endli"></p>
</li>
<li>
Heltai, L., and F. Costanzo. 2012. “Variational Implementation of Immersed Finite Element Methods.” Computer Methods in Applied Mechanics and Engineering 229–232. </li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Most of these have been introduced elsewhere, we'll comment only on the new ones.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div></div><!-- fragment --><p>The parameter acceptor class is the first novelty of this tutorial program: in general parameter files are used to steer the execution of a program at run time. While even a simple approach saves compile time, as the same executable can be run with different parameter settings, it can become difficult to handle hundreds of parameters simultaneously while maintaining compatibility between different programs. This is where the class <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> proves useful.</p>
<p>This class is used to define a public interface for classes that want to use a single global <a class="el" href="classParameterHandler.html">ParameterHandler</a> to handle parameters. The class provides a static <a class="el" href="classParameterHandler.html">ParameterHandler</a> member, namely <a class="el" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>, and implements the "Command design pattern" (see, for example, E. Gamma, R. Helm, R. Johnson, J. Vlissides, Design <a class="el" href="namespacePatterns.html">Patterns</a>: Elements of Reusable Object-Oriented Software, Addison-Wesley Professional, 1994. <a href="https://goo.gl/FNYByc">https://goo.gl/FNYByc</a>).</p>
<p><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> provides a global subscription mechanism. Whenever an object of a class derived from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> is constructed, a pointer to that object-of-derived-type is registered, together with a section entry in the parameter file. Such registry is traversed upon invocation of the single function <a class="el" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>("file.prm") which in turn makes sure that all classes stored in the global registry declare the parameters they will be using, and after having declared them, it reads the content of <code>file.prm</code> to parse the actual parameters.</p>
<p>If you call the method <a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">ParameterHandler::add_parameter</a> for each of the parameters you want to use in your code, there is nothing else you need to do. If you are using an already existing class that provides the two functions <code>declare_parameters</code> and <code>parse_parameters</code>, you can still use <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>, by encapsulating the existing class into a <a class="el" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy</a> class.</p>
<p>In this example, we'll use both strategies, using <a class="el" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy</a> for deal.II classes, and deriving our own parameter classes directly from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The other new include file is the one that contains the <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> class. The structure of deal.II, as many modern numerical libraries, is organized following a Directed Acyclic Graph (DAG). A DAG is a directed graph with topological ordering: each node structurally represents an object, and is connected to non-root nodes by one (or more) oriented edges, from the parent to the child. The most significant example of this structure is the <a class="el" href="classTriangulation.html">Triangulation</a> and its <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">Triangulation::cell_iterator</a> structure. From a <a class="el" href="classTriangulation.html">Triangulation</a> (the main node), we can access each cell (children nodes of the triangulation). From the cells themselves we can access over all vertices of the cell. In this simple example, the DAG structure can be represented as three node types (the triangulation, the cell iterator, and the vertex) connected by oriented edges from the triangulation to the cell iterators, and from the cell iterator to the vertices. This has several advantages, but it intrinsically creates “asymmetries”, making certain operations fast and their inverse very slow: finding the vertices of a cell has low computational cost, and can be done by simply traversing the DAG, while finding all the cells that share a vertex requires a non-trivial computation unless a new DAG data structure is added that represents the inverse search.</p>
<p>Since inverse operations are usually not needed in a finite element code, these are implemented in <a class="el" href="namespaceGridTools.html">GridTools</a> without the use of extra data structures related to the <a class="el" href="classTriangulation.html">Triangulation</a> which would make them much faster. One such data structure, for example, is a map from the vertices of a <a class="el" href="classTriangulation.html">Triangulation</a> to all cells that share those vertices, which would reduce the computations needed to answer to the previous question.</p>
<p>Some methods, for example <a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point</a>, make heavy usage of these non-standard operations. If you need to call these methods more than once, it becomes convenient to store those data structures somewhere. <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> does exactly this, giving you access to previously computed objects, or computing them on the fly (and then storing them inside the class for later use), and making sure that whenever the <a class="el" href="classTriangulation.html">Triangulation</a> is updated, also the relevant data structures are recomputed.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools__cache_8h.html">deal.II/grid/grid_tools_cache.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2fe_2fe_8h.html">deal.II/fe/fe.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div></div><!-- fragment --><p>In this example, we will be using a reference domain to describe an embedded <a class="el" href="classTriangulation.html">Triangulation</a>, deformed through a finite element vector field.</p>
<p>The next two include files contain the definition of two classes that can be used in these cases. <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> allows one to describe a domain through a <em>displacement</em> field, based on a <a class="el" href="classFESystem.html">FESystem</a>[<a class="el" href="classFE__Q.html">FE_Q(p)</a>^spacedim] finite element space. The second is a little more generic, and allows you to use arbitrary vector <a class="el" href="classFiniteElement.html">FiniteElement</a> spaces, as long as they provide a <em>continuous</em> description of your domain. In this case, the description is done through the actual <em>deformation</em> field, rather than a <em>displacement</em> field.</p>
<p>Which one is used depends on how the user wants to specify the reference domain, and/or the actual configuration. We'll provide both options, and experiment a little in the results section of this tutorial program.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__eulerian_8h.html">deal.II/fe/mapping_q_eulerian.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__fe__field_8h.html">deal.II/fe/mapping_fe_field.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The parsed function class is another new entry. It allows one to create a <a class="el" href="classFunction.html">Function</a> object, starting from a string in a parameter file which is parsed into an object that you can use anywhere deal.II accepts a <a class="el" href="classFunction.html">Function</a> (for example, for interpolation, boundary conditions, etc.).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parsed__function_8h.html">deal.II/base/parsed_function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div></div><!-- fragment --><p>This is the last new entry for this tutorial program. The namespace <a class="el" href="namespaceNonMatching.html">NonMatching</a> contains a few methods that are useful when performing computations on non-matching grids, or on curves that are not aligned with the underlying mesh.</p>
<p>We'll discuss its use in detail later on in the <code>setup_coupling</code> method.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="coupling_8h.html">deal.II/non_matching/coupling.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step60</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="DistributedLagrangeProblem"></a> </p><h3>DistributedLagrangeProblem</h3>
<p>In the DistributedLagrangeProblem, we need two parameters describing the dimensions of the domain \(\Gamma\) (<code>dim</code>) and of the domain \(\Omega\) (<code>spacedim</code>).</p>
<p>These will be used to initialize a Triangulation&lt;dim,spacedim&gt; (for \(\Gamma\)) and a Triangulation&lt;spacedim,spacedim&gt; (for \(\Omega\)).</p>
<p>A novelty with respect to other tutorial programs is the heavy use of std::unique_ptr. These behave like classical pointers, with the advantage of doing automatic house-keeping: the contained object is automatically destroyed as soon as the unique_ptr goes out of scope, even if it is inside a container or there's an exception. Moreover it does not allow for duplicate pointers, which prevents ownership problems. We do this, because we want to be able to i) construct the problem, ii) read the parameters, and iii) initialize all objects according to what is specified in a parameter file.</p>
<p>We construct the parameters of our problem in the internal class <code>Parameters</code>, derived from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>. The <code>DistributedLagrangeProblem</code> class takes a const reference to a <code>Parameters</code> object, so that it is not possible to modify the parameters from within the DistributedLagrangeProblem class itself.</p>
<p>We could have initialized the parameters first, and then pass the parameters to the DistributedLagrangeProblem assuming all entries are set to the desired values, but this has two disadvantages:</p>
<ul>
<li>We should not make assumptions on how the user initializes a class that is not under our direct control. If the user fails to initialize the class, we should notice and throw an exception;</li>
<li>Not all objects that need to read parameters from a parameter file may be available when we construct the Parameters; this is often the case for complex programs, with multiple physics, or where we reuse existing code in some external classes. We simulate this by keeping some "complex" objects, like ParsedFunction objects, inside the <code>DistributedLagrangeProblem</code> instead of inside the <code>Parameters</code>.</li>
</ul>
<p>Here we assume that upon construction, the classes that build up our problem are not usable yet. Parsing the parameter file is what ensures we have all ingredients to build up our classes, and we design them so that if parsing fails, or is not executed, the run is aborted.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line"><span class="keyword">class </span>DistributedLagrangeProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div></div><!-- fragment --><p>The <code>Parameters</code> class is derived from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>. This allows us to use the <a class="el" href="classParameterAcceptor.html#af2a534c7f1ea5bfa165fa8a469744a5d">ParameterAcceptor::add_parameter()</a> method in its constructor.</p>
<p>The members of this function are all non-const, but the <code>DistributedLagrangeProblem</code> class takes a const reference to a <code>Parameters</code> object: this ensures that parameters are not modified from within the <code>DistributedLagrangeProblem</code> class.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Parameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Parameters();</div></div><!-- fragment --><p>The parameters now described can all be set externally using a parameter file: if no parameter file is present when running the executable, the program will create a "parameters.prm" file with the default values defined here, and then abort to give the user a chance to modify the parameters.prm file.</p>
<p>Initial refinement for the embedding grid, corresponding to the domain \(\Omega\).</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement = 4;</div></div><!-- fragment --><p>The interaction between the embedded grid \(\Omega\) and the embedding grid \(\Gamma\) is handled through the computation of \(C\), which involves all cells of \(\Omega\) overlapping with parts of \(\Gamma\): a higher refinement of such cells might improve quality of our computations. For this reason we define <code>delta_refinement</code>: if it is greater than zero, then we mark each cell of the space grid that contains a vertex of the embedded grid and its neighbors, execute the refinement, and repeat this process <code>delta_refinement</code> times.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> delta_refinement = 3;</div></div><!-- fragment --><p>Starting refinement of the embedded grid, corresponding to the domain \(\Gamma\).</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_embedded_refinement = 8;</div></div><!-- fragment --><p>The list of boundary ids where we impose homogeneous Dirichlet boundary conditions. On the remaining boundary ids (if any), we impose homogeneous Neumann boundary conditions. As a default problem we have zero Dirichlet boundary conditions on \(\partial \Omega\)</p>
<div class="fragment"><div class="line">std::list&lt;types::boundary_id&gt; homogeneous_dirichlet_ids{0, 1, 2, 3};</div></div><!-- fragment --><p><a class="el" href="classFiniteElement.html">FiniteElement</a> degree of the embedding space: \(V_h(\Omega)\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedding_space_finite_element_degree = 1;</div></div><!-- fragment --><p><a class="el" href="classFiniteElement.html">FiniteElement</a> degree of the embedded space: \(Q_h(\Gamma)\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedded_space_finite_element_degree = 1;</div></div><!-- fragment --><p><a class="el" href="classFiniteElement.html">FiniteElement</a> degree of the space used to describe the deformation of the embedded domain</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedded_configuration_finite_element_degree = 1;</div></div><!-- fragment --><p>Order of the quadrature formula used to integrate the coupling</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> coupling_quadrature_order = 3;</div></div><!-- fragment --><p>If set to true, then the embedded configuration function is interpreted as a displacement function</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> use_displacement = <span class="keyword">false</span>;</div></div><!-- fragment --><p>Level of verbosity to use in the output</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> verbosity_level = 10;</div></div><!-- fragment --><p>A flag to keep track if we were initialized or not</p>
<div class="fragment"><div class="line">  <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">};</div><div class="line"></div><div class="line">DistributedLagrangeProblem(<span class="keyword">const</span> Parameters &amp;parameters);</div></div><!-- fragment --><p>Entry point for the DistributedLagrangeProblem</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div></div><!-- fragment --><p>Object containing the actual parameters</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Parameters &amp;parameters;</div></div><!-- fragment --><p>The following functions are similar to all other tutorial programs, with the exception that we now need to set up things for two different families of objects, namely the ones related to the <em>embedding</em> grids, and the ones related to the <em>embedded</em> one.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_grids_and_dofs();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> setup_embedding_dofs();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> setup_embedded_dofs();</div></div><!-- fragment --><p>The only unconventional function we have here is the <code>setup_coupling()</code> method, used to generate the sparsity patter for the coupling matrix \(C\).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_coupling();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> output_results();</div></div><!-- fragment --><p>first we gather all the objects related to the embedding space geometry</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;Triangulation&lt;spacedim&gt;&gt; space_grid;</div><div class="line">std::unique_ptr&lt;GridTools::Cache&lt;spacedim, spacedim&gt;&gt;</div><div class="line">                                         space_grid_tools_cache;</div><div class="line">std::unique_ptr&lt;FiniteElement&lt;spacedim&gt;&gt; space_fe;</div><div class="line">std::unique_ptr&lt;DoFHandler&lt;spacedim&gt;&gt;    space_dh;</div></div><!-- fragment --><p>Then the ones related to the embedded grid, with the <a class="el" href="classDoFHandler.html">DoFHandler</a> associated to the Lagrange multiplier <code>lambda</code></p>
<div class="fragment"><div class="line">std::unique_ptr&lt;Triangulation&lt;dim, spacedim&gt;&gt; embedded_grid;</div><div class="line">std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; embedded_fe;</div><div class="line">std::unique_ptr&lt;DoFHandler&lt;dim, spacedim&gt;&gt;    embedded_dh;</div></div><!-- fragment --><p>And finally, everything that is needed to <em>deform</em> the embedded triangulation</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; embedded_configuration_fe;</div><div class="line">std::unique_ptr&lt;DoFHandler&lt;dim, spacedim&gt;&gt;    embedded_configuration_dh;</div><div class="line">Vector&lt;double&gt;                                embedded_configuration;</div></div><!-- fragment --><p>The <a class="el" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy</a> class is a "transparent" wrapper derived from both <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> and the type passed as its template parameter. At construction, the arguments are split into two parts: the first argument is an std::string, forwarded to the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class, and containing the name of the section that should be used for this class, while all the remaining arguments are forwarded to the constructor of the templated type, in this case, to the <a class="el" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction</a> constructor.</p>
<p>This class allows you to use existing classes in conjunction with the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> registration mechanism, provided that those classes have the members <code>declare_parameters()</code> and <code>parse_parameters()</code>.</p>
<p>This is the case here, making it fairly easy to exploit the <a class="el" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction</a> class: instead of requiring users to create new <a class="el" href="classFunction.html">Function</a> objects in their code for the RHS, boundary functions, etc., (like it is done in most of the other tutorials), here we allow the user to use deal.II interface to muParser (<a href="http://muparser.beltoforion.de">http://muparser.beltoforion.de</a>), where the specification of the function is not done at compile time, but at run time, using a string that is parsed into an actual <a class="el" href="classFunction.html">Function</a> object.</p>
<p>In this case, the <code>embedded_configuration_function</code> is a vector valued <a class="el" href="classFunction.html">Function</a> that can be interpreted as either a <em>deformation</em> or a displacement* according to the boolean value of <code>parameters.use_displacement</code>. The number of components is specified later on in the construction.</p>
<div class="fragment"><div class="line"><a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">  embedded_configuration_function;</div><div class="line"></div><div class="line">std::unique_ptr&lt;Mapping&lt;dim, spacedim&gt;&gt; embedded_mapping;</div></div><!-- fragment --><p>We do the same thing to specify the value of the function \(g\), which is what we want our solution to be in the embedded space. In this case the <a class="el" href="classFunction.html">Function</a> is a scalar one.</p>
<div class="fragment"><div class="line"><a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">  embedded_value_function;</div></div><!-- fragment --><p>Similarly to what we have done with the <a class="el" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction</a> class, we repeat the same for the <a class="el" href="classReductionControl.html">ReductionControl</a> class, allowing us to specify all possible stopping criteria for the Schur complement iterative solver we'll use later on.</p>
<div class="fragment"><div class="line"><a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;ReductionControl&gt;</a> schur_solver_control;</div></div><!-- fragment --><p>Next we gather all <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>, and <a class="el" href="classVector.html">Vector</a> objects we'll need</p>
<div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a> stiffness_sparsity;</div><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a> coupling_sparsity;</div><div class="line"></div><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> stiffness_matrix;</div><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> coupling_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">Vector&lt;double&gt; solution;</div><div class="line">Vector&lt;double&gt; rhs;</div><div class="line"></div><div class="line">Vector&lt;double&gt; lambda;</div><div class="line">Vector&lt;double&gt; embedded_rhs;</div><div class="line">Vector&lt;double&gt; embedded_value;</div></div><!-- fragment --><p>The <a class="el" href="classTimerOutput.html">TimerOutput</a> class is used to provide some statistics on the performance of our program.</p>
<div class="fragment"><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> monitor;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="DistributedLagrangeProblemParameters"></a> </p><h3>DistributedLagrangeProblem::Parameters</h3>
<p>At construction time, we initialize also the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class, with the section name we want our problem to use when parsing the parameter file.</p>
<p>Parameter files can be organized into section/subsection/etc.: this has the advantage that defined objects share parameters when sharing the same section/subsection/etc. <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> allows to specify the section name using Unix conventions on paths. If the section name starts with a slash ("/"), then the section is interpreted as an <em>absolute path</em>, <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> enters a subsection for each directory in the path, using the last name it encountered as the landing subsection for the current class.</p>
<p>For example, if you construct your class using <code><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>("/first/second/third/My Class")</code>, the parameters will be organized as follows:</p>
<div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line"><span class="preprocessor"># Example parameter file</span></div><div class="line">subsection <a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a></div><div class="line">  subsection <a class="code" href="grid__out_8cc.html#a2cc229a4f1ffc75e83ed269d5f725729">second</a></div><div class="line">    subsection third</div><div class="line">      subsection My Class</div><div class="line">       ... # all the parameters</div><div class="line">      end</div><div class="line">    end</div><div class="line">  end</div><div class="line">end</div></div><!-- fragment --> </div><p>Internally, the <em>current path</em> stored in <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> is now considered to be "/first/second/third/", i.e. when you specify an absolute path, <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> <em>changes</em> the current section to the current path, i.e. to the path of the section name until the <em>last</em> "/".</p>
<p>You can now construct another class derived from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> using a relative path (e.g., <code><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>("My Other Class")</code>) instead of the absolute one (e.g. <code><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>("/first/second/third/My Other
 Class")</code>), obtaining: </p><div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line"><span class="preprocessor"># Example parameter file</span></div><div class="line">subsection <a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a></div><div class="line">  subsection <a class="code" href="grid__out_8cc.html#a2cc229a4f1ffc75e83ed269d5f725729">second</a></div><div class="line">    subsection third</div><div class="line">      subsection My Class</div><div class="line">        ... # all the parameters</div><div class="line">      end</div><div class="line">      subsection My Other Class</div><div class="line">        ... # all the parameters of MyOtherClass</div><div class="line">      end</div><div class="line">    end</div><div class="line">  end</div><div class="line">end</div></div><!-- fragment --> </div><p>If the section name <em>ends</em> with a slash then subsequent classes will interpret this as a full path: for example, similar to the one above, if we have two classes, one initialized with <code><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>("/first/second/third/My Class/")</code> and the other with <code><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>("My Other Class")</code>, then the resulting parameter file will look like:</p>
<div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line"><span class="preprocessor"># Example parameter file</span></div><div class="line">subsection <a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a></div><div class="line">  subsection <a class="code" href="grid__out_8cc.html#a2cc229a4f1ffc75e83ed269d5f725729">second</a></div><div class="line">    subsection third</div><div class="line">      subsection My Class</div><div class="line">        ... # all the parameters of MyClass</div><div class="line">        ... # notice My Class subsection does not end here</div><div class="line">        subsection My Other Class</div><div class="line">          ... # all the parameters of MyOtherClass</div><div class="line">        end # of subsection My Other Class</div><div class="line">      end # of subsection My Class</div><div class="line">    end</div><div class="line">  end</div><div class="line">end</div></div><!-- fragment --> </div><p>We are going to exploit this, by making our <code>Parameters</code> the <em>parent</em> of all subsequently constructed classes. Since most of the other classes are members of <code>DistributedLagrangeProblem</code> this allows, for example, to construct two <code>DistributedLagrangeProblem</code> for two different dimensions, without having conflicts in the parameters for the two problems.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">DistributedLagrangeProblem&lt;dim, spacedim&gt;::Parameters::Parameters()</div><div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Distributed Lagrange&lt;&quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html">Utilities</a>::<a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">int_to_string</a>(dim) + <span class="stringliteral">&quot;,&quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html">Utilities</a>::<a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">int_to_string</a>(spacedim) + <span class="stringliteral">&quot;&gt;/&quot;</span>)</div><div class="line">{</div></div><!-- fragment --><p>The <a class="el" href="classParameterAcceptor.html#af2a534c7f1ea5bfa165fa8a469744a5d">ParameterAcceptor::add_parameter()</a> function does a few things:</p>
<ul>
<li>enters the subsection specified at construction time to <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a></li>
<li>calls the ParameterAcceptor::prm.add_parameter() function</li>
<li>calls any signal you may have attached to <a class="el" href="classParameterAcceptor.html#a1704a7098e692599c254a14c15ab05d2">ParameterAcceptor::declare_parameters_call_back</a></li>
<li>leaves the subsection</li>
</ul>
<p>In turn, ParameterAcceptor::prm.add_parameter</p>
<ul>
<li>declares an entry in the parameter handler for the given variable;</li>
<li>takes the current value of the variable</li>
<li>transforms it to a string, used as the default value for the parameter file</li>
<li>attaches an <em>action</em> to <a class="el" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a> that monitors when a file is parsed, or when an entry is set, and when this happens, it updates the value of the variable passed to <code>add_parameter()</code> by setting it to whatever was specified in the input file (of course, after the input file has been parsed and the text representation converted to the type of the variable).</li>
</ul>
<div class="fragment"><div class="line">add_parameter(<span class="stringliteral">&quot;Initial embedding space refinement&quot;</span>, initial_refinement);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Initial embedded space refinement&quot;</span>,</div><div class="line">              initial_embedded_refinement);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Local refinements steps near embedded domain&quot;</span>,</div><div class="line">              delta_refinement);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Homogeneous Dirichlet boundary ids&quot;</span>,</div><div class="line">              homogeneous_dirichlet_ids);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Use displacement in embedded interface&quot;</span>, use_displacement);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Embedding space finite element degree&quot;</span>,</div><div class="line">              embedding_space_finite_element_degree);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Embedded space finite element degree&quot;</span>,</div><div class="line">              embedded_space_finite_element_degree);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Embedded configuration finite element degree&quot;</span>,</div><div class="line">              embedded_configuration_finite_element_degree);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Coupling quadrature order&quot;</span>, coupling_quadrature_order);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Verbosity level&quot;</span>, verbosity_level);</div></div><!-- fragment --><p>Once the parameter file has been parsed, then the parameters are good to go. Set the internal variable <code>initialized</code> to true.</p>
<div class="fragment"><div class="line">  parse_parameters_call_back.connect([&amp;]() -&gt; <span class="keywordtype">void</span> { initialized = <span class="keyword">true</span>; });</div><div class="line">}</div></div><!-- fragment --><p>The constructor is pretty standard, with the exception of the <code><a class="el" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy</a></code> objects, as explained earlier.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">DistributedLagrangeProblem&lt;dim, spacedim&gt;::DistributedLagrangeProblem(</div><div class="line">  <span class="keyword">const</span> Parameters &amp;parameters)</div><div class="line">  : parameters(parameters)</div><div class="line">  , embedded_configuration_function(<span class="stringliteral">&quot;Embedded configuration&quot;</span>, spacedim)</div><div class="line">  , embedded_value_function(<span class="stringliteral">&quot;Embedded value&quot;</span>)</div><div class="line">  , schur_solver_control(<span class="stringliteral">&quot;Schur solver control&quot;</span>)</div><div class="line">  , monitor(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::cpu_and_wall_times)</div><div class="line">{</div></div><!-- fragment --><p>Here is a way to set default values for a <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class that was constructed using <a class="el" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy</a>.</p>
<p>In this case, we set the default deformation of the embedded grid to be a circle with radius \(R\) and center \((Cx, Cy)\), we set the default value for the embedded_value_function to be the constant one, and specify some sensible values for the <a class="el" href="classSolverControl.html">SolverControl</a> object.</p>
<p>It is fundamental for \(\Gamma\) to be embedded: from the definition of \(C_{\alpha j}\) is clear that, if \(\Gamma \not\subseteq \Omega\), certain rows of the matrix \(C\) will be zero. This would be a problem, as the Schur complement method requires \(C\) to have full column rank.</p>
<div class="fragment"><div class="line">  embedded_configuration_function.declare_parameters_call_back.connect(</div><div class="line">    []() -&gt; <span class="keywordtype">void</span> {</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function constants&quot;</span>, <span class="stringliteral">&quot;R=.3, Cx=.4, Cy=.4&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>,</div><div class="line">                                 <span class="stringliteral">&quot;R*cos(2*pi*x)+Cx; R*sin(2*pi*x)+Cy&quot;</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">  embedded_value_function.declare_parameters_call_back.connect(</div><div class="line">    []() -&gt; <span class="keywordtype">void</span> { <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>); });</div><div class="line"></div><div class="line">  schur_solver_control.declare_parameters_call_back.connect([]() -&gt; <span class="keywordtype">void</span> {</div><div class="line">    <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Max steps&quot;</span>, <span class="stringliteral">&quot;1000&quot;</span>);</div><div class="line">    <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Reduction&quot;</span>, <span class="stringliteral">&quot;1.e-12&quot;</span>);</div><div class="line">    <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Tolerance&quot;</span>, <span class="stringliteral">&quot;1.e-12&quot;</span>);</div><div class="line">  });</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Setup"></a> </p><h3>Set up</h3>
<p>The function <code>DistributedLagrangeProblem::setup_grids_and_dofs()</code> is used to set up the finite element spaces. Notice how <code>std::make_unique</code> is used to create objects wrapped inside <code>std::unique_ptr</code> objects.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_grids_and_dofs()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Setup grids and dofs&quot;</span>);</div></div><!-- fragment --><p>Initializing \(\Omega\): constructing the <a class="el" href="classTriangulation.html">Triangulation</a> and wrapping it into a <code>std::unique_ptr</code> object</p>
<div class="fragment"><div class="line">space_grid = std::make_unique&lt;Triangulation&lt;spacedim&gt;&gt;();</div></div><!-- fragment --><p>Next, we actually create the triangulation using <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>. The last argument is set to true: this activates colorization (i.e., assigning different boundary indicators to different parts of the boundary), which we use to assign the Dirichlet and Neumann conditions.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(*space_grid, 0, 1, <span class="keyword">true</span>);</div></div><!-- fragment --><p>Once we constructed a <a class="el" href="classTriangulation.html">Triangulation</a>, we refine it globally according to the specifications in the parameter file, and construct a <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> with it.</p>
<div class="fragment"><div class="line">space_grid-&gt;refine_global(parameters.initial_refinement);</div><div class="line">space_grid_tools_cache =</div><div class="line">  std::make_unique&lt;GridTools::Cache&lt;spacedim, spacedim&gt;&gt;(*space_grid);</div></div><!-- fragment --><p>The same is done with the embedded grid. Since the embedded grid is deformed, we first need to setup the deformation mapping. We do so in the following few lines:</p>
<div class="fragment"><div class="line">embedded_grid = std::make_unique&lt;Triangulation&lt;dim, spacedim&gt;&gt;();</div><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(*embedded_grid);</div><div class="line">embedded_grid-&gt;refine_global(parameters.initial_embedded_refinement);</div><div class="line"></div><div class="line">embedded_configuration_fe = std::make_unique&lt;FESystem&lt;dim, spacedim&gt;&gt;(</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim, spacedim&gt;</a>(</div><div class="line">    parameters.embedded_configuration_finite_element_degree),</div><div class="line">  spacedim);</div><div class="line"></div><div class="line">embedded_configuration_dh =</div><div class="line">  std::make_unique&lt;DoFHandler&lt;dim, spacedim&gt;&gt;(*embedded_grid);</div><div class="line"></div><div class="line">embedded_configuration_dh-&gt;distribute_dofs(*embedded_configuration_fe);</div><div class="line">embedded_configuration.reinit(embedded_configuration_dh-&gt;n_dofs());</div></div><!-- fragment --><p>Once we have defined a finite dimensional space for the deformation, we interpolate the <code>embedded_configuration_function</code> defined in the parameter file :</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(*embedded_configuration_dh,</div><div class="line">                         embedded_configuration_function,</div><div class="line">                         embedded_configuration);</div></div><!-- fragment --><p>Now we can interpret it according to what the user has specified in the parameter file: as a displacement, in which case we construct a mapping that <em>displaces</em> the position of each support point of our configuration finite element space by the specified amount on the corresponding configuration vector, or as an absolution position.</p>
<p>In the first case, the class <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> offers its services, while in the second one, we'll use the class <a class="el" href="classMappingFEField.html">MappingFEField</a>. They are in fact very similar. <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> will only work for systems of <a class="el" href="classFE__Q.html">FE_Q</a> finite element spaces, where the displacement vector is stored in the first <code>spacedim</code> components of the <a class="el" href="classFESystem.html">FESystem</a>, and the degree given as a parameter at construction time, must match the degree of the first <code>spacedim</code> components.</p>
<p>The class <a class="el" href="classMappingFEField.html">MappingFEField</a> is slightly more general, in that it allows you to select arbitrary <a class="el" href="classFiniteElement.html">FiniteElement</a> types when constructing your approximation. Naturally some choices may (or may not) make sense, according to the type of <a class="el" href="classFiniteElement.html">FiniteElement</a> you choose. <a class="el" href="classMappingFEField.html">MappingFEField</a> implements the pure iso-parametric concept, and can be used, for example, to implement iso-geometric analysis codes in deal.II, by combining it with the <a class="el" href="classFE__Bernstein.html">FE_Bernstein</a> finite element class. In this example, we'll use the two interchangeably, by taking into account the fact that one configuration will be a <code>displacement</code>, while the other will be an absolute <code>deformation</code> field.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (parameters.use_displacement == <span class="keyword">true</span>)</div><div class="line">  embedded_mapping =</div><div class="line">    std::make_unique&lt;MappingQEulerian&lt;dim, Vector&lt;double&gt;, spacedim&gt;&gt;(</div><div class="line">      parameters.embedded_configuration_finite_element_degree,</div><div class="line">      *embedded_configuration_dh,</div><div class="line">      embedded_configuration);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  embedded_mapping =</div><div class="line">    std::make_unique&lt;MappingFEField&lt;dim, spacedim, Vector&lt;double&gt;&gt;&gt;(</div><div class="line">      *embedded_configuration_dh, embedded_configuration);</div><div class="line"></div><div class="line">setup_embedded_dofs();</div></div><!-- fragment --><p>In this tutorial program we not only refine \(\Omega\) globally, but also allow a local refinement depending on the position of \(\Gamma\), according to the value of <code>parameters.delta_refinement</code>, that we use to decide how many rounds of local refinement we should do on \(\Omega\), corresponding to the position of \(\Gamma\).</p>
<p>With the mapping in place, it is now possible to query what is the location of all support points associated with the <code>embedded_dh</code>, by calling the method <a class="el" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a>.</p>
<p>This method has two variants. One that does <em>not</em> take a <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a>, and one that takes a <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a>. If you use the second type, like we are doing in this case, the support points are computed through the specified mapping, which can manipulate them accordingly.</p>
<p>This is precisely what the <code>embedded_mapping</code> is there for.</p>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;spacedim&gt;&gt; support_points(embedded_dh-&gt;n_dofs());</div><div class="line"><span class="keywordflow">if</span> (parameters.delta_refinement != 0)</div><div class="line">  <a class="code" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a>(*embedded_mapping,</div><div class="line">                                       *embedded_dh,</div><div class="line">                                       support_points);</div></div><!-- fragment --><p>Once we have the support points of the embedded finite element space, we would like to identify what cells of the embedding space contain what support point, to get a chance at refining the embedding grid where it is necessary, i.e., where the embedded grid is. This can be done manually, by looping over each support point, and then calling the method <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell</a> for each cell of the embedding space, until we find one that returns points in the unit reference cell, or it can be done in a more intelligent way.</p>
<p>The <a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point</a> is a possible option that performs the above task in a cheaper way, by first identifying the closest vertex of the embedding <a class="el" href="classTriangulation.html">Triangulation</a> to the target point, and then by calling <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell</a> only for those cells that share the found vertex.</p>
<p>In fact, there are algorithms in the <a class="el" href="namespaceGridTools.html">GridTools</a> namespace that exploit a <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> object, and possibly a KDTree object to speed up these operations as much as possible.</p>
<p>The simplest way to exploit the maximum speed is by calling a specialized method, <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a>, that will store a lot of useful information and data structures during the first point search, and then reuse all of this for subsequent points.</p>
<p><a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a> returns a tuple where the first element is a vector of cells containing the input points, in this case support_points. For refinement, this is the only information we need, and this is exactly what happens now.</p>
<p>When we need to assemble a coupling matrix, however, we'll also need the reference location of each point to evaluate the basis functions of the embedding space. The other elements of the tuple returned by <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a> allow you to reconstruct, for each point, what cell contains it, and what is the location in the reference cell of the given point. Since this information is better grouped into cells, then this is what the algorithm returns: a tuple, containing a vector of all cells that have at least one point in them, together with a list of all reference points and their corresponding index in the original vector.</p>
<p>In the following loop, we will be ignoring all returned objects except the first, identifying all cells contain at least one support point of the embedded space. This allows for a simple adaptive refinement strategy: refining these cells and their neighbors.</p>
<p>Notice that we need to do some sanity checks, in the sense that we want to have an embedding grid which is well refined around the embedded grid, but where two consecutive support points lie either in the same cell, or in neighbor embedding cells.</p>
<p>This is only possible if we ensure that the smallest cell size of the embedding grid is nonetheless bigger than the largest cell size of the embedded grid. Since users can modify both levels of refinements, as well as the amount of local refinement they want around the embedded grid, we make sure that the resulting meshes satisfy our requirements, and if this is not the case, we bail out with an exception.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; parameters.delta_refinement; ++i)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> point_locations =</div><div class="line">      <a class="code" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a>(*space_grid_tools_cache,</div><div class="line">                                         support_points);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cells = std::get&lt;0&gt;(point_locations);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : cells)</div><div class="line">      {</div><div class="line">        cell-&gt;set_refine_flag();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">          <span class="keywordflow">if</span> (!cell-&gt;at_boundary(face_no))</div><div class="line">            cell-&gt;neighbor(face_no)-&gt;set_refine_flag();</div><div class="line">      }</div><div class="line">    space_grid-&gt;execute_coarsening_and_refinement();</div><div class="line">  }</div></div><!-- fragment --><p>In order to construct a well posed coupling interpolation operator \(C\), there are some constraints on the relative dimension of the grids between the embedding and the embedded domains. The coupling operator \(C\) and the spaces \(V\) and \(Q\) have to satisfy an inf-sup condition in order for the problem to have a solution. It turns out that the non-matching \(L^2\) projection satisfies such inf-sup, provided that the spaces \(V\) and \(Q\) are compatible between each other (for example, provided that they are chosen to be the ones described in the introduction).</p>
<p>However, the <em>discrete</em> inf-sup condition must also hold. No complications arise here, but it turns out that the discrete inf-sup constant deteriorates when the non-matching grids have local diameters that are too far away from each other. In particular, it turns out that if you choose an embedding grid which is <em>finer</em> with respect to the embedded grid, the inf-sup constant deteriorates much more than if you let the embedded grid be finer.</p>
<p>In order to avoid issues, in this tutorial we will throw an exception if the parameters chosen by the user are such that the maximal diameter of the embedded grid is greater than the minimal diameter of the embedding grid.</p>
<p>This choice guarantees that almost every cell of the embedded grid spans no more than two cells of the embedding grid, with some rare exceptions, that are negligible in terms of the resulting inf-sup.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> embedded_space_maximal_diameter =</div><div class="line">  <a class="code" href="namespaceGridTools.html#ae8409fa9cb46a0070abc4da7de0f47f2">GridTools::maximal_cell_diameter</a>(*embedded_grid, *embedded_mapping);</div><div class="line"><span class="keywordtype">double</span> embedding_space_minimal_diameter =</div><div class="line">  <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(*space_grid);</div><div class="line"></div><div class="line"><a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedding minimal diameter: &quot;</span></div><div class="line">        &lt;&lt; embedding_space_minimal_diameter</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;, embedded maximal diameter: &quot;</span></div><div class="line">        &lt;&lt; embedded_space_maximal_diameter &lt;&lt; <span class="stringliteral">&quot;, ratio: &quot;</span></div><div class="line">        &lt;&lt; embedded_space_maximal_diameter /</div><div class="line">             embedding_space_minimal_diameter</div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(embedded_space_maximal_diameter &lt;</div><div class="line">              embedding_space_minimal_diameter,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">              <span class="stringliteral">&quot;The embedding grid is too refined (or the embedded grid &quot;</span></div><div class="line">              <span class="stringliteral">&quot;is too coarse). Adjust the parameters so that the minimal &quot;</span></div><div class="line">              <span class="stringliteral">&quot;grid size of the embedding grid is larger &quot;</span></div><div class="line">              <span class="stringliteral">&quot;than the maximal grid size of the embedded grid.&quot;</span>));</div></div><!-- fragment --><p>\(\Omega\) has been refined and we can now set up its DoFs</p>
<div class="fragment"><div class="line">  setup_embedding_dofs();</div><div class="line">}</div></div><!-- fragment --><p>We now set up the DoFs of \(\Omega\) and \(\Gamma\): since they are fundamentally independent (except for the fact that \(\Omega\)'s mesh is more refined "around" \(\Gamma\)) the procedure is standard.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_embedding_dofs()</div><div class="line">{</div><div class="line">  space_dh = std::make_unique&lt;DoFHandler&lt;spacedim&gt;&gt;(*space_grid);</div><div class="line">  space_fe = std::make_unique&lt;FE_Q&lt;spacedim&gt;&gt;(</div><div class="line">    parameters.embedding_space_finite_element_degree);</div><div class="line">  space_dh-&gt;distribute_dofs(*space_fe);</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(*space_dh, constraints);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keywordtype">id</span> : parameters.homogeneous_dirichlet_ids)</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        *space_dh, <span class="keywordtype">id</span>, <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;spacedim&gt;</a>(), constraints);</div><div class="line">    }</div><div class="line">  constraints.close();</div></div><!-- fragment --><p>By definition the stiffness matrix involves only \(\Omega\)'s DoFs</p>
<div class="fragment"><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(space_dh-&gt;n_dofs(), space_dh-&gt;n_dofs());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(*space_dh, dsp, constraints);</div><div class="line">  stiffness_sparsity.copy_from(dsp);</div><div class="line">  stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(stiffness_sparsity);</div><div class="line">  solution.reinit(space_dh-&gt;n_dofs());</div><div class="line">  rhs.reinit(space_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedding dofs: &quot;</span> &lt;&lt; space_dh-&gt;n_dofs() &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_embedded_dofs()</div><div class="line">{</div><div class="line">  embedded_dh = std::make_unique&lt;DoFHandler&lt;dim, spacedim&gt;&gt;(*embedded_grid);</div><div class="line">  embedded_fe = std::make_unique&lt;FE_Q&lt;dim, spacedim&gt;&gt;(</div><div class="line">    parameters.embedded_space_finite_element_degree);</div><div class="line">  embedded_dh-&gt;distribute_dofs(*embedded_fe);</div></div><!-- fragment --><p>By definition the rhs of the system we're solving involves only a zero vector and \(G\), which is computed using only \(\Gamma\)'s DoFs</p>
<div class="fragment"><div class="line">  lambda.reinit(embedded_dh-&gt;n_dofs());</div><div class="line">  embedded_rhs.reinit(embedded_dh-&gt;n_dofs());</div><div class="line">  embedded_value.reinit(embedded_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedded dofs: &quot;</span> &lt;&lt; embedded_dh-&gt;n_dofs() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Creating the coupling sparsity pattern is a complex operation, but it can be easily done using the <a class="el" href="namespaceNonMatching.html#a8829bfa8e55c21b8eeaafd086c53680d">NonMatching::create_coupling_sparsity_pattern</a>, which requires the two <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, the quadrature points for the coupling, a <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> (which then needs to be copied into the sparsity one, as usual), the component mask for the embedding and embedded <a class="el" href="classTriangulation.html">Triangulation</a> (which we leave empty) and the mappings for both the embedding and the embedded <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_coupling()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Setup coupling&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quad(parameters.coupling_quadrature_order);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(space_dh-&gt;n_dofs(), embedded_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">  <a class="code" href="namespaceNonMatching.html#a8829bfa8e55c21b8eeaafd086c53680d">NonMatching::create_coupling_sparsity_pattern</a>(*space_grid_tools_cache,</div><div class="line">                                                *space_dh,</div><div class="line">                                                *embedded_dh,</div><div class="line">                                                quad,</div><div class="line">                                                dsp,</div><div class="line">                                                <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a>(),</div><div class="line">                                                <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                                <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                                *embedded_mapping);</div><div class="line">  coupling_sparsity.copy_from(dsp);</div><div class="line">  coupling_matrix.reinit(coupling_sparsity);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assembly"></a> </p><h3>Assembly</h3>
<p>The following function creates the matrices: as noted before computing the stiffness matrix and the rhs is a standard procedure.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Assemble system&quot;</span>);</div></div><!-- fragment --><p>Embedding stiffness matrix \(K\), and the right hand side \(G\).</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixTools::create_laplace_matrix</a>(</div><div class="line">    *space_dh,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;spacedim&gt;</a>(2 * space_fe-&gt;degree + 1),</div><div class="line">    stiffness_matrix,</div><div class="line">    static_cast&lt;<span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;spacedim&gt;</a> *&gt;(<span class="keyword">nullptr</span>),</div><div class="line">    constraints);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(*embedded_mapping,</div><div class="line">                                      *embedded_dh,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(2 * embedded_fe-&gt;degree +</div><div class="line">                                                  1),</div><div class="line">                                      embedded_value_function,</div><div class="line">                                      embedded_rhs);</div><div class="line">}</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Assemble coupling system&quot;</span>);</div></div><!-- fragment --><p>To compute the coupling matrix we use the <a class="el" href="namespaceNonMatching.html#ac3821491559b8a76af0be66736fe4c6f">NonMatching::create_coupling_mass_matrix</a> tool, which works similarly to <a class="el" href="namespaceNonMatching.html#a8829bfa8e55c21b8eeaafd086c53680d">NonMatching::create_coupling_sparsity_pattern</a>.</p>
<div class="fragment"><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quad(parameters.coupling_quadrature_order);</div><div class="line">    <a class="code" href="namespaceNonMatching.html#ac3821491559b8a76af0be66736fe4c6f">NonMatching::create_coupling_mass_matrix</a>(*space_grid_tools_cache,</div><div class="line">                                             *space_dh,</div><div class="line">                                             *embedded_dh,</div><div class="line">                                             quad,</div><div class="line">                                             coupling_matrix,</div><div class="line">                                             <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a>(),</div><div class="line">                                             <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                             <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                             *embedded_mapping);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(*embedded_mapping,</div><div class="line">                             *embedded_dh,</div><div class="line">                             embedded_value_function,</div><div class="line">                             embedded_value);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solve"></a> </p><h3>Solve</h3>
<p>All parts have been assembled: we solve the system using the Schur complement method</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Solve system&quot;</span>);</div></div><!-- fragment --><p>Start by creating the inverse stiffness matrix</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> K_inv_umfpack;</div><div class="line">K_inv_umfpack.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(stiffness_matrix);</div></div><!-- fragment --><p>Initializing the operators, as described in the introduction</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> K  = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(stiffness_matrix);</div><div class="line"><span class="keyword">auto</span> Ct = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(coupling_matrix);</div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>  = <a class="code" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a>(Ct);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> K_inv = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K, K_inv_umfpack);</div></div><!-- fragment --><p>Using the Schur complement method</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span>                     S = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a> * K_inv * Ct;</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver_cg(schur_solver_control);</div><div class="line">  <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S, solver_cg, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  lambda = S_inv * embedded_rhs;</div><div class="line"></div><div class="line">  solution = K_inv * Ct * lambda;</div><div class="line"></div><div class="line">  constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p>The following function simply generates standard result output on two separate files, one for each mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::output_results()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Output results&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;</a> embedding_out;</div><div class="line"></div><div class="line">  std::ofstream embedding_out_file(<span class="stringliteral">&quot;embedding.vtu&quot;</span>);</div><div class="line"></div><div class="line">  embedding_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(*space_dh);</div><div class="line">  embedding_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  embedding_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(</div><div class="line">    parameters.embedding_space_finite_element_degree);</div><div class="line">  embedding_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(embedding_out_file);</div></div><!-- fragment --><p>The only difference between the two output routines is that in the second case, we want to output the data on the current configuration, and not on the reference one. This is possible by passing the actual embedded_mapping to the <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches</a> function. The mapping will take care of outputting the result on the actual deformed configuration.</p>
<div class="fragment"><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;</a> embedded_out;</div><div class="line"></div><div class="line">  std::ofstream embedded_out_file(<span class="stringliteral">&quot;embedded.vtu&quot;</span>);</div><div class="line"></div><div class="line">  embedded_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(*embedded_dh);</div><div class="line">  embedded_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(lambda, <span class="stringliteral">&quot;lambda&quot;</span>);</div><div class="line">  embedded_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(embedded_value, <span class="stringliteral">&quot;g&quot;</span>);</div><div class="line">  embedded_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(*embedded_mapping,</div><div class="line">                             parameters.embedded_space_finite_element_degree);</div><div class="line">  embedded_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(embedded_out_file);</div><div class="line">}</div></div><!-- fragment --><p>Similar to all other tutorial programs, the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function simply calls all other methods in the correct order. Nothing special to note, except that we check if parsing was done before we actually attempt to run our program.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">DistributedLagrangeProblem&lt;dim, spacedim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(parameters.initialized, <a class="code" href="group__Exceptions.html#ga426dec8d8185f1410e09a795e0b36e86">ExcNotInitialized</a>());</div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(parameters.verbosity_level);</div><div class="line"></div><div class="line">    setup_grids_and_dofs();</div><div class="line">    setup_coupling();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step60</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step60;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 1, spacedim = 2;</div></div><!-- fragment --><p>Differently to what happens in other tutorial programs, here we use <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> style of initialization, i.e., all objects are first constructed, and then a single call to the static method <a class="el" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a> is issued to fill all parameters of the classes that are derived from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>.</p>
<p>We check if the user has specified a parameter file name to use when the program was launched. If so, try to read that parameter file, otherwise, try to read the file "parameters.prm".</p>
<p>If the parameter file that was specified (implicitly or explicitly) does not exist, <a class="el" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a> will create one for you, and exit the program.</p>
<div class="fragment"><div class="line">      DistributedLagrangeProblem&lt;dim, spacedim&gt;::Parameters parameters;</div><div class="line">      DistributedLagrangeProblem&lt;dim, spacedim&gt;             problem(parameters);</div><div class="line"></div><div class="line">      std::string parameter_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        parameter_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        parameter_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(parameter_file, <span class="stringliteral">&quot;used_parameters.prm&quot;</span>);</div><div class="line">      problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The directory in which this program is run does not contain a parameter file by default. On the other hand, this program wants to read its parameters from a file called parameters.prm &ndash; and so, when you execute it the first time, you will get an exception that no such file can be found:</p>
<div class="fragment"><div class="line">----------------------------------------------------</div><div class="line">Exception on processing:</div><div class="line"></div><div class="line">--------------------------------------------------------</div><div class="line">An error occurred in line &lt;74&gt; of file &lt;../source/base/parameter_acceptor.cc&gt; in <span class="keyword">function</span></div><div class="line">    <span class="keyword">static</span> void ::ParameterAcceptor::initialize(<span class="keyword">const</span> std::string &amp;, <span class="keyword">const</span> std::string &amp;, <span class="keyword">const</span> <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a>, ::<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;)</div><div class="line">The violated condition was:</div><div class="line">    <span class="keyword">false</span></div><div class="line">Additional information:</div><div class="line">    You specified &lt;parameters.prm&gt; as input parameter file, but it does not exist. We created it <span class="keywordflow">for</span> you.</div><div class="line">--------------------------------------------------------</div><div class="line"></div><div class="line">Aborting!</div><div class="line">----------------------------------------------------</div></div><!-- fragment --><p>However, as the error message already states, the code that triggers the exception will also generate a parameters.prm file that simply contains the default values for all parameters this program cares about. By inspection of the parameter file, we see the following:</p>
<div class="fragment"><div class="line"><span class="preprocessor"># Listing of Parameters</span></div><div class="line"><span class="preprocessor"># ---------------------</span></div><div class="line">subsection Distributed Lagrange&lt;1,2&gt;</div><div class="line">  <span class="keyword">set</span> <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> quadrature order                    = 3</div><div class="line">  <span class="keyword">set</span> Embedded configuration finite element degree = 1</div><div class="line">  <span class="keyword">set</span> Embedded space finite element degree         = 1</div><div class="line">  <span class="keyword">set</span> Embedding space finite element degree        = 1</div><div class="line">  <span class="keyword">set</span> Homogeneous Dirichlet boundary ids           = 0, 1, 2, 3</div><div class="line">  <span class="keyword">set</span> Initial embedded space refinement            = 7</div><div class="line">  <span class="keyword">set</span> Initial embedding space refinement           = 4</div><div class="line">  <span class="keyword">set</span> Local refinements steps near embedded domain = 3</div><div class="line">  <span class="keyword">set</span> Use displacement in embedded <span class="keyword">interface       </span>= false</div><div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Verbosity level                              = 10</div><div class="line"></div><div class="line"></div><div class="line">  subsection Embedded configuration</div><div class="line"><span class="preprocessor">    # Sometimes it is convenient to use symbolic constants in the expression</span></div><div class="line"><span class="preprocessor">    # that describes the function, rather than having to use its numeric value</span></div><div class="line"><span class="preprocessor">    # everywhere the constant appears. These values can be defined using this</span></div><div class="line"><span class="preprocessor">    # parameter, in the form `var1=value1, var2=value2, ...&#39;.</span></div><div class="line"><span class="preprocessor">    #</span></div><div class="line"><span class="preprocessor">    # A typical example would be to set this runtime parameter to</span></div><div class="line"><span class="preprocessor">    # `pi=3.1415926536&#39; and then use `pi&#39; in the expression of the actual</span></div><div class="line"><span class="preprocessor">    # formula. (That said, for convenience this class actually defines both</span></div><div class="line"><span class="preprocessor">    # `pi&#39; and `Pi&#39; by default, but you get the idea.)</span></div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  = R=.3, Cx=.4, Cy=.4                 # <span class="keywordflow">default</span>:</div><div class="line"></div><div class="line"><span class="preprocessor">    # The formula that denotes the function you want to evaluate for</span></div><div class="line"><span class="preprocessor">    # particular values of the independent variables. This expression may</span></div><div class="line"><span class="preprocessor">    # contain any of the usual operations such as addition or multiplication,</span></div><div class="line"><span class="preprocessor">    # as well as all of the common functions such as `sin&#39; or `cos&#39;. In</span></div><div class="line"><span class="preprocessor">    # addition, it may contain expressions like `if(x&gt;0, 1, -1)&#39; where the</span></div><div class="line"><span class="preprocessor">    # expression evaluates to the second argument if the first argument is</span></div><div class="line"><span class="preprocessor">    # true, and to the third argument otherwise. For a full overview of</span></div><div class="line"><span class="preprocessor">    # possible expressions accepted see the documentation of the muparser</span></div><div class="line"><span class="preprocessor">    # library at http://muparser.beltoforion.de/.</span></div><div class="line"><span class="preprocessor">    #</span></div><div class="line"><span class="preprocessor">    # If the function you are describing represents a vector-valued function</span></div><div class="line"><span class="preprocessor">    # with multiple components, then separate the expressions for individual</span></div><div class="line"><span class="preprocessor">    # components by a semicolon.</span></div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = R*<a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(2*pi*x)+Cx; R*<a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(2*pi*x)+Cy # <span class="keywordflow">default</span>: 0</div><div class="line"></div><div class="line"><span class="preprocessor">    # The names of the variables as they will be used in the function,</span></div><div class="line"><span class="preprocessor">    # separated by commas. By default, the names of variables at which the</span></div><div class="line"><span class="preprocessor">    # function will be evaluated are `x&#39; (in 1d), `x,y&#39; (in 2d) or `x,y,z&#39; (in</span></div><div class="line"><span class="preprocessor">    # 3d) for spatial coordinates and `t&#39; for time. You can then use these</span></div><div class="line"><span class="preprocessor">    # variable names in your function expression and they will be replaced by</span></div><div class="line"><span class="preprocessor">    # the values of these variables at which the function is currently</span></div><div class="line"><span class="preprocessor">    # evaluated. However, you can also choose a different set of names for the</span></div><div class="line"><span class="preprocessor">    # independent variables at which to evaluate your function expression. For</span></div><div class="line"><span class="preprocessor">    # example, if you work in spherical coordinates, you may wish to set this</span></div><div class="line"><span class="preprocessor">    # input parameter to `r,phi,theta,t&#39; and then use these variable names in</span></div><div class="line"><span class="preprocessor">    # your function expression.</span></div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line"></div><div class="line">  subsection Embedded value</div><div class="line"><span class="preprocessor">    # Sometimes it is convenient to use symbolic constants in the expression</span></div><div class="line"><span class="preprocessor">    # that describes the function, rather than having to use its numeric value</span></div><div class="line"><span class="preprocessor">    # everywhere the constant appears. These values can be defined using this</span></div><div class="line"><span class="preprocessor">    # parameter, in the form `var1=value1, var2=value2, ...&#39;.</span></div><div class="line"><span class="preprocessor">    #</span></div><div class="line"><span class="preprocessor">    # A typical example would be to set this runtime parameter to</span></div><div class="line"><span class="preprocessor">    # `pi=3.1415926536&#39; and then use `pi&#39; in the expression of the actual</span></div><div class="line"><span class="preprocessor">    # formula. (That said, for convenience this class actually defines both</span></div><div class="line"><span class="preprocessor">    # `pi&#39; and `Pi&#39; by default, but you get the idea.)</span></div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line"></div><div class="line"><span class="preprocessor">    # The formula that denotes the function you want to evaluate for</span></div><div class="line"><span class="preprocessor">    # particular values of the independent variables. This expression may</span></div><div class="line"><span class="preprocessor">    # contain any of the usual operations such as addition or multiplication,</span></div><div class="line"><span class="preprocessor">    # as well as all of the common functions such as `sin&#39; or `cos&#39;. In</span></div><div class="line"><span class="preprocessor">    # addition, it may contain expressions like `if(x&gt;0, 1, -1)&#39; where the</span></div><div class="line"><span class="preprocessor">    # expression evaluates to the second argument if the first argument is</span></div><div class="line"><span class="preprocessor">    # true, and to the third argument otherwise. For a full overview of</span></div><div class="line"><span class="preprocessor">    # possible expressions accepted see the documentation of the muparser</span></div><div class="line"><span class="preprocessor">    # library at http://muparser.beltoforion.de/.</span></div><div class="line"><span class="preprocessor">    #</span></div><div class="line"><span class="preprocessor">    # If the function you are describing represents a vector-valued function</span></div><div class="line"><span class="preprocessor">    # with multiple components, then separate the expressions for individual</span></div><div class="line"><span class="preprocessor">    # components by a semicolon.</span></div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 1     # <span class="keywordflow">default</span>: 0</div><div class="line"></div><div class="line"><span class="preprocessor">    # The names of the variables as they will be used in the function,</span></div><div class="line"><span class="preprocessor">    # separated by commas. By default, the names of variables at which the</span></div><div class="line"><span class="preprocessor">    # function will be evaluated are `x&#39; (in 1d), `x,y&#39; (in 2d) or `x,y,z&#39; (in</span></div><div class="line"><span class="preprocessor">    # 3d) for spatial coordinates and `t&#39; for time. You can then use these</span></div><div class="line"><span class="preprocessor">    # variable names in your function expression and they will be replaced by</span></div><div class="line"><span class="preprocessor">    # the values of these variables at which the function is currently</span></div><div class="line"><span class="preprocessor">    # evaluated. However, you can also choose a different set of names for the</span></div><div class="line"><span class="preprocessor">    # independent variables at which to evaluate your function expression. For</span></div><div class="line"><span class="preprocessor">    # example, if you work in spherical coordinates, you may wish to set this</span></div><div class="line"><span class="preprocessor">    # input parameter to `r,phi,theta,t&#39; and then use these variable names in</span></div><div class="line"><span class="preprocessor">    # your function expression.</span></div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line"></div><div class="line">  subsection Schur solver control</div><div class="line">    <span class="keyword">set</span> Log frequency = 1</div><div class="line">    <span class="keyword">set</span> Log history   = <span class="keyword">false</span></div><div class="line">    <span class="keyword">set</span> Log result    = <span class="keyword">true</span></div><div class="line">    <span class="keyword">set</span> Max steps     = 1000   # <span class="keywordflow">default</span>: 100</div><div class="line">    <span class="keyword">set</span> Reduction     = 1.e-12 # <span class="keywordflow">default</span>: 1.e-2</div><div class="line">    <span class="keyword">set</span> Tolerance     = 1.e-12 # <span class="keywordflow">default</span>: 1.e-10</div><div class="line">  end</div><div class="line"></div><div class="line">end</div></div><!-- fragment --><p>If you now run the program, you will get a file called <code>used_parameters.prm</code>, containing a shorter version of the above parameters (without comments and documentation), documenting all parameters that were used to run your program: </p><div class="fragment"><div class="line"><span class="preprocessor"># Parameter file generated with</span></div><div class="line"><span class="preprocessor"># DEAL_II_PACKAGE_VERSION = 9.0.0</span></div><div class="line">subsection Distributed Lagrange&lt;1,2&gt;</div><div class="line">  <span class="keyword">set</span> <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> quadrature order                    = 3</div><div class="line">  <span class="keyword">set</span> Embedded configuration finite element degree = 1</div><div class="line">  <span class="keyword">set</span> Embedded space finite element degree         = 1</div><div class="line">  <span class="keyword">set</span> Embedding space finite element degree        = 1</div><div class="line">  <span class="keyword">set</span> Homogeneous Dirichlet boundary ids           = 0, 1, 2, 3</div><div class="line">  <span class="keyword">set</span> Initial embedded space refinement            = 7</div><div class="line">  <span class="keyword">set</span> Initial embedding space refinement           = 4</div><div class="line">  <span class="keyword">set</span> Local refinements steps near embedded domain = 3</div><div class="line">  <span class="keyword">set</span> Use displacement in embedded <span class="keyword">interface       </span>= false</div><div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Verbosity level                              = 10</div><div class="line">  subsection Embedded configuration</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  = R=.3, Cx=.4, Cy=.4</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = R*<a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(2*pi*x)+Cx; R*<a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(2*pi*x)+Cy</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line">  subsection Embedded value</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 1</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line">  subsection Schur solver control</div><div class="line">    <span class="keyword">set</span> Log frequency = 1</div><div class="line">    <span class="keyword">set</span> Log history   = <span class="keyword">false</span></div><div class="line">    <span class="keyword">set</span> Log result    = <span class="keyword">true</span></div><div class="line">    <span class="keyword">set</span> Max steps     = 1000</div><div class="line">    <span class="keyword">set</span> Reduction     = 1.e-12</div><div class="line">    <span class="keyword">set</span> Tolerance     = 1.e-12</div><div class="line">  end</div><div class="line">end</div></div><!-- fragment --><p>The rationale behind creating first <code>parameters.prm</code> file (the first time the program is run) and then a <code>used_parameters.prm</code> (every other times you run the program), is because you may want to leave most parameters to their default values, and only modify a handful of them.</p>
<p>For example, you could use the following (perfectly valid) parameter file with this tutorial program: </p><div class="fragment"><div class="line">subsection Distributed Lagrange&lt;1,2&gt;</div><div class="line">  <span class="keyword">set</span> Initial embedded space refinement            = 7</div><div class="line">  <span class="keyword">set</span> Initial embedding space refinement           = 4</div><div class="line">  <span class="keyword">set</span> Local refinements steps near embedded domain = 3</div><div class="line">  subsection Embedded configuration</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  = R=.3, Cx=.4, Cy=.4</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = R*<a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(2*pi*x)+Cx; R*<a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(2*pi*x)+Cy</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line">  subsection Embedded value</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 1</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line">end</div></div><!-- fragment --><p>and you would obtain exactly the same results as in test case 1 below.</p>
<p><a class="anchor" id="Testcase1"></a></p><h3>Test case 1: </h3>
<p>For the default problem the value of \(u\) on \(\Gamma\) is set to the constant \(1\): this is like imposing a constant Dirichlet boundary condition on \(\Gamma\), seen as boundary of the portion of \(\Omega\) inside \(\Gamma\). Similarly on \(\partial \Omega\) we have zero Dirichlet boundary conditions.</p>
<div class="twocolumn" style="width: 80%"> <div class="parent"> <div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.1_no_grid.png" width="500"/>
</div>
 </div> </div> <div class="parent"> <div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.1_grid.png" width="500"/>
</div>
 </div> </div> </div><p>The output of the program will look like the following:</p>
<div class="fragment"><div class="line">DEAL::Embedded dofs: 129</div><div class="line">DEAL::Embedding minimal <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">diameter</a>: 0.0110485, embedded maximal <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">diameter</a>: 0.00781250, ratio: 0.707107</div><div class="line">DEAL::Embedding dofs: 2429</div><div class="line">DEAL:cg::Starting value 0.166266</div><div class="line">DEAL:cg::Convergence step 108 value 7.65958e-13</div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total CPU time elapsed since start          |     0.586s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  CPU time  | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble coupling system        |         1 |     0.132s |        23% |</div><div class="line">| Assemble system                 |         1 |    0.0733s |        12% |</div><div class="line">| Output results                  |         1 |     0.087s |        15% |</div><div class="line">| Setup coupling                  |         1 |    0.0244s |       4.2% |</div><div class="line">| Setup grids and dofs            |         1 |    0.0907s |        15% |</div><div class="line">| Solve system                    |         1 |     0.178s |        30% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |     0.301s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble coupling system        |         1 |    0.0385s |        13% |</div><div class="line">| Assemble system                 |         1 |    0.0131s |       4.3% |</div><div class="line">| Output results                  |         1 |    0.0736s |        24% |</div><div class="line">| Setup coupling                  |         1 |    0.0234s |       7.7% |</div><div class="line">| Setup grids and dofs            |         1 |    0.0679s |        23% |</div><div class="line">| Solve system                    |         1 |    0.0832s |        28% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>You may notice that, in terms of CPU time, assembling the coupling system is twice as expensive as assembling the standard Poisson system, even though the matrix is smaller. This is due to the non-matching nature of the discretization. Whether this is acceptable or not, depends on the applications.</p>
<p>If the problem was set in a three-dimensional setting, and the immersed mesh was time dependent, it would be much more expensive to recreate the mesh at each step rather than use the technique we present here. Moreover, you may be able to create a very fast and optimized solver on a uniformly refined square or cubic grid, and embed the domain where you want to perform your computation using the technique presented here. This would require you to only have a surface representatio of your domain (a much cheaper and easier mesh to produce).</p>
<p>To play around a little bit, we are going to complicate a little the fictitious domain as well as the boundary conditions we impose on it.</p>
<p><a class="anchor" id="Testcase2and3"></a></p><h3>Test case 2 and 3: </h3>
<p>If we use the following parameter file : </p><div class="fragment"><div class="line">subsection Distributed Lagrange&lt;1,2&gt;</div><div class="line">  <span class="keyword">set</span> <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> quadrature order                    = 3</div><div class="line">  <span class="keyword">set</span> Embedded configuration finite element degree = 1</div><div class="line">  <span class="keyword">set</span> Embedded space finite element degree         = 1</div><div class="line">  <span class="keyword">set</span> Embedding space finite element degree        = 1</div><div class="line">  <span class="keyword">set</span> Homogeneous Dirichlet boundary ids           = 0,1,2,3</div><div class="line">  <span class="keyword">set</span> Initial embedded space refinement            = 8</div><div class="line">  <span class="keyword">set</span> Initial embedding space refinement           = 4</div><div class="line">  <span class="keyword">set</span> Local refinements steps near embedded domain = 4</div><div class="line">  <span class="keyword">set</span> Use displacement in embedded <span class="keyword">interface       </span>= false</div><div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Verbosity level                              = 10</div><div class="line">  subsection Embedded configuration</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  = R=.3, Cx=.5, Cy=.5, r=.1, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6b25dd8f005063d8d2b0a4bdb0d277f3">w</a>=12</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = (R+r*<a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6b25dd8f005063d8d2b0a4bdb0d277f3">w</a>*pi*x))*<a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(2*pi*x)+Cx; (R+r*<a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6b25dd8f005063d8d2b0a4bdb0d277f3">w</a>*pi*x))*<a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(2*pi*x)+Cy</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line">  subsection Embedded value</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = x-.5</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line">  subsection Schur solver control</div><div class="line">    <span class="keyword">set</span> Log frequency = 1</div><div class="line">    <span class="keyword">set</span> Log history   = <span class="keyword">false</span></div><div class="line">    <span class="keyword">set</span> Log result    = <span class="keyword">true</span></div><div class="line">    <span class="keyword">set</span> Max steps     = 100000</div><div class="line">    <span class="keyword">set</span> Reduction     = 1.e-12</div><div class="line">    <span class="keyword">set</span> Tolerance     = 1.e-12</div><div class="line">  end</div><div class="line">end</div></div><!-- fragment --><p>We get a "flowery" looking domain, where we impose a linear boundary condition \(g=x-.5\). This test shows that the method is actually quite accurate in recovering an exactly linear function from its boundary conditions, and even though the meshes are not aligned, we obtain a pretty good result.</p>
<p>Replacing \(x-.5\) with \(2(x-.5)^2-2(y-.5)^2\), i.e., modifying the parameter file such that we have </p><div class="fragment"><div class="line">...</div><div class="line">subsection Embedded value</div><div class="line">  <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line">  <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 2*(x-.5)^2-2*(y-.5)^2</div><div class="line">  <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">end</div></div><!-- fragment --><p> produces the saddle on the right.</p>
<div class="twocolumn" style="width: 80%"> <div class="parent"> <div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.3_grid.png" width="500"/>
</div>
 </div> </div> <div class="parent"> <div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.4_grid.png" width="500"/>
</div>
 </div> </div> </div><p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Runningwithspacedimequaltothree"></a></p><h4>Running with <code>spacedim</code> equal to three</h4>
<p>While the current tutorial program is written for <code>spacedim</code> equal to two, there are only minor changes you have to do in order for the program to run in different combinations of dimensions.</p>
<p>If you want to run with <code>spacedim</code> equal to three and <code>dim</code> equal to two, then you will almost certainly want to perform the following changes:</p>
<ul>
<li>use a different reference domain for the embedded grid, maybe reading it from a file. It is not possible to construct a smooth closed surface with one single parametrization of a square domain, therefore you'll most likely want to use a reference domain that is topologically equivalent to a the boundary of a sphere.</li>
<li>use a displacement instead of the deformation to map \(\Gamma_0\) into \(\Gamma\)</li>
</ul>
<p><a class="anchor" id="Moregeneraldomains"></a></p><h4>More general domains </h4>
<p>We have seen in other tutorials (for example in <a class="el" href="step_5.html">step-5</a> and <a class="el" href="step_54.html">step-54</a>) how to read grids from input files. A nice generalization for this tutorial program would be to allow the user to select a grid to read from the parameter file itself, instead of hardcoding the mesh type in the tutorial program itself.</p>
<p><a class="anchor" id="Preconditioner"></a></p><h4>Preconditioner</h4>
<p>At the moment, we have no preconditioner on the Schur complement. This is ok for two dimensional problems, where a few hundred iterations bring the residual down to the machine precision, but it's not going to work in three dimensions.</p>
<p>It is not obvious what a good preconditioner would be here. The physical problem we are solving with the Schur complement, is to associate to the Dirichlet data \(g\), the value of the Lagrange multiplier \(\lambda\). \(\lambda\) can be interpreted as the <em>jump</em> in the normal gradient that needs to be imposed on \(u\) across \(\Gamma\), in order to obtain the Dirichlet data \(g\).</p>
<p>So \(S\) is some sort of Neumann to Dirichlet map, and we would like to have a good approximation for the Dirichlet to Neumann map. A possibility would be to use a Boundary Element approximation of the problem on \(\Gamma\), and construct a rough approximation of the hyper-singular operator for the Poisson problem associated to \(\Gamma\), which is precisely a Dirichlet to Neumann map.</p>
<p><a class="anchor" id="ParallelCode"></a></p><h4>Parallel Code </h4>
<p>The simple code proposed here can serve as a starting point for more complex problems which, to be solved, need to be run on parallel code, possibly using distributed meshes (see <a class="el" href="step_17.html">step-17</a>, <a class="el" href="step_40.html">step-40</a>, and the documentation for <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>).</p>
<p>When using non-matching grids in parallel a problem arises: to compute the matrix \(C\) a process needs information about both meshes on the same portion of real space but, when working with distributed meshes, this information may not be available, because the locally owned part of the \(\Omega\) triangulation stored on a given processor may not be physically co-located with the locally owned part of the \(\Gamma\) triangulation stored on the same processor.</p>
<p>Various strategies can be implemented to tackle this problem:</p>
<ul>
<li>distribute the two meshes so that this constraint is satisfied;</li>
<li>use communication for the parts of real space where the constraint is not satisfied;</li>
<li>use a distributed triangulation for the embedding space, and a shared triangulation for the emdedded configuration.</li>
</ul>
<p>The latter strategy is clearly the easiest to implement, as most of the functions used in this tutorial program will work unchanged also in the parallel case. Of course one could use the reversal strategy (that is, have a distributed embedded <a class="el" href="classTriangulation.html">Triangulation</a> and a shared embedding <a class="el" href="classTriangulation.html">Triangulation</a>).</p>
<p>However, this strategy is most likely going to be more expensive, since by definition the embedding grid is larger than the embedded grid, and it makes more sense to distribute the largest of the two grids, maintaining the smallest one shared among all processors.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2018 - 2020 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Luca Heltai, Giovanni Alzetta,</span></div><div class="line"><span class="comment"> * International School for Advanced Studies, Trieste, 2018</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools__cache_8h.html">deal.II/grid/grid_tools_cache.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2fe_2fe_8h.html">deal.II/fe/fe.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__eulerian_8h.html">deal.II/fe/mapping_q_eulerian.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__fe__field_8h.html">deal.II/fe/mapping_fe_field.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parsed__function_8h.html">deal.II/base/parsed_function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="coupling_8h.html">deal.II/non_matching/coupling.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step60</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line">  <span class="keyword">class </span>DistributedLagrangeProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">class </span>Parameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Parameters();</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement = 4;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> delta_refinement = 3;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_embedded_refinement = 8;</div><div class="line"></div><div class="line">      std::list&lt;types::boundary_id&gt; homogeneous_dirichlet_ids{0, 1, 2, 3};</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedding_space_finite_element_degree = 1;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedded_space_finite_element_degree = 1;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedded_configuration_finite_element_degree = 1;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> coupling_quadrature_order = 3;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> use_displacement = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> verbosity_level = 10;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">    };</div><div class="line"></div><div class="line">    DistributedLagrangeProblem(<span class="keyword">const</span> Parameters &amp;parameters);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Parameters &amp;parameters;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_grids_and_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_embedding_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_embedded_dofs();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_coupling();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    std::unique_ptr&lt;Triangulation&lt;spacedim&gt;&gt; space_grid;</div><div class="line">    std::unique_ptr&lt;GridTools::Cache&lt;spacedim, spacedim&gt;&gt;</div><div class="line">                                             space_grid_tools_cache;</div><div class="line">    std::unique_ptr&lt;FiniteElement&lt;spacedim&gt;&gt; space_fe;</div><div class="line">    std::unique_ptr&lt;DoFHandler&lt;spacedim&gt;&gt;    space_dh;</div><div class="line"></div><div class="line"></div><div class="line">    std::unique_ptr&lt;Triangulation&lt;dim, spacedim&gt;&gt; embedded_grid;</div><div class="line">    std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; embedded_fe;</div><div class="line">    std::unique_ptr&lt;DoFHandler&lt;dim, spacedim&gt;&gt;    embedded_dh;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; embedded_configuration_fe;</div><div class="line">    std::unique_ptr&lt;DoFHandler&lt;dim, spacedim&gt;&gt;    embedded_configuration_dh;</div><div class="line">    Vector&lt;double&gt;                                embedded_configuration;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">      embedded_configuration_function;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;Mapping&lt;dim, spacedim&gt;&gt; embedded_mapping;</div><div class="line"></div><div class="line">    <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">      embedded_value_function;</div><div class="line"></div><div class="line">    <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;ReductionControl&gt;</a> schur_solver_control;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a> stiffness_sparsity;</div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a> coupling_sparsity;</div><div class="line"></div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> stiffness_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> coupling_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; rhs;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; lambda;</div><div class="line">    Vector&lt;double&gt; embedded_rhs;</div><div class="line">    Vector&lt;double&gt; embedded_value;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> monitor;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  DistributedLagrangeProblem&lt;dim, spacedim&gt;::Parameters::Parameters()</div><div class="line">    : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Distributed Lagrange&lt;&quot;</span> +</div><div class="line">                        <a class="code" href="namespaceUtilities.html">Utilities</a>::<a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">int_to_string</a>(dim) + <span class="stringliteral">&quot;,&quot;</span> +</div><div class="line">                        <a class="code" href="namespaceUtilities.html">Utilities</a>::<a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">int_to_string</a>(spacedim) + <span class="stringliteral">&quot;&gt;/&quot;</span>)</div><div class="line">  {</div><div class="line">    add_parameter(<span class="stringliteral">&quot;Initial embedding space refinement&quot;</span>, initial_refinement);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Initial embedded space refinement&quot;</span>,</div><div class="line">                  initial_embedded_refinement);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Local refinements steps near embedded domain&quot;</span>,</div><div class="line">                  delta_refinement);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Homogeneous Dirichlet boundary ids&quot;</span>,</div><div class="line">                  homogeneous_dirichlet_ids);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Use displacement in embedded interface&quot;</span>, use_displacement);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Embedding space finite element degree&quot;</span>,</div><div class="line">                  embedding_space_finite_element_degree);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Embedded space finite element degree&quot;</span>,</div><div class="line">                  embedded_space_finite_element_degree);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Embedded configuration finite element degree&quot;</span>,</div><div class="line">                  embedded_configuration_finite_element_degree);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Coupling quadrature order&quot;</span>, coupling_quadrature_order);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Verbosity level&quot;</span>, verbosity_level);</div><div class="line"></div><div class="line">    parse_parameters_call_back.connect([&amp;]() -&gt; <span class="keywordtype">void</span> { initialized = <span class="keyword">true</span>; });</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  DistributedLagrangeProblem&lt;dim, spacedim&gt;::DistributedLagrangeProblem(</div><div class="line">    <span class="keyword">const</span> Parameters &amp;parameters)</div><div class="line">    : parameters(parameters)</div><div class="line">    , embedded_configuration_function(<span class="stringliteral">&quot;Embedded configuration&quot;</span>, spacedim)</div><div class="line">    , embedded_value_function(<span class="stringliteral">&quot;Embedded value&quot;</span>)</div><div class="line">    , schur_solver_control(<span class="stringliteral">&quot;Schur solver control&quot;</span>)</div><div class="line">    , monitor(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::cpu_and_wall_times)</div><div class="line">  {</div><div class="line">    embedded_configuration_function.declare_parameters_call_back.connect(</div><div class="line">      []() -&gt; <span class="keywordtype">void</span> {</div><div class="line">        <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function constants&quot;</span>, <span class="stringliteral">&quot;R=.3, Cx=.4, Cy=.4&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line">        <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>,</div><div class="line">                                   <span class="stringliteral">&quot;R*cos(2*pi*x)+Cx; R*sin(2*pi*x)+Cy&quot;</span>);</div><div class="line">      });</div><div class="line"></div><div class="line">    embedded_value_function.declare_parameters_call_back.connect(</div><div class="line">      []() -&gt; <span class="keywordtype">void</span> { <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>); });</div><div class="line"></div><div class="line">    schur_solver_control.declare_parameters_call_back.connect([]() -&gt; <span class="keywordtype">void</span> {</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Max steps&quot;</span>, <span class="stringliteral">&quot;1000&quot;</span>);</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Reduction&quot;</span>, <span class="stringliteral">&quot;1.e-12&quot;</span>);</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Tolerance&quot;</span>, <span class="stringliteral">&quot;1.e-12&quot;</span>);</div><div class="line">    });</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_grids_and_dofs()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Setup grids and dofs&quot;</span>);</div><div class="line"></div><div class="line">    space_grid = std::make_unique&lt;Triangulation&lt;spacedim&gt;&gt;();</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(*space_grid, 0, 1, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    space_grid-&gt;refine_global(parameters.initial_refinement);</div><div class="line">    space_grid_tools_cache =</div><div class="line">      std::make_unique&lt;GridTools::Cache&lt;spacedim, spacedim&gt;&gt;(*space_grid);</div><div class="line"></div><div class="line">    embedded_grid = std::make_unique&lt;Triangulation&lt;dim, spacedim&gt;&gt;();</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(*embedded_grid);</div><div class="line">    embedded_grid-&gt;refine_global(parameters.initial_embedded_refinement);</div><div class="line"></div><div class="line">    embedded_configuration_fe = std::make_unique&lt;FESystem&lt;dim, spacedim&gt;&gt;(</div><div class="line">      <a class="code" href="classFE__Q.html">FE_Q&lt;dim, spacedim&gt;</a>(</div><div class="line">        parameters.embedded_configuration_finite_element_degree),</div><div class="line">      spacedim);</div><div class="line"></div><div class="line">    embedded_configuration_dh =</div><div class="line">      std::make_unique&lt;DoFHandler&lt;dim, spacedim&gt;&gt;(*embedded_grid);</div><div class="line"></div><div class="line">    embedded_configuration_dh-&gt;distribute_dofs(*embedded_configuration_fe);</div><div class="line">    embedded_configuration.reinit(embedded_configuration_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(*embedded_configuration_dh,</div><div class="line">                             embedded_configuration_function,</div><div class="line">                             embedded_configuration);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (parameters.use_displacement == <span class="keyword">true</span>)</div><div class="line">      embedded_mapping =</div><div class="line">        std::make_unique&lt;MappingQEulerian&lt;dim, Vector&lt;double&gt;, spacedim&gt;&gt;(</div><div class="line">          parameters.embedded_configuration_finite_element_degree,</div><div class="line">          *embedded_configuration_dh,</div><div class="line">          embedded_configuration);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      embedded_mapping =</div><div class="line">        std::make_unique&lt;MappingFEField&lt;dim, spacedim, Vector&lt;double&gt;&gt;&gt;(</div><div class="line">          *embedded_configuration_dh, embedded_configuration);</div><div class="line"></div><div class="line">    setup_embedded_dofs();</div><div class="line"></div><div class="line">    std::vector&lt;Point&lt;spacedim&gt;&gt; support_points(embedded_dh-&gt;n_dofs());</div><div class="line">    <span class="keywordflow">if</span> (parameters.delta_refinement != 0)</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a>(*embedded_mapping,</div><div class="line">                                           *embedded_dh,</div><div class="line">                                           support_points);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; parameters.delta_refinement; ++i)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> point_locations =</div><div class="line">          <a class="code" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a>(*space_grid_tools_cache,</div><div class="line">                                             support_points);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cells = std::get&lt;0&gt;(point_locations);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : cells)</div><div class="line">          {</div><div class="line">            cell-&gt;set_refine_flag();</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">              <span class="keywordflow">if</span> (!cell-&gt;at_boundary(face_no))</div><div class="line">                cell-&gt;neighbor(face_no)-&gt;set_refine_flag();</div><div class="line">          }</div><div class="line">        space_grid-&gt;execute_coarsening_and_refinement();</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> embedded_space_maximal_diameter =</div><div class="line">      <a class="code" href="namespaceGridTools.html#ae8409fa9cb46a0070abc4da7de0f47f2">GridTools::maximal_cell_diameter</a>(*embedded_grid, *embedded_mapping);</div><div class="line">    <span class="keywordtype">double</span> embedding_space_minimal_diameter =</div><div class="line">      <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(*space_grid);</div><div class="line"></div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedding minimal diameter: &quot;</span></div><div class="line">            &lt;&lt; embedding_space_minimal_diameter</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;, embedded maximal diameter: &quot;</span></div><div class="line">            &lt;&lt; embedded_space_maximal_diameter &lt;&lt; <span class="stringliteral">&quot;, ratio: &quot;</span></div><div class="line">            &lt;&lt; embedded_space_maximal_diameter /</div><div class="line">                 embedding_space_minimal_diameter</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(embedded_space_maximal_diameter &lt;</div><div class="line">                  embedding_space_minimal_diameter,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                  <span class="stringliteral">&quot;The embedding grid is too refined (or the embedded grid &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;is too coarse). Adjust the parameters so that the minimal &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;grid size of the embedding grid is larger &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;than the maximal grid size of the embedded grid.&quot;</span>));</div><div class="line"></div><div class="line">    setup_embedding_dofs();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_embedding_dofs()</div><div class="line">  {</div><div class="line">    space_dh = std::make_unique&lt;DoFHandler&lt;spacedim&gt;&gt;(*space_grid);</div><div class="line">    space_fe = std::make_unique&lt;FE_Q&lt;spacedim&gt;&gt;(</div><div class="line">      parameters.embedding_space_finite_element_degree);</div><div class="line">    space_dh-&gt;distribute_dofs(*space_fe);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(*space_dh, constraints);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keywordtype">id</span> : parameters.homogeneous_dirichlet_ids)</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">          *space_dh, <span class="keywordtype">id</span>, <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;spacedim&gt;</a>(), constraints);</div><div class="line">      }</div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(space_dh-&gt;n_dofs(), space_dh-&gt;n_dofs());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(*space_dh, dsp, constraints);</div><div class="line">    stiffness_sparsity.copy_from(dsp);</div><div class="line">    stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(stiffness_sparsity);</div><div class="line">    solution.reinit(space_dh-&gt;n_dofs());</div><div class="line">    rhs.reinit(space_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedding dofs: &quot;</span> &lt;&lt; space_dh-&gt;n_dofs() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_embedded_dofs()</div><div class="line">  {</div><div class="line">    embedded_dh = std::make_unique&lt;DoFHandler&lt;dim, spacedim&gt;&gt;(*embedded_grid);</div><div class="line">    embedded_fe = std::make_unique&lt;FE_Q&lt;dim, spacedim&gt;&gt;(</div><div class="line">      parameters.embedded_space_finite_element_degree);</div><div class="line">    embedded_dh-&gt;distribute_dofs(*embedded_fe);</div><div class="line"></div><div class="line">    lambda.reinit(embedded_dh-&gt;n_dofs());</div><div class="line">    embedded_rhs.reinit(embedded_dh-&gt;n_dofs());</div><div class="line">    embedded_value.reinit(embedded_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedded dofs: &quot;</span> &lt;&lt; embedded_dh-&gt;n_dofs() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_coupling()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Setup coupling&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quad(parameters.coupling_quadrature_order);</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(space_dh-&gt;n_dofs(), embedded_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceNonMatching.html#a8829bfa8e55c21b8eeaafd086c53680d">NonMatching::create_coupling_sparsity_pattern</a>(*space_grid_tools_cache,</div><div class="line">                                                  *space_dh,</div><div class="line">                                                  *embedded_dh,</div><div class="line">                                                  quad,</div><div class="line">                                                  dsp,</div><div class="line">                                                  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a>(),</div><div class="line">                                                  <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                                  <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                                  *embedded_mapping);</div><div class="line">    coupling_sparsity.copy_from(dsp);</div><div class="line">    coupling_matrix.reinit(coupling_sparsity);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Assemble system&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixTools::create_laplace_matrix</a>(</div><div class="line">        *space_dh,</div><div class="line">        <a class="code" href="classQGauss.html">QGauss&lt;spacedim&gt;</a>(2 * space_fe-&gt;degree + 1),</div><div class="line">        stiffness_matrix,</div><div class="line">        static_cast&lt;<span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;spacedim&gt;</a> *&gt;(<span class="keyword">nullptr</span>),</div><div class="line">        constraints);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(*embedded_mapping,</div><div class="line">                                          *embedded_dh,</div><div class="line">                                          <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(2 * embedded_fe-&gt;degree +</div><div class="line">                                                      1),</div><div class="line">                                          embedded_value_function,</div><div class="line">                                          embedded_rhs);</div><div class="line">    }</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Assemble coupling system&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quad(parameters.coupling_quadrature_order);</div><div class="line">      <a class="code" href="namespaceNonMatching.html#ac3821491559b8a76af0be66736fe4c6f">NonMatching::create_coupling_mass_matrix</a>(*space_grid_tools_cache,</div><div class="line">                                               *space_dh,</div><div class="line">                                               *embedded_dh,</div><div class="line">                                               quad,</div><div class="line">                                               coupling_matrix,</div><div class="line">                                               <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a>(),</div><div class="line">                                               <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                               <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                               *embedded_mapping);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(*embedded_mapping,</div><div class="line">                               *embedded_dh,</div><div class="line">                               embedded_value_function,</div><div class="line">                               embedded_value);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Solve system&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> K_inv_umfpack;</div><div class="line">    K_inv_umfpack.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(stiffness_matrix);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> K  = <a class="code" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a>(stiffness_matrix);</div><div class="line">    <span class="keyword">auto</span> Ct = <a class="code" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a>(coupling_matrix);</div><div class="line">    <span class="keyword">auto</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>  = <a class="code" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a>(Ct);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> K_inv = <a class="code" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a>(K, K_inv_umfpack);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>                     S = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a> * K_inv * Ct;</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver_cg(schur_solver_control);</div><div class="line">    <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S, solver_cg, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    lambda = S_inv * embedded_rhs;</div><div class="line"></div><div class="line">    solution = K_inv * Ct * lambda;</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::output_results()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Output results&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;</a> embedding_out;</div><div class="line"></div><div class="line">    std::ofstream embedding_out_file(<span class="stringliteral">&quot;embedding.vtu&quot;</span>);</div><div class="line"></div><div class="line">    embedding_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(*space_dh);</div><div class="line">    embedding_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    embedding_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(</div><div class="line">      parameters.embedding_space_finite_element_degree);</div><div class="line">    embedding_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(embedding_out_file);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;</a> embedded_out;</div><div class="line"></div><div class="line">    std::ofstream embedded_out_file(<span class="stringliteral">&quot;embedded.vtu&quot;</span>);</div><div class="line"></div><div class="line">    embedded_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(*embedded_dh);</div><div class="line">    embedded_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(lambda, <span class="stringliteral">&quot;lambda&quot;</span>);</div><div class="line">    embedded_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(embedded_value, <span class="stringliteral">&quot;g&quot;</span>);</div><div class="line">    embedded_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(*embedded_mapping,</div><div class="line">                               parameters.embedded_space_finite_element_degree);</div><div class="line">    embedded_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(embedded_out_file);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">DistributedLagrangeProblem&lt;dim, spacedim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(parameters.initialized, <a class="code" href="group__Exceptions.html#ga426dec8d8185f1410e09a795e0b36e86">ExcNotInitialized</a>());</div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(parameters.verbosity_level);</div><div class="line"></div><div class="line">    setup_grids_and_dofs();</div><div class="line">    setup_coupling();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step60</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step60;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 1, spacedim = 2;</div><div class="line"></div><div class="line"></div><div class="line">      DistributedLagrangeProblem&lt;dim, spacedim&gt;::Parameters parameters;</div><div class="line">      DistributedLagrangeProblem&lt;dim, spacedim&gt;             problem(parameters);</div><div class="line"></div><div class="line">      std::string parameter_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        parameter_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        parameter_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(parameter_file, <span class="stringliteral">&quot;used_parameters.prm&quot;</span>);</div><div class="line">      problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_6.html">step-6</a> . <table class="tutorial"
 width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a
 href="#NonmatchinggridconstraintsthroughdistributedLagrangemultipliers">Non-matching
 grid constraints through distributed Lagrange multipliers</a><a
 href="#NonmatchinggridconstraintsthroughdistributedLagrangemultipliers">Non-matching
 grid constraints through distributed Lagrange multipliers</a>
 <li><a href="#Thetestcase">The testcase</a><a href="#Thetestcase">The
 testcase</a>
 <li><a href="#References">References</a><a
 href="#References">References</a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Includefiles">Include files</a><a
 href="#Includefiles">Include files</a>
 <li><a href="#DistributedLagrangeProblem">DistributedLagrangeProblem</a><a
 href="#DistributedLagrangeProblem">DistributedLagrangeProblem</a>
 <li><a
 href="#DistributedLagrangeProblemParameters">DistributedLagrangeProblem::Parameters</a><a
 href="#DistributedLagrangeProblemParameters">DistributedLagrangeProblem::Parameters</a>
 <li><a href="#Setup">Set up</a><a href="#Setup">Set up</a>
 <li><a href="#Assembly">Assembly</a><a href="#Assembly">Assembly</a>
 <li><a href="#Solve">Solve</a><a href="#Solve">Solve</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#Testcase1"> Test case 1: </a><a href="#Testcase1"> Test case
 1: </a>
 <li><a href="#Testcase2and3"> Test case 2 and 3: </a><a
 href="#Testcase2and3"> Test case 2 and 3: </a>
 <li><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a>
 <ul>
 <li><a href="#Runningwithspacedimequaltothree"> Running with `spacedim`
 equal to three</a><a href="#Runningwithspacedimequaltothree"> Running with
 `spacedim` equal to three</a>
 <li><a href="#Moregeneraldomains"> More general domains </a><a
 href="#Moregeneraldomains"> More general domains </a>
 <li><a href="#Preconditioner"> Preconditioner</a><a href="#Preconditioner">
 Preconditioner</a>
 <li><a href="#ParallelCode"> Parallel Code </a><a href="#ParallelCode">
 Parallel Code </a>
 </ul>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <br />
 <em>This program was contributed by Luca Heltai and Giovanni Alzetta, SISSA, Trieste. </em> </p><dl class="section note"><dt>Note</dt><dd>If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.1243280"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.1243280.svg" alt="10.5281/zenodo.1243280"/></a> </dd></dl>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="NonmatchinggridconstraintsthroughdistributedLagrangemultipliers"></a></p><h3>Non-matching grid constraints through distributed Lagrange multipliers</h3>
<p>In this tutorial we consider the case of two domains, \(\Omega\) in \(R^{\text{spacedim}}\) and \(\Gamma\) in \(R^{\text{dim}}\) , where \(\Gamma\) isembedded in \(\Omega\) ( \(\Gamma \subseteq \Omega\) ). We want to solve a partialdifferential equation on \(\Omega\) , enforcing some conditions on the solution ofthe problemon the embedded domain* \(\Gamma\) . There are two interesting scenarios:</p>
<ul>
<li>the geometrical dimension <code>dim</code> of the embedded domain \(\Gamma\) is the same ofthe domain \(\Omega\) (<code>spacedim</code>), that is, the spacedim-dimensional measure of \(\Gamma\) is not zero, or</li>
<li>the embedded domain \(\Gamma\) has an intrinsic dimension <code>dim</code> which is smallerthan that of \(\Omega\) (<code>spacedim</code>), thus its spacedim-dimensional measure iszero; for example it is a curve embedded in a two dimensional domain, or asurface embedded in a three-dimensional domain. In both cases define the restriction operator \(\gamma\) as the operator that,given a continuous function on \(\Omega\) , returns its (continuous) restriction on \(\Gamma\) , i.e., <p class="formulaDsp">
\[ \gamma : C^0(\Omega) \mapsto C^0(\Gamma), \quad \text{ s.t. } \gamma u = u|_{\Gamma} \in C^0(\Gamma), \quad \forall u \in C^0(\Omega). \]
</p>
 It is well known that the operator \(\gamma\) can be extended to a continuousoperator on \(H^1(\Omega)\) , mapping functions in \(H^1(\Omega)\) to functions in \(H^1(\Gamma)\) when the intrinsic dimension of \(\Gamma\) is the same of \(\Omega\) . The same is true, with a less regular range space (namely \(H^{1/2}(\Gamma)\) ),when the dimension of \(\Gamma\) is one less with respect to \(\Omega\) , and \(\Gamma\) does not have a boundary. In this second case, the operator \(\gamma\) isalso known as thetrace* operator, and it is well defined for Lipschitzco-dimension one curves and surfaces \(\Gamma\) embedded in \(\Omega\) (read <a href="https://en.wikipedia.org/wiki/Trace_operator">this wikipedia article</a>for further details on the trace operator). The co-dimension two case is a little more complicated, and in general it is notpossible to construct a continuous trace operator, not even from \(H^1(\Omega)\) to \(L^2(\Gamma)\) , when the dimension of \(\Gamma\) is zero or one respectively in twoand three dimensions. In this tutorial program we're not interested in further details on \(\gamma\) : wetake the extension \(\gamma\) for granted, assuming that the dimension of theembedded domain (<code>dim</code>) is always smaller by one or equal with respect to thedimension of the embedding domain \(\Omega\) (<code>spacedim</code>). We are going to solve the following differential problem: given a sufficientlyregular function \(g\) on \(\Gamma\) , find the solution \(u\) to <p class="formulaDsp">
\begin{eqnarray*} - \Delta u + \gamma^T \lambda &amp;=&amp; 0 \text{ in } \Omega\\ \gamma u &amp;=&amp; g \text{ in } \Gamma \\ u &amp; = &amp; 0 \text{ on } \partial\Omega. \end{eqnarray*}
</p>
</li>
</ul>
<p>This is a constrained problem, where we are looking for a harmonic function \(u\) that satisfies homogeneous boundary conditions on \(\partial\Omega\) , subject tothe constraint \(\gamma u = g\) using a Lagrange multiplier. This problem has a physical interpretation: harmonic functions, i.e., functionsthat satisfy the Laplace equation, can be thought of as the displacements of amembrane whose boundary values are prescribed. The current situation thencorresponds to finding the shape of a membrane for which not only thedisplacement at the boundary, but also on \(\Gamma\) is prescribed. For example,if \(\Gamma\) is a closed curve in 2d space, then that would model a soap filmthat is held in place by a wire loop along \(\partial \Omega\) as well as a secondloop along \(\Gamma\) . In cases where \(\Gamma\) is a whole area, you can think ofthis as a membrane that is stretched over an obstacle where \(\Gamma\) is thecontact area. (If the contact area is not known we have a different problem</p>
<ul>
<li>called the "obstacle problem"</li>
<li>which is modeled in <a class="el" href="step_41.html">step-41</a> .) As a first example we study the zero Dirichlet boundary condition on \(\partial\Omega\) . The same equations apply if we apply zero Neumann boundaryconditions on \(\partial\Omega\) or a mix of the two. The variational formulation can be derived by introducing two infinitedimensional spaces \(V(\Omega)\) and \(Q^*(\Gamma)\) , respectively for the solution \(u\) and for the Lagrange multiplier \(\lambda\) . Multiplying the first equation by \(v \in V(\Omega)\) and the second by \(q \in Q(\Gamma)\) , integrating by parts when possible, and exploiting the boundaryconditions on \(\partial\Omega\) , we obtain the following variational problem: Given a sufficiently regular function \(g\) on \(\Gamma\) , find the solution \(u\) to <p class="formulaDsp">
\begin{eqnarray*} (\nabla u, \nabla v)_{\Omega} + (\lambda, \gamma v)_{\Gamma} &amp;=&amp; 0 \qquad \forall v \in V(\Omega) \\ (\gamma u, q)_{\Gamma} &amp;=&amp; (g,q)_{\Gamma} \qquad \forall q \in Q(\Gamma), \end{eqnarray*}
</p>
</li>
</ul>
<p>where \((\cdot, \cdot)_{\Omega}\) and \((\cdot, \cdot)_{\Gamma}\) represent,respectively, \(L^2\) scalar products in \(\Omega\) and in \(\Gamma\) . Inspection of the variational formulation tells us that the space \(V(\Omega)\) can be taken to be \(H^1_0(\Omega)\) . The space \(Q(\Gamma)\) , in the co-dimensionzero case, should be taken as \(H^1(\Gamma)\) , while in the co-dimension one caseshould be taken as \(H^{1/2}(\Gamma)\) . The function \(g\) should therefore be either in \(H^1(\Gamma)\) (for theco-dimension zero case) or \(H^{1/2}(\Gamma)\) (for the co-dimension one case).This leaves us with a Lagrange multiplier \(\lambda\) in \(Q^*(\Gamma)\) , which iseither \(H^{-1}(\Gamma)\) or \(H^{-1/2}(\Gamma)\) . There are two options for the discretization of the problem above. One could choosematching discretizations, where the <a class="el" href="classTriangulation.html">Triangulation</a> for \(\Gamma\) is aligned with theTriangulation for \(\Omega\) , or one could choose to discretize the two domains ina completely independent way. The first option is clearly more indicated for the simple problem weproposed above: it is sufficient to use a single <a class="el" href="classTriangulation.html">Triangulation</a> for \(\Omega\) andthen impose certain constraints depending \(\Gamma\) . An example of this approachis studied in <a class="el" href="step_40.html">step-40</a> , where the solution has to stay above an obstacle and thisis achieved imposing constraints on \(\Omega\) . To solve more complex problems, for example one where the domain \(\Gamma\) is timedependent, the second option could be a more viable solution. Handlingnon aligned meshes is complex by itself: to illustrate how is done we study asimple problem. The technique we describe here is presented in the literature using one of many names:the <b>immersed finite element method</b>, the <b>fictitious boundary method</b>, the<b>distributed Lagrange multiplier method</b>, and others. The main principle isthat the discretization of the two grids and of the two finite element spacesare kept completely independent. This technique is particularly efficient forthe simulation of fluid-structure interaction problems, where the configurationof the embedded structure is part of the problem itself, and one solves a(possibly non-linear) elastic problem to determine the (time dependent)configuration of \(\Gamma\) , and a (possibly non-linear) flow problem in \(\Omega \setminus \Gamma\) , plus coupling conditions on the interface between the fluidand the solid. In this tutorial program we keep things a little simpler, and we assume that theconfiguration of the embedded domain is given in one of two possible ways:</p>
<ul>
<li>as a deformation mapping \(\psi: \Gamma_0 \mapsto \Gamma \subseteq \Omega\) ,defined on a continuous finite dimensional space on \(\Gamma_0\) and representing,for any point \(x \in \Gamma_0\) , its coordinate \(\psi(x)\) in \(\Omega\) ;</li>
<li>as a displacement mapping \(\delta \psi(x) = \psi(x)-x\) for \(x\in \Gamma_0\) ,representing for any point \(x\) the displacement vector applied in order todeform \(x\) to its actual configuration \(\psi(x) = x +\delta\psi(x)\) . We define the embedded reference domain \(\Gamma_0\) <code>embedded_grid</code>: onthis triangulation we construct a finite dimensional space (<code>embedded_configuration_dh</code>)to describe either the deformation or the displacement through a FiniteElementsystem of <a class="el" href="classFE__Q.html">FE_Q</a> objects (<code>embedded_configuration_fe</code>). This finite dimensionalspace is used only to interpolate a user supplied function(<code>embedded_configuration_function</code>) representing either \(\psi\) (if theparameter <code>use_displacement</code> is set to <code>false</code>) or \(\delta\psi\) (if theparameter <code>use_displacement</code> is set to <code>true</code>). The Lagrange multiplier \(\lambda\) and the user supplied function \(g\) aredefined through another finite dimensional space <code>embedded_dh</code>, and throughanother <a class="el" href="classFiniteElement.html">FiniteElement</a> <code>embedded_fe</code>, using the same reference domain. Inorder to take into account the deformation of the domain, either a MappingFEFieldor a <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> object are initialized with the <code>embedded_configuration</code>vector. In the embedding space, a standard finite dimensional space <code>space_dh</code> isconstructed on the embedding grid <code>space_grid</code>, using theFiniteElement <code>space_fe</code>, following almost verbatim the approach taken in <a class="el" href="step_6.html">step-6</a> . We represent the discretizations of the spaces \(V\) and \(Q\) with <p class="formulaDsp">
\[ V_h(\Omega) = \text{span} \{v_i\}_{i=1}^n \]
</p>
 <p class="formulaDsp">
\[ Q_h(\Gamma) = \text{span} \{q_i\}_{i=1}^m \]
</p>
, where \(n\) is the dimension of <code>space_dh</code>, and \(m\) the dimension of <code>embedded_dh</code>. Once all the finite dimensional spaces are defined, the variational formulationof the problem above leaves us with the following finite dimensional systemof equations: <p class="formulaDsp">
\[ \begin{pmatrix} K &amp; C^T \\ C &amp; 0 \end{pmatrix} \begin{pmatrix} u \\ \lambda \end{pmatrix} = \begin{pmatrix} 0 \\ G \end{pmatrix} \]
</p>
 where <p class="formulaDsp">
\begin{eqnarray*} K_{ij} &amp;\dealcoloneq&amp; (\nabla v_j, \nabla v_i)_\Omega \qquad i,j=1,\dots,n \\ C_{\alpha j} &amp;\dealcoloneq&amp; (v_j, q_\alpha)_\Gamma \qquad j=1,\dots,n, \alpha = 1,\dots, m \\\\ G_{\alpha} &amp;\dealcoloneq&amp; (g, q_\alpha)_\Gamma \qquad \alpha = 1,\dots, m. \end{eqnarray*}
</p>
</li>
</ul>
<p>While the matrix \(K\) is the standard stiffness matrix for the Poisson problem on \(\Omega\) , and the vector \(G\) is a standard right-hand-side vector for a finiteelement problem with forcing term \(g\) on \(\Gamma\) , (see, for example, <a class="el" href="step_3.html">step-3</a> ),the matrix \(C\) or its transpose \(C^T\) are non-standard since they coupleinformation on two non-matching grids. In particular, the integral that appears in the computation of a single entry of \(C\) , is computed on \(\Gamma\) . As usual in finite elements we split thisintegral into contributions from all cells of the triangulation used todiscretize \(\Gamma\) , we transform the integral on \(K\) to an integral on thereference element \(\hat K\) , where \(F_{K}\) is the mapping from \(\hat K\) to \(K\) ,and compute the integral on \(\hat K\) using a quadrature formula: </p><p class="formulaDsp">
\[ C_{\alpha j} \dealcoloneq (v_j, q_\alpha)_\Gamma = \sum_{K\in \Gamma} \int_{\hat K} \hat q_\alpha(\hat x) (v_j \circ F_{K}) (\hat x) J_K (\hat x) \mathrm{d} \hat x = \sum_{K\in \Gamma} \sum_{i=1}^{n_q} \big(\hat q_\alpha(\hat x_i) (v_j \circ F_{K}) (\hat x_i) J_K (\hat x_i) w_i \big) \]
</p>
<p> Computing this sum is non-trivial because we have to evaluate \((v_j \circ F_{K}) (\hat x_i)\) . In general, if \(\Gamma\) and \(\Omega\) are not aligned, the point \(F_{K}(\hat x_i)\) is completely arbitrary with respect to \(\Omega\) , and unlesswe figure out a way to interpolate all basis functions of \(V_h(\Omega)\) on anarbitrary point on \(\Omega\) , we cannot compute the integral needed for an entryof the matrix \(C\) . To evaluate \((v_j \circ F_{K}) (\hat x_i)\) the following steps needs to betaken (as shown in the picture below):</p>
<ul>
<li>For a given cell \(K\) in \(\Gamma\) compute the real point \(y_i \dealcoloneq F_{K} (\hat x_i)\) , where \(x_i\) is one of the quadrature points used for the integral on \(K \subseteq \Gamma\) .</li>
<li>Find the cell of \(\Omega\) in which \(y_i\) lies. We shall call this element \(T\) .</li>
<li>To evaluate the basis function use the inverse of the mapping \(G_T\) thattransforms the reference element \(\hat T\) into the element \(T\) : \(v_j(y_i) = \hat v_j \circ G^{-1}_{T} (y_i)\) . </li>
</ul>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.C_interpolation.png"/>
</div>
 <p>The three steps above can be computed by calling, in turn,</p>
<ul>
<li><a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point()</a>, followed by</li>
<li><a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a>. We then</li>
<li>construct a custom <a class="el" href="classQuadrature.html">Quadrature</a> formula, containing the point in the reference cell and then</li>
<li>construct an <a class="el" href="classFEValues.html">FEValues</a> object, with the given quadrature formula, and initialized with the cell obtained in the first step. This is what the deal.II function <a class="el" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value()</a> does whenevaluating a finite element field (not just a single shape function) at anarbitrary point; but this would be inefficient in this case. A better solution is to use a convenient wrapper to perform the first threesteps on a collection of points: <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations()</a>. If one isactually interested in computing the full coupling matrix, then it is possibleto call the method <a class="el" href="namespaceNonMatching.html#ac3821491559b8a76af0be66736fe4c6f">NonMatching::create_coupling_mass_matrix()</a>, that performs theabove steps in an efficient way, reusing all possible data structures, andgathering expensive steps together. This is the function we'll be using later inthis tutorial. We solve the final saddle point problem by an iterative solver, applied to theSchur complement \(S\) (whose construction is described, for example, in <a class="el" href="step_20.html">step-20</a> ),and we construct \(S\) using <a class="el" href="classLinearOperator.html">LinearOperator</a> classes.</li>
</ul>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>The problem we solve here is identical to <a class="el" href="step_4.html">step-4</a> , with the difference that weimpose some constraints on an embedded domain \(\Gamma\) . The tutorial is writtenin a dimension independent way, and in the results section we show how to varyboth <code>dim</code> and <code>spacedim</code>. The tutorial is compiled for <code>dim</code> equal to one and <code>spacedim</code> equal to two. Ifyou want to run the program in embedding dimension <code>spacedim</code> equal to three,you will most likely want to change the reference domain for \(\Gamma\) to be, forexample, something you read from file, or a closed sphere that you later deformto something more interesting. In the default scenario, \(\Gamma\) has co-dimension one, and this tutorialprogram implements the Fictitious Boundary Method. As it turns out, the sametechniques are used in the Variational Immersed Finite Element Method, andthe coupling operator \(C\) defined above is the same in almost all of thesenon-matching methods. The embedded domain is assumed to be included in \(\Omega\) , which we take as theunit square \([0,1]^2\) . The definition of the fictitious domain \(\Gamma\) can bemodified through the parameter file, and can be given as a mapping from thereference interval \([0,1]\) to a curve in \(\Omega\) . If the curve is closed, then the results will be similar to running the sameproblem on a grid whose boundary is \(\Gamma\) . The program will happily run alsowith a non-closed \(\Gamma\) , although in those cases the mathematicalformulation of the problem is more difficult, since \(\Gamma\) will have aboundary by itself that has co-dimension two with respect to the domain \(\Omega\) .</p>
<p><a class="anchor" id="References"></a></p><h3>References</h3>
<ul>
<li>
Glowinski, R., T.-W. Pan, T.I. Hesla, and D.D. Joseph. 1999. “A Distributed Lagrange Multiplier/fictitious Domain Method for Particulate Flows.” International Journal of Multiphase Flow 25 (5). Pergamon: 755–94. </li>
<li>
Boffi, D., L. Gastaldi, L. Heltai, and C.S. Peskin. 2008. “On the Hyper-Elastic Formulation of the Immersed Boundary Method.” Computer Methods in Applied Mechanics and Engineering 197 (25–28). </li>
<li>
Heltai, L., and F. Costanzo. 2012. “Variational Implementation of Immersed Finite Element Methods.” Computer Methods in Applied Mechanics and Engineering 229–232. </li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Most of these have been introduced elsewhere, we'll comment only on the new ones.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div></div><!-- fragment --><p>The parameter acceptor class is the first novelty of this tutorial program: in general parameter files are used to steer the execution of a program at run time. While even a simple approach saves compile time, as the same executable can be run with different parameter settings, it can become difficult to handle hundreds of parameters simultaneously while maintaining compatibility between different programs. This is where the class <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> proves useful.</p>
<p>This class is used to define a public interface for classes that want to use a single global <a class="el" href="classParameterHandler.html">ParameterHandler</a> to handle parameters. The class provides a static <a class="el" href="classParameterHandler.html">ParameterHandler</a> member, namely <a class="el" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>, and implements the "Command design pattern" (see, for example, E. Gamma, R. Helm, R. Johnson, J. Vlissides, Design <a class="el" href="namespacePatterns.html">Patterns</a>: Elements of Reusable Object-Oriented Software, Addison-Wesley Professional, 1994. <a href="https://goo.gl/FNYByc">https://goo.gl/FNYByc</a>).</p>
<p><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> provides a global subscription mechanism. Whenever an object of a class derived from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> is constructed, a pointer to that object-of-derived-type is registered, together with a section entry in the parameter file. Such registry is traversed upon invocation of the single function <a class="el" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>("file.prm") which in turn makes sure that all classes stored in the global registry declare the parameters they will be using, and after having declared them, it reads the content of <code>file.prm</code> to parse the actual parameters.</p>
<p>If you call the method <a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">ParameterHandler::add_parameter</a> for each of the parameters you want to use in your code, there is nothing else you need to do. If you are using an already existing class that provides the two functions <code>declare_parameters</code> and <code>parse_parameters</code>, you can still use <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>, by encapsulating the existing class into a <a class="el" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy</a> class.</p>
<p>In this example, we'll use both strategies, using <a class="el" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy</a> for deal.II classes, and deriving our own parameter classes directly from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The other new include file is the one that contains the <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> class. The structure of deal.II, as many modern numerical libraries, is organized following a Directed Acyclic Graph (DAG). A DAG is a directed graph with topological ordering: each node structurally represents an object, and is connected to non-root nodes by one (or more) oriented edges, from the parent to the child. The most significant example of this structure is the <a class="el" href="classTriangulation.html">Triangulation</a> and its <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">Triangulation::cell_iterator</a> structure. From a <a class="el" href="classTriangulation.html">Triangulation</a> (the main node), we can access each cell (children nodes of the triangulation). From the cells themselves we can access over all vertices of the cell. In this simple example, the DAG structure can be represented as three node types (the triangulation, the cell iterator, and the vertex) connected by oriented edges from the triangulation to the cell iterators, and from the cell iterator to the vertices. This has several advantages, but it intrinsically creates “asymmetries”, making certain operations fast and their inverse very slow: finding the vertices of a cell has low computational cost, and can be done by simply traversing the DAG, while finding all the cells that share a vertex requires a non-trivial computation unless a new DAG data structure is added that represents the inverse search.</p>
<p>Since inverse operations are usually not needed in a finite element code, these are implemented in <a class="el" href="namespaceGridTools.html">GridTools</a> without the use of extra data structures related to the <a class="el" href="classTriangulation.html">Triangulation</a> which would make them much faster. One such data structure, for example, is a map from the vertices of a <a class="el" href="classTriangulation.html">Triangulation</a> to all cells that share those vertices, which would reduce the computations needed to answer to the previous question.</p>
<p>Some methods, for example <a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point</a>, make heavy usage of these non-standard operations. If you need to call these methods more than once, it becomes convenient to store those data structures somewhere. <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> does exactly this, giving you access to previously computed objects, or computing them on the fly (and then storing them inside the class for later use), and making sure that whenever the <a class="el" href="classTriangulation.html">Triangulation</a> is updated, also the relevant data structures are recomputed.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools__cache_8h.html">deal.II/grid/grid_tools_cache.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2fe_2fe_8h.html">deal.II/fe/fe.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div></div><!-- fragment --><p>In this example, we will be using a reference domain to describe an embedded <a class="el" href="classTriangulation.html">Triangulation</a>, deformed through a finite element vector field.</p>
<p>The next two include files contain the definition of two classes that can be used in these cases. <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> allows one to describe a domain through adisplacement* field, based on a <a class="el" href="classFESystem.html">FESystem</a>[<a class="el" href="classFE__Q.html">FE_Q(p)</a>^spacedim] finite element space. The second is a little more generic, and allows you to use arbitrary vector <a class="el" href="classFiniteElement.html">FiniteElement</a> spaces, as long as they provide acontinuous* description of your domain. In this case, the description is done through the actualdeformation* field, rather than adisplacement* field.</p>
<p>Which one is used depends on how the user wants to specify the reference domain, and/or the actual configuration. We'll provide both options, and experiment a little in the results section of this tutorial program.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__eulerian_8h.html">deal.II/fe/mapping_q_eulerian.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__fe__field_8h.html">deal.II/fe/mapping_fe_field.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The parsed function class is another new entry. It allows one to create a <a class="el" href="classFunction.html">Function</a> object, starting from a string in a parameter file which is parsed into an object that you can use anywhere deal.II accepts a <a class="el" href="classFunction.html">Function</a> (for example, for interpolation, boundary conditions, etc.).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parsed__function_8h.html">deal.II/base/parsed_function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div></div><!-- fragment --><p>This is the last new entry for this tutorial program. The namespace <a class="el" href="namespaceNonMatching.html">NonMatching</a> contains a few methods that are useful when performing computations on non-matching grids, or on curves that are not aligned with the underlying mesh.</p>
<p>We'll discuss its use in detail later on in the <code>setup_coupling</code> method.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="coupling_8h.html">deal.II/non_matching/coupling.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step60</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="DistributedLagrangeProblem"></a> </p><h3>DistributedLagrangeProblem</h3>
<p>In the DistributedLagrangeProblem, we need two parameters describing the dimensions of the domain \(\Gamma\) (<code>dim</code>) and of the domain \(\Omega\) (<code>spacedim</code>). These will be used to initialize a Triangulation&lt;dim,spacedim&gt; (for \(\Gamma\) ) and a Triangulation&lt;spacedim,spacedim&gt; (for \(\Omega\) ). A novelty with respect to other tutorial programs is the heavy use of std::unique_ptr. These behave like classical pointers, with the advantage of doing automatic house-keeping: the contained object is automatically destroyed as soon as the unique_ptr goes out of scope, even if it is inside a container or there's an exception. Moreover it does not allow for duplicate pointers, which prevents ownership problems. We do this, because we want to be able to i) construct the problem, ii) read the parameters, and iii) initialize all objects according to what is specified in a parameter file. We construct the parameters of our problem in the internal class <code>Parameters</code>, derived from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>. The <code>DistributedLagrangeProblem</code> class takes a const reference to a <code>Parameters</code> object, so that it is not possible to modify the parameters from within the DistributedLagrangeProblem class itself. We could have initialized the parameters first, and then pass the parameters to the DistributedLagrangeProblem assuming all entries are set to the desired values, but this has two disadvantages:</p>
<ul>
<li>We should not make assumptions on how the user initializes a class that is not under our direct control. If the user fails to initialize the class, we should notice and throw an exception;</li>
<li>Not all objects that need to read parameters from a parameter file may be available when we construct the Parameters; this is often the case for complex programs, with multiple physics, or where we reuse existing code in some external classes. We simulate this by keeping some "complex" objects, like ParsedFunction objects, inside the <code>DistributedLagrangeProblem</code> instead of inside the <code>Parameters</code>. Here we assume that upon construction, the classes that build up our problem are not usable yet. Parsing the parameter file is what ensures we have all ingredients to build up our classes, and we design them so that if parsing fails, or is not executed, the run is aborted.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line"><span class="keyword">class </span>DistributedLagrangeProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div></div><!-- fragment --><p>The <code>Parameters</code> class is derived from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>. This allows us to use the <a class="el" href="classParameterAcceptor.html#af2a534c7f1ea5bfa165fa8a469744a5d">ParameterAcceptor::add_parameter()</a> method in its constructor. The members of this function are all non-const, but the <code>DistributedLagrangeProblem</code> class takes a const reference to a <code>Parameters</code> object: this ensures that parameters are not modified from within the <code>DistributedLagrangeProblem</code> class.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Parameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Parameters();</div></div><!-- fragment --><p>The parameters now described can all be set externally using a parameter file: if no parameter file is present when running the executable, the program will create a "parameters.prm" file with the default values defined here, and then abort to give the user a chance to modify the parameters.prm file.</p>
<p>Initial refinement for the embedding grid, corresponding to the domain \(\Omega\) .</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement = 4;</div></div><!-- fragment --><p>The interaction between the embedded grid \(\Omega\) and the embedding grid \(\Gamma\) is handled through the computation of \(C\) , which involves all cells of \(\Omega\) overlapping with parts of \(\Gamma\) : a higher refinement of such cells might improve quality of our computations. For this reason we define <code>delta_refinement</code>: if it is greater than zero, then we mark each cell of the space grid that contains a vertex of the embedded grid and its neighbors, execute the refinement, and repeat this process <code>delta_refinement</code> times.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> delta_refinement = 3;</div></div><!-- fragment --><p>Starting refinement of the embedded grid, corresponding to the domain \(\Gamma\) .</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_embedded_refinement = 8;</div></div><!-- fragment --><p>The list of boundary ids where we impose homogeneous Dirichlet boundary conditions. On the remaining boundary ids (if any), we impose homogeneous Neumann boundary conditions. As a default problem we have zero Dirichlet boundary conditions on \(\partial \Omega\)</p>
<div class="fragment"><div class="line">std::list&lt;types::boundary_id&gt; homogeneous_dirichlet_ids{0, 1, 2, 3};</div></div><!-- fragment --><p><a class="el" href="classFiniteElement.html">FiniteElement</a> degree of the embedding space: \(V_h(\Omega)\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedding_space_finite_element_degree = 1;</div></div><!-- fragment --><p><a class="el" href="classFiniteElement.html">FiniteElement</a> degree of the embedded space: \(Q_h(\Gamma)\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedded_space_finite_element_degree = 1;</div></div><!-- fragment --><p><a class="el" href="classFiniteElement.html">FiniteElement</a> degree of the space used to describe the deformation of the embedded domain</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedded_configuration_finite_element_degree = 1;</div></div><!-- fragment --><p>Order of the quadrature formula used to integrate the coupling</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> coupling_quadrature_order = 3;</div></div><!-- fragment --><p>If set to true, then the embedded configuration function is interpreted as a displacement function</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> use_displacement = <span class="keyword">false</span>;</div></div><!-- fragment --><p>Level of verbosity to use in the output</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> verbosity_level = 10;</div></div><!-- fragment --><p>A flag to keep track if we were initialized or not</p>
<div class="fragment"><div class="line">  <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">};</div><div class="line"></div><div class="line">DistributedLagrangeProblem(<span class="keyword">const</span> Parameters &amp;parameters);</div></div><!-- fragment --><p>Entry point for the DistributedLagrangeProblem</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div></div><!-- fragment --><p>Object containing the actual parameters</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Parameters &amp;parameters;</div></div><!-- fragment --><p>The following functions are similar to all other tutorial programs, with the exception that we now need to set up things for two different families of objects, namely the ones related to theembedding* grids, and the ones related to theembedded* one.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_grids_and_dofs();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> setup_embedding_dofs();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> setup_embedded_dofs();</div></div><!-- fragment --><p>The only unconventional function we have here is the <code>setup_coupling()</code> method, used to generate the sparsity patter for the coupling matrix \(C\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_coupling();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> output_results();</div></div><!-- fragment --><p>first we gather all the objects related to the embedding space geometry</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;Triangulation&lt;spacedim&gt;&gt; space_grid;</div><div class="line">std::unique_ptr&lt;GridTools::Cache&lt;spacedim, spacedim&gt;&gt;</div><div class="line">                                         space_grid_tools_cache;</div><div class="line">std::unique_ptr&lt;FiniteElement&lt;spacedim&gt;&gt; space_fe;</div><div class="line">std::unique_ptr&lt;DoFHandler&lt;spacedim&gt;&gt;    space_dh;</div></div><!-- fragment --><p>Then the ones related to the embedded grid, with the <a class="el" href="classDoFHandler.html">DoFHandler</a> associated to the Lagrange multiplier <code>lambda</code></p>
<div class="fragment"><div class="line">std::unique_ptr&lt;Triangulation&lt;dim, spacedim&gt;&gt; embedded_grid;</div><div class="line">std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; embedded_fe;</div><div class="line">std::unique_ptr&lt;DoFHandler&lt;dim, spacedim&gt;&gt;    embedded_dh;</div></div><!-- fragment --><p>And finally, everything that is needed todeform* the embedded triangulation</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; embedded_configuration_fe;</div><div class="line">std::unique_ptr&lt;DoFHandler&lt;dim, spacedim&gt;&gt;    embedded_configuration_dh;</div><div class="line">Vector&lt;double&gt;                                embedded_configuration;</div></div><!-- fragment --><p>The <a class="el" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy</a> class is a "transparent" wrapper derived from both <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> and the type passed as its template parameter. At construction, the arguments are split into two parts: the first argument is an std::string, forwarded to the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class, and containing the name of the section that should be used for this class, while all the remaining arguments are forwarded to the constructor of the templated type, in this case, to the <a class="el" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction</a> constructor. This class allows you to use existing classes in conjunction with the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> registration mechanism, provided that those classes have the members <code>declare_parameters()</code> and <code>parse_parameters()</code>. This is the case here, making it fairly easy to exploit the <a class="el" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction</a> class: instead of requiring users to create new <a class="el" href="classFunction.html">Function</a> objects in their code for the RHS, boundary functions, etc., (like it is done in most of the other tutorials), here we allow the user to use deal.II interface to muParser (<a href="http://muparser.beltoforion.de">http://muparser.beltoforion.de</a>), where the specification of the function is not done at compile time, but at run time, using a string that is parsed into an actual <a class="el" href="classFunction.html">Function</a> object. In this case, the <code>embedded_configuration_function</code> is a vector valued <a class="el" href="classFunction.html">Function</a> that can be interpreted as either adeformation* or adisplacement* according to the boolean value of <code>parameters.use_displacement</code>. The number of components is specified later on in the construction.</p>
<div class="fragment"><div class="line"><a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">  embedded_configuration_function;</div><div class="line"></div><div class="line">std::unique_ptr&lt;Mapping&lt;dim, spacedim&gt;&gt; embedded_mapping;</div></div><!-- fragment --><p>We do the same thing to specify the value of the function \(g\) , which is what we want our solution to be in the embedded space. In this case the <a class="el" href="classFunction.html">Function</a> is a scalar one.</p>
<div class="fragment"><div class="line"><a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">  embedded_value_function;</div></div><!-- fragment --><p>Similarly to what we have done with the <a class="el" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction</a> class, we repeat the same for the <a class="el" href="classReductionControl.html">ReductionControl</a> class, allowing us to specify all possible stopping criteria for the Schur complement iterative solver we'll use later on.</p>
<div class="fragment"><div class="line"><a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;ReductionControl&gt;</a> schur_solver_control;</div></div><!-- fragment --><p>Next we gather all <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>, and <a class="el" href="classVector.html">Vector</a> objects we'll need</p>
<div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a> stiffness_sparsity;</div><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a> coupling_sparsity;</div><div class="line"></div><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> stiffness_matrix;</div><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> coupling_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">Vector&lt;double&gt; solution;</div><div class="line">Vector&lt;double&gt; rhs;</div><div class="line"></div><div class="line">Vector&lt;double&gt; lambda;</div><div class="line">Vector&lt;double&gt; embedded_rhs;</div><div class="line">Vector&lt;double&gt; embedded_value;</div></div><!-- fragment --><p>The <a class="el" href="classTimerOutput.html">TimerOutput</a> class is used to provide some statistics on the performance of our program.</p>
<div class="fragment"><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> monitor;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="DistributedLagrangeProblemParameters"></a> </p><h3>DistributedLagrangeProblem::Parameters</h3>
<p>At construction time, we initialize also the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class, with the section name we want our problem to use when parsing the parameter file. Parameter files can be organized into section/subsection/etc.: this has the advantage that defined objects share parameters when sharing the same section/subsection/etc. <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> allows to specify the section name using Unix conventions on paths. If the section name starts with a slash ("/"), then the section is interpreted as anabsolute path*, <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> enters a subsection for each directory in the path, using the last name it encountered as the landing subsection for the current class. For example, if you construct your class using <code><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>("/first/second/third/My Class")</code>, the parameters will be organized as follows: </p><div class="CodeFragmentInTutorialComment"></div><div class="CodeFragmentInTutorialComment"><div class="fragment"><div class="line"><span class="preprocessor"># Example parameter file</span></div><div class="line">subsection <a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a></div><div class="line">subsection <a class="code" href="grid__out_8cc.html#a2cc229a4f1ffc75e83ed269d5f725729">second</a></div><div class="line">  subsection third</div><div class="line">    subsection My Class</div><div class="line">     ... # all the parameters</div><div class="line">    end</div><div class="line">  end</div><div class="line">end</div><div class="line">end</div></div><!-- fragment --></div><div class="CodeFragmentInTutorialComment"> </div><p> Internally, thecurrent path* stored in <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> is now considered to be "/first/second/third/", i.e. when you specify an absolute path, ParameterAcceptorchanges* the current section to the current path, i.e. to the path of the section name until thelast* "/". You can now construct another class derived from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> using a relative path (e.g., <code><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>("My Other Class")</code>) instead of the absolute one (e.g. <code><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>("/first/second/third/My Other Class")</code>), obtaining: </p><div class="CodeFragmentInTutorialComment"></div><div class="CodeFragmentInTutorialComment"><div class="fragment"><div class="line"><span class="preprocessor"># Example parameter file</span></div><div class="line">subsection <a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a></div><div class="line">subsection <a class="code" href="grid__out_8cc.html#a2cc229a4f1ffc75e83ed269d5f725729">second</a></div><div class="line">  subsection third</div><div class="line">    subsection My Class</div><div class="line">      ... # all the parameters</div><div class="line">    end</div><div class="line">    subsection My Other Class</div><div class="line">      ... # all the parameters of MyOtherClass</div><div class="line">    end</div><div class="line">  end</div><div class="line">end</div><div class="line">end</div></div><!-- fragment --></div><div class="CodeFragmentInTutorialComment"> </div><p> If the section nameends* with a slash then subsequent classes will interpret this as a full path: for example, similar to the one above, if we have two classes, one initialized with <code><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>("/first/second/third/My Class/")</code> and the other with <code><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>("My Other Class")</code>, then the resulting parameter file will look like: </p><div class="CodeFragmentInTutorialComment"></div><div class="CodeFragmentInTutorialComment"><div class="fragment"><div class="line"><span class="preprocessor"># Example parameter file</span></div><div class="line">subsection <a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a></div><div class="line">subsection <a class="code" href="grid__out_8cc.html#a2cc229a4f1ffc75e83ed269d5f725729">second</a></div><div class="line">  subsection third</div><div class="line">    subsection My Class</div><div class="line">      ... # all the parameters of MyClass</div><div class="line">      ... # notice My Class subsection does not end here</div><div class="line">      subsection My Other Class</div><div class="line">        ... # all the parameters of MyOtherClass</div><div class="line">      end # of subsection My Other Class</div><div class="line">    end # of subsection My Class</div><div class="line">  end</div><div class="line">end</div><div class="line">end</div></div><!-- fragment --></div><div class="CodeFragmentInTutorialComment"> </div><p> We are going to exploit this, by making our <code>Parameters</code> theparent* of all subsequently constructed classes. Since most of the other classes are members of <code>DistributedLagrangeProblem</code> this allows, for example, to construct two <code>DistributedLagrangeProblem</code> for two different dimensions, without having conflicts in the parameters for the two problems.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">DistributedLagrangeProblem&lt;dim, spacedim&gt;::Parameters::Parameters()</div><div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Distributed Lagrange&lt;&quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html">Utilities</a>::<a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">int_to_string</a>(dim) + <span class="stringliteral">&quot;,&quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html">Utilities</a>::<a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">int_to_string</a>(spacedim) + <span class="stringliteral">&quot;&gt;/&quot;</span>)</div><div class="line">{</div></div><!-- fragment --><p>The <a class="el" href="classParameterAcceptor.html#af2a534c7f1ea5bfa165fa8a469744a5d">ParameterAcceptor::add_parameter()</a> function does a few things:</p>
<ul>
<li>enters the subsection specified at construction time to <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a></li>
<li>calls the ParameterAcceptor::prm.add_parameter() function</li>
<li>calls any signal you may have attached to <a class="el" href="classParameterAcceptor.html#a1704a7098e692599c254a14c15ab05d2">ParameterAcceptor::declare_parameters_call_back</a></li>
<li>leaves the subsection In turn, ParameterAcceptor::prm.add_parameter</li>
<li>declares an entry in the parameter handler for the given variable;</li>
<li>takes the current value of the variable</li>
<li>transforms it to a string, used as the default value for the parameter file</li>
<li>attaches anaction* to <a class="el" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a> that monitors when a file is parsed, or when an entry is set, and when this happens, it updates the value of the variable passed to <code>add_parameter()</code> by setting it to whatever was specified in the input file (of course, after the input file has been parsed and the text representation converted to the type of the variable).</li>
</ul>
<div class="fragment"><div class="line">add_parameter(<span class="stringliteral">&quot;Initial embedding space refinement&quot;</span>, initial_refinement);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Initial embedded space refinement&quot;</span>,</div><div class="line">              initial_embedded_refinement);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Local refinements steps near embedded domain&quot;</span>,</div><div class="line">              delta_refinement);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Homogeneous Dirichlet boundary ids&quot;</span>,</div><div class="line">              homogeneous_dirichlet_ids);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Use displacement in embedded interface&quot;</span>, use_displacement);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Embedding space finite element degree&quot;</span>,</div><div class="line">              embedding_space_finite_element_degree);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Embedded space finite element degree&quot;</span>,</div><div class="line">              embedded_space_finite_element_degree);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Embedded configuration finite element degree&quot;</span>,</div><div class="line">              embedded_configuration_finite_element_degree);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Coupling quadrature order&quot;</span>, coupling_quadrature_order);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Verbosity level&quot;</span>, verbosity_level);</div></div><!-- fragment --><p>Once the parameter file has been parsed, then the parameters are good to go. Set the internal variable <code>initialized</code> to true.</p>
<div class="fragment"><div class="line">  parse_parameters_call_back.connect([&amp;]()</div><div class="line"></div><div class="line">-&gt; <span class="keywordtype">void</span> { initialized = <span class="keyword">true</span>; });</div><div class="line">}</div></div><!-- fragment --><p>The constructor is pretty standard, with the exception of the <code><a class="el" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy</a></code> objects, as explained earlier.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">DistributedLagrangeProblem&lt;dim, spacedim&gt;::DistributedLagrangeProblem(</div><div class="line">  <span class="keyword">const</span> Parameters &amp;parameters)</div><div class="line">  : parameters(parameters)</div><div class="line">  , embedded_configuration_function(<span class="stringliteral">&quot;Embedded configuration&quot;</span>, spacedim)</div><div class="line">  , embedded_value_function(<span class="stringliteral">&quot;Embedded value&quot;</span>)</div><div class="line">  , schur_solver_control(<span class="stringliteral">&quot;Schur solver control&quot;</span>)</div><div class="line">  , monitor(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::cpu_and_wall_times)</div><div class="line">{</div></div><!-- fragment --><p>Here is a way to set default values for a <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class that was constructed using <a class="el" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy</a>. In this case, we set the default deformation of the embedded grid to be a circle with radius \(R\) and center \((Cx, Cy)\) , we set the default value for the embedded_value_function to be the constant one, and specify some sensible values for the <a class="el" href="classSolverControl.html">SolverControl</a> object. It is fundamental for \(\Gamma\) to be embedded: from the definition of \(C_{\alpha j}\) is clear that, if \(\Gamma \not\subseteq \Omega\) , certain rows of the matrix \(C\) will be zero. This would be a problem, as the Schur complement method requires \(C\) to have full column rank.</p>
<div class="fragment"><div class="line">  embedded_configuration_function.declare_parameters_call_back.connect(</div><div class="line">    []()</div><div class="line"></div><div class="line">-&gt; <span class="keywordtype">void</span> {</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function constants&quot;</span>, <span class="stringliteral">&quot;R=.3, Cx=.4, Cy=.4&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>,</div><div class="line">                                 <span class="stringliteral">&quot;R*cos(2*pi*x)+Cx; R*sin(2*pi*x)+Cy&quot;</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">  embedded_value_function.declare_parameters_call_back.connect(</div><div class="line">    []()</div><div class="line"></div><div class="line">-&gt; <span class="keywordtype">void</span> { <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>); });</div><div class="line"></div><div class="line">  schur_solver_control.declare_parameters_call_back.connect([]()</div><div class="line"></div><div class="line">-&gt; <span class="keywordtype">void</span> {</div><div class="line">    <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Max steps&quot;</span>, <span class="stringliteral">&quot;1000&quot;</span>);</div><div class="line">    <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Reduction&quot;</span>, <span class="stringliteral">&quot;1.e-12&quot;</span>);</div><div class="line">    <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Tolerance&quot;</span>, <span class="stringliteral">&quot;1.e-12&quot;</span>);</div><div class="line">  });</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Setup"></a> </p><h3>Set up</h3>
<p>The function <code>DistributedLagrangeProblem::setup_grids_and_dofs()</code> is used to set up the finite element spaces. Notice how <code>std::make_unique</code> is used to create objects wrapped inside <code>std::unique_ptr</code> objects.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_grids_and_dofs()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Setup grids and dofs&quot;</span>);</div></div><!-- fragment --><p>Initializing \(\Omega\) : constructing the <a class="el" href="classTriangulation.html">Triangulation</a> and wrapping it into a <code>std::unique_ptr</code> object</p>
<div class="fragment"><div class="line">space_grid = std::make_unique&lt;Triangulation&lt;spacedim&gt;&gt;();</div></div><!-- fragment --><p>Next, we actually create the triangulation using <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>. The last argument is set to true: this activates colorization (i.e., assigning different boundary indicators to different parts of the boundary), which we use to assign the Dirichlet and Neumann conditions.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(*space_grid, 0, 1, <span class="keyword">true</span>);</div></div><!-- fragment --><p>Once we constructed a <a class="el" href="classTriangulation.html">Triangulation</a>, we refine it globally according to the specifications in the parameter file, and construct a <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> with it.</p>
<div class="fragment"><div class="line">space_grid-&gt;refine_global(parameters.initial_refinement);</div><div class="line">space_grid_tools_cache =</div><div class="line">  std::make_unique&lt;GridTools::Cache&lt;spacedim, spacedim&gt;&gt;(*space_grid);</div></div><!-- fragment --><p>The same is done with the embedded grid. Since the embedded grid is deformed, we first need to setup the deformation mapping. We do so in the following few lines:</p>
<div class="fragment"><div class="line">embedded_grid = std::make_unique&lt;Triangulation&lt;dim, spacedim&gt;&gt;();</div><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(*embedded_grid);</div><div class="line">embedded_grid-&gt;refine_global(parameters.initial_embedded_refinement);</div><div class="line"></div><div class="line">embedded_configuration_fe = std::make_unique&lt;FESystem&lt;dim, spacedim&gt;&gt;(</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim, spacedim&gt;</a>(</div><div class="line">    parameters.embedded_configuration_finite_element_degree),</div><div class="line">  spacedim);</div><div class="line"></div><div class="line">embedded_configuration_dh =</div><div class="line">  std::make_unique&lt;DoFHandler&lt;dim, spacedim&gt;&gt;(*embedded_grid);</div><div class="line"></div><div class="line">embedded_configuration_dh-&gt;distribute_dofs(*embedded_configuration_fe);</div><div class="line">embedded_configuration.reinit(embedded_configuration_dh-&gt;n_dofs());</div></div><!-- fragment --><p>Once we have defined a finite dimensional space for the deformation, we interpolate the <code>embedded_configuration_function</code> defined in the parameter file :</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(*embedded_configuration_dh,</div><div class="line">                         embedded_configuration_function,</div><div class="line">                         embedded_configuration);</div></div><!-- fragment --><p>Now we can interpret it according to what the user has specified in the parameter file: as a displacement, in which case we construct a mapping thatdisplaces* the position of each support point of our configuration finite element space by the specified amount on the corresponding configuration vector, or as an absolution position. In the first case, the class <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> offers its services, while in the second one, we'll use the class <a class="el" href="classMappingFEField.html">MappingFEField</a>. They are in fact very similar. <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> will only work for systems of <a class="el" href="classFE__Q.html">FE_Q</a> finite element spaces, where the displacement vector is stored in the first <code>spacedim</code> components of the <a class="el" href="classFESystem.html">FESystem</a>, and the degree given as a parameter at construction time, must match the degree of the first <code>spacedim</code> components. The class <a class="el" href="classMappingFEField.html">MappingFEField</a> is slightly more general, in that it allows you to select arbitrary <a class="el" href="classFiniteElement.html">FiniteElement</a> types when constructing your approximation. Naturally some choices may (or may not) make sense, according to the type of <a class="el" href="classFiniteElement.html">FiniteElement</a> you choose. <a class="el" href="classMappingFEField.html">MappingFEField</a> implements the pure iso-parametric concept, and can be used, for example, to implement iso-geometric analysis codes in deal.II, by combining it with the <a class="el" href="classFE__Bernstein.html">FE_Bernstein</a> finite element class. In this example, we'll use the two interchangeably, by taking into account the fact that one configuration will be a <code>displacement</code>, while the other will be an absolute <code>deformation</code> field.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (parameters.use_displacement == <span class="keyword">true</span>)</div><div class="line">  embedded_mapping =</div><div class="line">    std::make_unique&lt;MappingQEulerian&lt;dim, Vector&lt;double&gt;, spacedim&gt;&gt;(</div><div class="line">      parameters.embedded_configuration_finite_element_degree,</div><div class="line">     embedded_configuration_dh,</div><div class="line">      embedded_configuration);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  embedded_mapping =</div><div class="line">    std::make_unique&lt;MappingFEField&lt;dim, spacedim, Vector&lt;double&gt;&gt;&gt;(</div><div class="line">     embedded_configuration_dh, embedded_configuration);</div><div class="line"></div><div class="line">setup_embedded_dofs();</div></div><!-- fragment --><p>In this tutorial program we not only refine \(\Omega\) globally, but also allow a local refinement depending on the position of \(\Gamma\) , according to the value of <code>parameters.delta_refinement</code>, that we use to decide how many rounds of local refinement we should do on \(\Omega\) , corresponding to the position of \(\Gamma\) . With the mapping in place, it is now possible to query what is the location of all support points associated with the <code>embedded_dh</code>, by calling the method <a class="el" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a>. This method has two variants. One that doesnot* take a <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a>, and one that takes a <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a>. If you use the second type, like we are doing in this case, the support points are computed through the specified mapping, which can manipulate them accordingly. This is precisely what the <code>embedded_mapping</code> is there for.</p>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;spacedim&gt;&gt; support_points(embedded_dh-&gt;n_dofs());</div><div class="line"><span class="keywordflow">if</span> (parameters.delta_refinement != 0)</div><div class="line">  <a class="code" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a>(*embedded_mapping,</div><div class="line">                                      embedded_dh,</div><div class="line">                                       support_points);</div></div><!-- fragment --><p>Once we have the support points of the embedded finite element space, we would like to identify what cells of the embedding space contain what support point, to get a chance at refining the embedding grid where it is necessary, i.e., where the embedded grid is. This can be done manually, by looping over each support point, and then calling the method <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell</a> for each cell of the embedding space, until we find one that returns points in the unit reference cell, or it can be done in a more intelligent way. The <a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point</a> is a possible option that performs the above task in a cheaper way, by first identifying the closest vertex of the embedding <a class="el" href="classTriangulation.html">Triangulation</a> to the target point, and then by calling <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell</a> only for those cells that share the found vertex. In fact, there are algorithms in the <a class="el" href="namespaceGridTools.html">GridTools</a> namespace that exploit a <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> object, and possibly a KDTree object to speed up these operations as much as possible. The simplest way to exploit the maximum speed is by calling a specialized method, <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a>, that will store a lot of useful information and data structures during the first point search, and then reuse all of this for subsequent points. <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a> returns a tuple where the first element is a vector of cells containing the input points, in this case support_points. For refinement, this is the only information we need, and this is exactly what happens now. When we need to assemble a coupling matrix, however, we'll also need the reference location of each point to evaluate the basis functions of the embedding space. The other elements of the tuple returned by <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a> allow you to reconstruct, for each point, what cell contains it, and what is the location in the reference cell of the given point. Since this information is better grouped into cells, then this is what the algorithm returns: a tuple, containing a vector of all cells that have at least one point in them, together with a list of all reference points and their corresponding index in the original vector. In the following loop, we will be ignoring all returned objects except the first, identifying all cells contain at least one support point of the embedded space. This allows for a simple adaptive refinement strategy: refining these cells and their neighbors. Notice that we need to do some sanity checks, in the sense that we want to have an embedding grid which is well refined around the embedded grid, but where two consecutive support points lie either in the same cell, or in neighbor embedding cells. This is only possible if we ensure that the smallest cell size of the embedding grid is nonetheless bigger than the largest cell size of the embedded grid. Since users can modify both levels of refinements, as well as the amount of local refinement they want around the embedded grid, we make sure that the resulting meshes satisfy our requirements, and if this is not the case, we bail out with an exception.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; parameters.delta_refinement; ++i)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> point_locations =</div><div class="line">      <a class="code" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a>(*space_grid_tools_cache,</div><div class="line">                                         support_points);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cells = std::get&lt;0&gt;(point_locations);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : cells)</div><div class="line">      {</div><div class="line">        cell-&gt;set_refine_flag();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">          <span class="keywordflow">if</span> (!cell-&gt;at_boundary(face_no))</div><div class="line">            cell-&gt;neighbor(face_no)-&gt;set_refine_flag();</div><div class="line">      }</div><div class="line">    space_grid-&gt;execute_coarsening_and_refinement();</div><div class="line">  }</div></div><!-- fragment --><p>In order to construct a well posed coupling interpolation operator \(C\) , there are some constraints on the relative dimension of the grids between the embedding and the embedded domains. The coupling operator \(C\) and the spaces \(V\) and \(Q\) have to satisfy an inf-sup condition in order for the problem to have a solution. It turns out that the non-matching \(L^2\) projection satisfies such inf-sup, provided that the spaces \(V\) and \(Q\) are compatible between each other (for example, provided that they are chosen to be the ones described in the introduction). However, thediscrete* inf-sup condition must also hold. No complications arise here, but it turns out that the discrete inf-sup constant deteriorates when the non-matching grids have local diameters that are too far away from each other. In particular, it turns out that if you choose an embedding grid which isfiner* with respect to the embedded grid, the inf-sup constant deteriorates much more than if you let the embedded grid be finer. In order to avoid issues, in this tutorial we will throw an exception if the parameters chosen by the user are such that the maximal diameter of the embedded grid is greater than the minimal diameter of the embedding grid. This choice guarantees that almost every cell of the embedded grid spans no more than two cells of the embedding grid, with some rare exceptions, that are negligible in terms of the resulting inf-sup.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> embedded_space_maximal_diameter =</div><div class="line">  <a class="code" href="namespaceGridTools.html#ae8409fa9cb46a0070abc4da7de0f47f2">GridTools::maximal_cell_diameter</a>(*embedded_grid,embedded_mapping);</div><div class="line"><span class="keywordtype">double</span> embedding_space_minimal_diameter =</div><div class="line">  <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(*space_grid);</div><div class="line"></div><div class="line"><a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedding minimal diameter: &quot;</span></div><div class="line">        &lt;&lt; embedding_space_minimal_diameter</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;, embedded maximal diameter: &quot;</span></div><div class="line">        &lt;&lt; embedded_space_maximal_diameter &lt;&lt; <span class="stringliteral">&quot;, ratio: &quot;</span></div><div class="line">        &lt;&lt; embedded_space_maximal_diameter /</div><div class="line">             embedding_space_minimal_diameter</div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(embedded_space_maximal_diameter &lt;</div><div class="line">              embedding_space_minimal_diameter,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">              <span class="stringliteral">&quot;The embedding grid is too refined (or the embedded grid &quot;</span></div><div class="line">              <span class="stringliteral">&quot;is too coarse). Adjust the parameters so that the minimal &quot;</span></div><div class="line">              <span class="stringliteral">&quot;grid size of the embedding grid is larger &quot;</span></div><div class="line">              <span class="stringliteral">&quot;than the maximal grid size of the embedded grid.&quot;</span>));</div></div><!-- fragment --><p>\(\Omega\) has been refined and we can now set up its DoFs</p>
<div class="fragment"><div class="line">  setup_embedding_dofs();</div><div class="line">}</div></div><!-- fragment --><p>We now set up the DoFs of \(\Omega\) and \(\Gamma\) : since they are fundamentally independent (except for the fact that \(\Omega\) 's mesh is more refined "around" \(\Gamma\) ) the procedure is standard.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_embedding_dofs()</div><div class="line">{</div><div class="line">  space_dh = std::make_unique&lt;DoFHandler&lt;spacedim&gt;&gt;(*space_grid);</div><div class="line">  space_fe = std::make_unique&lt;FE_Q&lt;spacedim&gt;&gt;(</div><div class="line">    parameters.embedding_space_finite_element_degree);</div><div class="line">  space_dh-&gt;distribute_dofs(*space_fe);</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(*space_dh, constraints);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keywordtype">id</span> : parameters.homogeneous_dirichlet_ids)</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">       space_dh, <span class="keywordtype">id</span>, <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;spacedim&gt;</a>(), constraints);</div><div class="line">    }</div><div class="line">  constraints.close();</div></div><!-- fragment --><p>By definition the stiffness matrix involves only \(\Omega\) 's DoFs</p>
<div class="fragment"><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(space_dh-&gt;n_dofs(), space_dh-&gt;n_dofs());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(*space_dh, dsp, constraints);</div><div class="line">  stiffness_sparsity.copy_from(dsp);</div><div class="line">  stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(stiffness_sparsity);</div><div class="line">  solution.reinit(space_dh-&gt;n_dofs());</div><div class="line">  rhs.reinit(space_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedding dofs: &quot;</span> &lt;&lt; space_dh-&gt;n_dofs() &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_embedded_dofs()</div><div class="line">{</div><div class="line">  embedded_dh = std::make_unique&lt;DoFHandler&lt;dim, spacedim&gt;&gt;(*embedded_grid);</div><div class="line">  embedded_fe = std::make_unique&lt;FE_Q&lt;dim, spacedim&gt;&gt;(</div><div class="line">    parameters.embedded_space_finite_element_degree);</div><div class="line">  embedded_dh-&gt;distribute_dofs(*embedded_fe);</div></div><!-- fragment --><p>By definition the rhs of the system we're solving involves only a zero vector and \(G\) , which is computed using only \(\Gamma\) 's DoFs</p>
<div class="fragment"><div class="line">  lambda.reinit(embedded_dh-&gt;n_dofs());</div><div class="line">  embedded_rhs.reinit(embedded_dh-&gt;n_dofs());</div><div class="line">  embedded_value.reinit(embedded_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedded dofs: &quot;</span> &lt;&lt; embedded_dh-&gt;n_dofs() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Creating the coupling sparsity pattern is a complex operation, but it can be easily done using the <a class="el" href="namespaceNonMatching.html#a8829bfa8e55c21b8eeaafd086c53680d">NonMatching::create_coupling_sparsity_pattern</a>, which requires the two <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, the quadrature points for the coupling, a <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> (which then needs to be copied into the sparsity one, as usual), the component mask for the embedding and embedded <a class="el" href="classTriangulation.html">Triangulation</a> (which we leave empty) and the mappings for both the embedding and the embedded <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_coupling()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Setup coupling&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quad(parameters.coupling_quadrature_order);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(space_dh-&gt;n_dofs(), embedded_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">  <a class="code" href="namespaceNonMatching.html#a8829bfa8e55c21b8eeaafd086c53680d">NonMatching::create_coupling_sparsity_pattern</a>(*space_grid_tools_cache,</div><div class="line">                                               space_dh,</div><div class="line">                                               embedded_dh,</div><div class="line">                                                quad,</div><div class="line">                                                dsp,</div><div class="line">                                                <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a>(),</div><div class="line">                                                <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                                <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                               embedded_mapping);</div><div class="line">  coupling_sparsity.copy_from(dsp);</div><div class="line">  coupling_matrix.reinit(coupling_sparsity);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assembly"></a> </p><h3>Assembly</h3>
<p>The following function creates the matrices: as noted before computing the stiffness matrix and the rhs is a standard procedure.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Assemble system&quot;</span>);</div></div><!-- fragment --><p>Embedding stiffness matrix \(K\) , and the right hand side \(G\) .</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixTools::create_laplace_matrix</a>(</div><div class="line">   space_dh,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;spacedim&gt;</a>(2 space_fe-&gt;degree + 1),</div><div class="line">    stiffness_matrix,</div><div class="line">    static_cast&lt;<span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;spacedim&gt;</a>&gt;(<span class="keyword">nullptr</span>),</div><div class="line">    constraints);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(*embedded_mapping,</div><div class="line">                                     embedded_dh,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(2 embedded_fe-&gt;degree +</div><div class="line">                                                  1),</div><div class="line">                                      embedded_value_function,</div><div class="line">                                      embedded_rhs);</div><div class="line">}</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Assemble coupling system&quot;</span>);</div></div><!-- fragment --><p>To compute the coupling matrix we use the <a class="el" href="namespaceNonMatching.html#ac3821491559b8a76af0be66736fe4c6f">NonMatching::create_coupling_mass_matrix</a> tool, which works similarly to <a class="el" href="namespaceNonMatching.html#a8829bfa8e55c21b8eeaafd086c53680d">NonMatching::create_coupling_sparsity_pattern</a>.</p>
<div class="fragment"><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quad(parameters.coupling_quadrature_order);</div><div class="line">    <a class="code" href="namespaceNonMatching.html#ac3821491559b8a76af0be66736fe4c6f">NonMatching::create_coupling_mass_matrix</a>(*space_grid_tools_cache,</div><div class="line">                                            space_dh,</div><div class="line">                                            embedded_dh,</div><div class="line">                                             quad,</div><div class="line">                                             coupling_matrix,</div><div class="line">                                             <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a>(),</div><div class="line">                                             <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                             <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                            embedded_mapping);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(*embedded_mapping,</div><div class="line">                            embedded_dh,</div><div class="line">                             embedded_value_function,</div><div class="line">                             embedded_value);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solve"></a> </p><h3>Solve</h3>
<p>All parts have been assembled: we solve the system using the Schur complement method</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Solve system&quot;</span>);</div></div><!-- fragment --><p>Start by creating the inverse stiffness matrix</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> K_inv_umfpack;</div><div class="line">K_inv_umfpack.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(stiffness_matrix);</div></div><!-- fragment --><p>Initializing the operators, as described in the introduction</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> K  = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(stiffness_matrix);</div><div class="line"><span class="keyword">auto</span> Ct = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(coupling_matrix);</div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>  = <a class="code" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a>(Ct);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> K_inv = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K, K_inv_umfpack);</div></div><!-- fragment --><p>Using the Schur complement method</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span>                     S = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a> K_inv Ct;</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver_cg(schur_solver_control);</div><div class="line">  <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S, solver_cg, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  lambda = S_inv embedded_rhs;</div><div class="line"></div><div class="line">  solution = K_inv Ct lambda;</div><div class="line"></div><div class="line">  constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p>The following function simply generates standard result output on two separate files, one for each mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::output_results()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Output results&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;</a> embedding_out;</div><div class="line"></div><div class="line">  std::ofstream embedding_out_file(<span class="stringliteral">&quot;embedding.vtu&quot;</span>);</div><div class="line"></div><div class="line">  embedding_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(*space_dh);</div><div class="line">  embedding_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  embedding_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(</div><div class="line">    parameters.embedding_space_finite_element_degree);</div><div class="line">  embedding_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(embedding_out_file);</div></div><!-- fragment --><p>The only difference between the two output routines is that in the second case, we want to output the data on the current configuration, and not on the reference one. This is possible by passing the actual embedded_mapping to the <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches</a> function. The mapping will take care of outputting the result on the actual deformed configuration.</p>
<div class="fragment"><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;</a> embedded_out;</div><div class="line"></div><div class="line">  std::ofstream embedded_out_file(<span class="stringliteral">&quot;embedded.vtu&quot;</span>);</div><div class="line"></div><div class="line">  embedded_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(*embedded_dh);</div><div class="line">  embedded_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(lambda, <span class="stringliteral">&quot;lambda&quot;</span>);</div><div class="line">  embedded_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(embedded_value, <span class="stringliteral">&quot;g&quot;</span>);</div><div class="line">  embedded_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(*embedded_mapping,</div><div class="line">                             parameters.embedded_space_finite_element_degree);</div><div class="line">  embedded_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(embedded_out_file);</div><div class="line">}</div></div><!-- fragment --><p>Similar to all other tutorial programs, the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function simply calls all other methods in the correct order. Nothing special to note, except that we check if parsing was done before we actually attempt to run our program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">DistributedLagrangeProblem&lt;dim, spacedim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(parameters.initialized, <a class="code" href="group__Exceptions.html#ga426dec8d8185f1410e09a795e0b36e86">ExcNotInitialized</a>());</div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(parameters.verbosity_level);</div><div class="line"></div><div class="line">  setup_grids_and_dofs();</div><div class="line">  setup_coupling();</div><div class="line">  assemble_system();</div><div class="line">  solve();</div><div class="line">  output_results();</div><div class="line">}</div><div class="line">} <span class="comment">// namespace Step60</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv)</div><div class="line">{</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">    <span class="keyword">using namespace </span>Step60;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 1, spacedim = 2;</div></div><!-- fragment --><p>Differently to what happens in other tutorial programs, here we use <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> style of initialization, i.e., all objects are first constructed, and then a single call to the static method <a class="el" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a> is issued to fill all parameters of the classes that are derived from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>. We check if the user has specified a parameter file name to use when the program was launched. If so, try to read that parameter file, otherwise, try to read the file "parameters.prm". If the parameter file that was specified (implicitly or explicitly) does not exist, <a class="el" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a> will create one for you, and exit the program.</p>
<div class="fragment"><div class="line">    DistributedLagrangeProblem&lt;dim, spacedim&gt;::Parameters parameters;</div><div class="line">    DistributedLagrangeProblem&lt;dim, spacedim&gt;             problem(parameters);</div><div class="line"></div><div class="line">    std::string parameter_file;</div><div class="line">    <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">      parameter_file = argv[1];</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      parameter_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(parameter_file, <span class="stringliteral">&quot;used_parameters.prm&quot;</span>);</div><div class="line">    problem.run();</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The directory in which this program is run does not contain a parameter file bydefault. On the other hand, this program wants to read its parameters from afile called parameters.prm</p>
<ul>
<li>and so, when you execute it the first time, youwill get an exception that no such file can be found: <div class="fragment"><div class="line">----------------------------------------------------</div><div class="line">Exception on processing:</div><div class="line"></div><div class="line">--------------------------------------------------------</div><div class="line">An error occurred in line &lt;74&gt; of file &lt;../source/base/parameter_acceptor.cc&gt; in <span class="keyword">function</span></div><div class="line"> <span class="keyword">static</span> void ::ParameterAcceptor::initialize(<span class="keyword">const</span> std::string &amp;, <span class="keyword">const</span> std::string &amp;, <span class="keyword">const</span> <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a>, ::<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;)</div><div class="line">The violated condition was:</div><div class="line"> <span class="keyword">false</span></div><div class="line">Additional information:</div><div class="line"> You specified &lt;parameters.prm&gt; as input parameter file, but it does not exist. We created it <span class="keywordflow">for</span> you.</div><div class="line"></div><div class="line">--------------------------------------------------------</div><div class="line"></div><div class="line">Aborting!</div><div class="line"></div><div class="line">----------------------------------------------------</div></div><!-- fragment --></li>
</ul>
<p>However, as the error message already states, the code that triggers theexception will also generate a parameters.prm file that simply contains thedefault values for all parameters this program cares about. By inspection of theparameter file, we see the following: </p><div class="fragment"><div class="line"><span class="preprocessor"># Listing of Parameters</span></div><div class="line"><span class="preprocessor">#</span></div><div class="line"></div><div class="line">---------------------</div><div class="line">subsection Distributed Lagrange&lt;1,2&gt;</div><div class="line"><span class="keyword">set</span> <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> quadrature order                    = 3</div><div class="line"><span class="keyword">set</span> Embedded configuration finite element degree = 1</div><div class="line"><span class="keyword">set</span> Embedded space finite element degree         = 1</div><div class="line"><span class="keyword">set</span> Embedding space finite element degree        = 1</div><div class="line"><span class="keyword">set</span> Homogeneous Dirichlet boundary ids           = 0, 1, 2, 3</div><div class="line"><span class="keyword">set</span> Initial embedded space refinement            = 7</div><div class="line"><span class="keyword">set</span> Initial embedding space refinement           = 4</div><div class="line"><span class="keyword">set</span> Local refinements steps near embedded domain = 3</div><div class="line"><span class="keyword">set</span> Use displacement in embedded <span class="keyword">interface       </span>= false</div><div class="line"><a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Verbosity level                              = 10</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">subsection Embedded configuration</div><div class="line"><span class="preprocessor"> # Sometimes it is convenient to use symbolic constants in the expression</span></div><div class="line"><span class="preprocessor"> # that describes the function, rather than having to use its numeric value</span></div><div class="line"><span class="preprocessor"> # everywhere the constant appears. These values can be defined using this</span></div><div class="line"><span class="preprocessor"> # parameter, in the form `var1=value1, var2=value2, ...&#39;.</span></div><div class="line"><span class="preprocessor"> #</span></div><div class="line"><span class="preprocessor"> # A typical example would be to set this runtime parameter to</span></div><div class="line"><span class="preprocessor"> # `pi=3.1415926536&#39; and then use `pi&#39; in the expression of the actual</span></div><div class="line"><span class="preprocessor"> # formula. (That said, for convenience this class actually defines both</span></div><div class="line"><span class="preprocessor"> # `pi&#39; and `Pi&#39; by default, but you get the idea.)</span></div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  = R=.3, Cx=.4, Cy=.4                 # <span class="keywordflow">default</span>:</div><div class="line"></div><div class="line"><span class="preprocessor"> # The formula that denotes the function you want to evaluate for</span></div><div class="line"><span class="preprocessor"> # particular values of the independent variables. This expression may</span></div><div class="line"><span class="preprocessor"> # contain any of the usual operations such as addition or multiplication,</span></div><div class="line"><span class="preprocessor"> # as well as all of the common functions such as `sin&#39; or `cos&#39;. In</span></div><div class="line"><span class="preprocessor"> # addition, it may contain expressions like `if(x&gt;0, 1,</span></div><div class="line"></div><div class="line">-1)<span class="stringliteral">&#39; where the</span></div><div class="line"><span class="stringliteral"> # expression evaluates to the second argument if the first argument is</span></div><div class="line"><span class="stringliteral"> # true, and to the third argument otherwise. For a full overview of</span></div><div class="line"><span class="stringliteral"> # possible expressions accepted see the documentation of the muparser</span></div><div class="line"><span class="stringliteral"> # library at http://muparser.beltoforion.de/.</span></div><div class="line"><span class="stringliteral"> #</span></div><div class="line"><span class="stringliteral"> # If the function you are describing represents a vector-valued function</span></div><div class="line"><span class="stringliteral"> # with multiple components, then separate the expressions for individual</span></div><div class="line"><span class="stringliteral"> # components by a semicolon.</span></div><div class="line"><span class="stringliteral"> set Function expression = R*cos(2*pi*x)+Cx; R*sin(2*pi*x)+Cy # default: 0</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"> # The names of the variables as they will be used in the function,</span></div><div class="line"><span class="stringliteral"> # separated by commas. By default, the names of variables at which the</span></div><div class="line"><span class="stringliteral"> # function will be evaluated are `x&#39;</span> (in 1d), `x,y<span class="stringliteral">&#39; (in 2d) or `x,y,z&#39;</span> (in</div><div class="line"><span class="preprocessor"> # 3d) for spatial coordinates and `t&#39; for time. You can then use these</span></div><div class="line"><span class="preprocessor"> # variable names in your function expression and they will be replaced by</span></div><div class="line"><span class="preprocessor"> # the values of these variables at which the function is currently</span></div><div class="line"><span class="preprocessor"> # evaluated. However, you can also choose a different set of names for the</span></div><div class="line"><span class="preprocessor"> # independent variables at which to evaluate your function expression. For</span></div><div class="line"><span class="preprocessor"> # example, if you work in spherical coordinates, you may wish to set this</span></div><div class="line"><span class="preprocessor"> # input parameter to `r,phi,theta,t&#39; and then use these variable names in</span></div><div class="line"><span class="preprocessor"> # your function expression.</span></div><div class="line"> <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">end</div><div class="line"></div><div class="line">subsection Embedded value</div><div class="line"><span class="preprocessor"> # Sometimes it is convenient to use symbolic constants in the expression</span></div><div class="line"><span class="preprocessor"> # that describes the function, rather than having to use its numeric value</span></div><div class="line"><span class="preprocessor"> # everywhere the constant appears. These values can be defined using this</span></div><div class="line"><span class="preprocessor"> # parameter, in the form `var1=value1, var2=value2, ...&#39;.</span></div><div class="line"><span class="preprocessor"> #</span></div><div class="line"><span class="preprocessor"> # A typical example would be to set this runtime parameter to</span></div><div class="line"><span class="preprocessor"> # `pi=3.1415926536&#39; and then use `pi&#39; in the expression of the actual</span></div><div class="line"><span class="preprocessor"> # formula. (That said, for convenience this class actually defines both</span></div><div class="line"><span class="preprocessor"> # `pi&#39; and `Pi&#39; by default, but you get the idea.)</span></div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line"></div><div class="line"><span class="preprocessor"> # The formula that denotes the function you want to evaluate for</span></div><div class="line"><span class="preprocessor"> # particular values of the independent variables. This expression may</span></div><div class="line"><span class="preprocessor"> # contain any of the usual operations such as addition or multiplication,</span></div><div class="line"><span class="preprocessor"> # as well as all of the common functions such as `sin&#39; or `cos&#39;. In</span></div><div class="line"><span class="preprocessor"> # addition, it may contain expressions like `if(x&gt;0, 1,</span></div><div class="line"></div><div class="line">-1)<span class="stringliteral">&#39; where the</span></div><div class="line"><span class="stringliteral"> # expression evaluates to the second argument if the first argument is</span></div><div class="line"><span class="stringliteral"> # true, and to the third argument otherwise. For a full overview of</span></div><div class="line"><span class="stringliteral"> # possible expressions accepted see the documentation of the muparser</span></div><div class="line"><span class="stringliteral"> # library at http://muparser.beltoforion.de/.</span></div><div class="line"><span class="stringliteral"> #</span></div><div class="line"><span class="stringliteral"> # If the function you are describing represents a vector-valued function</span></div><div class="line"><span class="stringliteral"> # with multiple components, then separate the expressions for individual</span></div><div class="line"><span class="stringliteral"> # components by a semicolon.</span></div><div class="line"><span class="stringliteral"> set Function expression = 1     # default: 0</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral"> # The names of the variables as they will be used in the function,</span></div><div class="line"><span class="stringliteral"> # separated by commas. By default, the names of variables at which the</span></div><div class="line"><span class="stringliteral"> # function will be evaluated are `x&#39;</span> (in 1d), `x,y<span class="stringliteral">&#39; (in 2d) or `x,y,z&#39;</span> (in</div><div class="line"><span class="preprocessor"> # 3d) for spatial coordinates and `t&#39; for time. You can then use these</span></div><div class="line"><span class="preprocessor"> # variable names in your function expression and they will be replaced by</span></div><div class="line"><span class="preprocessor"> # the values of these variables at which the function is currently</span></div><div class="line"><span class="preprocessor"> # evaluated. However, you can also choose a different set of names for the</span></div><div class="line"><span class="preprocessor"> # independent variables at which to evaluate your function expression. For</span></div><div class="line"><span class="preprocessor"> # example, if you work in spherical coordinates, you may wish to set this</span></div><div class="line"><span class="preprocessor"> # input parameter to `r,phi,theta,t&#39; and then use these variable names in</span></div><div class="line"><span class="preprocessor"> # your function expression.</span></div><div class="line"> <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">end</div><div class="line"></div><div class="line">subsection Schur solver control</div><div class="line"> <span class="keyword">set</span> Log frequency = 1</div><div class="line"> <span class="keyword">set</span> Log history   = <span class="keyword">false</span></div><div class="line"> <span class="keyword">set</span> Log result    = <span class="keyword">true</span></div><div class="line"> <span class="keyword">set</span> Max steps     = 1000   # <span class="keywordflow">default</span>: 100</div><div class="line"> <span class="keyword">set</span> Reduction     = 1.e-12 # <span class="keywordflow">default</span>: 1.e-2</div><div class="line"> <span class="keyword">set</span> Tolerance     = 1.e-12 # <span class="keywordflow">default</span>: 1.e-10</div><div class="line">end</div><div class="line"></div><div class="line">end</div></div><!-- fragment --><p>If you now run the program, you will get a file called <code>used_parameters.prm</code>,containing a shorter version of the above parameters (without comments anddocumentation), documenting all parameters that were used to run your program: </p><div class="fragment"><div class="line"><span class="preprocessor"># Parameter file generated with</span></div><div class="line"><span class="preprocessor"># DEAL_II_PACKAGE_VERSION = 9.0.0</span></div><div class="line">subsection Distributed Lagrange&lt;1,2&gt;</div><div class="line"><span class="keyword">set</span> <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> quadrature order                    = 3</div><div class="line"><span class="keyword">set</span> Embedded configuration finite element degree = 1</div><div class="line"><span class="keyword">set</span> Embedded space finite element degree         = 1</div><div class="line"><span class="keyword">set</span> Embedding space finite element degree        = 1</div><div class="line"><span class="keyword">set</span> Homogeneous Dirichlet boundary ids           = 0, 1, 2, 3</div><div class="line"><span class="keyword">set</span> Initial embedded space refinement            = 7</div><div class="line"><span class="keyword">set</span> Initial embedding space refinement           = 4</div><div class="line"><span class="keyword">set</span> Local refinements steps near embedded domain = 3</div><div class="line"><span class="keyword">set</span> Use displacement in embedded <span class="keyword">interface       </span>= false</div><div class="line"><a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Verbosity level                              = 10</div><div class="line">subsection Embedded configuration</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  = R=.3, Cx=.4, Cy=.4</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = R*<a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(2*pi*x)+Cx; R*<a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(2*pi*x)+Cy</div><div class="line"> <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">end</div><div class="line">subsection Embedded value</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 1</div><div class="line"> <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">end</div><div class="line">subsection Schur solver control</div><div class="line"> <span class="keyword">set</span> Log frequency = 1</div><div class="line"> <span class="keyword">set</span> Log history   = <span class="keyword">false</span></div><div class="line"> <span class="keyword">set</span> Log result    = <span class="keyword">true</span></div><div class="line"> <span class="keyword">set</span> Max steps     = 1000</div><div class="line"> <span class="keyword">set</span> Reduction     = 1.e-12</div><div class="line"> <span class="keyword">set</span> Tolerance     = 1.e-12</div><div class="line">end</div><div class="line">end</div></div><!-- fragment --><p>The rationale behind creating first <code>parameters.prm</code> file (the first time theprogram is run) and then a <code>used_parameters.prm</code> (every other times you run theprogram), is because you may want to leave most parameters to their defaultvalues, and only modify a handful of them. For example, you could use the following (perfectly valid) parameter file withthis tutorial program: </p><div class="fragment"><div class="line">subsection Distributed Lagrange&lt;1,2&gt;</div><div class="line"><span class="keyword">set</span> Initial embedded space refinement            = 7</div><div class="line"><span class="keyword">set</span> Initial embedding space refinement           = 4</div><div class="line"><span class="keyword">set</span> Local refinements steps near embedded domain = 3</div><div class="line">subsection Embedded configuration</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  = R=.3, Cx=.4, Cy=.4</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = R*<a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(2*pi*x)+Cx; R*<a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(2*pi*x)+Cy</div><div class="line"> <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">end</div><div class="line">subsection Embedded value</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 1</div><div class="line"> <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">end</div><div class="line">end</div></div><!-- fragment --><p>and you would obtain exactly the same results as in test case 1 below. <a class="anchor" id="Testcase1"></a></p><h3>Test case 1: </h3>
<p>For the default problem the value of \(u\) on \(\Gamma\) is set to the constant \(1\) :this is like imposing a constant Dirichlet boundary condition on \(\Gamma\) , seenas boundary of the portion of \(\Omega\) inside \(\Gamma\) . Similarly on \(\partial \Omega\) we have zero Dirichlet boundary conditions.</p>
<div class="twocolumn" style="width: 80%"> <div class="parent"> <div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.1_no_grid.png" width="500"/>
</div>
 </div> </div> <div class="parent"> <div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.1_grid.png" width="500"/>
</div>
 </div> </div> </div><p> The output of the program will look like the following: </p><div class="fragment"><div class="line">DEAL::Embedded dofs: 129</div><div class="line">DEAL::Embedding minimal <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">diameter</a>: 0.0110485, embedded maximal <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">diameter</a>: 0.00781250, ratio: 0.707107</div><div class="line">DEAL::Embedding dofs: 2429</div><div class="line">DEAL:cg::Starting value 0.166266</div><div class="line">DEAL:cg::Convergence step 108 value 7.65958e-13</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total CPU time elapsed since start          |     0.586s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  CPU time  | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble coupling system        |         1 |     0.132s |        23% |</div><div class="line">| Assemble system                 |         1 |    0.0733s |        12% |</div><div class="line">| Output results                  |         1 |     0.087s |        15% |</div><div class="line">| Setup coupling                  |         1 |    0.0244s |       4.2% |</div><div class="line">| Setup grids and dofs            |         1 |    0.0907s |        15% |</div><div class="line">| Solve system                    |         1 |     0.178s |        30% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |     0.301s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble coupling system        |         1 |    0.0385s |        13% |</div><div class="line">| Assemble system                 |         1 |    0.0131s |       4.3% |</div><div class="line">| Output results                  |         1 |    0.0736s |        24% |</div><div class="line">| Setup coupling                  |         1 |    0.0234s |       7.7% |</div><div class="line">| Setup grids and dofs            |         1 |    0.0679s |        23% |</div><div class="line">| Solve system                    |         1 |    0.0832s |        28% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>You may notice that, in terms of CPU time, assembling the coupling system istwice as expensive as assembling the standard Poisson system, even though thematrix is smaller. This is due to the non-matching nature of the discretization.Whether this is acceptable or not, depends on the applications. If the problem was set in a three-dimensional setting, and the immersed mesh wastime dependent, it would be much more expensive to recreate the mesh at eachstep rather than use the technique we present here. Moreover, you may be able tocreate a very fast and optimized solver on a uniformly refined square or cubicgrid, and embed the domain where you want to perform your computation using thetechnique presented here. This would require you to only have a surfacerepresentatio of your domain (a much cheaper and easier mesh to produce). To play around a little bit, we are going to complicate a little the fictitiousdomain as well as the boundary conditions we impose on it. <a class="anchor" id="Testcase2and3"></a></p><h3>Test case 2 and 3: </h3>
<p>If we use the following parameter file : </p><div class="fragment"><div class="line">subsection Distributed Lagrange&lt;1,2&gt;</div><div class="line"><span class="keyword">set</span> <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> quadrature order                    = 3</div><div class="line"><span class="keyword">set</span> Embedded configuration finite element degree = 1</div><div class="line"><span class="keyword">set</span> Embedded space finite element degree         = 1</div><div class="line"><span class="keyword">set</span> Embedding space finite element degree        = 1</div><div class="line"><span class="keyword">set</span> Homogeneous Dirichlet boundary ids           = 0,1,2,3</div><div class="line"><span class="keyword">set</span> Initial embedded space refinement            = 8</div><div class="line"><span class="keyword">set</span> Initial embedding space refinement           = 4</div><div class="line"><span class="keyword">set</span> Local refinements steps near embedded domain = 4</div><div class="line"><span class="keyword">set</span> Use displacement in embedded <span class="keyword">interface       </span>= false</div><div class="line"><a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Verbosity level                              = 10</div><div class="line">subsection Embedded configuration</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  = R=.3, Cx=.5, Cy=.5, r=.1, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6b25dd8f005063d8d2b0a4bdb0d277f3">w</a>=12</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = (R+r*<a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6b25dd8f005063d8d2b0a4bdb0d277f3">w</a>*pi*x))*<a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(2*pi*x)+Cx; (R+r*<a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6b25dd8f005063d8d2b0a4bdb0d277f3">w</a>*pi*x))*<a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(2*pi*x)+Cy</div><div class="line"> <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">end</div><div class="line">subsection Embedded value</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = x-.5</div><div class="line"> <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">end</div><div class="line">subsection Schur solver control</div><div class="line"> <span class="keyword">set</span> Log frequency = 1</div><div class="line"> <span class="keyword">set</span> Log history   = <span class="keyword">false</span></div><div class="line"> <span class="keyword">set</span> Log result    = <span class="keyword">true</span></div><div class="line"> <span class="keyword">set</span> Max steps     = 100000</div><div class="line"> <span class="keyword">set</span> Reduction     = 1.e-12</div><div class="line"> <span class="keyword">set</span> Tolerance     = 1.e-12</div><div class="line">end</div><div class="line">end</div></div><!-- fragment --><p>We get a "flowery" looking domain, where we impose a linear boundary condition \(g=x-.5\) . This test shows that the method is actually quite accurate inrecovering an exactly linear function from its boundary conditions, and eventhough the meshes are not aligned, we obtain a pretty good result. Replacing \(x-.5\) with \(2(x-.5)^2-2(y-.5)^2\) , i.e., modifying the parameter filesuch that we have </p><div class="fragment"><div class="line">...</div><div class="line">subsection Embedded value</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line"> <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 2*(x-.5)^2-2*(y-.5)^2</div><div class="line"> <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">end</div></div><!-- fragment --><p> produces the saddle on the right. </p><div class="twocolumn" style="width:
 80%"> <div class="parent"> <div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.3_grid.png" width="500"/>
</div>
 </div> </div> <div class="parent"> <div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.4_grid.png" width="500"/>
</div>
 </div> </div> </div><p> <a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Runningwithspacedimequaltothree"></a></p><h4>Running with <code>spacedim</code> equal to three</h4>
<p>While the current tutorial program is written for <code>spacedim</code> equal to two, thereare only minor changes you have to do in order for the program to run indifferent combinations of dimensions. If you want to run with <code>spacedim</code> equal to three and <code>dim</code> equal to two, thenyou will almost certainly want to perform the following changes:</p>
<ul>
<li>use a different reference domain for the embedded grid, maybe reading it from a file. It is not possible to construct a smooth closed surface with one single parametrization of a square domain, therefore you'll most likely want to use a reference domain that is topologically equivalent to a the boundary of a sphere.</li>
<li>use a displacement instead of the deformation to map \(\Gamma_0\) into \(\Gamma\) <a class="anchor" id="Moregeneraldomains"></a><h4>More general domains </h4>
</li>
</ul>
<p>We have seen in other tutorials (for example in <a class="el" href="step_5.html">step-5</a> and <a class="el" href="step_54.html">step-54</a> ) how to readgrids from input files. A nice generalization for this tutorial program would beto allow the user to select a grid to read from the parameter file itself,instead of hardcoding the mesh type in the tutorial program itself. <a class="anchor" id="Preconditioner"></a></p><h4>Preconditioner</h4>
<p>At the moment, we have no preconditioner on the Schur complement. This is ok fortwo dimensional problems, where a few hundred iterations bring the residual downto the machine precision, but it's not going to work in three dimensions. It is not obvious what a good preconditioner would be here. The physical problemwe are solving with the Schur complement, is to associate to the Dirichlet data \(g\) , the value of the Lagrange multiplier \(\lambda\) . \(\lambda\) can beinterpreted as thejump* in the normal gradient that needs to be imposed on \(u\) across \(\Gamma\) , in order to obtain the Dirichlet data \(g\) . So \(S\) is some sort of Neumann to Dirichlet map, and we would like to have agood approximation for the Dirichlet to Neumann map. A possibility would be touse a Boundary Element approximation of the problem on \(\Gamma\) , and construct arough approximation of the hyper-singular operator for the Poisson problemassociated to \(\Gamma\) , which is precisely a Dirichlet to Neumann map. <a class="anchor" id="ParallelCode"></a></p><h4>Parallel Code </h4>
<p>The simple code proposed here can serve as a starting point for morecomplex problems which, to be solved, need to be run on parallelcode, possibly using distributed meshes (see <a class="el" href="step_17.html">step-17</a> , <a class="el" href="step_40.html">step-40</a> , and thedocumentation for <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> and <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>). When using non-matching grids in parallel a problem arises: to compute thematrix \(C\) a process needs information about both meshes on the same portion ofreal space but, when working with distributed meshes, this information may notbe available, because the locally owned part of the \(\Omega\) triangulationstored on a given processor may not be physically co-located with the locallyowned part of the \(\Gamma\) triangulation stored on the same processor. Various strategies can be implemented to tackle this problem:</p>
<ul>
<li>distribute the two meshes so that this constraint is satisfied;</li>
<li>use communication for the parts of real space where the constraint is not satisfied;</li>
<li>use a distributed triangulation for the embedding space, and a shared triangulation for the emdedded configuration. The latter strategy is clearly the easiest to implement, as most of thefunctions used in this tutorial program will work unchanged also in the parallelcase. Of course one could use the reversal strategy (that is, have a distributedembedded <a class="el" href="classTriangulation.html">Triangulation</a> and a shared embedding <a class="el" href="classTriangulation.html">Triangulation</a>). However, this strategy is most likely going to be more expensive, since bydefinition the embedding grid is larger than the embedded grid, and it makesmore sense to distribute the largest of the two grids, maintaining the smallestone shared among all processors.</li>
</ul>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2018 - 2020 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Luca Heltai, Giovanni Alzetta,</span></div><div class="line"><span class="comment"> * International School for Advanced Studies, Trieste, 2018</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools__cache_8h.html">deal.II/grid/grid_tools_cache.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2fe_2fe_8h.html">deal.II/fe/fe.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__eulerian_8h.html">deal.II/fe/mapping_q_eulerian.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__fe__field_8h.html">deal.II/fe/mapping_fe_field.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parsed__function_8h.html">deal.II/base/parsed_function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="coupling_8h.html">deal.II/non_matching/coupling.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step60</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line">  <span class="keyword">class </span>DistributedLagrangeProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">class </span>Parameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Parameters();</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement = 4;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> delta_refinement = 3;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_embedded_refinement = 8;</div><div class="line"></div><div class="line">      std::list&lt;types::boundary_id&gt; homogeneous_dirichlet_ids{0, 1, 2, 3};</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedding_space_finite_element_degree = 1;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedded_space_finite_element_degree = 1;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedded_configuration_finite_element_degree = 1;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> coupling_quadrature_order = 3;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> use_displacement = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> verbosity_level = 10;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">    };</div><div class="line"></div><div class="line">    DistributedLagrangeProblem(<span class="keyword">const</span> Parameters &amp;parameters);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Parameters &amp;parameters;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_grids_and_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_embedding_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_embedded_dofs();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_coupling();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    std::unique_ptr&lt;Triangulation&lt;spacedim&gt;&gt; space_grid;</div><div class="line">    std::unique_ptr&lt;GridTools::Cache&lt;spacedim, spacedim&gt;&gt;</div><div class="line">                                             space_grid_tools_cache;</div><div class="line">    std::unique_ptr&lt;FiniteElement&lt;spacedim&gt;&gt; space_fe;</div><div class="line">    std::unique_ptr&lt;DoFHandler&lt;spacedim&gt;&gt;    space_dh;</div><div class="line"></div><div class="line"></div><div class="line">    std::unique_ptr&lt;Triangulation&lt;dim, spacedim&gt;&gt; embedded_grid;</div><div class="line">    std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; embedded_fe;</div><div class="line">    std::unique_ptr&lt;DoFHandler&lt;dim, spacedim&gt;&gt;    embedded_dh;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; embedded_configuration_fe;</div><div class="line">    std::unique_ptr&lt;DoFHandler&lt;dim, spacedim&gt;&gt;    embedded_configuration_dh;</div><div class="line">    Vector&lt;double&gt;                                embedded_configuration;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">      embedded_configuration_function;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;Mapping&lt;dim, spacedim&gt;&gt; embedded_mapping;</div><div class="line"></div><div class="line">    <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">      embedded_value_function;</div><div class="line"></div><div class="line">    <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;ReductionControl&gt;</a> schur_solver_control;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a> stiffness_sparsity;</div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a> coupling_sparsity;</div><div class="line"></div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> stiffness_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> coupling_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; rhs;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; lambda;</div><div class="line">    Vector&lt;double&gt; embedded_rhs;</div><div class="line">    Vector&lt;double&gt; embedded_value;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> monitor;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  DistributedLagrangeProblem&lt;dim, spacedim&gt;::Parameters::Parameters()</div><div class="line">    : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Distributed Lagrange&lt;&quot;</span> +</div><div class="line">                        <a class="code" href="namespaceUtilities.html">Utilities</a>::<a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">int_to_string</a>(dim) + <span class="stringliteral">&quot;,&quot;</span> +</div><div class="line">                        <a class="code" href="namespaceUtilities.html">Utilities</a>::<a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">int_to_string</a>(spacedim) + <span class="stringliteral">&quot;&gt;/&quot;</span>)</div><div class="line">  {</div><div class="line">    add_parameter(<span class="stringliteral">&quot;Initial embedding space refinement&quot;</span>, initial_refinement);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Initial embedded space refinement&quot;</span>,</div><div class="line">                  initial_embedded_refinement);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Local refinements steps near embedded domain&quot;</span>,</div><div class="line">                  delta_refinement);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Homogeneous Dirichlet boundary ids&quot;</span>,</div><div class="line">                  homogeneous_dirichlet_ids);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Use displacement in embedded interface&quot;</span>, use_displacement);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Embedding space finite element degree&quot;</span>,</div><div class="line">                  embedding_space_finite_element_degree);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Embedded space finite element degree&quot;</span>,</div><div class="line">                  embedded_space_finite_element_degree);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Embedded configuration finite element degree&quot;</span>,</div><div class="line">                  embedded_configuration_finite_element_degree);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Coupling quadrature order&quot;</span>, coupling_quadrature_order);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Verbosity level&quot;</span>, verbosity_level);</div><div class="line"></div><div class="line">    parse_parameters_call_back.connect([&amp;]() -&gt; <span class="keywordtype">void</span> { initialized = <span class="keyword">true</span>; });</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  DistributedLagrangeProblem&lt;dim, spacedim&gt;::DistributedLagrangeProblem(</div><div class="line">    <span class="keyword">const</span> Parameters &amp;parameters)</div><div class="line">    : parameters(parameters)</div><div class="line">    , embedded_configuration_function(<span class="stringliteral">&quot;Embedded configuration&quot;</span>, spacedim)</div><div class="line">    , embedded_value_function(<span class="stringliteral">&quot;Embedded value&quot;</span>)</div><div class="line">    , schur_solver_control(<span class="stringliteral">&quot;Schur solver control&quot;</span>)</div><div class="line">    , monitor(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::cpu_and_wall_times)</div><div class="line">  {</div><div class="line">    embedded_configuration_function.declare_parameters_call_back.connect(</div><div class="line">      []() -&gt; <span class="keywordtype">void</span> {</div><div class="line">        <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function constants&quot;</span>, <span class="stringliteral">&quot;R=.3, Cx=.4, Cy=.4&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line">        <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>,</div><div class="line">                                   <span class="stringliteral">&quot;R*cos(2*pi*x)+Cx; R*sin(2*pi*x)+Cy&quot;</span>);</div><div class="line">      });</div><div class="line"></div><div class="line">    embedded_value_function.declare_parameters_call_back.connect(</div><div class="line">      []() -&gt; <span class="keywordtype">void</span> { <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>); });</div><div class="line"></div><div class="line">    schur_solver_control.declare_parameters_call_back.connect([]() -&gt; <span class="keywordtype">void</span> {</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Max steps&quot;</span>, <span class="stringliteral">&quot;1000&quot;</span>);</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Reduction&quot;</span>, <span class="stringliteral">&quot;1.e-12&quot;</span>);</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Tolerance&quot;</span>, <span class="stringliteral">&quot;1.e-12&quot;</span>);</div><div class="line">    });</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_grids_and_dofs()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Setup grids and dofs&quot;</span>);</div><div class="line"></div><div class="line">    space_grid = std::make_unique&lt;Triangulation&lt;spacedim&gt;&gt;();</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(*space_grid, 0, 1, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    space_grid-&gt;refine_global(parameters.initial_refinement);</div><div class="line">    space_grid_tools_cache =</div><div class="line">      std::make_unique&lt;GridTools::Cache&lt;spacedim, spacedim&gt;&gt;(*space_grid);</div><div class="line"></div><div class="line">    embedded_grid = std::make_unique&lt;Triangulation&lt;dim, spacedim&gt;&gt;();</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(*embedded_grid);</div><div class="line">    embedded_grid-&gt;refine_global(parameters.initial_embedded_refinement);</div><div class="line"></div><div class="line">    embedded_configuration_fe = std::make_unique&lt;FESystem&lt;dim, spacedim&gt;&gt;(</div><div class="line">      <a class="code" href="classFE__Q.html">FE_Q&lt;dim, spacedim&gt;</a>(</div><div class="line">        parameters.embedded_configuration_finite_element_degree),</div><div class="line">      spacedim);</div><div class="line"></div><div class="line">    embedded_configuration_dh =</div><div class="line">      std::make_unique&lt;DoFHandler&lt;dim, spacedim&gt;&gt;(*embedded_grid);</div><div class="line"></div><div class="line">    embedded_configuration_dh-&gt;distribute_dofs(*embedded_configuration_fe);</div><div class="line">    embedded_configuration.reinit(embedded_configuration_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(*embedded_configuration_dh,</div><div class="line">                             embedded_configuration_function,</div><div class="line">                             embedded_configuration);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (parameters.use_displacement == <span class="keyword">true</span>)</div><div class="line">      embedded_mapping =</div><div class="line">        std::make_unique&lt;MappingQEulerian&lt;dim, Vector&lt;double&gt;, spacedim&gt;&gt;(</div><div class="line">          parameters.embedded_configuration_finite_element_degree,</div><div class="line">          *embedded_configuration_dh,</div><div class="line">          embedded_configuration);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      embedded_mapping =</div><div class="line">        std::make_unique&lt;MappingFEField&lt;dim, spacedim, Vector&lt;double&gt;&gt;&gt;(</div><div class="line">          *embedded_configuration_dh, embedded_configuration);</div><div class="line"></div><div class="line">    setup_embedded_dofs();</div><div class="line"></div><div class="line">    std::vector&lt;Point&lt;spacedim&gt;&gt; support_points(embedded_dh-&gt;n_dofs());</div><div class="line">    <span class="keywordflow">if</span> (parameters.delta_refinement != 0)</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a>(*embedded_mapping,</div><div class="line">                                           *embedded_dh,</div><div class="line">                                           support_points);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; parameters.delta_refinement; ++i)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> point_locations =</div><div class="line">          <a class="code" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a>(*space_grid_tools_cache,</div><div class="line">                                             support_points);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cells = std::get&lt;0&gt;(point_locations);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : cells)</div><div class="line">          {</div><div class="line">            cell-&gt;set_refine_flag();</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">              <span class="keywordflow">if</span> (!cell-&gt;at_boundary(face_no))</div><div class="line">                cell-&gt;neighbor(face_no)-&gt;set_refine_flag();</div><div class="line">          }</div><div class="line">        space_grid-&gt;execute_coarsening_and_refinement();</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> embedded_space_maximal_diameter =</div><div class="line">      <a class="code" href="namespaceGridTools.html#ae8409fa9cb46a0070abc4da7de0f47f2">GridTools::maximal_cell_diameter</a>(*embedded_grid, *embedded_mapping);</div><div class="line">    <span class="keywordtype">double</span> embedding_space_minimal_diameter =</div><div class="line">      <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(*space_grid);</div><div class="line"></div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedding minimal diameter: &quot;</span></div><div class="line">            &lt;&lt; embedding_space_minimal_diameter</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;, embedded maximal diameter: &quot;</span></div><div class="line">            &lt;&lt; embedded_space_maximal_diameter &lt;&lt; <span class="stringliteral">&quot;, ratio: &quot;</span></div><div class="line">            &lt;&lt; embedded_space_maximal_diameter /</div><div class="line">                 embedding_space_minimal_diameter</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(embedded_space_maximal_diameter &lt;</div><div class="line">                  embedding_space_minimal_diameter,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                  <span class="stringliteral">&quot;The embedding grid is too refined (or the embedded grid &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;is too coarse). Adjust the parameters so that the minimal &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;grid size of the embedding grid is larger &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;than the maximal grid size of the embedded grid.&quot;</span>));</div><div class="line"></div><div class="line">    setup_embedding_dofs();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_embedding_dofs()</div><div class="line">  {</div><div class="line">    space_dh = std::make_unique&lt;DoFHandler&lt;spacedim&gt;&gt;(*space_grid);</div><div class="line">    space_fe = std::make_unique&lt;FE_Q&lt;spacedim&gt;&gt;(</div><div class="line">      parameters.embedding_space_finite_element_degree);</div><div class="line">    space_dh-&gt;distribute_dofs(*space_fe);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(*space_dh, constraints);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keywordtype">id</span> : parameters.homogeneous_dirichlet_ids)</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">          *space_dh, <span class="keywordtype">id</span>, <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;spacedim&gt;</a>(), constraints);</div><div class="line">      }</div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(space_dh-&gt;n_dofs(), space_dh-&gt;n_dofs());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(*space_dh, dsp, constraints);</div><div class="line">    stiffness_sparsity.copy_from(dsp);</div><div class="line">    stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(stiffness_sparsity);</div><div class="line">    solution.reinit(space_dh-&gt;n_dofs());</div><div class="line">    rhs.reinit(space_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedding dofs: &quot;</span> &lt;&lt; space_dh-&gt;n_dofs() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_embedded_dofs()</div><div class="line">  {</div><div class="line">    embedded_dh = std::make_unique&lt;DoFHandler&lt;dim, spacedim&gt;&gt;(*embedded_grid);</div><div class="line">    embedded_fe = std::make_unique&lt;FE_Q&lt;dim, spacedim&gt;&gt;(</div><div class="line">      parameters.embedded_space_finite_element_degree);</div><div class="line">    embedded_dh-&gt;distribute_dofs(*embedded_fe);</div><div class="line"></div><div class="line">    lambda.reinit(embedded_dh-&gt;n_dofs());</div><div class="line">    embedded_rhs.reinit(embedded_dh-&gt;n_dofs());</div><div class="line">    embedded_value.reinit(embedded_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedded dofs: &quot;</span> &lt;&lt; embedded_dh-&gt;n_dofs() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_coupling()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Setup coupling&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quad(parameters.coupling_quadrature_order);</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(space_dh-&gt;n_dofs(), embedded_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceNonMatching.html#a8829bfa8e55c21b8eeaafd086c53680d">NonMatching::create_coupling_sparsity_pattern</a>(*space_grid_tools_cache,</div><div class="line">                                                  *space_dh,</div><div class="line">                                                  *embedded_dh,</div><div class="line">                                                  quad,</div><div class="line">                                                  dsp,</div><div class="line">                                                  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a>(),</div><div class="line">                                                  <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                                  <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                                  *embedded_mapping);</div><div class="line">    coupling_sparsity.copy_from(dsp);</div><div class="line">    coupling_matrix.reinit(coupling_sparsity);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Assemble system&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixTools::create_laplace_matrix</a>(</div><div class="line">        *space_dh,</div><div class="line">        <a class="code" href="classQGauss.html">QGauss&lt;spacedim&gt;</a>(2 * space_fe-&gt;degree + 1),</div><div class="line">        stiffness_matrix,</div><div class="line">        static_cast&lt;<span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;spacedim&gt;</a> *&gt;(<span class="keyword">nullptr</span>),</div><div class="line">        constraints);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(*embedded_mapping,</div><div class="line">                                          *embedded_dh,</div><div class="line">                                          <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(2 * embedded_fe-&gt;degree +</div><div class="line">                                                      1),</div><div class="line">                                          embedded_value_function,</div><div class="line">                                          embedded_rhs);</div><div class="line">    }</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Assemble coupling system&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quad(parameters.coupling_quadrature_order);</div><div class="line">      <a class="code" href="namespaceNonMatching.html#ac3821491559b8a76af0be66736fe4c6f">NonMatching::create_coupling_mass_matrix</a>(*space_grid_tools_cache,</div><div class="line">                                               *space_dh,</div><div class="line">                                               *embedded_dh,</div><div class="line">                                               quad,</div><div class="line">                                               coupling_matrix,</div><div class="line">                                               <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a>(),</div><div class="line">                                               <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                               <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                               *embedded_mapping);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(*embedded_mapping,</div><div class="line">                               *embedded_dh,</div><div class="line">                               embedded_value_function,</div><div class="line">                               embedded_value);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Solve system&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> K_inv_umfpack;</div><div class="line">    K_inv_umfpack.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(stiffness_matrix);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> K  = <a class="code" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a>(stiffness_matrix);</div><div class="line">    <span class="keyword">auto</span> Ct = <a class="code" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a>(coupling_matrix);</div><div class="line">    <span class="keyword">auto</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>  = <a class="code" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a>(Ct);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> K_inv = <a class="code" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a>(K, K_inv_umfpack);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>                     S = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a> * K_inv * Ct;</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver_cg(schur_solver_control);</div><div class="line">    <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S, solver_cg, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    lambda = S_inv * embedded_rhs;</div><div class="line"></div><div class="line">    solution = K_inv * Ct * lambda;</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::output_results()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Output results&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;</a> embedding_out;</div><div class="line"></div><div class="line">    std::ofstream embedding_out_file(<span class="stringliteral">&quot;embedding.vtu&quot;</span>);</div><div class="line"></div><div class="line">    embedding_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(*space_dh);</div><div class="line">    embedding_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    embedding_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(</div><div class="line">      parameters.embedding_space_finite_element_degree);</div><div class="line">    embedding_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(embedding_out_file);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;</a> embedded_out;</div><div class="line"></div><div class="line">    std::ofstream embedded_out_file(<span class="stringliteral">&quot;embedded.vtu&quot;</span>);</div><div class="line"></div><div class="line">    embedded_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(*embedded_dh);</div><div class="line">    embedded_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(lambda, <span class="stringliteral">&quot;lambda&quot;</span>);</div><div class="line">    embedded_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(embedded_value, <span class="stringliteral">&quot;g&quot;</span>);</div><div class="line">    embedded_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(*embedded_mapping,</div><div class="line">                               parameters.embedded_space_finite_element_degree);</div><div class="line">    embedded_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(embedded_out_file);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">DistributedLagrangeProblem&lt;dim, spacedim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(parameters.initialized, <a class="code" href="group__Exceptions.html#ga426dec8d8185f1410e09a795e0b36e86">ExcNotInitialized</a>());</div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(parameters.verbosity_level);</div><div class="line"></div><div class="line">    setup_grids_and_dofs();</div><div class="line">    setup_coupling();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step60</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step60;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 1, spacedim = 2;</div><div class="line"></div><div class="line"></div><div class="line">      DistributedLagrangeProblem&lt;dim, spacedim&gt;::Parameters parameters;</div><div class="line">      DistributedLagrangeProblem&lt;dim, spacedim&gt;             problem(parameters);</div><div class="line"></div><div class="line">      std::string parameter_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        parameter_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        parameter_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(parameter_file, <span class="stringliteral">&quot;used_parameters.prm&quot;</span>);</div><div class="line">      problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_6.html">step-6</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#NonmatchinggridconstraintsthroughdistributedLagrangemultipliers">Non-matching grid constraints through distributed Lagrange multipliers</a>
        <li><a href="#Thetestcase">The testcase</a>
        <li><a href="#References">References</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#DistributedLagrangeProblem">DistributedLagrangeProblem</a>
        <li><a href="#DistributedLagrangeProblemParameters">DistributedLagrangeProblem::Parameters</a>
        <li><a href="#Setup">Set up</a>
        <li><a href="#Assembly">Assembly</a>
        <li><a href="#Solve">Solve</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Testcase1"> Test case 1: </a>
        <li><a href="#Testcase2and3"> Test case 2 and 3: </a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
      <ul>
        <li><a href="#Runningwithspacedimequaltothree"> Running with `spacedim` equal to three</a>
        <li><a href="#Moregeneraldomains"> More general domains </a>
        <li><a href="#Preconditioner"> Preconditioner</a>
        <li><a href="#ParallelCode"> Parallel Code </a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-60/doc/intro.dox</p>
<p><br />
</p>
<p><em>This program was contributed by Luca Heltai and Giovanni Alzetta, SISSA, Trieste. </em></p>
<dl class="section note"><dt>Note</dt><dd>If you use this program as a basis for your own work, please consider citing it in your list of references. The initial version of this work was contributed to the deal.II project by the authors listed in the following citation: <a href="https://doi.org/10.5281/zenodo.1243280"><img src="https://zenodo.org/badge/DOI/10.5281/zenodo.1243280.svg" alt="10.5281/zenodo.1243280"/></a> </dd></dl>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="NonmatchinggridconstraintsthroughdistributedLagrangemultipliers"></a></p><h3>Non-matching grid constraints through distributed Lagrange multipliers</h3>
<p>在本教程中，我们考虑两个域的情况， \(\Omega\) 在 \(R^{\text{spacedim}}\) 和 \(\Gamma\) 在 \(R^{\text{dim}}\) ，其中 \(\Gamma\) 嵌入在 \(\Omega\) （ \(\Gamma \subseteq \Omega\) ）。我们想在 \(\Omega\) 上解决一个偏微分方程，对问题的解决*在嵌入域* \(\Gamma\) 上强制执行一些条件。</p>
<p>有两种有趣的情况。</p>
<ul>
<li>嵌入域 \(\Gamma\) 的几何维度<code>dim</code>与域 \(\Omega\) 相同（<code>spacedim</code>），也就是说， \(\Gamma\) 的spacedim维度不为零，或</li>
<li>嵌入域 \(\Gamma\) 的内在维度<code>dim</code>小于 \(\Omega\) 的维度（<code>spacedim</code>），因此其spacedim维度为零；例如，它是一条嵌入二维域的曲线，或一个嵌入三维域的曲面。</li>
</ul>
<p>在这两种情况下，定义限制算子 \(\gamma\) 为算子，给定 \(\Omega\) 上的一个连续函数，返回其在 \(\Gamma\) 上的（连续）限制，即：。</p>
<p class="formulaDsp">
\[ \gamma : C^0(\Omega) \mapsto C^0(\Gamma), \quad \text{ s.t. } \gamma u = u|_{\Gamma} \in C^0(\Gamma), \quad \forall u \in C^0(\Omega). \]
</p>
<p>众所周知，当 \(\gamma\) 的内在维度与 \(\Omega\) 相同时，算子 \(\gamma\) 可以扩展为 \(H^1(\Omega)\) 上的连续算子，将 \(H^1(\Omega)\) 的函数映射为 \(H^1(\Gamma)\) 的函数。</p>
<p>同样的道理，在一个不太规则的范围空间（即 \(H^{1/2}(\Gamma)\) ）中，当 \(\Gamma\) 的维度相对于 \(\Omega\) 少一个，并且 \(\Gamma\) 没有边界。在这第二种情况下，算子 \(\gamma\) 也被称为*轨迹*算子，对于嵌入 \(\Omega\) 中的Lipschitz同维度曲线和曲面 \(\Gamma\) ，它有很好的定义（阅读<a href="https://en.wikipedia.org/wiki/Trace_operator">this wikipedia article</a>了解关于轨迹算子的进一步细节）。</p>
<p>同维度的情况要复杂一些，一般来说，不可能构造一个连续的跟踪算子，甚至不可能从 \(H^1(\Omega)\) 到 \(L^2(\Gamma)\) ，当 \(\Gamma\) 的维度在二维和三维中分别为零或一的时候。</p>
<p>在本教程中，我们对 \(\gamma\) 的进一步细节不感兴趣：我们认为扩展 \(\gamma\) 是理所当然的，假设嵌入域的尺寸（<code>dim</code>）总是比嵌入域的尺寸（<code>spacedim</code>）小一或相等。</p>
<p>我们要解决以下微分问题：给定 \(g\) 上的一个足够规则的函数 \(\Gamma\) ，找到 \(u\) 的解。</p>
<p class="formulaDsp">
\begin{eqnarray*} - \Delta u + \gamma^T \lambda &amp;=&amp; 0 \text{ in } \Omega\\ \gamma u &amp;=&amp; g \text{ in } \Gamma \\ u &amp; = &amp; 0 \text{ on } \partial\Omega. \end{eqnarray*}
</p>
<p>这是一个约束问题，我们正在寻找一个谐波函数 \(u\) ，满足 \(\partial\Omega\) 上的同质边界条件，受制于使用拉格朗日乘法器的约束 \(\gamma u = g\) 。</p>
<p>这个问题有一个物理解释：谐波函数，即满足拉普拉斯方程的函数，可以被认为是边界值被规定的膜的位移。那么，目前的情况相当于找到一个膜的形状，对于这个膜来说，不仅边界上的位移，而且 \(\Gamma\) 上的位移也是规定的。例如，如果 \(\Gamma\) 是二维空间中的一条封闭曲线，那么这将是一个肥皂膜的模型，它被沿 \(\partial \Omega\) 的一个线环以及沿 \(\Gamma\) 的第二个线环固定住。在 \(\Gamma\) 是整个区域的情况下，你可以把它看成是在障碍物上伸展的膜，其中 \(\Gamma\) 是接触区域。如果接触面积不知道，我们就有一个不同的问题&ndash;称为 "障碍物问题"&ndash;在步骤41中进行建模）。</p>
<p>作为第一个例子，我们研究 \(\partial\Omega\) 上的零迪里切特边界条件。如果我们在 \(\partial\Omega\) 上应用零诺伊曼边界条件或两者的混合，同样的方程也适用。</p>
<p>通过引入两个无限维空间 \(V(\Omega)\) 和 \(Q^*(\Gamma)\) ，可以得出变分公式，分别用于解 \(u\) 和拉格朗日乘子 \(\lambda\) 。</p>
<p>将第一个方程乘以 \(v \in V(\Omega)\) ，第二个方程乘以 \(q \in Q(\Gamma)\) ，在可能的情况下进行部分积分，并利用 \(\partial\Omega\) 的边界条件，我们得到以下变量问题。</p>
<p>给出 \(g\) 上的一个足够规则的函数 \(\Gamma\) ，求 \(u\) 的解</p>
<p class="formulaDsp">
\begin{eqnarray*} (\nabla u, \nabla v)_{\Omega} + (\lambda, \gamma v)_{\Gamma} &amp;=&amp; 0 \qquad \forall v \in V(\Omega) \\ (\gamma u, q)_{\Gamma} &amp;=&amp; (g,q)_{\Gamma} \qquad \forall q \in Q(\Gamma), \end{eqnarray*}
</p>
<p>其中 \((\cdot, \cdot)_{\Omega}\) 和 \((\cdot, \cdot)_{\Gamma}\) 分别代表 \(L^2\) 中的标量积和 \(\Gamma\) 中的标量积 。</p>
<p>对变量公式的检查告诉我们，空间 \(V(\Omega)\) 可以被认为是 \(H^1_0(\Omega)\) 。空间 \(Q(\Gamma)\) ，在同维度为零的情况下，应取为 \(H^1(\Gamma)\) ，而在同维度为一的情况下应取为 \(H^{1/2}(\Gamma)\) 。</p>
<p>因此函数 \(g\) 应该在 \(H^1(\Gamma)\) （对于同维度零的情况）或者 \(H^{1/2}(\Gamma)\) （对于同维度一的情况）。这使得我们在 \(Q^*(\Gamma)\) 中有一个拉格朗日乘数 \(\lambda\) ，它是 \(H^{-1}(\Gamma)\) 或 \(H^{-1/2}(\Gamma)\) 。</p>
<p>对于上述问题的离散化，有两种选择。可以选择匹配的离散化，即 \(\Gamma\) 的三角化与 \(\Omega\) 的三角化一致，也可以选择以完全独立的方式离散化这两个域。</p>
<p>对于我们上面提出的简单问题，第一种选择显然更有意义：对 \(\Omega\) 使用一个单一的三角形就足够了，然后根据 \(\Gamma\) 施加某些约束。在步骤40中研究了这种方法的一个例子，解决方案必须保持在一个障碍物之上，这是在 \(\Omega\) 上施加约束实现的。</p>
<p>为了解决更复杂的问题，例如域 \(\Gamma\) 与时间有关的问题，第二个选项可能是一个更可行的解决方案。处理不对齐的网格本身就很复杂：为了说明如何做，我们研究一个简单的问题。</p>
<p>我们在此描述的技术在文献中使用了许多名称之一：<b>immersed finite element method</b>、<b>fictitious boundary method</b>、<b>distributed Lagrange multiplier method</b>等。其主要原理是，两个网格的离散化和两个有限元空间的离散化保持完整。完全独立。这种技术对于模拟流体与结构的相互作用问题特别有效，其中嵌入结构的配置是问题本身的一部分，人们要解决一个（可能是非线性）弹性问题，以确定 \(\Gamma\) 的（与时间有关的）配置，以及 \(\Omega \setminus \Gamma\) 的（可能是非线性）流动问题，加上流体和固体之间界面上的耦合条件。</p>
<p>在这个教程程序中，我们把事情弄得简单一些，我们假设嵌入式领域的配置是以两种可能的方式之一给出的。</p>
<ul>
<li>作为一个变形映射 \(\psi: \Gamma_0 \mapsto \Gamma \subseteq \Omega\) ，定义在 \(\Gamma_0\) 的连续有限维空间上，对于任何一个点 \(x \in \Gamma_0\) ，代表其在 \(\Omega\) 的坐标 \(\psi(x)\) 。</li>
<li>作为 \(x\in \Gamma_0\) 的位移映射 \(\delta \psi(x) = \psi(x)-x\) ，代表任何一点 \(x\) 的位移矢量，以使 \(x\) 变形为其实际配置 \(\psi(x) = x +\delta\psi(x)\) 。</li>
</ul>
<p>我们定义嵌入式参考域 \(\Gamma_0\) <code>embedded_grid</code>：在这个三角形上，我们构建一个有限维空间（<code>embedded_configuration_dh</code>），通过FE_Q对象的有限元系统（<code>embedded_configuration_fe</code>）描述变形或位移。这个有限维度空间仅用于插值用户提供的函数（<code>embedded_configuration_function</code>），代表 \(\psi\) （如果参数<code>use_displacement</code>被设置为 <code>false</code>) 或 \(\delta\psi\) （如果参数<code>use_displacement</code>被设置为 <code>true</code>).</p>
<p>拉格朗日乘数 \(\lambda\) 和用户提供的函数 \(g\) 是通过另一个有限维度空间<code>embedded_dh</code>和另一个有限元素<code>embedded_fe</code>定义的，使用相同的参考域。为了考虑到域的变形，MappingFEField或MappingQEulerian对象被初始化为<code>embedded_configuration</code>向量。</p>
<p>在嵌入空间中，一个标准的有限维空间<code>space_dh</code>被构建在嵌入网格<code>space_grid</code>上，使用有限元素<code>space_fe</code>，几乎逐字逐句地遵循步骤6中的方法。</p>
<p>我们用以下方法表示空间 \(V\) 和 \(Q\) 的离散化</p>
<p class="formulaDsp">
\[ V_h(\Omega) = \text{span} \{v_i\}_{i=1}^n \]
</p>
<p> 和</p>
<p class="formulaDsp">
\[ Q_h(\Gamma) = \text{span} \{q_i\}_{i=1}^m \]
</p>
<p>，其中 \(n\) 是<code>空间_dh</code>的尺寸， \(m\) 是<code>嵌入_dh</code>的尺寸。</p>
<p>一旦所有的有限维空间都被定义，上述问题的变异表述给我们留下了以下有限维方程组。</p>
<p class="formulaDsp">
\[ \begin{pmatrix} K &amp; C^T \\ C &amp; 0 \end{pmatrix} \begin{pmatrix} u \\ \lambda \end{pmatrix} = \begin{pmatrix} 0 \\ G \end{pmatrix} \]
</p>
<p>其中</p>
<p class="formulaDsp">
\begin{eqnarray*} K_{ij} &amp;\dealcoloneq&amp; (\nabla v_j, \nabla v_i)_\Omega \qquad i,j=1,\dots,n \\ C_{\alpha j} &amp;\dealcoloneq&amp; (v_j, q_\alpha)_\Gamma \qquad j=1,\dots,n, \alpha = 1,\dots, m \\\\ G_{\alpha} &amp;\dealcoloneq&amp; (g, q_\alpha)_\Gamma \qquad \alpha = 1,\dots, m. \end{eqnarray*}
</p>
<p>虽然矩阵 \(K\) 是 \(\Omega\) 上泊松问题的标准刚度矩阵，而向量 \(G\) 是 \(g\) 上带有强制项的有限元问题的标准右手向量。矩阵 \(C\) 或其转置 \(C^T\) 是非标准的，因为它们是两个不匹配的网格上的信息。</p>
<p>特别是，在计算 \(C\) 的一个条目时出现的积分，是在 \(\Gamma\) 上计算的。在有限元中，我们通常将这个积分分成来自用于离散化 \(\Gamma\) 的三角形的所有单元的贡献，我们将 \(K\) 上的积分转换为参考元素 \(\hat K\) 上的积分，其中 \(F_{K}\) 是从 \(\hat K\) 到 \(K\) 的映射，并且使用正交公式计算 \(\hat K\) 上的积分。</p>
<p class="formulaDsp">
\[ C_{\alpha j} \dealcoloneq (v_j, q_\alpha)_\Gamma = \sum_{K\in \Gamma} \int_{\hat K} \hat q_\alpha(\hat x) (v_j \circ F_{K}) (\hat x) J_K (\hat x) \mathrm{d} \hat x = \sum_{K\in \Gamma} \sum_{i=1}^{n_q} \big(\hat q_\alpha(\hat x_i) (v_j \circ F_{K}) (\hat x_i) J_K (\hat x_i) w_i \big) \]
</p>
<p>计算这个和是不容易的，因为我们必须评估 \((v_j \circ F_{K}) (\hat x_i)\) 。一般来说，如果 \(\Gamma\) 和 \(\Omega\) 没有对齐，那么 \(F_{K}(\hat x_i)\) 这个点相对于 \(\Omega\) 来说是完全任意的，除非我们想出一个办法，在 \(\Omega\) 上的任意点上插值 \(V_h(\Omega)\) 的所有基函数，否则我们无法计算出矩阵 \(C\) 的一个条目需要的积分。</p>
<p>要评估 \((v_j \circ F_{K}) (\hat x_i)\) ，需要采取以下步骤（如下图所示）。</p>
<ul>
<li>对于 \(\Gamma\) 中的一个给定单元 \(K\) ，计算实点 \(y_i \dealcoloneq F_{K} (\hat x_i)\) ，其中 \(x_i\) 是用于 \(K \subseteq \Gamma\) 上的积分的正交点之一。</li>
<li>找到 \(\Omega\) 中 \(y_i\) 所在的单元。我们将称这个元素为 \(T\) 。</li>
<li>为了评估基函数，使用映射 \(G_T\) 的逆映射，将参考元素 \(\hat T\) 转换为元素 \(T\) : \(v_j(y_i) = \hat v_j \circ G^{-1}_{T} (y_i)\) 。</li>
</ul>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.C_interpolation.png"/>
</div>
 <p>上述三个步骤可以通过依次调用来计算。</p>
<ul>
<li><a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point()</a>, 后面是</li>
<li><a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a>. 然后我们</li>
<li>构建一个自定义的正交公式，包含参考单元格中的点，然后</li>
<li>构建一个FEValues对象，具有给定的正交公式，并以第一步中获得的单元格为初始化。</li>
</ul>
<p>这就是deal.II函数 <a class="el" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value()</a> 在任意点上评估有限元场（而不仅仅是单个形状函数）时的做法；但在这种情况下，这将是低效的。</p>
<p>一个更好的解决方案是使用一个方便的包装器来对一个点的集合执行前三个步骤。 <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations()</a>. 如果人们实际上对计算完整的耦合矩阵感兴趣，那么可以调用方法 <a class="el" href="namespaceNonMatching.html#ac3821491559b8a76af0be66736fe4c6f">NonMatching::create_coupling_mass_matrix()</a>, ，该方法以有效的方式执行上述步骤，重复使用所有可能的数据结构，并将昂贵的步骤聚集在一起。这就是我们在本教程后面要使用的函数。</p>
<p>我们通过迭代求解器来解决最终的鞍点问题，应用于Schur补数 \(S\) （其构造例如在步骤20中描述），我们使用LinearOperator类构造 \(S\) 。</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>我们在这里解决的问题与步骤4相同，不同的是我们对一个嵌入域施加了一些约束 \(\Gamma\) 。该教程是以独立于维度的方式编写的，在结果部分我们展示了如何改变<code>dim</code>和<code>spacedim</code>。</p>
<p>本教程是为<code>dim</code>等于1和<code>spacedim</code>等于2而编译的。如果你想在嵌入维度<code>spacedim</code>等于3的情况下运行程序，你很可能想改变 \(\Gamma\) 的参考域，例如，你从文件中读到的东西，或者你后来变形为更有趣的封闭球体。</p>
<p>在默认情况下， \(\Gamma\) 的共维为1，本教程程序实现的是虚构边界法。事实证明，同样的技术也用在了变量沉浸式有限元方法中，上面定义的耦合算子 \(C\) 在几乎所有这些非匹配方法中都是一样的。</p>
<p>嵌入域被假定包括在 \(\Omega\) 中，我们把它当作单位平方 \([0,1]^2\) 。虚域 \(\Gamma\) 的定义可以通过参数文件修改，可以给出从参考区间 \([0,1]\) 到 \(\Omega\) 中的一条曲线的映射。</p>
<p>如果曲线是封闭的，那么结果将类似于在边界为 \(\Gamma\) 的网格上运行同一问题。在非封闭的 \(\Gamma\) 的情况下，程序也能愉快地运行，尽管在这些情况下，问题的数学表述更加困难，因为 \(\Gamma\) 本身就有一个边界，相对于域 \(\Omega\) 来说是二维的。</p>
<p><a class="anchor" id="References"></a></p><h3>References</h3>
<ul>
<li>
<p class="startli">Glowinski, R., T.-W.Pan, T.I. Hesla, and D.D. Joseph.1999."分布式拉格朗日乘数/虚构域方法用于颗粒物流"。 International Journal of Multiphase Flow 25 (5).Pergamon: 755-94.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Boffi, D., L. Gastaldi, L. Heltai, and C.S. Peskin。2008."关于沉浸边界法的超弹性公式"。应用力学和工程中的计算机方法197（25-28）。</p>
<p class="endli"></p>
</li>
<li>
Heltai, L., and F. Costanzo.2012."浸没式有限元方法的变量实现"。应用力学和工程中的计算机方法》229-232。 </li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Most of these have been introduced elsewhere, we'll comment only on the new ones.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div></div><!-- fragment --><p>The parameter acceptor class is the first novelty of this tutorial program: in general parameter files are used to steer the execution of a program at run time. While even a simple approach saves compile time, as the same executable can be run with different parameter settings, it can become difficult to handle hundreds of parameters simultaneously while maintaining compatibility between different programs. This is where the class <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> proves useful.</p>
<p>This class is used to define a public interface for classes that want to use a single global <a class="el" href="classParameterHandler.html">ParameterHandler</a> to handle parameters. The class provides a static <a class="el" href="classParameterHandler.html">ParameterHandler</a> member, namely <a class="el" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>, and implements the "Command design pattern" (see, for example, E. Gamma, R. Helm, R. Johnson, J. Vlissides, Design <a class="el" href="namespacePatterns.html">Patterns</a>: Elements of Reusable Object-Oriented Software, Addison-Wesley Professional, 1994. <a href="https://goo.gl/FNYByc">https://goo.gl/FNYByc</a>).</p>
<p><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> provides a global subscription mechanism. Whenever an object of a class derived from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> is constructed, a pointer to that object-of-derived-type is registered, together with a section entry in the parameter file. Such registry is traversed upon invocation of the single function <a class="el" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>("file.prm") which in turn makes sure that all classes stored in the global registry declare the parameters they will be using, and after having declared them, it reads the content of <code>file.prm</code> to parse the actual parameters.</p>
<p>If you call the method <a class="el" href="classParameterHandler.html#a04b75c02037d19fd7fd781785fcefc79">ParameterHandler::add_parameter</a> for each of the parameters you want to use in your code, there is nothing else you need to do. If you are using an already existing class that provides the two functions <code>declare_parameters</code> and <code>parse_parameters</code>, you can still use <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>, by encapsulating the existing class into a <a class="el" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy</a> class.</p>
<p>In this example, we'll use both strategies, using <a class="el" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy</a> for deal.II classes, and deriving our own parameter classes directly from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The other new include file is the one that contains the <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> class. The structure of deal.II, as many modern numerical libraries, is organized following a Directed Acyclic Graph (DAG). A DAG is a directed graph with topological ordering: each node structurally represents an object, and is connected to non-root nodes by one (or more) oriented edges, from the parent to the child. The most significant example of this structure is the <a class="el" href="classTriangulation.html">Triangulation</a> and its <a class="el" href="group__Iterators.html#ga997d61ac77777cdc2be3ae934b1f7cdb">Triangulation::cell_iterator</a> structure. From a <a class="el" href="classTriangulation.html">Triangulation</a> (the main node), we can access each cell (children nodes of the triangulation). From the cells themselves we can access over all vertices of the cell. In this simple example, the DAG structure can be represented as three node types (the triangulation, the cell iterator, and the vertex) connected by oriented edges from the triangulation to the cell iterators, and from the cell iterator to the vertices. This has several advantages, but it intrinsically creates “asymmetries”, making certain operations fast and their inverse very slow: finding the vertices of a cell has low computational cost, and can be done by simply traversing the DAG, while finding all the cells that share a vertex requires a non-trivial computation unless a new DAG data structure is added that represents the inverse search.</p>
<p>Since inverse operations are usually not needed in a finite element code, these are implemented in <a class="el" href="namespaceGridTools.html">GridTools</a> without the use of extra data structures related to the <a class="el" href="classTriangulation.html">Triangulation</a> which would make them much faster. One such data structure, for example, is a map from the vertices of a <a class="el" href="classTriangulation.html">Triangulation</a> to all cells that share those vertices, which would reduce the computations needed to answer to the previous question.</p>
<p>Some methods, for example <a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point</a>, make heavy usage of these non-standard operations. If you need to call these methods more than once, it becomes convenient to store those data structures somewhere. <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> does exactly this, giving you access to previously computed objects, or computing them on the fly (and then storing them inside the class for later use), and making sure that whenever the <a class="el" href="classTriangulation.html">Triangulation</a> is updated, also the relevant data structures are recomputed.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools__cache_8h.html">deal.II/grid/grid_tools_cache.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2fe_2fe_8h.html">deal.II/fe/fe.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div></div><!-- fragment --><p>In this example, we will be using a reference domain to describe an embedded <a class="el" href="classTriangulation.html">Triangulation</a>, deformed through a finite element vector field.</p>
<p>The next two include files contain the definition of two classes that can be used in these cases. <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> allows one to describe a domain through a <em>displacement</em> field, based on a <a class="el" href="classFESystem.html">FESystem</a>[<a class="el" href="classFE__Q.html">FE_Q(p)</a>^spacedim] finite element space. The second is a little more generic, and allows you to use arbitrary vector <a class="el" href="classFiniteElement.html">FiniteElement</a> spaces, as long as they provide a <em>continuous</em> description of your domain. In this case, the description is done through the actual <em>deformation</em> field, rather than a <em>displacement</em> field.</p>
<p>Which one is used depends on how the user wants to specify the reference domain, and/or the actual configuration. We'll provide both options, and experiment a little in the results section of this tutorial program.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__eulerian_8h.html">deal.II/fe/mapping_q_eulerian.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__fe__field_8h.html">deal.II/fe/mapping_fe_field.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The parsed function class is another new entry. It allows one to create a <a class="el" href="classFunction.html">Function</a> object, starting from a string in a parameter file which is parsed into an object that you can use anywhere deal.II accepts a <a class="el" href="classFunction.html">Function</a> (for example, for interpolation, boundary conditions, etc.).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parsed__function_8h.html">deal.II/base/parsed_function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div></div><!-- fragment --><p>This is the last new entry for this tutorial program. The namespace <a class="el" href="namespaceNonMatching.html">NonMatching</a> contains a few methods that are useful when performing computations on non-matching grids, or on curves that are not aligned with the underlying mesh.</p>
<p>We'll discuss its use in detail later on in the <code>setup_coupling</code> method.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="coupling_8h.html">deal.II/non_matching/coupling.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step60</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="DistributedLagrangeProblem"></a> </p><h3>DistributedLagrangeProblem</h3>
<p>In the DistributedLagrangeProblem, we need two parameters describing the dimensions of the domain \(\Gamma\) (<code>dim</code>) and of the domain \(\Omega\) (<code>spacedim</code>).</p>
<p>These will be used to initialize a Triangulation&lt;dim,spacedim&gt; (for \(\Gamma\)) and a Triangulation&lt;spacedim,spacedim&gt; (for \(\Omega\)).</p>
<p>A novelty with respect to other tutorial programs is the heavy use of std::unique_ptr. These behave like classical pointers, with the advantage of doing automatic house-keeping: the contained object is automatically destroyed as soon as the unique_ptr goes out of scope, even if it is inside a container or there's an exception. Moreover it does not allow for duplicate pointers, which prevents ownership problems. We do this, because we want to be able to i) construct the problem, ii) read the parameters, and iii) initialize all objects according to what is specified in a parameter file.</p>
<p>We construct the parameters of our problem in the internal class <code>Parameters</code>, derived from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>. The <code>DistributedLagrangeProblem</code> class takes a const reference to a <code>Parameters</code> object, so that it is not possible to modify the parameters from within the DistributedLagrangeProblem class itself.</p>
<p>We could have initialized the parameters first, and then pass the parameters to the DistributedLagrangeProblem assuming all entries are set to the desired values, but this has two disadvantages:</p>
<ul>
<li>We should not make assumptions on how the user initializes a class that is not under our direct control. If the user fails to initialize the class, we should notice and throw an exception;</li>
<li>Not all objects that need to read parameters from a parameter file may be available when we construct the Parameters; this is often the case for complex programs, with multiple physics, or where we reuse existing code in some external classes. We simulate this by keeping some "complex" objects, like ParsedFunction objects, inside the <code>DistributedLagrangeProblem</code> instead of inside the <code>Parameters</code>.</li>
</ul>
<p>Here we assume that upon construction, the classes that build up our problem are not usable yet. Parsing the parameter file is what ensures we have all ingredients to build up our classes, and we design them so that if parsing fails, or is not executed, the run is aborted.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line"><span class="keyword">class </span>DistributedLagrangeProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div></div><!-- fragment --><p>The <code>Parameters</code> class is derived from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>. This allows us to use the <a class="el" href="classParameterAcceptor.html#af2a534c7f1ea5bfa165fa8a469744a5d">ParameterAcceptor::add_parameter()</a> method in its constructor.</p>
<p>The members of this function are all non-const, but the <code>DistributedLagrangeProblem</code> class takes a const reference to a <code>Parameters</code> object: this ensures that parameters are not modified from within the <code>DistributedLagrangeProblem</code> class.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Parameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Parameters();</div></div><!-- fragment --><p>The parameters now described can all be set externally using a parameter file: if no parameter file is present when running the executable, the program will create a "parameters.prm" file with the default values defined here, and then abort to give the user a chance to modify the parameters.prm file.</p>
<p>Initial refinement for the embedding grid, corresponding to the domain \(\Omega\).</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement = 4;</div></div><!-- fragment --><p>The interaction between the embedded grid \(\Omega\) and the embedding grid \(\Gamma\) is handled through the computation of \(C\), which involves all cells of \(\Omega\) overlapping with parts of \(\Gamma\): a higher refinement of such cells might improve quality of our computations. For this reason we define <code>delta_refinement</code>: if it is greater than zero, then we mark each cell of the space grid that contains a vertex of the embedded grid and its neighbors, execute the refinement, and repeat this process <code>delta_refinement</code> times.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> delta_refinement = 3;</div></div><!-- fragment --><p>Starting refinement of the embedded grid, corresponding to the domain \(\Gamma\).</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_embedded_refinement = 8;</div></div><!-- fragment --><p>The list of boundary ids where we impose homogeneous Dirichlet boundary conditions. On the remaining boundary ids (if any), we impose homogeneous Neumann boundary conditions. As a default problem we have zero Dirichlet boundary conditions on \(\partial \Omega\)</p>
<div class="fragment"><div class="line">std::list&lt;types::boundary_id&gt; homogeneous_dirichlet_ids{0, 1, 2, 3};</div></div><!-- fragment --><p><a class="el" href="classFiniteElement.html">FiniteElement</a> degree of the embedding space: \(V_h(\Omega)\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedding_space_finite_element_degree = 1;</div></div><!-- fragment --><p><a class="el" href="classFiniteElement.html">FiniteElement</a> degree of the embedded space: \(Q_h(\Gamma)\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedded_space_finite_element_degree = 1;</div></div><!-- fragment --><p><a class="el" href="classFiniteElement.html">FiniteElement</a> degree of the space used to describe the deformation of the embedded domain</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedded_configuration_finite_element_degree = 1;</div></div><!-- fragment --><p>Order of the quadrature formula used to integrate the coupling</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> coupling_quadrature_order = 3;</div></div><!-- fragment --><p>If set to true, then the embedded configuration function is interpreted as a displacement function</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> use_displacement = <span class="keyword">false</span>;</div></div><!-- fragment --><p>Level of verbosity to use in the output</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> verbosity_level = 10;</div></div><!-- fragment --><p>A flag to keep track if we were initialized or not</p>
<div class="fragment"><div class="line">  <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">};</div><div class="line"></div><div class="line">DistributedLagrangeProblem(<span class="keyword">const</span> Parameters &amp;parameters);</div></div><!-- fragment --><p>Entry point for the DistributedLagrangeProblem</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div></div><!-- fragment --><p>Object containing the actual parameters</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Parameters &amp;parameters;</div></div><!-- fragment --><p>The following functions are similar to all other tutorial programs, with the exception that we now need to set up things for two different families of objects, namely the ones related to the <em>embedding</em> grids, and the ones related to the <em>embedded</em> one.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_grids_and_dofs();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> setup_embedding_dofs();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> setup_embedded_dofs();</div></div><!-- fragment --><p>The only unconventional function we have here is the <code>setup_coupling()</code> method, used to generate the sparsity patter for the coupling matrix \(C\).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_coupling();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> output_results();</div></div><!-- fragment --><p>first we gather all the objects related to the embedding space geometry</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;Triangulation&lt;spacedim&gt;&gt; space_grid;</div><div class="line">std::unique_ptr&lt;GridTools::Cache&lt;spacedim, spacedim&gt;&gt;</div><div class="line">                                         space_grid_tools_cache;</div><div class="line">std::unique_ptr&lt;FiniteElement&lt;spacedim&gt;&gt; space_fe;</div><div class="line">std::unique_ptr&lt;DoFHandler&lt;spacedim&gt;&gt;    space_dh;</div></div><!-- fragment --><p>Then the ones related to the embedded grid, with the <a class="el" href="classDoFHandler.html">DoFHandler</a> associated to the Lagrange multiplier <code>lambda</code></p>
<div class="fragment"><div class="line">std::unique_ptr&lt;Triangulation&lt;dim, spacedim&gt;&gt; embedded_grid;</div><div class="line">std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; embedded_fe;</div><div class="line">std::unique_ptr&lt;DoFHandler&lt;dim, spacedim&gt;&gt;    embedded_dh;</div></div><!-- fragment --><p>And finally, everything that is needed to <em>deform</em> the embedded triangulation</p>
<div class="fragment"><div class="line">std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; embedded_configuration_fe;</div><div class="line">std::unique_ptr&lt;DoFHandler&lt;dim, spacedim&gt;&gt;    embedded_configuration_dh;</div><div class="line">Vector&lt;double&gt;                                embedded_configuration;</div></div><!-- fragment --><p>The <a class="el" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy</a> class is a "transparent" wrapper derived from both <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> and the type passed as its template parameter. At construction, the arguments are split into two parts: the first argument is an std::string, forwarded to the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class, and containing the name of the section that should be used for this class, while all the remaining arguments are forwarded to the constructor of the templated type, in this case, to the <a class="el" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction</a> constructor.</p>
<p>This class allows you to use existing classes in conjunction with the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> registration mechanism, provided that those classes have the members <code>declare_parameters()</code> and <code>parse_parameters()</code>.</p>
<p>This is the case here, making it fairly easy to exploit the <a class="el" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction</a> class: instead of requiring users to create new <a class="el" href="classFunction.html">Function</a> objects in their code for the RHS, boundary functions, etc., (like it is done in most of the other tutorials), here we allow the user to use deal.II interface to muParser (<a href="http://muparser.beltoforion.de">http://muparser.beltoforion.de</a>), where the specification of the function is not done at compile time, but at run time, using a string that is parsed into an actual <a class="el" href="classFunction.html">Function</a> object.</p>
<p>In this case, the <code>embedded_configuration_function</code> is a vector valued <a class="el" href="classFunction.html">Function</a> that can be interpreted as either a <em>deformation</em> or a <em>displacement</em> according to the boolean value of <code>parameters.use_displacement</code>. The number of components is specified later on in the construction.</p>
<div class="fragment"><div class="line"><a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">  embedded_configuration_function;</div><div class="line"></div><div class="line">std::unique_ptr&lt;Mapping&lt;dim, spacedim&gt;&gt; embedded_mapping;</div></div><!-- fragment --><p>We do the same thing to specify the value of the function \(g\), which is what we want our solution to be in the embedded space. In this case the <a class="el" href="classFunction.html">Function</a> is a scalar one.</p>
<div class="fragment"><div class="line"><a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">  embedded_value_function;</div></div><!-- fragment --><p>Similarly to what we have done with the <a class="el" href="classFunctions_1_1ParsedFunction.html">Functions::ParsedFunction</a> class, we repeat the same for the <a class="el" href="classReductionControl.html">ReductionControl</a> class, allowing us to specify all possible stopping criteria for the Schur complement iterative solver we'll use later on.</p>
<div class="fragment"><div class="line"><a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;ReductionControl&gt;</a> schur_solver_control;</div></div><!-- fragment --><p>Next we gather all <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>, and <a class="el" href="classVector.html">Vector</a> objects we'll need</p>
<div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a> stiffness_sparsity;</div><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a> coupling_sparsity;</div><div class="line"></div><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> stiffness_matrix;</div><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> coupling_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">Vector&lt;double&gt; solution;</div><div class="line">Vector&lt;double&gt; rhs;</div><div class="line"></div><div class="line">Vector&lt;double&gt; lambda;</div><div class="line">Vector&lt;double&gt; embedded_rhs;</div><div class="line">Vector&lt;double&gt; embedded_value;</div></div><!-- fragment --><p>The <a class="el" href="classTimerOutput.html">TimerOutput</a> class is used to provide some statistics on the performance of our program.</p>
<div class="fragment"><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> monitor;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="DistributedLagrangeProblemParameters"></a> </p><h3>DistributedLagrangeProblem::Parameters</h3>
<p>At construction time, we initialize also the <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class, with the section name we want our problem to use when parsing the parameter file.</p>
<p>Parameter files can be organized into section/subsection/etc.: this has the advantage that defined objects share parameters when sharing the same section/subsection/etc. <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> allows to specify the section name using Unix conventions on paths. If the section name starts with a slash ("/"), then the section is interpreted as an <em>absolute path</em>, <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> enters a subsection for each directory in the path, using the last name it encountered as the landing subsection for the current class.</p>
<p>For example, if you construct your class using <code><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>("/first/second/third/My Class")</code>, the parameters will be organized as follows:</p>
<div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line"><span class="preprocessor"># Example parameter file</span></div><div class="line">subsection <a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a></div><div class="line">  subsection <a class="code" href="grid__out_8cc.html#a2cc229a4f1ffc75e83ed269d5f725729">second</a></div><div class="line">    subsection third</div><div class="line">      subsection My Class</div><div class="line">       ... # all the parameters</div><div class="line">      end</div><div class="line">    end</div><div class="line">  end</div><div class="line">end</div></div><!-- fragment --> </div><p>Internally, the <em>current path</em> stored in <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> is now considered to be "/first/second/third/", i.e. when you specify an absolute path, <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> <em>changes</em> the current section to the current path, i.e. to the path of the section name until the <em>last</em> "/".</p>
<p>You can now construct another class derived from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> using a relative path (e.g., <code><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>("My Other Class")</code>) instead of the absolute one (e.g. <code><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>("/first/second/third/My Other
   Class")</code>), obtaining: </p><div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line"><span class="preprocessor"># Example parameter file</span></div><div class="line">subsection <a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a></div><div class="line">  subsection <a class="code" href="grid__out_8cc.html#a2cc229a4f1ffc75e83ed269d5f725729">second</a></div><div class="line">    subsection third</div><div class="line">      subsection My Class</div><div class="line">        ... # all the parameters</div><div class="line">      end</div><div class="line">      subsection My Other Class</div><div class="line">        ... # all the parameters of MyOtherClass</div><div class="line">      end</div><div class="line">    end</div><div class="line">  end</div><div class="line">end</div></div><!-- fragment --> </div><p>If the section name <em>ends</em> with a slash then subsequent classes will interpret this as a full path: for example, similar to the one above, if we have two classes, one initialized with <code><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>("/first/second/third/My Class/")</code> and the other with <code><a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>("My Other Class")</code>, then the resulting parameter file will look like:</p>
<div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line"><span class="preprocessor"># Example parameter file</span></div><div class="line">subsection <a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a></div><div class="line">  subsection <a class="code" href="grid__out_8cc.html#a2cc229a4f1ffc75e83ed269d5f725729">second</a></div><div class="line">    subsection third</div><div class="line">      subsection My Class</div><div class="line">        ... # all the parameters of MyClass</div><div class="line">        ... # notice My Class subsection does not end here</div><div class="line">        subsection My Other Class</div><div class="line">          ... # all the parameters of MyOtherClass</div><div class="line">        end # of subsection My Other Class</div><div class="line">      end # of subsection My Class</div><div class="line">    end</div><div class="line">  end</div><div class="line">end</div></div><!-- fragment --> </div><p>We are going to exploit this, by making our <code>Parameters</code> the <em>parent</em> of all subsequently constructed classes. Since most of the other classes are members of <code>DistributedLagrangeProblem</code> this allows, for example, to construct two <code>DistributedLagrangeProblem</code> for two different dimensions, without having conflicts in the parameters for the two problems.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">DistributedLagrangeProblem&lt;dim, spacedim&gt;::Parameters::Parameters()</div><div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Distributed Lagrange&lt;&quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html">Utilities</a>::<a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">int_to_string</a>(dim) + <span class="stringliteral">&quot;,&quot;</span> +</div><div class="line">                      <a class="code" href="namespaceUtilities.html">Utilities</a>::<a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">int_to_string</a>(spacedim) + <span class="stringliteral">&quot;&gt;/&quot;</span>)</div><div class="line">{</div></div><!-- fragment --><p>The <a class="el" href="classParameterAcceptor.html#af2a534c7f1ea5bfa165fa8a469744a5d">ParameterAcceptor::add_parameter()</a> function does a few things:</p>
<ul>
<li>enters the subsection specified at construction time to <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a></li>
<li>calls the ParameterAcceptor::prm.add_parameter() function</li>
<li>calls any signal you may have attached to <a class="el" href="classParameterAcceptor.html#a1704a7098e692599c254a14c15ab05d2">ParameterAcceptor::declare_parameters_call_back</a></li>
<li>leaves the subsection</li>
</ul>
<p>In turn, ParameterAcceptor::prm.add_parameter</p>
<ul>
<li>declares an entry in the parameter handler for the given variable;</li>
<li>takes the current value of the variable</li>
<li>transforms it to a string, used as the default value for the parameter file</li>
<li>attaches an <em>action</em> to <a class="el" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a> that monitors when a file is parsed, or when an entry is set, and when this happens, it updates the value of the variable passed to <code>add_parameter()</code> by setting it to whatever was specified in the input file (of course, after the input file has been parsed and the text representation converted to the type of the variable).</li>
</ul>
<div class="fragment"><div class="line">add_parameter(<span class="stringliteral">&quot;Initial embedding space refinement&quot;</span>, initial_refinement);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Initial embedded space refinement&quot;</span>,</div><div class="line">              initial_embedded_refinement);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Local refinements steps near embedded domain&quot;</span>,</div><div class="line">              delta_refinement);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Homogeneous Dirichlet boundary ids&quot;</span>,</div><div class="line">              homogeneous_dirichlet_ids);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Use displacement in embedded interface&quot;</span>, use_displacement);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Embedding space finite element degree&quot;</span>,</div><div class="line">              embedding_space_finite_element_degree);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Embedded space finite element degree&quot;</span>,</div><div class="line">              embedded_space_finite_element_degree);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Embedded configuration finite element degree&quot;</span>,</div><div class="line">              embedded_configuration_finite_element_degree);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Coupling quadrature order&quot;</span>, coupling_quadrature_order);</div><div class="line"></div><div class="line">add_parameter(<span class="stringliteral">&quot;Verbosity level&quot;</span>, verbosity_level);</div></div><!-- fragment --><p>Once the parameter file has been parsed, then the parameters are good to go. Set the internal variable <code>initialized</code> to true.</p>
<div class="fragment"><div class="line">  parse_parameters_call_back.connect([&amp;]() -&gt; <span class="keywordtype">void</span> { initialized = <span class="keyword">true</span>; });</div><div class="line">}</div></div><!-- fragment --><p>The constructor is pretty standard, with the exception of the <code><a class="el" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy</a></code> objects, as explained earlier.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">DistributedLagrangeProblem&lt;dim, spacedim&gt;::DistributedLagrangeProblem(</div><div class="line">  <span class="keyword">const</span> Parameters &amp;parameters)</div><div class="line">  : parameters(parameters)</div><div class="line">  , embedded_configuration_function(<span class="stringliteral">&quot;Embedded configuration&quot;</span>, spacedim)</div><div class="line">  , embedded_value_function(<span class="stringliteral">&quot;Embedded value&quot;</span>)</div><div class="line">  , schur_solver_control(<span class="stringliteral">&quot;Schur solver control&quot;</span>)</div><div class="line">  , monitor(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::cpu_and_wall_times)</div><div class="line">{</div></div><!-- fragment --><p>Here is a way to set default values for a <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> class that was constructed using <a class="el" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy</a>.</p>
<p>In this case, we set the default deformation of the embedded grid to be a circle with radius \(R\) and center \((Cx, Cy)\), we set the default value for the embedded_value_function to be the constant one, and specify some sensible values for the <a class="el" href="classSolverControl.html">SolverControl</a> object.</p>
<p>It is fundamental for \(\Gamma\) to be embedded: from the definition of \(C_{\alpha j}\) is clear that, if \(\Gamma \not\subseteq \Omega\), certain rows of the matrix \(C\) will be zero. This would be a problem, as the Schur complement method requires \(C\) to have full column rank.</p>
<div class="fragment"><div class="line">  embedded_configuration_function.declare_parameters_call_back.connect(</div><div class="line">    []() -&gt; <span class="keywordtype">void</span> {</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function constants&quot;</span>, <span class="stringliteral">&quot;R=.3, Cx=.4, Cy=.4&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>,</div><div class="line">                                 <span class="stringliteral">&quot;R*cos(2*pi*x)+Cx; R*sin(2*pi*x)+Cy&quot;</span>);</div><div class="line">    });</div><div class="line"></div><div class="line">  embedded_value_function.declare_parameters_call_back.connect(</div><div class="line">    []() -&gt; <span class="keywordtype">void</span> { <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>); });</div><div class="line"></div><div class="line">  schur_solver_control.declare_parameters_call_back.connect([]() -&gt; <span class="keywordtype">void</span> {</div><div class="line">    <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Max steps&quot;</span>, <span class="stringliteral">&quot;1000&quot;</span>);</div><div class="line">    <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Reduction&quot;</span>, <span class="stringliteral">&quot;1.e-12&quot;</span>);</div><div class="line">    <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Tolerance&quot;</span>, <span class="stringliteral">&quot;1.e-12&quot;</span>);</div><div class="line">  });</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Setup"></a> </p><h3>Set up</h3>
<p>The function <code>DistributedLagrangeProblem::setup_grids_and_dofs()</code> is used to set up the finite element spaces. Notice how <code>std::make_unique</code> is used to create objects wrapped inside <code>std::unique_ptr</code> objects.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_grids_and_dofs()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Setup grids and dofs&quot;</span>);</div></div><!-- fragment --><p>Initializing \(\Omega\): constructing the <a class="el" href="classTriangulation.html">Triangulation</a> and wrapping it into a <code>std::unique_ptr</code> object</p>
<div class="fragment"><div class="line">space_grid = std::make_unique&lt;Triangulation&lt;spacedim&gt;&gt;();</div></div><!-- fragment --><p>Next, we actually create the triangulation using <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>. The last argument is set to true: this activates colorization (i.e., assigning different boundary indicators to different parts of the boundary), which we use to assign the Dirichlet and Neumann conditions.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(*space_grid, 0, 1, <span class="keyword">true</span>);</div></div><!-- fragment --><p>Once we constructed a <a class="el" href="classTriangulation.html">Triangulation</a>, we refine it globally according to the specifications in the parameter file, and construct a <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> with it.</p>
<div class="fragment"><div class="line">space_grid-&gt;refine_global(parameters.initial_refinement);</div><div class="line">space_grid_tools_cache =</div><div class="line">  std::make_unique&lt;GridTools::Cache&lt;spacedim, spacedim&gt;&gt;(*space_grid);</div></div><!-- fragment --><p>The same is done with the embedded grid. Since the embedded grid is deformed, we first need to setup the deformation mapping. We do so in the following few lines:</p>
<div class="fragment"><div class="line">embedded_grid = std::make_unique&lt;Triangulation&lt;dim, spacedim&gt;&gt;();</div><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(*embedded_grid);</div><div class="line">embedded_grid-&gt;refine_global(parameters.initial_embedded_refinement);</div><div class="line"></div><div class="line">embedded_configuration_fe = std::make_unique&lt;FESystem&lt;dim, spacedim&gt;&gt;(</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim, spacedim&gt;</a>(</div><div class="line">    parameters.embedded_configuration_finite_element_degree),</div><div class="line">  spacedim);</div><div class="line"></div><div class="line">embedded_configuration_dh =</div><div class="line">  std::make_unique&lt;DoFHandler&lt;dim, spacedim&gt;&gt;(*embedded_grid);</div><div class="line"></div><div class="line">embedded_configuration_dh-&gt;distribute_dofs(*embedded_configuration_fe);</div><div class="line">embedded_configuration.reinit(embedded_configuration_dh-&gt;n_dofs());</div></div><!-- fragment --><p>Once we have defined a finite dimensional space for the deformation, we interpolate the <code>embedded_configuration_function</code> defined in the parameter file :</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(*embedded_configuration_dh,</div><div class="line">                         embedded_configuration_function,</div><div class="line">                         embedded_configuration);</div></div><!-- fragment --><p>Now we can interpret it according to what the user has specified in the parameter file: as a displacement, in which case we construct a mapping that <em>displaces</em> the position of each support point of our configuration finite element space by the specified amount on the corresponding configuration vector, or as an absolution position.</p>
<p>In the first case, the class <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> offers its services, while in the second one, we'll use the class <a class="el" href="classMappingFEField.html">MappingFEField</a>. They are in fact very similar. <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> will only work for systems of <a class="el" href="classFE__Q.html">FE_Q</a> finite element spaces, where the displacement vector is stored in the first <code>spacedim</code> components of the <a class="el" href="classFESystem.html">FESystem</a>, and the degree given as a parameter at construction time, must match the degree of the first <code>spacedim</code> components.</p>
<p>The class <a class="el" href="classMappingFEField.html">MappingFEField</a> is slightly more general, in that it allows you to select arbitrary <a class="el" href="classFiniteElement.html">FiniteElement</a> types when constructing your approximation. Naturally some choices may (or may not) make sense, according to the type of <a class="el" href="classFiniteElement.html">FiniteElement</a> you choose. <a class="el" href="classMappingFEField.html">MappingFEField</a> implements the pure iso-parametric concept, and can be used, for example, to implement iso-geometric analysis codes in deal.II, by combining it with the <a class="el" href="classFE__Bernstein.html">FE_Bernstein</a> finite element class. In this example, we'll use the two interchangeably, by taking into account the fact that one configuration will be a <code>displacement</code>, while the other will be an absolute <code>deformation</code> field.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (parameters.use_displacement == <span class="keyword">true</span>)</div><div class="line">  embedded_mapping =</div><div class="line">    std::make_unique&lt;MappingQEulerian&lt;dim, Vector&lt;double&gt;, spacedim&gt;&gt;(</div><div class="line">      parameters.embedded_configuration_finite_element_degree,</div><div class="line">      *embedded_configuration_dh,</div><div class="line">      embedded_configuration);</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  embedded_mapping =</div><div class="line">    std::make_unique&lt;MappingFEField&lt;dim, spacedim, Vector&lt;double&gt;&gt;&gt;(</div><div class="line">      *embedded_configuration_dh, embedded_configuration);</div><div class="line"></div><div class="line">setup_embedded_dofs();</div></div><!-- fragment --><p>In this tutorial program we not only refine \(\Omega\) globally, but also allow a local refinement depending on the position of \(\Gamma\), according to the value of <code>parameters.delta_refinement</code>, that we use to decide how many rounds of local refinement we should do on \(\Omega\), corresponding to the position of \(\Gamma\).</p>
<p>With the mapping in place, it is now possible to query what is the location of all support points associated with the <code>embedded_dh</code>, by calling the method <a class="el" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a>.</p>
<p>This method has two variants. One that does <em>not</em> take a <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a>, and one that takes a <a class="el" href="classMapping.html" title="映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用...">Mapping</a>. If you use the second type, like we are doing in this case, the support points are computed through the specified mapping, which can manipulate them accordingly.</p>
<p>This is precisely what the <code>embedded_mapping</code> is there for.</p>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;spacedim&gt;&gt; support_points(embedded_dh-&gt;n_dofs());</div><div class="line"><span class="keywordflow">if</span> (parameters.delta_refinement != 0)</div><div class="line">  <a class="code" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a>(*embedded_mapping,</div><div class="line">                                       *embedded_dh,</div><div class="line">                                       support_points);</div></div><!-- fragment --><p>Once we have the support points of the embedded finite element space, we would like to identify what cells of the embedding space contain what support point, to get a chance at refining the embedding grid where it is necessary, i.e., where the embedded grid is. This can be done manually, by looping over each support point, and then calling the method <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell</a> for each cell of the embedding space, until we find one that returns points in the unit reference cell, or it can be done in a more intelligent way.</p>
<p>The <a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point</a> is a possible option that performs the above task in a cheaper way, by first identifying the closest vertex of the embedding <a class="el" href="classTriangulation.html">Triangulation</a> to the target point, and then by calling <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell</a> only for those cells that share the found vertex.</p>
<p>In fact, there are algorithms in the <a class="el" href="namespaceGridTools.html">GridTools</a> namespace that exploit a <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> object, and possibly a KDTree object to speed up these operations as much as possible.</p>
<p>The simplest way to exploit the maximum speed is by calling a specialized method, <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a>, that will store a lot of useful information and data structures during the first point search, and then reuse all of this for subsequent points.</p>
<p><a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a> returns a tuple where the first element is a vector of cells containing the input points, in this case support_points. For refinement, this is the only information we need, and this is exactly what happens now.</p>
<p>When we need to assemble a coupling matrix, however, we'll also need the reference location of each point to evaluate the basis functions of the embedding space. The other elements of the tuple returned by <a class="el" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a> allow you to reconstruct, for each point, what cell contains it, and what is the location in the reference cell of the given point. Since this information is better grouped into cells, then this is what the algorithm returns: a tuple, containing a vector of all cells that have at least one point in them, together with a list of all reference points and their corresponding index in the original vector.</p>
<p>In the following loop, we will be ignoring all returned objects except the first, identifying all cells contain at least one support point of the embedded space. This allows for a simple adaptive refinement strategy: refining these cells and their neighbors.</p>
<p>Notice that we need to do some sanity checks, in the sense that we want to have an embedding grid which is well refined around the embedded grid, but where two consecutive support points lie either in the same cell, or in neighbor embedding cells.</p>
<p>This is only possible if we ensure that the smallest cell size of the embedding grid is nonetheless bigger than the largest cell size of the embedded grid. Since users can modify both levels of refinements, as well as the amount of local refinement they want around the embedded grid, we make sure that the resulting meshes satisfy our requirements, and if this is not the case, we bail out with an exception.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; parameters.delta_refinement; ++i)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> point_locations =</div><div class="line">      <a class="code" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a>(*space_grid_tools_cache,</div><div class="line">                                         support_points);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cells = std::get&lt;0&gt;(point_locations);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : cells)</div><div class="line">      {</div><div class="line">        cell-&gt;set_refine_flag();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">          <span class="keywordflow">if</span> (!cell-&gt;at_boundary(face_no))</div><div class="line">            cell-&gt;neighbor(face_no)-&gt;set_refine_flag();</div><div class="line">      }</div><div class="line">    space_grid-&gt;execute_coarsening_and_refinement();</div><div class="line">  }</div></div><!-- fragment --><p>In order to construct a well posed coupling interpolation operator \(C\), there are some constraints on the relative dimension of the grids between the embedding and the embedded domains. The coupling operator \(C\) and the spaces \(V\) and \(Q\) have to satisfy an inf-sup condition in order for the problem to have a solution. It turns out that the non-matching \(L^2\) projection satisfies such inf-sup, provided that the spaces \(V\) and \(Q\) are compatible between each other (for example, provided that they are chosen to be the ones described in the introduction).</p>
<p>However, the <em>discrete</em> inf-sup condition must also hold. No complications arise here, but it turns out that the discrete inf-sup constant deteriorates when the non-matching grids have local diameters that are too far away from each other. In particular, it turns out that if you choose an embedding grid which is <em>finer</em> with respect to the embedded grid, the inf-sup constant deteriorates much more than if you let the embedded grid be finer.</p>
<p>In order to avoid issues, in this tutorial we will throw an exception if the parameters chosen by the user are such that the maximal diameter of the embedded grid is greater than the minimal diameter of the embedding grid.</p>
<p>This choice guarantees that almost every cell of the embedded grid spans no more than two cells of the embedding grid, with some rare exceptions, that are negligible in terms of the resulting inf-sup.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> embedded_space_maximal_diameter =</div><div class="line">  <a class="code" href="namespaceGridTools.html#ae8409fa9cb46a0070abc4da7de0f47f2">GridTools::maximal_cell_diameter</a>(*embedded_grid, *embedded_mapping);</div><div class="line"><span class="keywordtype">double</span> embedding_space_minimal_diameter =</div><div class="line">  <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(*space_grid);</div><div class="line"></div><div class="line"><a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedding minimal diameter: &quot;</span></div><div class="line">        &lt;&lt; embedding_space_minimal_diameter</div><div class="line">        &lt;&lt; <span class="stringliteral">&quot;, embedded maximal diameter: &quot;</span></div><div class="line">        &lt;&lt; embedded_space_maximal_diameter &lt;&lt; <span class="stringliteral">&quot;, ratio: &quot;</span></div><div class="line">        &lt;&lt; embedded_space_maximal_diameter /</div><div class="line">             embedding_space_minimal_diameter</div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(embedded_space_maximal_diameter &lt;</div><div class="line">              embedding_space_minimal_diameter,</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">              <span class="stringliteral">&quot;The embedding grid is too refined (or the embedded grid &quot;</span></div><div class="line">              <span class="stringliteral">&quot;is too coarse). Adjust the parameters so that the minimal &quot;</span></div><div class="line">              <span class="stringliteral">&quot;grid size of the embedding grid is larger &quot;</span></div><div class="line">              <span class="stringliteral">&quot;than the maximal grid size of the embedded grid.&quot;</span>));</div></div><!-- fragment --><p>\(\Omega\) has been refined and we can now set up its DoFs</p>
<div class="fragment"><div class="line">  setup_embedding_dofs();</div><div class="line">}</div></div><!-- fragment --><p>We now set up the DoFs of \(\Omega\) and \(\Gamma\): since they are fundamentally independent (except for the fact that \(\Omega\)'s mesh is more refined "around" \(\Gamma\)) the procedure is standard.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_embedding_dofs()</div><div class="line">{</div><div class="line">  space_dh = std::make_unique&lt;DoFHandler&lt;spacedim&gt;&gt;(*space_grid);</div><div class="line">  space_fe = std::make_unique&lt;FE_Q&lt;spacedim&gt;&gt;(</div><div class="line">    parameters.embedding_space_finite_element_degree);</div><div class="line">  space_dh-&gt;distribute_dofs(*space_fe);</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(*space_dh, constraints);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keywordtype">id</span> : parameters.homogeneous_dirichlet_ids)</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">        *space_dh, <span class="keywordtype">id</span>, <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;spacedim&gt;</a>(), constraints);</div><div class="line">    }</div><div class="line">  constraints.close();</div></div><!-- fragment --><p>By definition the stiffness matrix involves only \(\Omega\)'s DoFs</p>
<div class="fragment"><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(space_dh-&gt;n_dofs(), space_dh-&gt;n_dofs());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(*space_dh, dsp, constraints);</div><div class="line">  stiffness_sparsity.copy_from(dsp);</div><div class="line">  stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(stiffness_sparsity);</div><div class="line">  solution.reinit(space_dh-&gt;n_dofs());</div><div class="line">  rhs.reinit(space_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedding dofs: &quot;</span> &lt;&lt; space_dh-&gt;n_dofs() &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_embedded_dofs()</div><div class="line">{</div><div class="line">  embedded_dh = std::make_unique&lt;DoFHandler&lt;dim, spacedim&gt;&gt;(*embedded_grid);</div><div class="line">  embedded_fe = std::make_unique&lt;FE_Q&lt;dim, spacedim&gt;&gt;(</div><div class="line">    parameters.embedded_space_finite_element_degree);</div><div class="line">  embedded_dh-&gt;distribute_dofs(*embedded_fe);</div></div><!-- fragment --><p>By definition the rhs of the system we're solving involves only a zero vector and \(G\), which is computed using only \(\Gamma\)'s DoFs</p>
<div class="fragment"><div class="line">  lambda.reinit(embedded_dh-&gt;n_dofs());</div><div class="line">  embedded_rhs.reinit(embedded_dh-&gt;n_dofs());</div><div class="line">  embedded_value.reinit(embedded_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedded dofs: &quot;</span> &lt;&lt; embedded_dh-&gt;n_dofs() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Creating the coupling sparsity pattern is a complex operation, but it can be easily done using the <a class="el" href="namespaceNonMatching.html#a8829bfa8e55c21b8eeaafd086c53680d">NonMatching::create_coupling_sparsity_pattern</a>, which requires the two <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, the quadrature points for the coupling, a <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> (which then needs to be copied into the sparsity one, as usual), the component mask for the embedding and embedded <a class="el" href="classTriangulation.html">Triangulation</a> (which we leave empty) and the mappings for both the embedding and the embedded <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_coupling()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Setup coupling&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quad(parameters.coupling_quadrature_order);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(space_dh-&gt;n_dofs(), embedded_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">  <a class="code" href="namespaceNonMatching.html#a8829bfa8e55c21b8eeaafd086c53680d">NonMatching::create_coupling_sparsity_pattern</a>(*space_grid_tools_cache,</div><div class="line">                                                *space_dh,</div><div class="line">                                                *embedded_dh,</div><div class="line">                                                quad,</div><div class="line">                                                dsp,</div><div class="line">                                                <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a>(),</div><div class="line">                                                <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                                <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                                *embedded_mapping);</div><div class="line">  coupling_sparsity.copy_from(dsp);</div><div class="line">  coupling_matrix.reinit(coupling_sparsity);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assembly"></a> </p><h3>Assembly</h3>
<p>The following function creates the matrices: as noted before computing the stiffness matrix and the rhs is a standard procedure.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Assemble system&quot;</span>);</div></div><!-- fragment --><p>Embedding stiffness matrix \(K\), and the right hand side \(G\).</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixTools::create_laplace_matrix</a>(</div><div class="line">    *space_dh,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;spacedim&gt;</a>(2 * space_fe-&gt;degree + 1),</div><div class="line">    stiffness_matrix,</div><div class="line">    static_cast&lt;<span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;spacedim&gt;</a> *&gt;(<span class="keyword">nullptr</span>),</div><div class="line">    constraints);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(*embedded_mapping,</div><div class="line">                                      *embedded_dh,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(2 * embedded_fe-&gt;degree +</div><div class="line">                                                  1),</div><div class="line">                                      embedded_value_function,</div><div class="line">                                      embedded_rhs);</div><div class="line">}</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Assemble coupling system&quot;</span>);</div></div><!-- fragment --><p>To compute the coupling matrix we use the <a class="el" href="namespaceNonMatching.html#ac3821491559b8a76af0be66736fe4c6f">NonMatching::create_coupling_mass_matrix</a> tool, which works similarly to <a class="el" href="namespaceNonMatching.html#a8829bfa8e55c21b8eeaafd086c53680d">NonMatching::create_coupling_sparsity_pattern</a>.</p>
<div class="fragment"><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quad(parameters.coupling_quadrature_order);</div><div class="line">    <a class="code" href="namespaceNonMatching.html#ac3821491559b8a76af0be66736fe4c6f">NonMatching::create_coupling_mass_matrix</a>(*space_grid_tools_cache,</div><div class="line">                                             *space_dh,</div><div class="line">                                             *embedded_dh,</div><div class="line">                                             quad,</div><div class="line">                                             coupling_matrix,</div><div class="line">                                             <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a>(),</div><div class="line">                                             <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                             <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                             *embedded_mapping);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(*embedded_mapping,</div><div class="line">                             *embedded_dh,</div><div class="line">                             embedded_value_function,</div><div class="line">                             embedded_value);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Solve"></a> </p><h3>Solve</h3>
<p>All parts have been assembled: we solve the system using the Schur complement method</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Solve system&quot;</span>);</div></div><!-- fragment --><p>Start by creating the inverse stiffness matrix</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> K_inv_umfpack;</div><div class="line">K_inv_umfpack.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(stiffness_matrix);</div></div><!-- fragment --><p>Initializing the operators, as described in the introduction</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> K  = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(stiffness_matrix);</div><div class="line"><span class="keyword">auto</span> Ct = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(coupling_matrix);</div><div class="line"><span class="keyword">auto</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>  = <a class="code" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a>(Ct);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> K_inv = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K, K_inv_umfpack);</div></div><!-- fragment --><p>Using the Schur complement method</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span>                     S = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a> * K_inv * Ct;</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver_cg(schur_solver_control);</div><div class="line">  <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S, solver_cg, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">  lambda = S_inv * embedded_rhs;</div><div class="line"></div><div class="line">  solution = K_inv * Ct * lambda;</div><div class="line"></div><div class="line">  constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p>The following function simply generates standard result output on two separate files, one for each mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::output_results()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Output results&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;</a> embedding_out;</div><div class="line"></div><div class="line">  std::ofstream embedding_out_file(<span class="stringliteral">&quot;embedding.vtu&quot;</span>);</div><div class="line"></div><div class="line">  embedding_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(*space_dh);</div><div class="line">  embedding_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  embedding_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(</div><div class="line">    parameters.embedding_space_finite_element_degree);</div><div class="line">  embedding_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(embedding_out_file);</div></div><!-- fragment --><p>The only difference between the two output routines is that in the second case, we want to output the data on the current configuration, and not on the reference one. This is possible by passing the actual embedded_mapping to the <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches</a> function. The mapping will take care of outputting the result on the actual deformed configuration.</p>
<div class="fragment"><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;</a> embedded_out;</div><div class="line"></div><div class="line">  std::ofstream embedded_out_file(<span class="stringliteral">&quot;embedded.vtu&quot;</span>);</div><div class="line"></div><div class="line">  embedded_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(*embedded_dh);</div><div class="line">  embedded_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(lambda, <span class="stringliteral">&quot;lambda&quot;</span>);</div><div class="line">  embedded_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(embedded_value, <span class="stringliteral">&quot;g&quot;</span>);</div><div class="line">  embedded_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(*embedded_mapping,</div><div class="line">                             parameters.embedded_space_finite_element_degree);</div><div class="line">  embedded_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(embedded_out_file);</div><div class="line">}</div></div><!-- fragment --><p>Similar to all other tutorial programs, the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function simply calls all other methods in the correct order. Nothing special to note, except that we check if parsing was done before we actually attempt to run our program.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">DistributedLagrangeProblem&lt;dim, spacedim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(parameters.initialized, <a class="code" href="group__Exceptions.html#ga426dec8d8185f1410e09a795e0b36e86">ExcNotInitialized</a>());</div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(parameters.verbosity_level);</div><div class="line"></div><div class="line">    setup_grids_and_dofs();</div><div class="line">    setup_coupling();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step60</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step60;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 1, spacedim = 2;</div></div><!-- fragment --><p>Differently to what happens in other tutorial programs, here we use <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a> style of initialization, i.e., all objects are first constructed, and then a single call to the static method <a class="el" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a> is issued to fill all parameters of the classes that are derived from <a class="el" href="classParameterAcceptor.html">ParameterAcceptor</a>.</p>
<p>We check if the user has specified a parameter file name to use when the program was launched. If so, try to read that parameter file, otherwise, try to read the file "parameters.prm".</p>
<p>If the parameter file that was specified (implicitly or explicitly) does not exist, <a class="el" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a> will create one for you, and exit the program.</p>
<div class="fragment"><div class="line">      DistributedLagrangeProblem&lt;dim, spacedim&gt;::Parameters parameters;</div><div class="line">      DistributedLagrangeProblem&lt;dim, spacedim&gt;             problem(parameters);</div><div class="line"></div><div class="line">      std::string parameter_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        parameter_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        parameter_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(parameter_file, <span class="stringliteral">&quot;used_parameters.prm&quot;</span>);</div><div class="line">      problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-60/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>运行该程序的目录中默认不包含参数文件。另一方面，这个程序想从一个叫parameters.prm的文件中读取它的参数 &ndash; 因此，当你第一次执行它时，你会得到一个异常，即找不到这样的文件。</p>
<div class="fragment"><div class="line">----------------------------------------------------</div><div class="line">Exception on processing:</div><div class="line"></div><div class="line"></div><div class="line">--------------------------------------------------------</div><div class="line">An error occurred in line &lt;74&gt; of file &lt;../source/base/parameter_acceptor.cc&gt; in <span class="keyword">function</span></div><div class="line">    <span class="keyword">static</span> void ::ParameterAcceptor::initialize(<span class="keyword">const</span> std::string &amp;, <span class="keyword">const</span> std::string &amp;, <span class="keyword">const</span> <a class="code" href="classParameterHandler.html#a8364dda711b93753c6809eefe2a8e827">ParameterHandler::OutputStyle</a>, ::<a class="code" href="classParameterHandler.html">ParameterHandler</a> &amp;)</div><div class="line">The violated condition was:</div><div class="line">    <span class="keyword">false</span></div><div class="line">Additional information:</div><div class="line">    You specified &lt;parameters.prm&gt; as input parameter file, but it does not exist. We created it <span class="keywordflow">for</span> you.</div><div class="line"></div><div class="line"></div><div class="line">--------------------------------------------------------</div><div class="line"></div><div class="line"></div><div class="line">Aborting!</div><div class="line"></div><div class="line"></div><div class="line">----------------------------------------------------</div></div><!-- fragment --><p>然而，正如错误信息已经指出的那样，触发该异常的代码也将生成一个参数.prm文件，该文件仅仅包含该程序所关心的所有参数的默认值。通过对参数文件的检查，我们看到以下内容。</p>
<div class="fragment"><div class="line"><span class="preprocessor"># Listing of Parameters</span></div><div class="line"><span class="preprocessor"># ---------------------</span></div><div class="line">subsection Distributed Lagrange&lt;1,2&gt;</div><div class="line">  <span class="keyword">set</span> <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> quadrature order                    = 3</div><div class="line">  <span class="keyword">set</span> Embedded configuration finite element degree = 1</div><div class="line">  <span class="keyword">set</span> Embedded space finite element degree         = 1</div><div class="line">  <span class="keyword">set</span> Embedding space finite element degree        = 1</div><div class="line">  <span class="keyword">set</span> Homogeneous Dirichlet boundary ids           = 0, 1, 2, 3</div><div class="line">  <span class="keyword">set</span> Initial embedded space refinement            = 7</div><div class="line">  <span class="keyword">set</span> Initial embedding space refinement           = 4</div><div class="line">  <span class="keyword">set</span> Local refinements steps near embedded domain = 3</div><div class="line">  <span class="keyword">set</span> Use displacement in embedded <span class="keyword">interface       </span>= false</div><div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Verbosity level                              = 10</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  subsection Embedded configuration</div><div class="line"><span class="preprocessor">    # Sometimes it is convenient to use symbolic constants in the expression</span></div><div class="line"><span class="preprocessor">    # that describes the function, rather than having to use its numeric value</span></div><div class="line"><span class="preprocessor">    # everywhere the constant appears. These values can be defined using this</span></div><div class="line"><span class="preprocessor">    # parameter, in the form `var1=value1, var2=value2, ...&#39;.</span></div><div class="line"><span class="preprocessor">    #</span></div><div class="line"><span class="preprocessor">    # A typical example would be to set this runtime parameter to</span></div><div class="line"><span class="preprocessor">    # `pi=3.1415926536&#39; and then use `pi&#39; in the expression of the actual</span></div><div class="line"><span class="preprocessor">    # formula. (That said, for convenience this class actually defines both</span></div><div class="line"><span class="preprocessor">    # `pi&#39; and `Pi&#39; by default, but you get the idea.)</span></div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  = R=.3, Cx=.4, Cy=.4                 # <span class="keywordflow">default</span>:</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">    # The formula that denotes the function you want to evaluate for</span></div><div class="line"><span class="preprocessor">    # particular values of the independent variables. This expression may</span></div><div class="line"><span class="preprocessor">    # contain any of the usual operations such as addition or multiplication,</span></div><div class="line"><span class="preprocessor">    # as well as all of the common functions such as `sin&#39; or `cos&#39;. In</span></div><div class="line"><span class="preprocessor">    # addition, it may contain expressions like `if(x&gt;0, 1, -1)&#39; where the</span></div><div class="line"><span class="preprocessor">    # expression evaluates to the second argument if the first argument is</span></div><div class="line"><span class="preprocessor">    # true, and to the third argument otherwise. For a full overview of</span></div><div class="line"><span class="preprocessor">    # possible expressions accepted see the documentation of the muparser</span></div><div class="line"><span class="preprocessor">    # library at http://muparser.beltoforion.de/.</span></div><div class="line"><span class="preprocessor">    #</span></div><div class="line"><span class="preprocessor">    # If the function you are describing represents a vector-valued function</span></div><div class="line"><span class="preprocessor">    # with multiple components, then separate the expressions for individual</span></div><div class="line"><span class="preprocessor">    # components by a semicolon.</span></div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = R*<a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(2*pi*x)+Cx; R*<a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(2*pi*x)+Cy # <span class="keywordflow">default</span>: 0</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">    # The names of the variables as they will be used in the function,</span></div><div class="line"><span class="preprocessor">    # separated by commas. By default, the names of variables at which the</span></div><div class="line"><span class="preprocessor">    # function will be evaluated are `x&#39; (in 1d), `x,y&#39; (in 2d) or `x,y,z&#39; (in</span></div><div class="line"><span class="preprocessor">    # 3d) for spatial coordinates and `t&#39; for time. You can then use these</span></div><div class="line"><span class="preprocessor">    # variable names in your function expression and they will be replaced by</span></div><div class="line"><span class="preprocessor">    # the values of these variables at which the function is currently</span></div><div class="line"><span class="preprocessor">    # evaluated. However, you can also choose a different set of names for the</span></div><div class="line"><span class="preprocessor">    # independent variables at which to evaluate your function expression. For</span></div><div class="line"><span class="preprocessor">    # example, if you work in spherical coordinates, you may wish to set this</span></div><div class="line"><span class="preprocessor">    # input parameter to `r,phi,theta,t&#39; and then use these variable names in</span></div><div class="line"><span class="preprocessor">    # your function expression.</span></div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line"></div><div class="line"></div><div class="line">  subsection Embedded value</div><div class="line"><span class="preprocessor">    # Sometimes it is convenient to use symbolic constants in the expression</span></div><div class="line"><span class="preprocessor">    # that describes the function, rather than having to use its numeric value</span></div><div class="line"><span class="preprocessor">    # everywhere the constant appears. These values can be defined using this</span></div><div class="line"><span class="preprocessor">    # parameter, in the form `var1=value1, var2=value2, ...&#39;.</span></div><div class="line"><span class="preprocessor">    #</span></div><div class="line"><span class="preprocessor">    # A typical example would be to set this runtime parameter to</span></div><div class="line"><span class="preprocessor">    # `pi=3.1415926536&#39; and then use `pi&#39; in the expression of the actual</span></div><div class="line"><span class="preprocessor">    # formula. (That said, for convenience this class actually defines both</span></div><div class="line"><span class="preprocessor">    # `pi&#39; and `Pi&#39; by default, but you get the idea.)</span></div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">    # The formula that denotes the function you want to evaluate for</span></div><div class="line"><span class="preprocessor">    # particular values of the independent variables. This expression may</span></div><div class="line"><span class="preprocessor">    # contain any of the usual operations such as addition or multiplication,</span></div><div class="line"><span class="preprocessor">    # as well as all of the common functions such as `sin&#39; or `cos&#39;. In</span></div><div class="line"><span class="preprocessor">    # addition, it may contain expressions like `if(x&gt;0, 1, -1)&#39; where the</span></div><div class="line"><span class="preprocessor">    # expression evaluates to the second argument if the first argument is</span></div><div class="line"><span class="preprocessor">    # true, and to the third argument otherwise. For a full overview of</span></div><div class="line"><span class="preprocessor">    # possible expressions accepted see the documentation of the muparser</span></div><div class="line"><span class="preprocessor">    # library at http://muparser.beltoforion.de/.</span></div><div class="line"><span class="preprocessor">    #</span></div><div class="line"><span class="preprocessor">    # If the function you are describing represents a vector-valued function</span></div><div class="line"><span class="preprocessor">    # with multiple components, then separate the expressions for individual</span></div><div class="line"><span class="preprocessor">    # components by a semicolon.</span></div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 1     # <span class="keywordflow">default</span>: 0</div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">    # The names of the variables as they will be used in the function,</span></div><div class="line"><span class="preprocessor">    # separated by commas. By default, the names of variables at which the</span></div><div class="line"><span class="preprocessor">    # function will be evaluated are `x&#39; (in 1d), `x,y&#39; (in 2d) or `x,y,z&#39; (in</span></div><div class="line"><span class="preprocessor">    # 3d) for spatial coordinates and `t&#39; for time. You can then use these</span></div><div class="line"><span class="preprocessor">    # variable names in your function expression and they will be replaced by</span></div><div class="line"><span class="preprocessor">    # the values of these variables at which the function is currently</span></div><div class="line"><span class="preprocessor">    # evaluated. However, you can also choose a different set of names for the</span></div><div class="line"><span class="preprocessor">    # independent variables at which to evaluate your function expression. For</span></div><div class="line"><span class="preprocessor">    # example, if you work in spherical coordinates, you may wish to set this</span></div><div class="line"><span class="preprocessor">    # input parameter to `r,phi,theta,t&#39; and then use these variable names in</span></div><div class="line"><span class="preprocessor">    # your function expression.</span></div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line"></div><div class="line"></div><div class="line">  subsection Schur solver control</div><div class="line">    <span class="keyword">set</span> Log frequency = 1</div><div class="line">    <span class="keyword">set</span> Log history   = <span class="keyword">false</span></div><div class="line">    <span class="keyword">set</span> Log result    = <span class="keyword">true</span></div><div class="line">    <span class="keyword">set</span> Max steps     = 1000   # <span class="keywordflow">default</span>: 100</div><div class="line">    <span class="keyword">set</span> Reduction     = 1.e-12 # <span class="keywordflow">default</span>: 1.e-2</div><div class="line">    <span class="keyword">set</span> Tolerance     = 1.e-12 # <span class="keywordflow">default</span>: 1.e-10</div><div class="line">  end</div><div class="line"></div><div class="line"></div><div class="line">end</div></div><!-- fragment --><p>如果你现在运行该程序，你将得到一个名为<code>used_parameters.prm</code>的文件，其中包含上述参数的简短版本（没有注释和文档），记录了所有用于运行你的程序的参数。</p>
<div class="fragment"><div class="line"><span class="preprocessor"># Parameter file generated with</span></div><div class="line"><span class="preprocessor"># DEAL_II_PACKAGE_VERSION = 9.0.0</span></div><div class="line">subsection Distributed Lagrange&lt;1,2&gt;</div><div class="line">  <span class="keyword">set</span> <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> quadrature order                    = 3</div><div class="line">  <span class="keyword">set</span> Embedded configuration finite element degree = 1</div><div class="line">  <span class="keyword">set</span> Embedded space finite element degree         = 1</div><div class="line">  <span class="keyword">set</span> Embedding space finite element degree        = 1</div><div class="line">  <span class="keyword">set</span> Homogeneous Dirichlet boundary ids           = 0, 1, 2, 3</div><div class="line">  <span class="keyword">set</span> Initial embedded space refinement            = 7</div><div class="line">  <span class="keyword">set</span> Initial embedding space refinement           = 4</div><div class="line">  <span class="keyword">set</span> Local refinements steps near embedded domain = 3</div><div class="line">  <span class="keyword">set</span> Use displacement in embedded <span class="keyword">interface       </span>= false</div><div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Verbosity level                              = 10</div><div class="line">  subsection Embedded configuration</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  = R=.3, Cx=.4, Cy=.4</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = R*<a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(2*pi*x)+Cx; R*<a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(2*pi*x)+Cy</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line">  subsection Embedded value</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 1</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line">  subsection Schur solver control</div><div class="line">    <span class="keyword">set</span> Log frequency = 1</div><div class="line">    <span class="keyword">set</span> Log history   = <span class="keyword">false</span></div><div class="line">    <span class="keyword">set</span> Log result    = <span class="keyword">true</span></div><div class="line">    <span class="keyword">set</span> Max steps     = 1000</div><div class="line">    <span class="keyword">set</span> Reduction     = 1.e-12</div><div class="line">    <span class="keyword">set</span> Tolerance     = 1.e-12</div><div class="line">  end</div><div class="line">end</div></div><!-- fragment --><p>首先创建<code>parameters.prm</code>文件（第一次运行程序），然后创建<code>used_parameters.prm</code>（每隔一段时间运行程序），其理由是你可能想让大多数参数保持默认值，而只修改其中的一小部分。</p>
<p>例如，你可以在这个教程程序中使用以下（完全有效的）参数文件。</p>
<div class="fragment"><div class="line">subsection Distributed Lagrange&lt;1,2&gt;</div><div class="line">  <span class="keyword">set</span> Initial embedded space refinement            = 7</div><div class="line">  <span class="keyword">set</span> Initial embedding space refinement           = 4</div><div class="line">  <span class="keyword">set</span> Local refinements steps near embedded domain = 3</div><div class="line">  subsection Embedded configuration</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  = R=.3, Cx=.4, Cy=.4</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = R*<a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(2*pi*x)+Cx; R*<a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(2*pi*x)+Cy</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line">  subsection Embedded value</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 1</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line">end</div></div><!-- fragment --><p>你会得到与下面测试案例1完全相同的结果。</p>
<p><a class="anchor" id="Testcase1"></a></p><h3>Test case 1: </h3>
<p>对于默认问题， \(u\) 在 \(\Gamma\) 上的值被设置为常数 \(1\) ：这就像在 \(\Gamma\) 上施加了一个常数迪里希特边界条件，被视为 \(\Omega\) 在 \(\Gamma\) 内的部分的边界。同样，在 \(\partial \Omega\) 上，我们有零的迪里切特边界条件。</p>
<div class="twocolumn" style="width: 80%"> <div class="parent"> <div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.1_no_grid.png" width="500"/>
</div>
 </div> </div> <div class="parent"> <div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.1_grid.png" width="500"/>
</div>
 </div> </div></div><p>程序的输出将如下所示。</p>
<div class="fragment"><div class="line">DEAL::Embedded dofs: 129</div><div class="line">DEAL::Embedding minimal <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">diameter</a>: 0.0110485, embedded maximal <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">diameter</a>: 0.00781250, ratio: 0.707107</div><div class="line">DEAL::Embedding dofs: 2429</div><div class="line">DEAL:cg::Starting value 0.166266</div><div class="line">DEAL:cg::Convergence step 108 value 7.65958e-13</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total CPU time elapsed since start          |     0.586s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  CPU time  | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble coupling system        |         1 |     0.132s |        23% |</div><div class="line">| Assemble system                 |         1 |    0.0733s |        12% |</div><div class="line">| Output results                  |         1 |     0.087s |        15% |</div><div class="line">| Setup coupling                  |         1 |    0.0244s |       4.2% |</div><div class="line">| Setup grids and dofs            |         1 |    0.0907s |        15% |</div><div class="line">| Solve system                    |         1 |     0.178s |        30% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |     0.301s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble coupling system        |         1 |    0.0385s |        13% |</div><div class="line">| Assemble system                 |         1 |    0.0131s |       4.3% |</div><div class="line">| Output results                  |         1 |    0.0736s |        24% |</div><div class="line">| Setup coupling                  |         1 |    0.0234s |       7.7% |</div><div class="line">| Setup grids and dofs            |         1 |    0.0679s |        23% |</div><div class="line">| Solve system                    |         1 |    0.0832s |        28% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>你可能会注意到，就CPU时间而言，组装耦合系统的成本是组装标准泊松系统的两倍，尽管矩阵更小。这是由于离散化的非匹配性造成的。这是否可以接受，取决于应用。</p>
<p>如果问题被设置在三维环境中，并且浸入式网格与时间有关，那么在每一步重新创建网格要比使用我们这里介绍的技术要昂贵得多。此外，你也许可以在一个均匀细化的正方形或立方体网格上创建一个非常快速和优化的求解器，并在你想进行计算的地方嵌入这里的技术。这就要求你只需要有一个领域的表面代表（一个更便宜和更容易制作的网格）。</p>
<p>为了玩一玩，我们要把虚构的领域以及我们强加给它的边界条件复杂化一点。</p>
<p><a class="anchor" id="Testcase2and3"></a></p><h3>Test case 2 and 3: </h3>
<p>如果我们使用以下参数文件。</p>
<div class="fragment"><div class="line">subsection Distributed Lagrange&lt;1,2&gt;</div><div class="line">  <span class="keyword">set</span> <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160">Coupling</a> quadrature order                    = 3</div><div class="line">  <span class="keyword">set</span> Embedded configuration finite element degree = 1</div><div class="line">  <span class="keyword">set</span> Embedded space finite element degree         = 1</div><div class="line">  <span class="keyword">set</span> Embedding space finite element degree        = 1</div><div class="line">  <span class="keyword">set</span> Homogeneous Dirichlet boundary ids           = 0,1,2,3</div><div class="line">  <span class="keyword">set</span> Initial embedded space refinement            = 8</div><div class="line">  <span class="keyword">set</span> Initial embedding space refinement           = 4</div><div class="line">  <span class="keyword">set</span> Local refinements steps near embedded domain = 4</div><div class="line">  <span class="keyword">set</span> Use displacement in embedded <span class="keyword">interface       </span>= false</div><div class="line">  <a class="code" href="group__CUDAWrappers.html#gabb7130e2cea54654455ca41ef304f939">set</a> Verbosity level                              = 10</div><div class="line">  subsection Embedded configuration</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  = R=.3, Cx=.5, Cy=.5, r=.1, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6b25dd8f005063d8d2b0a4bdb0d277f3">w</a>=12</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = (R+r*<a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6b25dd8f005063d8d2b0a4bdb0d277f3">w</a>*pi*x))*<a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(2*pi*x)+Cx; (R+r*<a class="code" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a6b25dd8f005063d8d2b0a4bdb0d277f3">w</a>*pi*x))*<a class="code" href="numbers_8h.html#a27989bdc7b4b828564982787d126bd91">sin</a>(2*pi*x)+Cy</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line">  subsection Embedded value</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line">    <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = x-.5</div><div class="line">    <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">  end</div><div class="line">  subsection Schur solver control</div><div class="line">    <span class="keyword">set</span> Log frequency = 1</div><div class="line">    <span class="keyword">set</span> Log history   = <span class="keyword">false</span></div><div class="line">    <span class="keyword">set</span> Log result    = <span class="keyword">true</span></div><div class="line">    <span class="keyword">set</span> Max steps     = 100000</div><div class="line">    <span class="keyword">set</span> Reduction     = 1.e-12</div><div class="line">    <span class="keyword">set</span> Tolerance     = 1.e-12</div><div class="line">  end</div><div class="line">end</div></div><!-- fragment --><p>我们得到了一个看起来很 "花 "的域，在这里我们施加了一个线性边界条件 \(g=x-.5\) 。这个测试表明，该方法在从边界条件中恢复一个完全线性的函数方面实际上是相当准确的，即使网格没有对齐，我们也得到了一个相当好的结果。</p>
<p>用 \(2(x-.5)^2-2(y-.5)^2\) 替换 \(x-.5\) ，即修改参数文件，使我们有</p>
<div class="fragment"><div class="line">...</div><div class="line">subsection Embedded value</div><div class="line">  <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> constants  =</div><div class="line">  <span class="keyword">set</span> <a class="code" href="classFunction.html">Function</a> expression = 2*(x-.5)^2-2*(y-.5)^2</div><div class="line">  <span class="keyword">set</span> Variable names      = x,y,t</div><div class="line">end</div></div><!-- fragment --><p>生产右边的马鞍。</p>
<div class="twocolumn" style="width: 80%"> <div class="parent"> <div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.3_grid.png" width="500"/>
</div>
 </div> </div> <div class="parent"> <div class="img" align="center"> <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-60.4_grid.png" width="500"/>
</div>
 </div> </div></div><p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p><a class="anchor" id="Runningwithspacedimequaltothree"></a></p><h4>Running with <code>spacedim</code> equal to three</h4>
<p>虽然目前的教程程序是为<code>spacedim</code>等于2而写的，但为了使程序在不同的尺寸组合中运行，你只需要做一些小的改动。</p>
<p>如果你想在<code>spacedim</code>等于3，<code>dim</code>等于2的情况下运行，那么你几乎肯定要进行以下修改。</p>
<ul>
<li>使用不同的参考域来嵌入网格，也许可以从一个文件中读取它。不可能用一个正方形域的单一参数化来构造一个光滑的封闭表面，因此你很可能想用一个拓扑学上等同于球体边界的参考域。</li>
<li>用位移代替变形，将 \(\Gamma_0\) 映射为 \(\Gamma\) 。</li>
</ul>
<p><a class="anchor" id="Moregeneraldomains"></a></p><h4>More general domains </h4>
<p>我们在其他教程中看到（例如在第5步和第54步）如何从输入文件中读取网格。这个教程程序的一个很好的概括是允许用户选择从参数文件本身读取网格，而不是在教程程序本身硬编码网格类型。</p>
<p><a class="anchor" id="Preconditioner"></a></p><h4>Preconditioner</h4>
<p>目前，我们没有关于Schur补数的预处理程序。这对于二维问题来说是可以的，几百次迭代就可以把残差降低到机器的精度，但在三维问题上是行不通的。</p>
<p>在这里，一个好的预处理程序是什么并不明显。我们用舒尔补码解决的物理问题是将Dirichlet数据 \(g\) 与Lagrange乘数 \(\lambda\) 的值联系起来。 \(\lambda\) 可以解释为法线梯度的*跳跃，需要强加在 \(u\) 上，跨越 \(\Gamma\) ，以获得迪里切特数据 \(g\) 。</p>
<p>所以 \(S\) 是某种诺伊曼到迪里切特的映射，我们希望有一个迪里切特到诺伊曼映射的良好近似。一种可能性是使用 \(\Gamma\) 上的问题的边界元素近似，并构建一个与 \(\Gamma\) 相关的泊松问题的超星形算子的粗略近似，这正是迪里切特到诺依曼的映射。</p>
<p><a class="anchor" id="ParallelCode"></a></p><h4>Parallel Code </h4>
<p>这里提出的简单代码可以作为更复杂问题的起点，要解决这些问题，需要在并行代码上运行，可能使用分布式网格（见步骤17、步骤40，以及 <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> 和 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>). 的文档）。</p>
<p>当并行使用非匹配网格时，会出现一个问题：为了计算矩阵 \(C\) ，一个进程需要关于实空间同一部分的两个网格的信息，但是，当使用分布式网格时，这种信息可能无法获得，因为存储在特定处理器上的 \(\Omega\) 三角形的本地所有部分可能与存储在同一处理器上的 \(\Gamma\) 三角形的本地所有部分不在同一地点。</p>
<p>可以实施各种策略来解决这个问题。</p>
<ul>
<li>分布这两个网格，以便满足这个约束条件。</li>
<li>对现实空间中不满足约束的部分使用通信。</li>
<li>对嵌入空间使用分布式三角法，对模拟配置使用共享三角法。</li>
</ul>
<p>后一种策略显然是最容易实现的，因为本教程程序中使用的大多数函数在并行情况下也能不变地工作。当然，我们可以使用反转策略（即有一个分布式嵌入三角法和一个共享嵌入三角法）。</p>
<p>然而，这种策略很可能会更加昂贵，因为根据定义，嵌入网格比嵌入网格要大，而且分配两个网格中最大的网格更有意义，保持最小的网格由所有处理器共享。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2018 - 2020 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Luca Heltai, Giovanni Alzetta,</span></div><div class="line"><span class="comment"> * International School for Advanced Studies, Trieste, 2018</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools__cache_8h.html">deal.II/grid/grid_tools_cache.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2fe_2fe_8h.html">deal.II/fe/fe.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q__eulerian_8h.html">deal.II/fe/mapping_q_eulerian.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__fe__field_8h.html">deal.II/fe/mapping_fe_field.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parsed__function_8h.html">deal.II/base/parsed_function.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="coupling_8h.html">deal.II/non_matching/coupling.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator_8h.html">deal.II/lac/linear_operator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step60</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim = dim&gt;</div><div class="line">  <span class="keyword">class </span>DistributedLagrangeProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">class </span>Parameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      Parameters();</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement = 4;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> delta_refinement = 3;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_embedded_refinement = 8;</div><div class="line"></div><div class="line">      std::list&lt;types::boundary_id&gt; homogeneous_dirichlet_ids{0, 1, 2, 3};</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedding_space_finite_element_degree = 1;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedded_space_finite_element_degree = 1;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> embedded_configuration_finite_element_degree = 1;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> coupling_quadrature_order = 3;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> use_displacement = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> verbosity_level = 10;</div><div class="line"></div><div class="line">      <span class="keywordtype">bool</span> initialized = <span class="keyword">false</span>;</div><div class="line">    };</div><div class="line"></div><div class="line">    DistributedLagrangeProblem(<span class="keyword">const</span> Parameters &amp;parameters);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> Parameters &amp;parameters;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_grids_and_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_embedding_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_embedded_dofs();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_coupling();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    std::unique_ptr&lt;Triangulation&lt;spacedim&gt;&gt; space_grid;</div><div class="line">    std::unique_ptr&lt;GridTools::Cache&lt;spacedim, spacedim&gt;&gt;</div><div class="line">                                             space_grid_tools_cache;</div><div class="line">    std::unique_ptr&lt;FiniteElement&lt;spacedim&gt;&gt; space_fe;</div><div class="line">    std::unique_ptr&lt;DoFHandler&lt;spacedim&gt;&gt;    space_dh;</div><div class="line"></div><div class="line"></div><div class="line">    std::unique_ptr&lt;Triangulation&lt;dim, spacedim&gt;&gt; embedded_grid;</div><div class="line">    std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; embedded_fe;</div><div class="line">    std::unique_ptr&lt;DoFHandler&lt;dim, spacedim&gt;&gt;    embedded_dh;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;FiniteElement&lt;dim, spacedim&gt;&gt; embedded_configuration_fe;</div><div class="line">    std::unique_ptr&lt;DoFHandler&lt;dim, spacedim&gt;&gt;    embedded_configuration_dh;</div><div class="line">    Vector&lt;double&gt;                                embedded_configuration;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">      embedded_configuration_function;</div><div class="line"></div><div class="line">    std::unique_ptr&lt;Mapping&lt;dim, spacedim&gt;&gt; embedded_mapping;</div><div class="line"></div><div class="line">    <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;Functions::ParsedFunction&lt;spacedim&gt;</a>&gt;</div><div class="line">      embedded_value_function;</div><div class="line"></div><div class="line">    <a class="code" href="classParameterAcceptorProxy.html">ParameterAcceptorProxy&lt;ReductionControl&gt;</a> schur_solver_control;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a> stiffness_sparsity;</div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a> coupling_sparsity;</div><div class="line"></div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> stiffness_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> coupling_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; rhs;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; lambda;</div><div class="line">    Vector&lt;double&gt; embedded_rhs;</div><div class="line">    Vector&lt;double&gt; embedded_value;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> monitor;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  DistributedLagrangeProblem&lt;dim, spacedim&gt;::Parameters::Parameters()</div><div class="line">    : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;/Distributed Lagrange&lt;&quot;</span> +</div><div class="line">                        <a class="code" href="namespaceUtilities.html">Utilities</a>::<a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">int_to_string</a>(dim) + <span class="stringliteral">&quot;,&quot;</span> +</div><div class="line">                        <a class="code" href="namespaceUtilities.html">Utilities</a>::<a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">int_to_string</a>(spacedim) + <span class="stringliteral">&quot;&gt;/&quot;</span>)</div><div class="line">  {</div><div class="line">    add_parameter(<span class="stringliteral">&quot;Initial embedding space refinement&quot;</span>, initial_refinement);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Initial embedded space refinement&quot;</span>,</div><div class="line">                  initial_embedded_refinement);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Local refinements steps near embedded domain&quot;</span>,</div><div class="line">                  delta_refinement);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Homogeneous Dirichlet boundary ids&quot;</span>,</div><div class="line">                  homogeneous_dirichlet_ids);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Use displacement in embedded interface&quot;</span>, use_displacement);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Embedding space finite element degree&quot;</span>,</div><div class="line">                  embedding_space_finite_element_degree);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Embedded space finite element degree&quot;</span>,</div><div class="line">                  embedded_space_finite_element_degree);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Embedded configuration finite element degree&quot;</span>,</div><div class="line">                  embedded_configuration_finite_element_degree);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Coupling quadrature order&quot;</span>, coupling_quadrature_order);</div><div class="line"></div><div class="line">    add_parameter(<span class="stringliteral">&quot;Verbosity level&quot;</span>, verbosity_level);</div><div class="line"></div><div class="line">    parse_parameters_call_back.connect([&amp;]() -&gt; <span class="keywordtype">void</span> { initialized = <span class="keyword">true</span>; });</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  DistributedLagrangeProblem&lt;dim, spacedim&gt;::DistributedLagrangeProblem(</div><div class="line">    <span class="keyword">const</span> Parameters &amp;parameters)</div><div class="line">    : parameters(parameters)</div><div class="line">    , embedded_configuration_function(<span class="stringliteral">&quot;Embedded configuration&quot;</span>, spacedim)</div><div class="line">    , embedded_value_function(<span class="stringliteral">&quot;Embedded value&quot;</span>)</div><div class="line">    , schur_solver_control(<span class="stringliteral">&quot;Schur solver control&quot;</span>)</div><div class="line">    , monitor(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::summary, <a class="code" href="classTimerOutput.html">TimerOutput</a>::cpu_and_wall_times)</div><div class="line">  {</div><div class="line">    embedded_configuration_function.declare_parameters_call_back.connect(</div><div class="line">      []() -&gt; <span class="keywordtype">void</span> {</div><div class="line">        <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function constants&quot;</span>, <span class="stringliteral">&quot;R=.3, Cx=.4, Cy=.4&quot;</span>);</div><div class="line"></div><div class="line"></div><div class="line">        <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>,</div><div class="line">                                   <span class="stringliteral">&quot;R*cos(2*pi*x)+Cx; R*sin(2*pi*x)+Cy&quot;</span>);</div><div class="line">      });</div><div class="line"></div><div class="line">    embedded_value_function.declare_parameters_call_back.connect(</div><div class="line">      []() -&gt; <span class="keywordtype">void</span> { <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Function expression&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>); });</div><div class="line"></div><div class="line">    schur_solver_control.declare_parameters_call_back.connect([]() -&gt; <span class="keywordtype">void</span> {</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Max steps&quot;</span>, <span class="stringliteral">&quot;1000&quot;</span>);</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Reduction&quot;</span>, <span class="stringliteral">&quot;1.e-12&quot;</span>);</div><div class="line">      <a class="code" href="classParameterAcceptor.html#a96081d4cc985b722c9841fcf0c0e54ec">ParameterAcceptor::prm</a>.<a class="code" href="classParameterHandler.html#aa6418ea655b1b550b9dcf63513030196">set</a>(<span class="stringliteral">&quot;Tolerance&quot;</span>, <span class="stringliteral">&quot;1.e-12&quot;</span>);</div><div class="line">    });</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_grids_and_dofs()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Setup grids and dofs&quot;</span>);</div><div class="line"></div><div class="line">    space_grid = std::make_unique&lt;Triangulation&lt;spacedim&gt;&gt;();</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(*space_grid, 0, 1, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">    space_grid-&gt;refine_global(parameters.initial_refinement);</div><div class="line">    space_grid_tools_cache =</div><div class="line">      std::make_unique&lt;GridTools::Cache&lt;spacedim, spacedim&gt;&gt;(*space_grid);</div><div class="line"></div><div class="line">    embedded_grid = std::make_unique&lt;Triangulation&lt;dim, spacedim&gt;&gt;();</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(*embedded_grid);</div><div class="line">    embedded_grid-&gt;refine_global(parameters.initial_embedded_refinement);</div><div class="line"></div><div class="line">    embedded_configuration_fe = std::make_unique&lt;FESystem&lt;dim, spacedim&gt;&gt;(</div><div class="line">      <a class="code" href="classFE__Q.html">FE_Q&lt;dim, spacedim&gt;</a>(</div><div class="line">        parameters.embedded_configuration_finite_element_degree),</div><div class="line">      spacedim);</div><div class="line"></div><div class="line">    embedded_configuration_dh =</div><div class="line">      std::make_unique&lt;DoFHandler&lt;dim, spacedim&gt;&gt;(*embedded_grid);</div><div class="line"></div><div class="line">    embedded_configuration_dh-&gt;distribute_dofs(*embedded_configuration_fe);</div><div class="line">    embedded_configuration.reinit(embedded_configuration_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(*embedded_configuration_dh,</div><div class="line">                             embedded_configuration_function,</div><div class="line">                             embedded_configuration);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (parameters.use_displacement == <span class="keyword">true</span>)</div><div class="line">      embedded_mapping =</div><div class="line">        std::make_unique&lt;MappingQEulerian&lt;dim, Vector&lt;double&gt;, spacedim&gt;&gt;(</div><div class="line">          parameters.embedded_configuration_finite_element_degree,</div><div class="line">          *embedded_configuration_dh,</div><div class="line">          embedded_configuration);</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      embedded_mapping =</div><div class="line">        std::make_unique&lt;MappingFEField&lt;dim, spacedim, Vector&lt;double&gt;&gt;&gt;(</div><div class="line">          *embedded_configuration_dh, embedded_configuration);</div><div class="line"></div><div class="line">    setup_embedded_dofs();</div><div class="line"></div><div class="line">    std::vector&lt;Point&lt;spacedim&gt;&gt; support_points(embedded_dh-&gt;n_dofs());</div><div class="line">    <span class="keywordflow">if</span> (parameters.delta_refinement != 0)</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a>(*embedded_mapping,</div><div class="line">                                           *embedded_dh,</div><div class="line">                                           support_points);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; parameters.delta_refinement; ++i)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> point_locations =</div><div class="line">          <a class="code" href="namespaceGridTools.html#a8e8bb9211264d2106758ac4d7184117e">GridTools::compute_point_locations</a>(*space_grid_tools_cache,</div><div class="line">                                             support_points);</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;cells = std::get&lt;0&gt;(point_locations);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : cells)</div><div class="line">          {</div><div class="line">            cell-&gt;set_refine_flag();</div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> face_no : cell-&gt;face_indices())</div><div class="line">              <span class="keywordflow">if</span> (!cell-&gt;at_boundary(face_no))</div><div class="line">                cell-&gt;neighbor(face_no)-&gt;set_refine_flag();</div><div class="line">          }</div><div class="line">        space_grid-&gt;execute_coarsening_and_refinement();</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> embedded_space_maximal_diameter =</div><div class="line">      <a class="code" href="namespaceGridTools.html#ae8409fa9cb46a0070abc4da7de0f47f2">GridTools::maximal_cell_diameter</a>(*embedded_grid, *embedded_mapping);</div><div class="line">    <span class="keywordtype">double</span> embedding_space_minimal_diameter =</div><div class="line">      <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(*space_grid);</div><div class="line"></div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedding minimal diameter: &quot;</span></div><div class="line">            &lt;&lt; embedding_space_minimal_diameter</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;, embedded maximal diameter: &quot;</span></div><div class="line">            &lt;&lt; embedded_space_maximal_diameter &lt;&lt; <span class="stringliteral">&quot;, ratio: &quot;</span></div><div class="line">            &lt;&lt; embedded_space_maximal_diameter /</div><div class="line">                 embedding_space_minimal_diameter</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(embedded_space_maximal_diameter &lt;</div><div class="line">                  embedding_space_minimal_diameter,</div><div class="line">                <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                  <span class="stringliteral">&quot;The embedding grid is too refined (or the embedded grid &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;is too coarse). Adjust the parameters so that the minimal &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;grid size of the embedding grid is larger &quot;</span></div><div class="line">                  <span class="stringliteral">&quot;than the maximal grid size of the embedded grid.&quot;</span>));</div><div class="line"></div><div class="line">    setup_embedding_dofs();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_embedding_dofs()</div><div class="line">  {</div><div class="line">    space_dh = std::make_unique&lt;DoFHandler&lt;spacedim&gt;&gt;(*space_grid);</div><div class="line">    space_fe = std::make_unique&lt;FE_Q&lt;spacedim&gt;&gt;(</div><div class="line">      parameters.embedding_space_finite_element_degree);</div><div class="line">    space_dh-&gt;distribute_dofs(*space_fe);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(*space_dh, constraints);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keywordtype">id</span> : parameters.homogeneous_dirichlet_ids)</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(</div><div class="line">          *space_dh, <span class="keywordtype">id</span>, <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;spacedim&gt;</a>(), constraints);</div><div class="line">      }</div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(space_dh-&gt;n_dofs(), space_dh-&gt;n_dofs());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(*space_dh, dsp, constraints);</div><div class="line">    stiffness_sparsity.copy_from(dsp);</div><div class="line">    stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(stiffness_sparsity);</div><div class="line">    solution.reinit(space_dh-&gt;n_dofs());</div><div class="line">    rhs.reinit(space_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedding dofs: &quot;</span> &lt;&lt; space_dh-&gt;n_dofs() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_embedded_dofs()</div><div class="line">  {</div><div class="line">    embedded_dh = std::make_unique&lt;DoFHandler&lt;dim, spacedim&gt;&gt;(*embedded_grid);</div><div class="line">    embedded_fe = std::make_unique&lt;FE_Q&lt;dim, spacedim&gt;&gt;(</div><div class="line">      parameters.embedded_space_finite_element_degree);</div><div class="line">    embedded_dh-&gt;distribute_dofs(*embedded_fe);</div><div class="line"></div><div class="line">    lambda.reinit(embedded_dh-&gt;n_dofs());</div><div class="line">    embedded_rhs.reinit(embedded_dh-&gt;n_dofs());</div><div class="line">    embedded_value.reinit(embedded_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Embedded dofs: &quot;</span> &lt;&lt; embedded_dh-&gt;n_dofs() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::setup_coupling()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Setup coupling&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quad(parameters.coupling_quadrature_order);</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(space_dh-&gt;n_dofs(), embedded_dh-&gt;n_dofs());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceNonMatching.html#a8829bfa8e55c21b8eeaafd086c53680d">NonMatching::create_coupling_sparsity_pattern</a>(*space_grid_tools_cache,</div><div class="line">                                                  *space_dh,</div><div class="line">                                                  *embedded_dh,</div><div class="line">                                                  quad,</div><div class="line">                                                  dsp,</div><div class="line">                                                  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a>(),</div><div class="line">                                                  <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                                  <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                                  *embedded_mapping);</div><div class="line">    coupling_sparsity.copy_from(dsp);</div><div class="line">    coupling_matrix.reinit(coupling_sparsity);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Assemble system&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">MatrixTools::create_laplace_matrix</a>(</div><div class="line">        *space_dh,</div><div class="line">        <a class="code" href="classQGauss.html">QGauss&lt;spacedim&gt;</a>(2 * space_fe-&gt;degree + 1),</div><div class="line">        stiffness_matrix,</div><div class="line">        static_cast&lt;<span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;spacedim&gt;</a> *&gt;(<span class="keyword">nullptr</span>),</div><div class="line">        constraints);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side</a>(*embedded_mapping,</div><div class="line">                                          *embedded_dh,</div><div class="line">                                          <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(2 * embedded_fe-&gt;degree +</div><div class="line">                                                      1),</div><div class="line">                                          embedded_value_function,</div><div class="line">                                          embedded_rhs);</div><div class="line">    }</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Assemble coupling system&quot;</span>);</div><div class="line"></div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quad(parameters.coupling_quadrature_order);</div><div class="line">      <a class="code" href="namespaceNonMatching.html#ac3821491559b8a76af0be66736fe4c6f">NonMatching::create_coupling_mass_matrix</a>(*space_grid_tools_cache,</div><div class="line">                                               *space_dh,</div><div class="line">                                               *embedded_dh,</div><div class="line">                                               quad,</div><div class="line">                                               coupling_matrix,</div><div class="line">                                               <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a>(),</div><div class="line">                                               <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                               <a class="code" href="classComponentMask.html">ComponentMask</a>(),</div><div class="line">                                               *embedded_mapping);</div><div class="line"></div><div class="line">      <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(*embedded_mapping,</div><div class="line">                               *embedded_dh,</div><div class="line">                               embedded_value_function,</div><div class="line">                               embedded_value);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Solve system&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> K_inv_umfpack;</div><div class="line">    K_inv_umfpack.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(stiffness_matrix);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> K  = <a class="code" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a>(stiffness_matrix);</div><div class="line">    <span class="keyword">auto</span> Ct = <a class="code" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a>(coupling_matrix);</div><div class="line">    <span class="keyword">auto</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>  = <a class="code" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a>(Ct);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> K_inv = <a class="code" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a>(K, K_inv_umfpack);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>                     S = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a> * K_inv * Ct;</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver_cg(schur_solver_control);</div><div class="line">    <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S, solver_cg, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line"></div><div class="line">    lambda = S_inv * embedded_rhs;</div><div class="line"></div><div class="line">    solution = K_inv * Ct * lambda;</div><div class="line"></div><div class="line">    constraints.distribute(solution);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> DistributedLagrangeProblem&lt;dim, spacedim&gt;::output_results()</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(monitor, <span class="stringliteral">&quot;Output results&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;spacedim&gt;</a> embedding_out;</div><div class="line"></div><div class="line">    std::ofstream embedding_out_file(<span class="stringliteral">&quot;embedding.vtu&quot;</span>);</div><div class="line"></div><div class="line">    embedding_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(*space_dh);</div><div class="line">    embedding_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    embedding_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(</div><div class="line">      parameters.embedding_space_finite_element_degree);</div><div class="line">    embedding_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(embedding_out_file);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim, spacedim&gt;</a> embedded_out;</div><div class="line"></div><div class="line">    std::ofstream embedded_out_file(<span class="stringliteral">&quot;embedded.vtu&quot;</span>);</div><div class="line"></div><div class="line">    embedded_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(*embedded_dh);</div><div class="line">    embedded_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(lambda, <span class="stringliteral">&quot;lambda&quot;</span>);</div><div class="line">    embedded_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(embedded_value, <span class="stringliteral">&quot;g&quot;</span>);</div><div class="line">    embedded_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(*embedded_mapping,</div><div class="line">                               parameters.embedded_space_finite_element_degree);</div><div class="line">    embedded_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(embedded_out_file);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">DistributedLagrangeProblem&lt;dim, spacedim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(parameters.initialized, <a class="code" href="group__Exceptions.html#ga426dec8d8185f1410e09a795e0b36e86">ExcNotInitialized</a>());</div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(parameters.verbosity_level);</div><div class="line"></div><div class="line">    setup_grids_and_dofs();</div><div class="line">    setup_coupling();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    output_results();</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step60</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step60;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 1, spacedim = 2;</div><div class="line"></div><div class="line"></div><div class="line">      DistributedLagrangeProblem&lt;dim, spacedim&gt;::Parameters parameters;</div><div class="line">      DistributedLagrangeProblem&lt;dim, spacedim&gt;             problem(parameters);</div><div class="line"></div><div class="line">      std::string parameter_file;</div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1)</div><div class="line">        parameter_file = argv[1];</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        parameter_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>;</div><div class="line"></div><div class="line">      <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(parameter_file, <span class="stringliteral">&quot;used_parameters.prm&quot;</span>);</div><div class="line">      problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
