<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_16.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-16 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-16 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_6.html">step-6</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thetestcase">The testcase</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#TheScratchandCopyobjects">The Scratch and Copy objects</a>
        <li><a href="#ThecodeLaplaceProblemcodeclasstemplate">The <code>LaplaceProblem</code> class template</a>
        <li><a href="#ThecodeLaplaceProblemcodeclassimplementation">The <code>LaplaceProblem</code> class implementation</a>
      <ul>
        <li><a href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a>
        <li><a href="#LaplaceProblemcell_worker">LaplaceProblem::cell_worker</a>
        <li><a href="#LaplaceProblemassemble_system">LaplaceProblem::assemble_system</a>
        <li><a href="#LaplaceProblemassemble_multigrid">LaplaceProblem::assemble_multigrid</a>
        <li><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a>
        <li><a href="#Postprocessing">Postprocessing</a>
        <li><a href="#LaplaceProblemrun">LaplaceProblem::run</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em> Note: A variant called <a class="el" href="step_16b.html">step-16b</a> of this tutorial exists, that uses <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> and <a class="el" href="namespaceLocalIntegrators.html" title="Library of integrals over cells and faces 这个命名空间包含了双线性形式、形式和误差估计的特定应用局部\x{00E7}...">LocalIntegrators</a> instead of assembling matrices manually as it is done in this tutorial. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This example shows the basic usage of the multilevel functions in deal.II. It solves almost the same problem as used in <a class="el" href="step_6.html">step-6</a>, but demonstrating the things one has to provide when using multigrid as a preconditioner. In particular, this requires that we define a hierarchy of levels, provide transfer operators from one level to the next and back, and provide representations of the Laplace operator on each level.</p>
<p>In order to allow sufficient flexibility in conjunction with systems of differential equations and block preconditioners, quite a few different objects have to be created before starting the multilevel method, although most of what needs to be done is provided by deal.II itself. These are</p><ul>
<li>the object handling transfer between grids; we use the <a class="el" href="classMGTransferPrebuilt.html">MGTransferPrebuilt</a> class for this that does almost all of the work inside the library,</li>
<li>the solver on the coarsest level; here, we use <a class="el" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder</a>,</li>
<li>the smoother on all other levels, which in our case will be the <a class="el" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a> class using SOR as the underlying method,</li>
<li>and <a class="el" href="classmg_1_1Matrix.html">mg::Matrix</a>, a class having a special level multiplication, i.e. we basically store one matrix per grid level and allow multiplication with it.</li>
</ul>
<p>Most of these objects will only be needed inside the function that actually solves the linear system. There, these objects are combined in an object of type <a class="el" href="classMultigrid.html">Multigrid</a>, containing the implementation of the V-cycle, which is in turn used by the preconditioner <a class="el" href="classPreconditionMG.html">PreconditionMG</a>, ready for plug-in into a linear solver of the LAC library.</p>
<p>The multigrid method implemented here for adaptively refined meshes follows the outline in the <a class="el" href="DEALGlossary.html#mg_paper">Multigrid paper</a>, which describes the underlying implementation in deal.II and also introduces a lot of the nomenclature. First, we have to distinguish between level meshes, namely cells that have the same refinement distance from the coarse mesh, and the leaf mesh consisting of active cells of the hierarchy (in older work we refer to this as the global mesh, but this term is overused). Most importantly, the leaf mesh is not identical with the level mesh on the finest level. The following image shows what we consider to be a "level mesh":</p>
<div class="image">
<img src="multigrid.png" alt="multigrid.png"/>
</div>
<p>The fine level in this mesh consists only of the degrees of freedom that are defined on the refined cells, but does not extend to that part of the domain that is not refined. While this guarantees that the overall effort grows as \({\cal O}(N)\) as necessary for optimal multigrid complexity, it leads to problems when defining where to smooth and what boundary conditions to pose for the operators defined on individual levels if the level boundary is not an external boundary. These questions are discussed in detail in the article cited above.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>The problem we solve here is similar to <a class="el" href="step_6.html">step-6</a>, with two main differences: first, the multigrid preconditioner, obviously. We also change the discontinuity of the coefficients such that the local assembler does not look more complicated than necessary.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Again, the first few include files are already known, so we won't comment on them:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div></div><!-- fragment --><p>These, now, are the include necessary for the multilevel methods. The first one declares how to handle Dirichlet boundary conditions on each of the levels of the multigrid method. For the actual description of the degrees of freedom, we do not need any new include file because <a class="el" href="classDoFHandler.html">DoFHandler</a> already has all necessary methods implemented. We will only need to distribute the DoFs for the levels further down.</p>
<p>The rest of the include files deals with the mechanics of multigrid as a linear operator (solver or preconditioner).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div></div><!-- fragment --><p>We will be using <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a> to loop over the cells, so include it here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div></div><!-- fragment --><p>This is C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step16</div><div class="line">{</div></div><!-- fragment --><p><a class="anchor" id="TheScratchandCopyobjects"></a> </p><h3>The Scratch and Copy objects</h3>
<p>We use <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> to assemble our matrices. For this, we need a ScratchData object to store temporary data on each cell (this is just the <a class="el" href="classFEValues.html">FEValues</a> object) and a CopyData object that will contain the output of each cell assembly. For more details about the usage of scratch and copy objects, see the <a class="el" href="namespaceWorkStream.html">WorkStream</a> namespace.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>ScratchData</div><div class="line">{</div><div class="line">  ScratchData(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        quadrature_degree,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags)</div><div class="line">    : fe_values(mapping, fe, <a class="code" href="classQGauss.html">QGauss</a>&lt;dim&gt;(quadrature_degree), update_flags)</div><div class="line">  {}</div><div class="line"></div><div class="line">  ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">    : fe_values(scratch_data.fe_values.get_mapping(),</div><div class="line">                scratch_data.fe_values.get_fe(),</div><div class="line">                scratch_data.fe_values.get_quadrature(),</div><div class="line">                scratch_data.fe_values.get_update_flags())</div><div class="line">  {}</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>CopyData</div><div class="line">{</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                         <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       cell_rhs;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> Iterator &amp;cell, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">  {</div><div class="line">    cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line">    cell_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dofs_per_cell);</div><div class="line"></div><div class="line">    local_dof_indices.resize(dofs_per_cell);</div><div class="line">    cell-&gt;get_active_or_mg_dof_indices(local_dof_indices);</div><div class="line">    level = cell-&gt;level();</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceProblemcodeclasstemplate"></a> </p><h3>The <code>LaplaceProblem</code> class template</h3>
<p>This main class is similar to the same class in <a class="el" href="step_6.html">step-6</a>. As far as member functions is concerned, the only additions are:</p><ul>
<li>The <code>assemble_multigrid</code> function that assembles the matrices that correspond to the discrete operators on intermediate levels.</li>
<li>The <code>cell_worker</code> function that assembles our PDE on a single cell.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>LaplaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">  <span class="keywordtype">void</span> cell_worker(<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                   ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                   CopyData &amp;        copy_data);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_multigrid();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> refine_grid();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div></div><!-- fragment --><p>The following members are the essential data structures for the multigrid method. The first four represent the sparsity patterns and the matrices on individual levels of the multilevel hierarchy, very much like the objects for the global mesh above.</p>
<p>Then we have two new matrices only needed for multigrid methods with local smoothing on adaptive meshes. They convey data between the interior part of the refined region and the refinement edge, as outlined in detail in the <a class="el" href="DEALGlossary.html#mg_paper">multigrid paper</a>.</p>
<p>The last object stores information about the boundary indices on each level and information about indices lying on a refinement edge between two different refinement levels. It thus serves a similar purpose as <a class="el" href="classAffineConstraints.html">AffineConstraints</a>, but on each level.</p>
<div class="fragment"><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_sparsity_patterns;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_interface_sparsity_patterns;</div><div class="line"></div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_matrices;</div><div class="line">  <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a>                   mg_constrained_dofs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceProblemcodeclassimplementation"></a> </p><h3>The <code>LaplaceProblem</code> class implementation</h3>
<p>Just one short remark about the constructor of the <a class="el" href="classTriangulation.html">Triangulation</a>: by convention, all adaptively refined triangulations in deal.II never change by more than one level across a face between cells. For our multigrid algorithms, however, we need a slightly stricter guarantee, namely that the mesh also does not change by more than refinement level across vertices that might connect two cells. In other words, we must prevent the following situation:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt="limit_level_difference_at_vertices.png"/>
</div>
<p>This is achieved by passing the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">Triangulation::limit_level_difference_at_vertices</a> flag to the constructor of the triangulation class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">LaplaceProblem&lt;dim&gt;::LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">  , fe(degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , degree(degree)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsetup_system"></a> </p><h4>LaplaceProblem::setup_system</h4>
<p>In addition to just distributing the degrees of freedom in the <a class="el" href="classDoFHandler.html">DoFHandler</a>, we do the same on each level. Then, we follow the same procedure as before to set up the system on the leaf mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (by level: &quot;</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.n_levels(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    std::cout &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level)</div><div class="line">              &lt;&lt; (level == triangulation.n_levels() - 1 ? <span class="stringliteral">&quot;)&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>);</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">  std::set&lt;types::boundary_id&gt; dirichlet_boundary_ids = {0};</div><div class="line">  <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> homogeneous_dirichlet_bc;</div><div class="line">  <span class="keyword">const</span> std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt;</div><div class="line">    dirichlet_boundary_functions = {</div><div class="line">      {<a class="code" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>(0), &amp;homogeneous_dirichlet_bc}};</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           dirichlet_boundary_functions,</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints);</div><div class="line">    sparsity_pattern.copy_from(dsp);</div><div class="line">  }</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>The multigrid constraints have to be initialized. They need to know where Dirichlet boundary conditions are prescribed.</p>
<div class="fragment"><div class="line">mg_constrained_dofs.clear();</div><div class="line">mg_constrained_dofs.initialize(dof_handler);</div><div class="line">mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                   dirichlet_boundary_ids);</div></div><!-- fragment --><p>Now for the things that concern the multigrid data structures. First, we resize the multilevel objects to hold matrices and sparsity patterns for every level. The coarse level is zero (this is mandatory right now but may change in a future revision). Note that these functions take a complete, inclusive range here (not a starting index and size), so the finest level is <code>n_levels-1</code>. We first have to resize the container holding the <a class="el" href="classSparseMatrix.html">SparseMatrix</a> classes, since they have to release their <a class="el" href="classSparsityPattern.html">SparsityPattern</a> before the can be destroyed upon resizing.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">mg_interface_matrices.resize(0, n_levels - 1);</div><div class="line">mg_matrices.resize(0, n_levels - 1);</div><div class="line">mg_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line">mg_interface_sparsity_patterns.resize(0, n_levels - 1);</div></div><!-- fragment --><p>Now, we have to provide a matrix on each level. To this end, we first use the <a class="el" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a> function to generate a preliminary compressed sparsity pattern on each level (see the <a class="el" href="group__Sparsity.html">Sparsity patterns</a> module for more information on this topic) and then copy it over to the one we really want. The next step is to initialize the interface matrices with the fitting sparsity pattern.</p>
<p>It may be worth pointing out that the interface matrices only have entries for degrees of freedom that sit at or next to the interface between coarser and finer levels of the mesh. They are therefore even sparser than the matrices on the individual levels of our multigrid hierarchy. Therefore, we use a function specifically build for this purpose to generate it.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      {</div><div class="line">        <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                   dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">        <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line"></div><div class="line">        mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">      }</div><div class="line">      {</div><div class="line">        <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                   dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">        <a class="code" href="namespaceMGTools.html#a8c677f65f8f1d21fb1f4c55cb90079e0">MGTools::make_interface_sparsity_pattern</a>(dof_handler,</div><div class="line">                                                 mg_constrained_dofs,</div><div class="line">                                                 dsp,</div><div class="line">                                                 level);</div><div class="line">        mg_interface_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">        mg_interface_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(</div><div class="line">          mg_interface_sparsity_patterns[level]);</div><div class="line">      }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemcell_worker"></a> </p><h4>LaplaceProblem::cell_worker</h4>
<p>The cell_worker function is used to assemble the matrix and right-hand side on the given cell. This function is used for the active cells to generate the system_matrix and on each level to build the level matrices.</p>
<p>Note that we also assemble a right-hand side when called from assemble_multigrid() even though it is not used.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::cell_worker(<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                                      ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                                      CopyData &amp;        copy_data)</div><div class="line">{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = scratch_data.fe_values;</div><div class="line">  fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line"></div><div class="line">  copy_data.reinit(cell, dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_values.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient =</div><div class="line">        (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>()[q][0] &lt; 0.0) ? 1.0 : 0.1;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              copy_data.cell_matrix(i, j) +=</div><div class="line">                coefficient *</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)) *</div><div class="line">                JxW[q];</div><div class="line">            }</div><div class="line">          copy_data.cell_rhs(i) += 1.0 * fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q) * JxW[q];</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_system"></a> </p><h4>LaplaceProblem::assemble_system</h4>
<p>The following function assembles the linear system on the active cells of the mesh. For this, we pass two lambda functions to the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop()</a> function. The cell_worker function redirects to the class member function of the same name, while the copier is specific to this function and copies local matrix and vector to the corresponding global ones using the constraints.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> cell_worker =</div><div class="line">    [&amp;](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">        ScratchData&lt;dim&gt; &amp;                                    scratch_data,</div><div class="line">        CopyData &amp;                                            copy_data) {</div><div class="line">      this-&gt;cell_worker(cell, scratch_data, copy_data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;cd) {</div><div class="line">    this-&gt;constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cd.cell_matrix,</div><div class="line">                                                 cd.cell_rhs,</div><div class="line">                                                 cd.local_dof_indices,</div><div class="line">                                                 system_matrix,</div><div class="line">                                                 system_rhs);</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = degree + 1;</div><div class="line"></div><div class="line">  ScratchData&lt;dim&gt; scratch_data(mapping,</div><div class="line">                                fe,</div><div class="line">                                n_gauss_points,</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        scratch_data,</div><div class="line">                        CopyData(),</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_multigrid"></a> </p><h4>LaplaceProblem::assemble_multigrid</h4>
<p>The next function is the one that builds the matrices that define the multigrid method on each level of the mesh. The integration core is the same as above, but the loop below will go over all existing cells instead of just the active ones, and the results must be entered into the correct level matrices. Fortunately, <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> hides most of that from us, and thus the difference between this function and the previous lies only in the setup of the assembler and the different iterators in the loop.</p>
<p>We generate an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object for each level containing the boundary and interface dofs as constrained entries. The corresponding object is then used to generate the level matrices.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid()</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>     mapping;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">  std::vector&lt;AffineConstraints&lt;double&gt;&gt; boundary_constraints(n_levels);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      <a class="code" href="classIndexSet.html">IndexSet</a> dofset;</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                    level,</div><div class="line">                                                    dofset);</div><div class="line">      boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(dofset);</div><div class="line">      boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">        mg_constrained_dofs.get_refinement_edge_indices(level));</div><div class="line">      boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">        mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">      boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].close();</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> cell_worker =</div><div class="line">    [&amp;](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::level_cell_iterator</a> &amp;cell,</div><div class="line">        ScratchData&lt;dim&gt; &amp;                                   scratch_data,</div><div class="line">        CopyData &amp;                                           copy_data) {</div><div class="line">      this-&gt;cell_worker(cell, scratch_data, copy_data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;cd) {</div><div class="line">    boundary_constraints[cd.level].distribute_local_to_global(</div><div class="line">      cd.cell_matrix, cd.local_dof_indices, mg_matrices[cd.level]);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cd.local_dof_indices.size();</div></div><!-- fragment --><p>Interface entries are ignored by the boundary_constraints object above when filling the mg_matrices[cd.level]. Instead, we copy these entries into the interface matrix of the current level manually:</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        <span class="keywordflow">if</span> (mg_constrained_dofs.is_interface_matrix_entry(</div><div class="line">              cd.level, cd.local_dof_indices[i], cd.local_dof_indices[j]))</div><div class="line">          {</div><div class="line">            mg_interface_matrices[cd.level].add(cd.local_dof_indices[i],</div><div class="line">                                                cd.local_dof_indices[j],</div><div class="line">                                                cd.cell_matrix(i, j));</div><div class="line">          }</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = degree + 1;</div><div class="line"></div><div class="line">  ScratchData&lt;dim&gt; scratch_data(mapping,</div><div class="line">                                fe,</div><div class="line">                                n_gauss_points,</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        scratch_data,</div><div class="line">                        CopyData(),</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsolve"></a> </p><h4>LaplaceProblem::solve</h4>
<p>This is the other function that is significantly different in support of the multigrid solver (or, in fact, the preconditioner for which we use the multigrid method).</p>
<p>Let us start out by setting up two of the components of multilevel methods: transfer operators between levels, and a solver on the coarsest level. In finite element methods, the transfer operators are derived from the finite element function spaces involved and can often be computed in a generic way independent of the problem under consideration. In that case, we can use the <a class="el" href="classMGTransferPrebuilt.html">MGTransferPrebuilt</a> class that, given the constraints of the final linear system and the <a class="el" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> object that knows about the boundary conditions on the each level and the degrees of freedom on interfaces between different refinement level can build the matrices for those transfer operations from a <a class="el" href="classDoFHandler.html">DoFHandler</a> object with level degrees of freedom.</p>
<p>The second part of the following lines deals with the coarse grid solver. Since our coarse grid is very coarse indeed, we decide for a direct solver (a <a class="el" href="classHouseholder.html">Householder</a> decomposition of the coarsest level matrix), even if its implementation is not particularly sophisticated. If our coarse mesh had many more cells than the five we have here, something better suited would obviously be necessary here.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt; mg_transfer(mg_constrained_dofs);</div><div class="line">  mg_transfer.build(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">  coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">  <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">  coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div></div><!-- fragment --><p>The next component of a multilevel solver or preconditioner is that we need a smoother on each level. A common choice for this is to use the application of a relaxation method (such as the SOR, Jacobi or Richardson method) or a small number of iterations of a solver method (such as CG or GMRES). The <a class="el" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a> and <a class="el" href="classMGSmootherPrecondition.html">MGSmootherPrecondition</a> classes provide support for these two kinds of smoothers. Here, we opt for the application of a single SOR iteration. To this end, we define an appropriate alias and then setup a smoother object.</p>
<p>The last step is to initialize the smoother object with our level matrices and to set some smoothing parameters. The <code>initialize()</code> function can optionally take additional arguments that will be passed to the smoother object on each level. In the current case for the SOR smoother, this could, for example, include a relaxation parameter. However, we here leave these at their default values. The call to <code>set_steps()</code> indicates that we will use two pre- and two post-smoothing steps on each level; to use a variable number of smoother steps on different levels, more options can be set in the constructor call to the <code>mg_smoother</code> object.</p>
<p>The last step results from the fact that we use the SOR method as a smoother - which is not symmetric - but we use the conjugate gradient iteration (which requires a symmetric preconditioner) below, we need to let the multilevel preconditioner make sure that we get a symmetric operator even for nonsymmetric smoothers:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line"><a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation&lt;Smoother, Vector&lt;double&gt;</a>&gt; mg_smoother;</div><div class="line">mg_smoother.<a class="code" href="classmg_1_1SmootherRelaxation.html#ae9e03c626c50a1b13dffe338f5f977b0">initialize</a>(mg_matrices);</div><div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(2);</div><div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#abed2837ee4e224f94c6a98405906df8f">set_symmetric</a>(<span class="keyword">true</span>);</div></div><!-- fragment --><p>The next preparatory step is that we must wrap our level and interface matrices in an object having the required multiplication functions. We will create two objects for the interface objects going from coarse to fine and the other way around; the multigrid algorithm will later use the transpose operator for the latter operation, allowing us to initialize both up and down versions of the operator with the matrices we already built:</p>
<div class="fragment"><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix(mg_matrices);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_up(mg_interface_matrices);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_down(mg_interface_matrices);</div></div><!-- fragment --><p>Now, we are ready to set up the V-cycle operator and the multilevel preconditioner.</p>
<div class="fragment"><div class="line"><a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">  mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);</div><div class="line"><a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_down, mg_interface_up);</div><div class="line"></div><div class="line"><a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt;&gt;</div><div class="line">  preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div></div><!-- fragment --><p>With all this together, we can finally get about solving the linear system in the usual way:</p>
<div class="fragment"><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">  solution = 0;</div><div class="line"></div><div class="line">  solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of CG iterations: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Postprocessing"></a> </p><h4>Postprocessing</h4>
<p>The following two functions postprocess a solution once it is computed. In particular, the first one refines the mesh at the beginning of each cycle while the second one outputs results at the end of each such cycle. The functions are almost unchanged from those in <a class="el" href="step_6.html">step-6</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::refine_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(degree + 2),</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">    solution,</div><div class="line">    estimated_error_per_cell);</div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.03);</div><div class="line">  triangulation.execute_coarsening_and_refinement();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemrun"></a> </p><h4>LaplaceProblem::run</h4>
<p>Like several of the functions above, this is almost exactly a copy of the corresponding function in <a class="el" href="step_6.html">step-6</a>. The only difference is the call to <code>assemble_multigrid</code> that takes care of forming the matrices on every level that we need in the multigrid method.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 8; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">            triangulation.refine_global(2);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.n_active_cells() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line">        assemble_multigrid();</div><div class="line"></div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step16</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>This is again the same function as in <a class="el" href="step_6.html">step-6</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step16;</div><div class="line"></div><div class="line">      LaplaceProblem&lt;2&gt; laplace_problem(1);</div><div class="line">      laplace_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>On the finest mesh, the solution looks like this:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-16.solution.png"/>
</div>
 <p>More importantly, we would like to see if the multigrid method really improved the solver performance. Therefore, here is the textual output:</p>
<pre>
Cycle 0
   Number of active cells:       80
   Number of degrees of freedom: 89 (by level: 8, 25, 89)
   Number of CG iterations: 8</pre><pre>Cycle 1
   Number of active cells:       158
   Number of degrees of freedom: 183 (by level: 8, 25, 89, 138)
   Number of CG iterations: 9</pre><pre>Cycle 2
   Number of active cells:       302
   Number of degrees of freedom: 352 (by level: 8, 25, 89, 223, 160)
   Number of CG iterations: 10</pre><pre>Cycle 3
   Number of active cells:       578
   Number of degrees of freedom: 649 (by level: 8, 25, 89, 231, 494, 66)
   Number of CG iterations: 10</pre><pre>Cycle 4
   Number of active cells:       1100
   Number of degrees of freedom: 1218 (by level: 8, 25, 89, 274, 764, 417, 126)
   Number of CG iterations: 10</pre><pre>Cycle 5
   Number of active cells:       2096
   Number of degrees of freedom: 2317 (by level: 8, 25, 89, 304, 779, 1214, 817)
   Number of CG iterations: 11</pre><pre>Cycle 6
   Number of active cells:       3986
   Number of degrees of freedom: 4366 (by level: 8, 25, 89, 337, 836, 2270, 897, 1617)
   Number of CG iterations: 10</pre><pre>Cycle 7
   Number of active cells:       7574
   Number of degrees of freedom: 8350 (by level: 8, 25, 89, 337, 1086, 2835, 2268, 1789, 3217)
   Number of CG iterations: 11
</pre><p>That's almost perfect multigrid performance: the linear residual gets reduced by 12 orders of magnitude in 10 iteration steps, and the results are almost independent of the mesh size. That's obviously in part due to the simple nature of the problem solved, but it shows the power of multigrid methods.</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>We encourage you to generate timings for the solve() call and compare to <a class="el" href="step_6.html">step-6</a>. You will see that the multigrid method has quite an overhead on coarse meshes, but that it always beats other methods on fine meshes because of its optimal complexity.</p>
<p>A close inspection of this program's performance shows that it is mostly dominated by matrix-vector operations. <a class="el" href="step_37.html">step-37</a> shows one way how this can be avoided by working with matrix-free methods.</p>
<p>Another avenue would be to use algebraic multigrid methods. The geometric multigrid method used here can at times be a bit awkward to implement because it needs all those additional data structures, and it becomes even more difficult if the program is to run in parallel on machines coupled through MPI, for example. In that case, it would be simpler if one could use a black-box preconditioner that uses some sort of multigrid hierarchy for good performance but can figure out level matrices and similar things by itself. Algebraic multigrid methods do exactly this, and we will use them in <a class="el" href="step_31.html">step-31</a> for the solution of a Stokes problem and in <a class="el" href="step_32.html">step-32</a> and <a class="el" href="step_40.html">step-40</a> for a parallel variation. That said, a parallel version of this example program with MPI can be found in <a class="el" href="step_50.html">step-50</a>.</p>
<p>Finally, one may want to think how to use geometric multigrid for other kinds of problems, specifically <a class="el" href="group__vector__valued.html">vector valued problems</a>. This is the topic of <a class="el" href="step_56.html">step-56</a> where we use the techniques shown here for the Stokes equation.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2003 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Guido Kanschat, University of Heidelberg, 2003</span></div><div class="line"><span class="comment"> *          Baerbel Janssen, University of Heidelberg, 2010</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University, 2010</span></div><div class="line"><span class="comment"> *          Timo Heister, Clemson University, 2018</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step16</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>ScratchData</div><div class="line">  {</div><div class="line">    ScratchData(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        quadrature_degree,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags)</div><div class="line">      : fe_values(mapping, fe, <a class="code" href="classQGauss.html">QGauss</a>&lt;dim&gt;(quadrature_degree), update_flags)</div><div class="line">    {}</div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">      : fe_values(scratch_data.fe_values.get_mapping(),</div><div class="line">                  scratch_data.fe_values.get_fe(),</div><div class="line">                  scratch_data.fe_values.get_quadrature(),</div><div class="line">                  scratch_data.fe_values.get_update_flags())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyData</div><div class="line">  {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                         <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    Vector&lt;double&gt;                       cell_rhs;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> Iterator &amp;cell, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">    {</div><div class="line">      cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line">      cell_rhs.reinit(dofs_per_cell);</div><div class="line"></div><div class="line">      local_dof_indices.resize(dofs_per_cell);</div><div class="line">      cell-&gt;get_active_or_mg_dof_indices(local_dof_indices);</div><div class="line">      level = cell-&gt;level();</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">    <span class="keywordtype">void</span> cell_worker(<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                     ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                     CopyData &amp;        copy_data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_multigrid();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> refine_grid();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_sparsity_patterns;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_interface_sparsity_patterns;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_matrices;</div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a>                   mg_constrained_dofs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceProblem&lt;dim&gt;::LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">    , fe(degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , degree(degree)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (by level: &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.n_levels(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      std::cout &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level)</div><div class="line">                &lt;&lt; (level == triangulation.n_levels() - 1 ? <span class="stringliteral">&quot;)&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>);</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt; dirichlet_boundary_ids = {0};</div><div class="line">    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> homogeneous_dirichlet_bc;</div><div class="line">    <span class="keyword">const</span> std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt;</div><div class="line">      dirichlet_boundary_functions = {</div><div class="line">        {<a class="code" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>(0), &amp;homogeneous_dirichlet_bc}};</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             dirichlet_boundary_functions,</div><div class="line">                                             constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints);</div><div class="line">      sparsity_pattern.copy_from(dsp);</div><div class="line">    }</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    mg_constrained_dofs.clear();</div><div class="line">    mg_constrained_dofs.initialize(dof_handler);</div><div class="line">    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                       dirichlet_boundary_ids);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">    mg_interface_matrices.resize(0, n_levels - 1);</div><div class="line">    mg_matrices.resize(0, n_levels - 1);</div><div class="line">    mg_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line">    mg_interface_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        {</div><div class="line">          <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                     dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">          <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line"></div><div class="line">          mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">          mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">        }</div><div class="line">        {</div><div class="line">          <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                     dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">          <a class="code" href="namespaceMGTools.html#a8c677f65f8f1d21fb1f4c55cb90079e0">MGTools::make_interface_sparsity_pattern</a>(dof_handler,</div><div class="line">                                                   mg_constrained_dofs,</div><div class="line">                                                   dsp,</div><div class="line">                                                   level);</div><div class="line">          mg_interface_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">          mg_interface_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(</div><div class="line">            mg_interface_sparsity_patterns[level]);</div><div class="line">        }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::cell_worker(<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                                        ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                                        CopyData &amp;        copy_data)</div><div class="line">  {</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = scratch_data.fe_values;</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line"></div><div class="line">    copy_data.reinit(cell, dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_values.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient =</div><div class="line">          (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>()[q][0] &lt; 0.0) ? 1.0 : 0.1;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                copy_data.cell_matrix(i, j) +=</div><div class="line">                  coefficient *</div><div class="line">                  (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)) *</div><div class="line">                  JxW[q];</div><div class="line">              }</div><div class="line">            copy_data.cell_rhs(i) += 1.0 * fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q) * JxW[q];</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> cell_worker =</div><div class="line">      [&amp;](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">          ScratchData&lt;dim&gt; &amp;                                    scratch_data,</div><div class="line">          CopyData &amp;                                            copy_data) {</div><div class="line">        this-&gt;cell_worker(cell, scratch_data, copy_data);</div><div class="line">      };</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;cd) {</div><div class="line">      this-&gt;constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cd.cell_matrix,</div><div class="line">                                                   cd.cell_rhs,</div><div class="line">                                                   cd.local_dof_indices,</div><div class="line">                                                   system_matrix,</div><div class="line">                                                   system_rhs);</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = degree + 1;</div><div class="line"></div><div class="line">    ScratchData&lt;dim&gt; scratch_data(mapping,</div><div class="line">                                  fe,</div><div class="line">                                  n_gauss_points,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          scratch_data,</div><div class="line">                          CopyData(),</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>     mapping;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">    std::vector&lt;AffineConstraints&lt;double&gt;&gt; boundary_constraints(n_levels);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classIndexSet.html">IndexSet</a> dofset;</div><div class="line">        <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                      level,</div><div class="line">                                                      dofset);</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(dofset);</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">          mg_constrained_dofs.get_refinement_edge_indices(level));</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">          mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].close();</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> cell_worker =</div><div class="line">      [&amp;](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::level_cell_iterator</a> &amp;cell,</div><div class="line">          ScratchData&lt;dim&gt; &amp;                                   scratch_data,</div><div class="line">          CopyData &amp;                                           copy_data) {</div><div class="line">        this-&gt;cell_worker(cell, scratch_data, copy_data);</div><div class="line">      };</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;cd) {</div><div class="line">      boundary_constraints[cd.level].distribute_local_to_global(</div><div class="line">        cd.cell_matrix, cd.local_dof_indices, mg_matrices[cd.level]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cd.local_dof_indices.size();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          <span class="keywordflow">if</span> (mg_constrained_dofs.is_interface_matrix_entry(</div><div class="line">                cd.level, cd.local_dof_indices[i], cd.local_dof_indices[j]))</div><div class="line">            {</div><div class="line">              mg_interface_matrices[cd.level].add(cd.local_dof_indices[i],</div><div class="line">                                                  cd.local_dof_indices[j],</div><div class="line">                                                  cd.cell_matrix(i, j));</div><div class="line">            }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = degree + 1;</div><div class="line"></div><div class="line">    ScratchData&lt;dim&gt; scratch_data(mapping,</div><div class="line">                                  fe,</div><div class="line">                                  n_gauss_points,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          scratch_data,</div><div class="line">                          CopyData(),</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt; mg_transfer(mg_constrained_dofs);</div><div class="line">    mg_transfer.build(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">    coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">    <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">    coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div><div class="line"></div><div class="line">    <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line">    <a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation&lt;Smoother, Vector&lt;double&gt;</a>&gt; mg_smoother;</div><div class="line">    mg_smoother.<a class="code" href="classmg_1_1SmootherRelaxation.html#ae9e03c626c50a1b13dffe338f5f977b0">initialize</a>(mg_matrices);</div><div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(2);</div><div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#abed2837ee4e224f94c6a98405906df8f">set_symmetric</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix(mg_matrices);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_up(mg_interface_matrices);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_down(mg_interface_matrices);</div><div class="line"></div><div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">      mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);</div><div class="line">    <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_down, mg_interface_up);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt;&gt;</div><div class="line">      preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">    solution = 0;</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of CG iterations: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::refine_grid()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(degree + 2),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line">    triangulation.execute_coarsening_and_refinement();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 8; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">            triangulation.refine_global(2);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.n_active_cells() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line">        assemble_multigrid();</div><div class="line"></div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step16</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step16;</div><div class="line"></div><div class="line">      LaplaceProblem&lt;2&gt; laplace_problem(1);</div><div class="line">      laplace_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_6.html">step-6</a> . <table class="tutorial"
 width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#Thetestcase">The testcase</a><a href="#Thetestcase">The
 testcase</a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Includefiles">Include files</a><a
 href="#Includefiles">Include files</a>
 <li><a href="#TheScratchandCopyobjects">The Scratch and Copy objects</a><a
 href="#TheScratchandCopyobjects">The Scratch and Copy objects</a>
 <li><a href="#ThecodeLaplaceProblemcodeclasstemplate">The
 <code>LaplaceProblem</code> class template</a><a
 href="#ThecodeLaplaceProblemcodeclasstemplate">The
 <code>LaplaceProblem</code> class template</a>
 <li><a href="#ThecodeLaplaceProblemcodeclassimplementation">The
 <code>LaplaceProblem</code> class implementation</a><a
 href="#ThecodeLaplaceProblemcodeclassimplementation">The
 <code>LaplaceProblem</code> class implementation</a>
 <ul>
 <li><a
 href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a><a
 href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a>
 <li><a href="#LaplaceProblemcell_worker">LaplaceProblem::cell_worker</a><a
 href="#LaplaceProblemcell_worker">LaplaceProblem::cell_worker</a>
 <li><a
 href="#LaplaceProblemassemble_system">LaplaceProblem::assemble_system</a><a
 href="#LaplaceProblemassemble_system">LaplaceProblem::assemble_system</a>
 <li><a
 href="#LaplaceProblemassemble_multigrid">LaplaceProblem::assemble_multigrid</a><a
 href="#LaplaceProblemassemble_multigrid">LaplaceProblem::assemble_multigrid</a>
 <li><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a><a
 href="#LaplaceProblemsolve">LaplaceProblem::solve</a>
 <li><a href="#Postprocessing">Postprocessing</a><a
 href="#Postprocessing">Postprocessing</a>
 <li><a href="#LaplaceProblemrun">LaplaceProblem::run</a><a
 href="#LaplaceProblemrun">LaplaceProblem::run</a>
 </ul>
 <li><a href="#Themainfunction">The main() function</a><a
 href="#Themainfunction">The main() function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#Possibilitiesforextensions"> Possibilities for extensions
 </a><a href="#Possibilitiesforextensions"> Possibilities for extensions
 </a>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <br />
 <em> Note: A variant called <a class="el" href="step_16b.html">step-16b</a> of this tutorial exists, that uses <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> and <a class="el" href="namespaceLocalIntegrators.html" title="Library of integrals over cells and faces 这个命名空间包含了双线性形式、形式和误差估计的特定应用局部\x{00E7}...">LocalIntegrators</a> instead of assembling matrices manually as it is done in this tutorial. </em> <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This example shows the basic usage of the multilevel functions in deal.II. Itsolves almost the same problem as used in <a class="el" href="step_6.html">step-6</a> , but demonstrating the thingsone has to provide when using multigrid as a preconditioner. In particular, thisrequires that we define a hierarchy of levels, provide transfer operators fromone level to the next and back, and provide representations of the Laplaceoperator on each level. In order to allow sufficient flexibility in conjunction with systems ofdifferential equations and block preconditioners, quite a few different objectshave to be created before starting the multilevel method, althoughmost of what needs to be done is provided by deal.II itself. These are</p>
<ul>
<li>the object handling transfer between grids; we use the <a class="el" href="classMGTransferPrebuilt.html">MGTransferPrebuilt</a> class for this that does almost all of the work inside the library,</li>
<li>the solver on the coarsest level; here, we use <a class="el" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder</a>,</li>
<li>the smoother on all other levels, which in our case will be the <a class="el" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a> class using SOR as the underlying method,</li>
<li>and <a class="el" href="classmg_1_1Matrix.html">mg::Matrix</a>, a class having a special level multiplication, i.e. we basically store one matrix per grid level and allow multiplication with it. Most of these objects will only be needed inside the function thatactually solves the linear system. There, these objects are combinedin an object of type <a class="el" href="classMultigrid.html">Multigrid</a>, containing the implementation of theV-cycle, which is in turn used by the preconditioner <a class="el" href="classPreconditionMG.html">PreconditionMG</a>,ready for plug-in into a linear solver of the LAC library. </li>
</ul>
<div class="image">
<img src="multigrid.png" alt="multigrid.png"/>
</div>
 <p>The fine level in this mesh consists only of the degrees of freedom that aredefined on the refined cells, but does not extend to that part of the domainthat is not refined. While this guarantees that the overall effort grows as \({\cal O}(N)\) as necessary for optimal multigrid complexity, it leads toproblems when defining where to smooth and what boundary conditions to pose forthe operators defined on individual levels if the level boundary is not anexternal boundary. These questions are discussed in detail in the article citedabove. <a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>The problem we solve here is similar to <a class="el" href="step_6.html">step-6</a> , with two maindifferences: first, the multigrid preconditioner, obviously. We alsochange the discontinuity of the coefficients such that the localassembler does not look more complicated than necessary.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Again, the first few include files are already known, so we won't comment on them:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div></div><!-- fragment --><p>These, now, are the include necessary for the multilevel methods. The first one declares how to handle Dirichlet boundary conditions on each of the levels of the multigrid method. For the actual description of the degrees of freedom, we do not need any new include file because <a class="el" href="classDoFHandler.html">DoFHandler</a> already has all necessary methods implemented. We will only need to distribute the DoFs for the levels further down.</p>
<p>The rest of the include files deals with the mechanics of multigrid as a linear operator (solver or preconditioner).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div></div><!-- fragment --><p>We will be using <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a> to loop over the cells, so include it here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div></div><!-- fragment --><p>This is C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step16</div><div class="line">{</div></div><!-- fragment --><p><a class="anchor" id="TheScratchandCopyobjects"></a> </p><h3>The Scratch and Copy objects</h3>
<p>We use <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> to assemble our matrices. For this, we need a ScratchData object to store temporary data on each cell (this is just the <a class="el" href="classFEValues.html">FEValues</a> object) and a CopyData object that will contain the output of each cell assembly. For more details about the usage of scratch and copy objects, see the <a class="el" href="namespaceWorkStream.html">WorkStream</a> namespace.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>ScratchData</div><div class="line">{</div><div class="line">  ScratchData(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        quadrature_degree,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags)</div><div class="line">    : fe_values(mapping, fe, <a class="code" href="classQGauss.html">QGauss</a>&lt;dim&gt;(quadrature_degree), update_flags)</div><div class="line">  {}</div><div class="line"></div><div class="line">  ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">    : fe_values(scratch_data.fe_values.get_mapping(),</div><div class="line">                scratch_data.fe_values.get_fe(),</div><div class="line">                scratch_data.fe_values.get_quadrature(),</div><div class="line">                scratch_data.fe_values.get_update_flags())</div><div class="line">  {}</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>CopyData</div><div class="line">{</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                         <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       cell_rhs;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> Iterator &amp;cell, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">  {</div><div class="line">    cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line">    cell_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dofs_per_cell);</div><div class="line"></div><div class="line">    local_dof_indices.resize(dofs_per_cell);</div><div class="line">    cell-&gt;get_active_or_mg_dof_indices(local_dof_indices);</div><div class="line">    level = cell-&gt;level();</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceProblemcodeclasstemplate"></a> </p><h3>The <code>LaplaceProblem</code> class template</h3>
<p>This main class is similar to the same class in <a class="el" href="step_6.html">step-6</a> . As far as member functions is concerned, the only additions are:</p>
<ul>
<li>The <code>assemble_multigrid</code> function that assembles the matrices that correspond to the discrete operators on intermediate levels.</li>
<li>The <code>cell_worker</code> function that assembles our PDE on a single cell.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>LaplaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">  <span class="keywordtype">void</span> cell_worker(<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                   ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                   CopyData &amp;        copy_data);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_multigrid();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> refine_grid();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div></div><!-- fragment --><p>The following members are the essential data structures for the multigrid method. The first four represent the sparsity patterns and the matrices on individual levels of the multilevel hierarchy, very much like the objects for the global mesh above. Then we have two new matrices only needed for multigrid methods with local smoothing on adaptive meshes. They convey data between the interior part of the refined region and the refinement edge, as outlined in detail in the <a class="el" href="DEALGlossary.html#mg_paper">multigrid paper</a>. The last object stores information about the boundary indices on each level and information about indices lying on a refinement edge between two different refinement levels. It thus serves a similar purpose as <a class="el" href="classAffineConstraints.html">AffineConstraints</a>, but on each level.</p>
<div class="fragment"><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_sparsity_patterns;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_interface_sparsity_patterns;</div><div class="line"></div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_matrices;</div><div class="line">  <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a>                   mg_constrained_dofs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceProblemcodeclassimplementation"></a> </p><h3>The <code>LaplaceProblem</code> class implementation</h3>
<p>Just one short remark about the constructor of the <a class="el" href="classTriangulation.html">Triangulation</a>: by convention, all adaptively refined triangulations in deal.II never change by more than one level across a face between cells. For our multigrid algorithms, however, we need a slightly stricter guarantee, namely that the mesh also does not change by more than refinement level across vertices that might connect two cells. In other words, we must prevent the following situation: </p><div class="image">
<img src="limit_level_difference_at_vertices.png" alt="limit_level_difference_at_vertices.png"/>
</div>
<p> This is achieved by passing the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">Triangulation::limit_level_difference_at_vertices</a> flag to the constructor of the triangulation class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">LaplaceProblem&lt;dim&gt;::LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">  , fe(degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , degree(degree)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsetup_system"></a> </p><h4>LaplaceProblem::setup_system</h4>
<p>In addition to just distributing the degrees of freedom in the <a class="el" href="classDoFHandler.html">DoFHandler</a>, we do the same on each level. Then, we follow the same procedure as before to set up the system on the leaf mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (by level: &quot;</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.n_levels(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    std::cout &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level)</div><div class="line">              &lt;&lt; (level == triangulation.n_levels()</div><div class="line"></div><div class="line">- 1 ? <span class="stringliteral">&quot;)&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>);</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">  std::set&lt;types::boundary_id&gt; dirichlet_boundary_ids = {0};</div><div class="line">  <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> homogeneous_dirichlet_bc;</div><div class="line">  <span class="keyword">const</span> std::map&lt;types::boundary_id, const Function&lt;dim&gt;&gt;</div><div class="line">    dirichlet_boundary_functions = {</div><div class="line">      {<a class="code" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>(0), &amp;homogeneous_dirichlet_bc}};</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           dirichlet_boundary_functions,</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints);</div><div class="line">    sparsity_pattern.copy_from(dsp);</div><div class="line">  }</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>The multigrid constraints have to be initialized. They need to know where Dirichlet boundary conditions are prescribed.</p>
<div class="fragment"><div class="line">mg_constrained_dofs.clear();</div><div class="line">mg_constrained_dofs.initialize(dof_handler);</div><div class="line">mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                   dirichlet_boundary_ids);</div></div><!-- fragment --><p>Now for the things that concern the multigrid data structures. First, we resize the multilevel objects to hold matrices and sparsity patterns for every level. The coarse level is zero (this is mandatory right now but may change in a future revision). Note that these functions take a complete, inclusive range here (not a starting index and size), so the finest level is <code>n_levels-1</code> . We first have to resize the container holding the <a class="el" href="classSparseMatrix.html">SparseMatrix</a> classes, since they have to release their <a class="el" href="classSparsityPattern.html">SparsityPattern</a> before the can be destroyed upon resizing.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">  mg_interface_matrices.resize(0, n_levels</div><div class="line"></div><div class="line">- 1);</div><div class="line">  mg_matrices.resize(0, n_levels</div><div class="line"></div><div class="line">- 1);</div><div class="line">  mg_sparsity_patterns.resize(0, n_levels</div><div class="line"></div><div class="line">- 1);</div><div class="line">  mg_interface_sparsity_patterns.resize(0, n_levels</div><div class="line"></div><div class="line">- 1);</div></div><!-- fragment --><p>Now, we have to provide a matrix on each level. To this end, we first use the <a class="el" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a> function to generate a preliminary compressed sparsity pattern on each level (see the <a class="el" href="group__Sparsity.html">Sparsity patterns</a> module for more information on this topic) and then copy it over to the one we really want. The next step is to initialize the interface matrices with the fitting sparsity pattern. It may be worth pointing out that the interface matrices only have entries for degrees of freedom that sit at or next to the interface between coarser and finer levels of the mesh. They are therefore even sparser than the matrices on the individual levels of our multigrid hierarchy. Therefore, we use a function specifically build for this purpose to generate it.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      {</div><div class="line">        <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                   dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">        <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line"></div><div class="line">        mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">      }</div><div class="line">      {</div><div class="line">        <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                   dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">        <a class="code" href="namespaceMGTools.html#a8c677f65f8f1d21fb1f4c55cb90079e0">MGTools::make_interface_sparsity_pattern</a>(dof_handler,</div><div class="line">                                                 mg_constrained_dofs,</div><div class="line">                                                 dsp,</div><div class="line">                                                 level);</div><div class="line">        mg_interface_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">        mg_interface_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(</div><div class="line">          mg_interface_sparsity_patterns[level]);</div><div class="line">      }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemcell_worker"></a> </p><h4>LaplaceProblem::cell_worker</h4>
<p>The cell_worker function is used to assemble the matrix and right-hand side on the given cell. This function is used for the active cells to generate the system_matrix and on each level to build the level matrices. Note that we also assemble a right-hand side when called from assemble_multigrid() even though it is not used.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::cell_worker(<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                                      ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                                      CopyData &amp;        copy_data)</div><div class="line">{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = scratch_data.fe_values;</div><div class="line">  fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line"></div><div class="line">  copy_data.reinit(cell, dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_values.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient =</div><div class="line">        (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>()[q][0] &lt; 0.0) ? 1.0 : 0.1;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              copy_data.cell_matrix(i, j) +=</div><div class="line">                coefficient</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q))</div><div class="line">                JxW[q];</div><div class="line">            }</div><div class="line">          copy_data.cell_rhs(i) += 1.0 fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q) JxW[q];</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_system"></a> </p><h4>LaplaceProblem::assemble_system</h4>
<p>The following function assembles the linear system on the active cells of the mesh. For this, we pass two lambda functions to the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop()</a> function. The cell_worker function redirects to the class member function of the same name, while the copier is specific to this function and copies local matrix and vector to the corresponding global ones using the constraints.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> cell_worker =</div><div class="line">    [&amp;](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">        ScratchData&lt;dim&gt; &amp;                                    scratch_data,</div><div class="line">        CopyData &amp;                                            copy_data) {</div><div class="line">      this-&gt;cell_worker(cell, scratch_data, copy_data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;cd) {</div><div class="line">    this-&gt;constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cd.cell_matrix,</div><div class="line">                                                 cd.cell_rhs,</div><div class="line">                                                 cd.local_dof_indices,</div><div class="line">                                                 system_matrix,</div><div class="line">                                                 system_rhs);</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = degree + 1;</div><div class="line"></div><div class="line">  ScratchData&lt;dim&gt; scratch_data(mapping,</div><div class="line">                                fe,</div><div class="line">                                n_gauss_points,</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        scratch_data,</div><div class="line">                        CopyData(),</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_multigrid"></a> </p><h4>LaplaceProblem::assemble_multigrid</h4>
<p>The next function is the one that builds the matrices that define the multigrid method on each level of the mesh. The integration core is the same as above, but the loop below will go over all existing cells instead of just the active ones, and the results must be entered into the correct level matrices. Fortunately, <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> hides most of that from us, and thus the difference between this function and the previous lies only in the setup of the assembler and the different iterators in the loop. We generate an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object for each level containing the boundary and interface dofs as constrained entries. The corresponding object is then used to generate the level matrices.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid()</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>     mapping;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">  std::vector&lt;AffineConstraints&lt;double&gt;&gt; boundary_constraints(n_levels);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      <a class="code" href="classIndexSet.html">IndexSet</a> dofset;</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                    level,</div><div class="line">                                                    dofset);</div><div class="line">      boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(dofset);</div><div class="line">      boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">        mg_constrained_dofs.get_refinement_edge_indices(level));</div><div class="line">      boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">        mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">      boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].close();</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> cell_worker =</div><div class="line">    [&amp;](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::level_cell_iterator</a> &amp;cell,</div><div class="line">        ScratchData&lt;dim&gt; &amp;                                   scratch_data,</div><div class="line">        CopyData &amp;                                           copy_data) {</div><div class="line">      this-&gt;cell_worker(cell, scratch_data, copy_data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;cd) {</div><div class="line">    boundary_constraints[cd.level].distribute_local_to_global(</div><div class="line">      cd.cell_matrix, cd.local_dof_indices, mg_matrices[cd.level]);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cd.local_dof_indices.size();</div></div><!-- fragment --><p>Interface entries are ignored by the boundary_constraints object above when filling the mg_matrices[cd.level]. Instead, we copy these entries into the interface matrix of the current level manually:</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        <span class="keywordflow">if</span> (mg_constrained_dofs.is_interface_matrix_entry(</div><div class="line">              cd.level, cd.local_dof_indices[i], cd.local_dof_indices[j]))</div><div class="line">          {</div><div class="line">            mg_interface_matrices[cd.level].add(cd.local_dof_indices[i],</div><div class="line">                                                cd.local_dof_indices[j],</div><div class="line">                                                cd.cell_matrix(i, j));</div><div class="line">          }</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = degree + 1;</div><div class="line"></div><div class="line">  ScratchData&lt;dim&gt; scratch_data(mapping,</div><div class="line">                                fe,</div><div class="line">                                n_gauss_points,</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        scratch_data,</div><div class="line">                        CopyData(),</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsolve"></a> </p><h4>LaplaceProblem::solve</h4>
<p>This is the other function that is significantly different in support of the multigrid solver (or, in fact, the preconditioner for which we use the multigrid method). Let us start out by setting up two of the components of multilevel methods: transfer operators between levels, and a solver on the coarsest level. In finite element methods, the transfer operators are derived from the finite element function spaces involved and can often be computed in a generic way independent of the problem under consideration. In that case, we can use the <a class="el" href="classMGTransferPrebuilt.html">MGTransferPrebuilt</a> class that, given the constraints of the final linear system and the <a class="el" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> object that knows about the boundary conditions on the each level and the degrees of freedom on interfaces between different refinement level can build the matrices for those transfer operations from a <a class="el" href="classDoFHandler.html">DoFHandler</a> object with level degrees of freedom. The second part of the following lines deals with the coarse grid solver. Since our coarse grid is very coarse indeed, we decide for a direct solver (a <a class="el" href="classHouseholder.html">Householder</a> decomposition of the coarsest level matrix), even if its implementation is not particularly sophisticated. If our coarse mesh had many more cells than the five we have here, something better suited would obviously be necessary here.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt; mg_transfer(mg_constrained_dofs);</div><div class="line">  mg_transfer.build(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">  coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">  <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">  coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div></div><!-- fragment --><p>The next component of a multilevel solver or preconditioner is that we need a smoother on each level. A common choice for this is to use the application of a relaxation method (such as the SOR, Jacobi or Richardson method) or a small number of iterations of a solver method (such as CG or GMRES). The <a class="el" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a> and <a class="el" href="classMGSmootherPrecondition.html">MGSmootherPrecondition</a> classes provide support for these two kinds of smoothers. Here, we opt for the application of a single SOR iteration. To this end, we define an appropriate alias and then setup a smoother object. The last step is to initialize the smoother object with our level matrices and to set some smoothing parameters. The <code>initialize()</code> function can optionally take additional arguments that will be passed to the smoother object on each level. In the current case for the SOR smoother, this could, for example, include a relaxation parameter. However, we here leave these at their default values. The call to <code>set_steps()</code> indicates that we will use two pre- and two post-smoothing steps on each level; to use a variable number of smoother steps on different levels, more options can be set in the constructor call to the <code>mg_smoother</code> object. The last step results from the fact that we use the SOR method as a smoother</p>
<ul>
<li>which is not symmetric</li>
<li>but we use the conjugate gradient iteration (which requires a symmetric preconditioner) below, we need to let the multilevel preconditioner make sure that we get a symmetric operator even for nonsymmetric smoothers:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line"><a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation&lt;Smoother, Vector&lt;double&gt;</a>&gt; mg_smoother;</div><div class="line">mg_smoother.<a class="code" href="classmg_1_1SmootherRelaxation.html#ae9e03c626c50a1b13dffe338f5f977b0">initialize</a>(mg_matrices);</div><div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(2);</div><div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#abed2837ee4e224f94c6a98405906df8f">set_symmetric</a>(<span class="keyword">true</span>);</div></div><!-- fragment --><p>The next preparatory step is that we must wrap our level and interface matrices in an object having the required multiplication functions. We will create two objects for the interface objects going from coarse to fine and the other way around; the multigrid algorithm will later use the transpose operator for the latter operation, allowing us to initialize both up and down versions of the operator with the matrices we already built:</p>
<div class="fragment"><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix(mg_matrices);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_up(mg_interface_matrices);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_down(mg_interface_matrices);</div></div><!-- fragment --><p>Now, we are ready to set up the V-cycle operator and the multilevel preconditioner.</p>
<div class="fragment"><div class="line"><a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">  mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);</div><div class="line"><a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_down, mg_interface_up);</div><div class="line"></div><div class="line"><a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt;&gt;</div><div class="line">  preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div></div><!-- fragment --><p>With all this together, we can finally get about solving the linear system in the usual way:</p>
<div class="fragment"><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">  solution = 0;</div><div class="line"></div><div class="line">  solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of CG iterations: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Postprocessing"></a> </p><h4>Postprocessing</h4>
<p>The following two functions postprocess a solution once it is computed. In particular, the first one refines the mesh at the beginning of each cycle while the second one outputs results at the end of each such cycle. The functions are almost unchanged from those in <a class="el" href="step_6.html">step-6</a> .</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::refine_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt;(degree + 2),</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>&gt;(),</div><div class="line">    solution,</div><div class="line">    estimated_error_per_cell);</div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.03);</div><div class="line">  triangulation.execute_coarsening_and_refinement();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemrun"></a> </p><h4>LaplaceProblem::run</h4>
<p>Like several of the functions above, this is almost exactly a copy of the corresponding function in <a class="el" href="step_6.html">step-6</a> . The only difference is the call to <code>assemble_multigrid</code> that takes care of forming the matrices on every level that we need in the multigrid method.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 8; ++cycle)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">        {</div><div class="line">          <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">          triangulation.refine_global(2);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        refine_grid();</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">                &lt;&lt; triangulation.n_active_cells() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      setup_system();</div><div class="line"></div><div class="line">      assemble_system();</div><div class="line">      assemble_multigrid();</div><div class="line"></div><div class="line">      solve();</div><div class="line">      output_results(cycle);</div><div class="line">    }</div><div class="line">}</div><div class="line">} <span class="comment">// namespace Step16</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>This is again the same function as in <a class="el" href="step_6.html">step-6</a> :</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    <span class="keyword">using namespace </span>Step16;</div><div class="line"></div><div class="line">    LaplaceProblem&lt;2&gt; laplace_problem(1);</div><div class="line">    laplace_problem.run();</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>On the finest mesh, the solution looks like this: </p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-16.solution.png"/>
</div>
 <p>More importantly, we would like to see if the multigrid method really improvedthe solver performance. Therefore, here is the textual output: </p><pre>Cycle 0   Number of active cells:       80   Number of degrees
 of freedom: 89 (by level: 8, 25, 89)   Number of CG iterations: 8 Cycle 1
 Number of active cells:       158   Number of degrees of freedom: 183 (by
 level: 8, 25, 89, 138)   Number of CG iterations: 9 Cycle 2   Number of
 active cells:       302   Number of degrees of freedom: 352 (by level: 8,
 25, 89, 223, 160)   Number of CG iterations: 10 Cycle 3   Number of active
 cells:       578   Number of degrees of freedom: 649 (by level: 8, 25, 89,
 231, 494, 66)   Number of CG iterations: 10 Cycle 4   Number of active
 cells:       1100   Number of degrees of freedom: 1218 (by level: 8, 25,
 89, 274, 764, 417, 126)   Number of CG iterations: 10 Cycle 5   Number of
 active cells:       2096   Number of degrees of freedom: 2317 (by level: 8,
 25, 89, 304, 779, 1214, 817)   Number of CG iterations: 11 Cycle 6   Number
 of active cells:       3986   Number of degrees of freedom: 4366 (by level:
 8, 25, 89, 337, 836, 2270, 897, 1617)   Number of CG iterations: 10 Cycle 7
 Number of active cells:       7574   Number of degrees of freedom: 8350 (by
 level: 8, 25, 89, 337, 1086, 2835, 2268, 1789, 3217)   Number of CG
 iterations: 11</pre><p> That's almost perfect multigrid performance: the linear residual gets reduced by 12 orders ofmagnitude in 10 iteration steps, and the results are almost independent of the mesh size. That'sobviously in part due to the simple nature of the problem solved, butit shows the power of multigrid methods.</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>We encourage you to generate timings for the solve() call and compare to <a class="el" href="step_6.html">step-6</a> . You will see that the multigrid method has quite an overheadon coarse meshes, but that it always beats other methods on finemeshes because of its optimal complexity. A close inspection of this program's performance shows that it is mostlydominated by matrix-vector operations. <a class="el" href="step_37.html">step-37</a> shows one wayhow this can be avoided by working with matrix-free methods. Another avenue would be to use algebraic multigrid methods. The geometricmultigrid method used here can at times be a bit awkward to implement because itneeds all those additional data structures, and it becomes even more difficultif the program is to run in parallel on machines coupled through MPI, forexample. In that case, it would be simpler if one could use a black-boxpreconditioner that uses some sort of multigrid hierarchy for good performancebut can figure out level matrices and similar things by itself. Algebraicmultigrid methods do exactly this, and we will use them in <a class="el" href="step_31.html">step-31</a> for thesolution of a Stokes problem and in <a class="el" href="step_32.html">step-32</a> and <a class="el" href="step_40.html">step-40</a> for a parallelvariation. That said, a parallel version of this example program with MPI can befound in <a class="el" href="step_50.html">step-50</a> . Finally, one may want to think how to use geometric multigrid for other kinds ofproblems, specifically <a class="el" href="group__vector__valued.html">vector valued problems</a>. This is thetopic of <a class="el" href="step_56.html">step-56</a> where we use the techniques shown here for the Stokes equation.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2003 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Guido Kanschat, University of Heidelberg, 2003</span></div><div class="line"><span class="comment"> *          Baerbel Janssen, University of Heidelberg, 2010</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University, 2010</span></div><div class="line"><span class="comment"> *          Timo Heister, Clemson University, 2018</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step16</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>ScratchData</div><div class="line">  {</div><div class="line">    ScratchData(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        quadrature_degree,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags)</div><div class="line">      : fe_values(mapping, fe, <a class="code" href="classQGauss.html">QGauss</a>&lt;dim&gt;(quadrature_degree), update_flags)</div><div class="line">    {}</div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">      : fe_values(scratch_data.fe_values.get_mapping(),</div><div class="line">                  scratch_data.fe_values.get_fe(),</div><div class="line">                  scratch_data.fe_values.get_quadrature(),</div><div class="line">                  scratch_data.fe_values.get_update_flags())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyData</div><div class="line">  {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                         <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    Vector&lt;double&gt;                       cell_rhs;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> Iterator &amp;cell, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">    {</div><div class="line">      cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line">      cell_rhs.reinit(dofs_per_cell);</div><div class="line"></div><div class="line">      local_dof_indices.resize(dofs_per_cell);</div><div class="line">      cell-&gt;get_active_or_mg_dof_indices(local_dof_indices);</div><div class="line">      level = cell-&gt;level();</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">    <span class="keywordtype">void</span> cell_worker(<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                     ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                     CopyData &amp;        copy_data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_multigrid();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> refine_grid();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_sparsity_patterns;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_interface_sparsity_patterns;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_matrices;</div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a>                   mg_constrained_dofs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceProblem&lt;dim&gt;::LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">    , fe(degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , degree(degree)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (by level: &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.n_levels(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      std::cout &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level)</div><div class="line">                &lt;&lt; (level == triangulation.n_levels() - 1 ? <span class="stringliteral">&quot;)&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>);</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt; dirichlet_boundary_ids = {0};</div><div class="line">    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> homogeneous_dirichlet_bc;</div><div class="line">    <span class="keyword">const</span> std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt;</div><div class="line">      dirichlet_boundary_functions = {</div><div class="line">        {<a class="code" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>(0), &amp;homogeneous_dirichlet_bc}};</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             dirichlet_boundary_functions,</div><div class="line">                                             constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints);</div><div class="line">      sparsity_pattern.copy_from(dsp);</div><div class="line">    }</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    mg_constrained_dofs.clear();</div><div class="line">    mg_constrained_dofs.initialize(dof_handler);</div><div class="line">    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                       dirichlet_boundary_ids);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">    mg_interface_matrices.resize(0, n_levels - 1);</div><div class="line">    mg_matrices.resize(0, n_levels - 1);</div><div class="line">    mg_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line">    mg_interface_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        {</div><div class="line">          <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                     dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">          <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line"></div><div class="line">          mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">          mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">        }</div><div class="line">        {</div><div class="line">          <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                     dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">          <a class="code" href="namespaceMGTools.html#a8c677f65f8f1d21fb1f4c55cb90079e0">MGTools::make_interface_sparsity_pattern</a>(dof_handler,</div><div class="line">                                                   mg_constrained_dofs,</div><div class="line">                                                   dsp,</div><div class="line">                                                   level);</div><div class="line">          mg_interface_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">          mg_interface_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(</div><div class="line">            mg_interface_sparsity_patterns[level]);</div><div class="line">        }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::cell_worker(<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                                        ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                                        CopyData &amp;        copy_data)</div><div class="line">  {</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = scratch_data.fe_values;</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line"></div><div class="line">    copy_data.reinit(cell, dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_values.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient =</div><div class="line">          (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>()[q][0] &lt; 0.0) ? 1.0 : 0.1;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                copy_data.cell_matrix(i, j) +=</div><div class="line">                  coefficient *</div><div class="line">                  (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)) *</div><div class="line">                  JxW[q];</div><div class="line">              }</div><div class="line">            copy_data.cell_rhs(i) += 1.0 * fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q) * JxW[q];</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> cell_worker =</div><div class="line">      [&amp;](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">          ScratchData&lt;dim&gt; &amp;                                    scratch_data,</div><div class="line">          CopyData &amp;                                            copy_data) {</div><div class="line">        this-&gt;cell_worker(cell, scratch_data, copy_data);</div><div class="line">      };</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;cd) {</div><div class="line">      this-&gt;constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cd.cell_matrix,</div><div class="line">                                                   cd.cell_rhs,</div><div class="line">                                                   cd.local_dof_indices,</div><div class="line">                                                   system_matrix,</div><div class="line">                                                   system_rhs);</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = degree + 1;</div><div class="line"></div><div class="line">    ScratchData&lt;dim&gt; scratch_data(mapping,</div><div class="line">                                  fe,</div><div class="line">                                  n_gauss_points,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          scratch_data,</div><div class="line">                          CopyData(),</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>     mapping;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">    std::vector&lt;AffineConstraints&lt;double&gt;&gt; boundary_constraints(n_levels);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classIndexSet.html">IndexSet</a> dofset;</div><div class="line">        <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                      level,</div><div class="line">                                                      dofset);</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(dofset);</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">          mg_constrained_dofs.get_refinement_edge_indices(level));</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">          mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].close();</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> cell_worker =</div><div class="line">      [&amp;](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::level_cell_iterator</a> &amp;cell,</div><div class="line">          ScratchData&lt;dim&gt; &amp;                                   scratch_data,</div><div class="line">          CopyData &amp;                                           copy_data) {</div><div class="line">        this-&gt;cell_worker(cell, scratch_data, copy_data);</div><div class="line">      };</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;cd) {</div><div class="line">      boundary_constraints[cd.level].distribute_local_to_global(</div><div class="line">        cd.cell_matrix, cd.local_dof_indices, mg_matrices[cd.level]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cd.local_dof_indices.size();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          <span class="keywordflow">if</span> (mg_constrained_dofs.is_interface_matrix_entry(</div><div class="line">                cd.level, cd.local_dof_indices[i], cd.local_dof_indices[j]))</div><div class="line">            {</div><div class="line">              mg_interface_matrices[cd.level].add(cd.local_dof_indices[i],</div><div class="line">                                                  cd.local_dof_indices[j],</div><div class="line">                                                  cd.cell_matrix(i, j));</div><div class="line">            }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = degree + 1;</div><div class="line"></div><div class="line">    ScratchData&lt;dim&gt; scratch_data(mapping,</div><div class="line">                                  fe,</div><div class="line">                                  n_gauss_points,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          scratch_data,</div><div class="line">                          CopyData(),</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt; mg_transfer(mg_constrained_dofs);</div><div class="line">    mg_transfer.build(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">    coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">    <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">    coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div><div class="line"></div><div class="line">    <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line">    <a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation&lt;Smoother, Vector&lt;double&gt;</a>&gt; mg_smoother;</div><div class="line">    mg_smoother.<a class="code" href="classmg_1_1SmootherRelaxation.html#ae9e03c626c50a1b13dffe338f5f977b0">initialize</a>(mg_matrices);</div><div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(2);</div><div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#abed2837ee4e224f94c6a98405906df8f">set_symmetric</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix(mg_matrices);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_up(mg_interface_matrices);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_down(mg_interface_matrices);</div><div class="line"></div><div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">      mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);</div><div class="line">    <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_down, mg_interface_up);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt;&gt;</div><div class="line">      preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">    solution = 0;</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of CG iterations: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::refine_grid()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(degree + 2),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line">    triangulation.execute_coarsening_and_refinement();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 8; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">            triangulation.refine_global(2);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.n_active_cells() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line">        assemble_multigrid();</div><div class="line"></div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step16</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step16;</div><div class="line"></div><div class="line">      LaplaceProblem&lt;2&gt; laplace_problem(1);</div><div class="line">      laplace_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_6.html">step-6</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thetestcase">The testcase</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#TheScratchandCopyobjects">The Scratch and Copy objects</a>
        <li><a href="#ThecodeLaplaceProblemcodeclasstemplate">The <code>LaplaceProblem</code> class template</a>
        <li><a href="#ThecodeLaplaceProblemcodeclassimplementation">The <code>LaplaceProblem</code> class implementation</a>
      <ul>
        <li><a href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a>
        <li><a href="#LaplaceProblemcell_worker">LaplaceProblem::cell_worker</a>
        <li><a href="#LaplaceProblemassemble_system">LaplaceProblem::assemble_system</a>
        <li><a href="#LaplaceProblemassemble_multigrid">LaplaceProblem::assemble_multigrid</a>
        <li><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a>
        <li><a href="#Postprocessing">Postprocessing</a>
        <li><a href="#LaplaceProblemrun">LaplaceProblem::run</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-16/doc/intro.dox</p>
<p><br />
</p>
<p><em> Note: A variant called <a class="el" href="step_16b.html">step-16b</a> of this tutorial exists, that uses <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> and <a class="el" href="namespaceLocalIntegrators.html" title="Library of integrals over cells and faces 这个命名空间包含了双线性形式、形式和误差估计的特定应用局部\x{00E7}...">LocalIntegrators</a> instead of assembling matrices manually as it is done in this tutorial. </em></p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>这个例子展示了deal.II中多级函数的基本用法。它几乎解决了与步骤6中使用的相同的问题，但展示了使用多网格作为预处理程序时必须提供的东西。特别是，这要求我们定义一个层次结构，提供从一个层次到下一个层次以及返回的转移算子，并在每个层次上提供拉普拉斯算子的表示。</p>
<p>为了使微分方程系统和块状预处理程序具有足够的灵活性，在启动多级方法之前必须创建一些不同的对象，尽管大部分需要做的事情都是由deal.II本身提供。这些对象是</p>
<ul>
<li>网格之间的对象处理转移；我们使用MGTransferPrebuilt类来处理这个问题，它几乎完成了库内的所有工作。</li>
<li>解算器的最粗层次；在这里，我们使用MGCoarseGridHouseholder。</li>
<li>所有其他级别的平滑器，在我们的例子中，这将是使用SOR作为基本方法的 <a class="el" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a> 类。</li>
<li>和 <a class="el" href="classmg_1_1Matrix.html">mg::Matrix</a>, 一个具有特殊水平乘法的类，也就是说，我们基本上每个网格水平存储一个矩阵并允许与之相乘。</li>
</ul>
<p>这些对象中的大多数只需要在实际求解线性系统的函数中使用。在这里，这些对象被组合到一个多网格类型的对象中，其中包含V型循环的实现，它又被预设条件器PreconditionMG使用，准备插入LAC库的线性求解器中。</p>
<p>这里实现的自适应细化网格的多网格方法遵循 <a class="el" href="DEALGlossary.html#mg_paper">多网格论文 </a>中的大纲，该论文在deal.II中描述了底层实现，也介绍了很多术语。首先，我们必须区分层次网格，即与粗网格有相同细化距离的单元，以及由层次中的活动单元组成的叶子网格（在较早的工作中，我们将其称为全局网格，但这个术语被过度使用）。最重要的是，叶子网格与最细层次上的层次网格不完全相同。下面的图片显示了我们认为的 "层次网"。</p>
<div class="image">
<img src="multigrid.png" alt="multigrid.png"/>
</div>
 <p>。</p>
<p>这个网格中的精细层次只包括定义在精细单元上的自由度，但不延伸到领域中未被精细化的那部分。虽然这保证了整体的努力增长为 \({\cal O}(N)\) 的最佳多网格复杂度所必需的，但它导致了在定义平滑的地方和对定义在各个层次上的算子提出什么边界条件时的问题，如果层次边界不是外部边界。这些问题将在上面引用的文章中详细讨论。</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>我们在这里解决的问题与第6步类似，主要有两个不同点：第一，多网格预处理程序，显然。我们还改变了系数的不连续性，使局部装配器看起来不会比必要的更复杂。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Again, the first few include files are already known, so we won't comment on them:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div></div><!-- fragment --><p>These, now, are the include necessary for the multilevel methods. The first one declares how to handle Dirichlet boundary conditions on each of the levels of the multigrid method. For the actual description of the degrees of freedom, we do not need any new include file because <a class="el" href="classDoFHandler.html">DoFHandler</a> already has all necessary methods implemented. We will only need to distribute the DoFs for the levels further down.</p>
<p>The rest of the include files deals with the mechanics of multigrid as a linear operator (solver or preconditioner).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div></div><!-- fragment --><p>We will be using <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a> to loop over the cells, so include it here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div></div><!-- fragment --><p>This is C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step16</div><div class="line">{</div></div><!-- fragment --><p><a class="anchor" id="TheScratchandCopyobjects"></a> </p><h3>The Scratch and Copy objects</h3>
<p>We use <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> to assemble our matrices. For this, we need a ScratchData object to store temporary data on each cell (this is just the <a class="el" href="classFEValues.html">FEValues</a> object) and a CopyData object that will contain the output of each cell assembly. For more details about the usage of scratch and copy objects, see the <a class="el" href="namespaceWorkStream.html">WorkStream</a> namespace.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>ScratchData</div><div class="line">{</div><div class="line">  ScratchData(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        quadrature_degree,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags)</div><div class="line">    : fe_values(mapping, fe, <a class="code" href="classQGauss.html">QGauss</a>&lt;dim&gt;(quadrature_degree), update_flags)</div><div class="line">  {}</div><div class="line"></div><div class="line">  ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">    : fe_values(scratch_data.fe_values.get_mapping(),</div><div class="line">                scratch_data.fe_values.get_fe(),</div><div class="line">                scratch_data.fe_values.get_quadrature(),</div><div class="line">                scratch_data.fe_values.get_update_flags())</div><div class="line">  {}</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>CopyData</div><div class="line">{</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                         <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       cell_rhs;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> Iterator &amp;cell, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">  {</div><div class="line">    cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line">    cell_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dofs_per_cell);</div><div class="line"></div><div class="line">    local_dof_indices.resize(dofs_per_cell);</div><div class="line">    cell-&gt;get_active_or_mg_dof_indices(local_dof_indices);</div><div class="line">    level = cell-&gt;level();</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceProblemcodeclasstemplate"></a> </p><h3>The <code>LaplaceProblem</code> class template</h3>
<p>This main class is similar to the same class in <a class="el" href="step_6.html">step-6</a>. As far as member functions is concerned, the only additions are:</p><ul>
<li>The <code>assemble_multigrid</code> function that assembles the matrices that correspond to the discrete operators on intermediate levels.</li>
<li>The <code>cell_worker</code> function that assembles our PDE on a single cell.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>LaplaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">  <span class="keywordtype">void</span> cell_worker(<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                   ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                   CopyData &amp;        copy_data);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_multigrid();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> refine_grid();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div></div><!-- fragment --><p>The following members are the essential data structures for the multigrid method. The first four represent the sparsity patterns and the matrices on individual levels of the multilevel hierarchy, very much like the objects for the global mesh above.</p>
<p>Then we have two new matrices only needed for multigrid methods with local smoothing on adaptive meshes. They convey data between the interior part of the refined region and the refinement edge, as outlined in detail in the <a class="el" href="DEALGlossary.html#mg_paper">multigrid paper</a>.</p>
<p>The last object stores information about the boundary indices on each level and information about indices lying on a refinement edge between two different refinement levels. It thus serves a similar purpose as <a class="el" href="classAffineConstraints.html">AffineConstraints</a>, but on each level.</p>
<div class="fragment"><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_sparsity_patterns;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_interface_sparsity_patterns;</div><div class="line"></div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_matrices;</div><div class="line">  <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a>                   mg_constrained_dofs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceProblemcodeclassimplementation"></a> </p><h3>The <code>LaplaceProblem</code> class implementation</h3>
<p>Just one short remark about the constructor of the <a class="el" href="classTriangulation.html">Triangulation</a>: by convention, all adaptively refined triangulations in deal.II never change by more than one level across a face between cells. For our multigrid algorithms, however, we need a slightly stricter guarantee, namely that the mesh also does not change by more than refinement level across vertices that might connect two cells. In other words, we must prevent the following situation:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt="limit_level_difference_at_vertices.png"/>
</div>
<p>This is achieved by passing the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">Triangulation::limit_level_difference_at_vertices</a> flag to the constructor of the triangulation class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">LaplaceProblem&lt;dim&gt;::LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">  , fe(degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , degree(degree)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsetup_system"></a> </p><h4>LaplaceProblem::setup_system</h4>
<p>In addition to just distributing the degrees of freedom in the <a class="el" href="classDoFHandler.html">DoFHandler</a>, we do the same on each level. Then, we follow the same procedure as before to set up the system on the leaf mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (by level: &quot;</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.n_levels(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    std::cout &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level)</div><div class="line">              &lt;&lt; (level == triangulation.n_levels() - 1 ? <span class="stringliteral">&quot;)&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>);</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">  std::set&lt;types::boundary_id&gt; dirichlet_boundary_ids = {0};</div><div class="line">  <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> homogeneous_dirichlet_bc;</div><div class="line">  <span class="keyword">const</span> std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt;</div><div class="line">    dirichlet_boundary_functions = {</div><div class="line">      {<a class="code" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>(0), &amp;homogeneous_dirichlet_bc}};</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           dirichlet_boundary_functions,</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints);</div><div class="line">    sparsity_pattern.copy_from(dsp);</div><div class="line">  }</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>The multigrid constraints have to be initialized. They need to know where Dirichlet boundary conditions are prescribed.</p>
<div class="fragment"><div class="line">mg_constrained_dofs.clear();</div><div class="line">mg_constrained_dofs.initialize(dof_handler);</div><div class="line">mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                   dirichlet_boundary_ids);</div></div><!-- fragment --><p>Now for the things that concern the multigrid data structures. First, we resize the multilevel objects to hold matrices and sparsity patterns for every level. The coarse level is zero (this is mandatory right now but may change in a future revision). Note that these functions take a complete, inclusive range here (not a starting index and size), so the finest level is <code>n_levels-1</code>. We first have to resize the container holding the <a class="el" href="classSparseMatrix.html">SparseMatrix</a> classes, since they have to release their <a class="el" href="classSparsityPattern.html">SparsityPattern</a> before the can be destroyed upon resizing.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">mg_interface_matrices.resize(0, n_levels - 1);</div><div class="line">mg_matrices.resize(0, n_levels - 1);</div><div class="line">mg_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line">mg_interface_sparsity_patterns.resize(0, n_levels - 1);</div></div><!-- fragment --><p>Now, we have to provide a matrix on each level. To this end, we first use the <a class="el" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a> function to generate a preliminary compressed sparsity pattern on each level (see the <a class="el" href="group__Sparsity.html">Sparsity patterns</a> module for more information on this topic) and then copy it over to the one we really want. The next step is to initialize the interface matrices with the fitting sparsity pattern.</p>
<p>It may be worth pointing out that the interface matrices only have entries for degrees of freedom that sit at or next to the interface between coarser and finer levels of the mesh. They are therefore even sparser than the matrices on the individual levels of our multigrid hierarchy. Therefore, we use a function specifically build for this purpose to generate it.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      {</div><div class="line">        <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                   dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">        <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line"></div><div class="line">        mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">      }</div><div class="line">      {</div><div class="line">        <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                   dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">        <a class="code" href="namespaceMGTools.html#a8c677f65f8f1d21fb1f4c55cb90079e0">MGTools::make_interface_sparsity_pattern</a>(dof_handler,</div><div class="line">                                                 mg_constrained_dofs,</div><div class="line">                                                 dsp,</div><div class="line">                                                 level);</div><div class="line">        mg_interface_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">        mg_interface_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(</div><div class="line">          mg_interface_sparsity_patterns[level]);</div><div class="line">      }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemcell_worker"></a> </p><h4>LaplaceProblem::cell_worker</h4>
<p>The cell_worker function is used to assemble the matrix and right-hand side on the given cell. This function is used for the active cells to generate the system_matrix and on each level to build the level matrices.</p>
<p>Note that we also assemble a right-hand side when called from assemble_multigrid() even though it is not used.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::cell_worker(<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                                      ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                                      CopyData &amp;        copy_data)</div><div class="line">{</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = scratch_data.fe_values;</div><div class="line">  fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line"></div><div class="line">  copy_data.reinit(cell, dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_values.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient =</div><div class="line">        (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>()[q][0] &lt; 0.0) ? 1.0 : 0.1;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              copy_data.cell_matrix(i, j) +=</div><div class="line">                coefficient *</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)) *</div><div class="line">                JxW[q];</div><div class="line">            }</div><div class="line">          copy_data.cell_rhs(i) += 1.0 * fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q) * JxW[q];</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_system"></a> </p><h4>LaplaceProblem::assemble_system</h4>
<p>The following function assembles the linear system on the active cells of the mesh. For this, we pass two lambda functions to the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop()</a> function. The cell_worker function redirects to the class member function of the same name, while the copier is specific to this function and copies local matrix and vector to the corresponding global ones using the constraints.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> cell_worker =</div><div class="line">    [&amp;](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">        ScratchData&lt;dim&gt; &amp;                                    scratch_data,</div><div class="line">        CopyData &amp;                                            copy_data) {</div><div class="line">      this-&gt;cell_worker(cell, scratch_data, copy_data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;cd) {</div><div class="line">    this-&gt;constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cd.cell_matrix,</div><div class="line">                                                 cd.cell_rhs,</div><div class="line">                                                 cd.local_dof_indices,</div><div class="line">                                                 system_matrix,</div><div class="line">                                                 system_rhs);</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = degree + 1;</div><div class="line"></div><div class="line">  ScratchData&lt;dim&gt; scratch_data(mapping,</div><div class="line">                                fe,</div><div class="line">                                n_gauss_points,</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        scratch_data,</div><div class="line">                        CopyData(),</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_multigrid"></a> </p><h4>LaplaceProblem::assemble_multigrid</h4>
<p>The next function is the one that builds the matrices that define the multigrid method on each level of the mesh. The integration core is the same as above, but the loop below will go over all existing cells instead of just the active ones, and the results must be entered into the correct level matrices. Fortunately, <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> hides most of that from us, and thus the difference between this function and the previous lies only in the setup of the assembler and the different iterators in the loop.</p>
<p>We generate an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object for each level containing the boundary and interface dofs as constrained entries. The corresponding object is then used to generate the level matrices.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid()</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>     mapping;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">  std::vector&lt;AffineConstraints&lt;double&gt;&gt; boundary_constraints(n_levels);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      <a class="code" href="classIndexSet.html">IndexSet</a> dofset;</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                    level,</div><div class="line">                                                    dofset);</div><div class="line">      boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(dofset);</div><div class="line">      boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">        mg_constrained_dofs.get_refinement_edge_indices(level));</div><div class="line">      boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">        mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">      boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].close();</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> cell_worker =</div><div class="line">    [&amp;](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::level_cell_iterator</a> &amp;cell,</div><div class="line">        ScratchData&lt;dim&gt; &amp;                                   scratch_data,</div><div class="line">        CopyData &amp;                                           copy_data) {</div><div class="line">      this-&gt;cell_worker(cell, scratch_data, copy_data);</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;cd) {</div><div class="line">    boundary_constraints[cd.level].distribute_local_to_global(</div><div class="line">      cd.cell_matrix, cd.local_dof_indices, mg_matrices[cd.level]);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cd.local_dof_indices.size();</div></div><!-- fragment --><p>Interface entries are ignored by the boundary_constraints object above when filling the mg_matrices[cd.level]. Instead, we copy these entries into the interface matrix of the current level manually:</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        <span class="keywordflow">if</span> (mg_constrained_dofs.is_interface_matrix_entry(</div><div class="line">              cd.level, cd.local_dof_indices[i], cd.local_dof_indices[j]))</div><div class="line">          {</div><div class="line">            mg_interface_matrices[cd.level].add(cd.local_dof_indices[i],</div><div class="line">                                                cd.local_dof_indices[j],</div><div class="line">                                                cd.cell_matrix(i, j));</div><div class="line">          }</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = degree + 1;</div><div class="line"></div><div class="line">  ScratchData&lt;dim&gt; scratch_data(mapping,</div><div class="line">                                fe,</div><div class="line">                                n_gauss_points,</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                        dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        scratch_data,</div><div class="line">                        CopyData(),</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsolve"></a> </p><h4>LaplaceProblem::solve</h4>
<p>This is the other function that is significantly different in support of the multigrid solver (or, in fact, the preconditioner for which we use the multigrid method).</p>
<p>Let us start out by setting up two of the components of multilevel methods: transfer operators between levels, and a solver on the coarsest level. In finite element methods, the transfer operators are derived from the finite element function spaces involved and can often be computed in a generic way independent of the problem under consideration. In that case, we can use the <a class="el" href="classMGTransferPrebuilt.html">MGTransferPrebuilt</a> class that, given the constraints of the final linear system and the <a class="el" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> object that knows about the boundary conditions on the each level and the degrees of freedom on interfaces between different refinement level can build the matrices for those transfer operations from a <a class="el" href="classDoFHandler.html">DoFHandler</a> object with level degrees of freedom.</p>
<p>The second part of the following lines deals with the coarse grid solver. Since our coarse grid is very coarse indeed, we decide for a direct solver (a <a class="el" href="classHouseholder.html">Householder</a> decomposition of the coarsest level matrix), even if its implementation is not particularly sophisticated. If our coarse mesh had many more cells than the five we have here, something better suited would obviously be necessary here.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt; mg_transfer(mg_constrained_dofs);</div><div class="line">  mg_transfer.build(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">  coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">  <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">  coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div></div><!-- fragment --><p>The next component of a multilevel solver or preconditioner is that we need a smoother on each level. A common choice for this is to use the application of a relaxation method (such as the SOR, Jacobi or Richardson method) or a small number of iterations of a solver method (such as CG or GMRES). The <a class="el" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a> and <a class="el" href="classMGSmootherPrecondition.html">MGSmootherPrecondition</a> classes provide support for these two kinds of smoothers. Here, we opt for the application of a single SOR iteration. To this end, we define an appropriate alias and then setup a smoother object.</p>
<p>The last step is to initialize the smoother object with our level matrices and to set some smoothing parameters. The <code>initialize()</code> function can optionally take additional arguments that will be passed to the smoother object on each level. In the current case for the SOR smoother, this could, for example, include a relaxation parameter. However, we here leave these at their default values. The call to <code>set_steps()</code> indicates that we will use two pre- and two post-smoothing steps on each level; to use a variable number of smoother steps on different levels, more options can be set in the constructor call to the <code>mg_smoother</code> object.</p>
<p>The last step results from the fact that we use the SOR method as a smoother - which is not symmetric - but we use the conjugate gradient iteration (which requires a symmetric preconditioner) below, we need to let the multilevel preconditioner make sure that we get a symmetric operator even for nonsymmetric smoothers:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line"><a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation&lt;Smoother, Vector&lt;double&gt;</a>&gt; mg_smoother;</div><div class="line">mg_smoother.<a class="code" href="classmg_1_1SmootherRelaxation.html#ae9e03c626c50a1b13dffe338f5f977b0">initialize</a>(mg_matrices);</div><div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(2);</div><div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#abed2837ee4e224f94c6a98405906df8f">set_symmetric</a>(<span class="keyword">true</span>);</div></div><!-- fragment --><p>The next preparatory step is that we must wrap our level and interface matrices in an object having the required multiplication functions. We will create two objects for the interface objects going from coarse to fine and the other way around; the multigrid algorithm will later use the transpose operator for the latter operation, allowing us to initialize both up and down versions of the operator with the matrices we already built:</p>
<div class="fragment"><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix(mg_matrices);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_up(mg_interface_matrices);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_down(mg_interface_matrices);</div></div><!-- fragment --><p>Now, we are ready to set up the V-cycle operator and the multilevel preconditioner.</p>
<div class="fragment"><div class="line"><a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">  mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);</div><div class="line"><a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_down, mg_interface_up);</div><div class="line"></div><div class="line"><a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt;&gt;</div><div class="line">  preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div></div><!-- fragment --><p>With all this together, we can finally get about solving the linear system in the usual way:</p>
<div class="fragment"><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">  solution = 0;</div><div class="line"></div><div class="line">  solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of CG iterations: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Postprocessing"></a> </p><h4>Postprocessing</h4>
<p>The following two functions postprocess a solution once it is computed. In particular, the first one refines the mesh at the beginning of each cycle while the second one outputs results at the end of each such cycle. The functions are almost unchanged from those in <a class="el" href="step_6.html">step-6</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::refine_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(degree + 2),</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">    solution,</div><div class="line">    estimated_error_per_cell);</div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.03);</div><div class="line">  triangulation.execute_coarsening_and_refinement();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemrun"></a> </p><h4>LaplaceProblem::run</h4>
<p>Like several of the functions above, this is almost exactly a copy of the corresponding function in <a class="el" href="step_6.html">step-6</a>. The only difference is the call to <code>assemble_multigrid</code> that takes care of forming the matrices on every level that we need in the multigrid method.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 8; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">            triangulation.refine_global(2);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.n_active_cells() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line">        assemble_multigrid();</div><div class="line"></div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step16</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>This is again the same function as in <a class="el" href="step_6.html">step-6</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step16;</div><div class="line"></div><div class="line">      LaplaceProblem&lt;2&gt; laplace_problem(1);</div><div class="line">      laplace_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-16/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>在最细的网格上，解决方案看起来像这样。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-16.solution.png"/>
</div>
 <p>。</p>
<p>更重要的是，我们想看看多网格方法是否真的改善了求解器的性能。因此，这里是文本输出。</p>
<p>周期0 活动单元数：80 自由度数：89（按级别：8，25，89） CG迭代数。8</p>
<p>周期1 活动单元数：158 自由度数：183（按级别：8，25，89，138） CG迭代次数。9</p>
<p>周期2 活动单元数：302 自由度数：352（按级别：8、25、89、223、160） CG迭代次数。10</p>
<p>周期3 活动单元数：578 自由度数：649（按级别：8、25、89、231、494、66） CG迭代次数。10</p>
<p>第四周期 活跃单元数：1100 自由度数：1218（按级别：8、25、89、274、764、417、126） CG迭代次数。10</p>
<p>周期5 活动单元数：2096 自由度数：2317（按级别：8、25、89、304、779、1214、817） CG迭代次数。11</p>
<p>第6周期 活跃单元数：3986 自由度数：4366（按级别：8，25，89，337，836，2270，897，1617） CG迭代数。10</p>
<p>周期7 活动单元数：7574 自由度数：8350（按级别：8、25、89、337、1086、2835、2268、1789、3217） CG迭代次数。11 </p>
<p>这几乎是完美的多重网格性能：线性残差在10个迭代步骤中被减少了12个数量级，而且结果几乎与网格大小无关。这显然部分是由于所解决的问题的简单性质，但它显示了多梯度方法的力量。</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>我们鼓励你生成solve()调用的时间并与步骤6进行比较。你会看到多网格方法在粗网格上有相当大的开销，但由于其最佳的复杂性，它在细网格上总是胜过其他方法。</p>
<p>仔细检查这个程序的性能就会发现，它主要是由矩阵-向量操作主导的。<a class="el" href="step_37.html">step-37</a>展示了一种通过使用无矩阵方法来避免这种情况的方法。</p>
<p>另一个途径是使用代数多网格方法。这里使用的几何多栅方法在实现上有时会有点尴尬，因为它需要所有这些额外的数据结构，如果程序要在parallel的机器上通过MPI耦合运行，就会变得更加困难，例如。在这种情况下，如果能使用一个黑盒预处理程序，就会更简单，该程序使用某种多栅层次结构以获得良好的性能，但可以自己计算出水平矩阵和类似的东西。代数多栅方法正是这样做的，我们将在步骤31中使用它们来解决斯托克斯问题，在步骤32和步骤40中使用它们来解决平行变化。也就是说，在步骤50中可以找到这个例子程序的MPI并行版本。</p>
<p>最后，人们可能要考虑如何将几何多网格用于其他类型的问题，特别是 <a class="el" href="group__vector__valued.html">矢量值问题</a>。这是<a class="el" href="step_56.html">step-56</a>的主题，我们将这里的技术用于斯托克斯方程。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2003 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Guido Kanschat, University of Heidelberg, 2003</span></div><div class="line"><span class="comment"> *          Baerbel Janssen, University of Heidelberg, 2010</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University, 2010</span></div><div class="line"><span class="comment"> *          Timo Heister, Clemson University, 2018</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step16</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>ScratchData</div><div class="line">  {</div><div class="line">    ScratchData(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;      mapping,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp;fe,</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        quadrature_degree,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>         update_flags)</div><div class="line">      : fe_values(mapping, fe, <a class="code" href="classQGauss.html">QGauss</a>&lt;dim&gt;(quadrature_degree), update_flags)</div><div class="line">    {}</div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">      : fe_values(scratch_data.fe_values.get_mapping(),</div><div class="line">                  scratch_data.fe_values.get_fe(),</div><div class="line">                  scratch_data.fe_values.get_quadrature(),</div><div class="line">                  scratch_data.fe_values.get_update_flags())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyData</div><div class="line">  {</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                         <a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>;</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    Vector&lt;double&gt;                       cell_rhs;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> Iterator &amp;cell, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">    {</div><div class="line">      cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line">      cell_rhs.reinit(dofs_per_cell);</div><div class="line"></div><div class="line">      local_dof_indices.resize(dofs_per_cell);</div><div class="line">      cell-&gt;get_active_or_mg_dof_indices(local_dof_indices);</div><div class="line">      level = cell-&gt;level();</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">    <span class="keywordtype">void</span> cell_worker(<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                     ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                     CopyData &amp;        copy_data);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_multigrid();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> refine_grid();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_sparsity_patterns;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a> mg_interface_sparsity_patterns;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_matrices;</div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a>                   mg_constrained_dofs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceProblem&lt;dim&gt;::LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">    , fe(degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , degree(degree)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (by level: &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.n_levels(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      std::cout &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level)</div><div class="line">                &lt;&lt; (level == triangulation.n_levels() - 1 ? <span class="stringliteral">&quot;)&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>);</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt; dirichlet_boundary_ids = {0};</div><div class="line">    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> homogeneous_dirichlet_bc;</div><div class="line">    <span class="keyword">const</span> std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt;</div><div class="line">      dirichlet_boundary_functions = {</div><div class="line">        {<a class="code" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>(0), &amp;homogeneous_dirichlet_bc}};</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             dirichlet_boundary_functions,</div><div class="line">                                             constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints);</div><div class="line">      sparsity_pattern.copy_from(dsp);</div><div class="line">    }</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    mg_constrained_dofs.clear();</div><div class="line">    mg_constrained_dofs.initialize(dof_handler);</div><div class="line">    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                       dirichlet_boundary_ids);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">    mg_interface_matrices.resize(0, n_levels - 1);</div><div class="line">    mg_matrices.resize(0, n_levels - 1);</div><div class="line">    mg_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line">    mg_interface_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        {</div><div class="line">          <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                     dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">          <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line"></div><div class="line">          mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">          mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">        }</div><div class="line">        {</div><div class="line">          <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                     dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">          <a class="code" href="namespaceMGTools.html#a8c677f65f8f1d21fb1f4c55cb90079e0">MGTools::make_interface_sparsity_pattern</a>(dof_handler,</div><div class="line">                                                   mg_constrained_dofs,</div><div class="line">                                                   dsp,</div><div class="line">                                                   level);</div><div class="line">          mg_interface_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line">          mg_interface_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(</div><div class="line">            mg_interface_sparsity_patterns[level]);</div><div class="line">        }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::cell_worker(<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                                        ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                                        CopyData &amp;        copy_data)</div><div class="line">  {</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;fe_values = scratch_data.fe_values;</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line"></div><div class="line">    copy_data.reinit(cell, dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW = fe_values.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient =</div><div class="line">          (fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>()[q][0] &lt; 0.0) ? 1.0 : 0.1;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                copy_data.cell_matrix(i, j) +=</div><div class="line">                  coefficient *</div><div class="line">                  (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)) *</div><div class="line">                  JxW[q];</div><div class="line">              }</div><div class="line">            copy_data.cell_rhs(i) += 1.0 * fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q) * JxW[q];</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> cell_worker =</div><div class="line">      [&amp;](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp;cell,</div><div class="line">          ScratchData&lt;dim&gt; &amp;                                    scratch_data,</div><div class="line">          CopyData &amp;                                            copy_data) {</div><div class="line">        this-&gt;cell_worker(cell, scratch_data, copy_data);</div><div class="line">      };</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;cd) {</div><div class="line">      this-&gt;constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cd.cell_matrix,</div><div class="line">                                                   cd.cell_rhs,</div><div class="line">                                                   cd.local_dof_indices,</div><div class="line">                                                   system_matrix,</div><div class="line">                                                   system_rhs);</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = degree + 1;</div><div class="line"></div><div class="line">    ScratchData&lt;dim&gt; scratch_data(mapping,</div><div class="line">                                  fe,</div><div class="line">                                  n_gauss_points,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          scratch_data,</div><div class="line">                          CopyData(),</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>     mapping;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">    std::vector&lt;AffineConstraints&lt;double&gt;&gt; boundary_constraints(n_levels);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classIndexSet.html">IndexSet</a> dofset;</div><div class="line">        <a class="code" href="namespaceDoFTools.html#a1fef7be07cf379b661646e39b9354e17">DoFTools::extract_locally_relevant_level_dofs</a>(dof_handler,</div><div class="line">                                                      level,</div><div class="line">                                                      dofset);</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(dofset);</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">          mg_constrained_dofs.get_refinement_edge_indices(level));</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].add_lines(</div><div class="line">          mg_constrained_dofs.get_boundary_indices(level));</div><div class="line">        boundary_constraints[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].close();</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> cell_worker =</div><div class="line">      [&amp;](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::level_cell_iterator</a> &amp;cell,</div><div class="line">          ScratchData&lt;dim&gt; &amp;                                   scratch_data,</div><div class="line">          CopyData &amp;                                           copy_data) {</div><div class="line">        this-&gt;cell_worker(cell, scratch_data, copy_data);</div><div class="line">      };</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;cd) {</div><div class="line">      boundary_constraints[cd.level].distribute_local_to_global(</div><div class="line">        cd.cell_matrix, cd.local_dof_indices, mg_matrices[cd.level]);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = cd.local_dof_indices.size();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">          <span class="keywordflow">if</span> (mg_constrained_dofs.is_interface_matrix_entry(</div><div class="line">                cd.level, cd.local_dof_indices[i], cd.local_dof_indices[j]))</div><div class="line">            {</div><div class="line">              mg_interface_matrices[cd.level].add(cd.local_dof_indices[i],</div><div class="line">                                                  cd.local_dof_indices[j],</div><div class="line">                                                  cd.cell_matrix(i, j));</div><div class="line">            }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_gauss_points = degree + 1;</div><div class="line"></div><div class="line">    ScratchData&lt;dim&gt; scratch_data(mapping,</div><div class="line">                                  fe,</div><div class="line">                                  n_gauss_points,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                          dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          scratch_data,</div><div class="line">                          CopyData(),</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt; mg_transfer(mg_constrained_dofs);</div><div class="line">    mg_transfer.build(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">    coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">    <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">    coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div><div class="line"></div><div class="line">    <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line">    <a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation&lt;Smoother, Vector&lt;double&gt;</a>&gt; mg_smoother;</div><div class="line">    mg_smoother.<a class="code" href="classmg_1_1SmootherRelaxation.html#ae9e03c626c50a1b13dffe338f5f977b0">initialize</a>(mg_matrices);</div><div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(2);</div><div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#abed2837ee4e224f94c6a98405906df8f">set_symmetric</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix(mg_matrices);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_up(mg_interface_matrices);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_down(mg_interface_matrices);</div><div class="line"></div><div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">      mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);</div><div class="line">    <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_down, mg_interface_up);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt;&gt;</div><div class="line">      preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">    solution = 0;</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of CG iterations: &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::refine_grid()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(degree + 2),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line">    triangulation.execute_coarsening_and_refinement();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 8; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">            triangulation.refine_global(2);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.n_active_cells() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line">        assemble_multigrid();</div><div class="line"></div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step16</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step16;</div><div class="line"></div><div class="line">      LaplaceProblem&lt;2&gt; laplace_problem(1);</div><div class="line">      laplace_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
