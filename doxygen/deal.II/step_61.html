<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_61.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-61 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-61 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_51.html">step-51</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#WeakGalerkinfiniteelementmethods"> Weak Galerkin finite element methods </a>
        <li><a href="#Theequationtosolve"> The equation to solve </a>
        <li><a href="#WeakGalerkinscheme"> Weak Galerkin scheme </a>
        <li><a href="#Representingtheweakgradient"> Representing the weak gradient </a>
        <li><a href="#Assemblingthelinearsystem"> Assembling the linear system </a>
        <li><a href="#PostprocessingandiLsub2subierrors"> Post-processing and <i>L<sub>2</sub></i>-errors </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#TheWGDarcyEquationclasstemplate">The WGDarcyEquation class template</a>
        <li><a href="#Righthandsideboundaryvaluesandexactsolution">Right hand side, boundary values, and exact solution</a>
        <li><a href="#WGDarcyEquationclassimplementation">WGDarcyEquation class implementation</a>
      <ul>
        <li><a href="#WGDarcyEquationWGDarcyEquation">WGDarcyEquation::WGDarcyEquation</a>
        <li><a href="#WGDarcyEquationmake_grid">WGDarcyEquation::make_grid</a>
        <li><a href="#WGDarcyEquationsetup_system">WGDarcyEquation::setup_system</a>
        <li><a href="#WGDarcyEquationassemble_system">WGDarcyEquation::assemble_system</a>
        <li><a href="#WGDarcyEquationdimsolve">WGDarcyEquation<dim>::solve</a>
        <li><a href="#WGDarcyEquationdimcompute_postprocessed_velocity">WGDarcyEquation<dim>::compute_postprocessed_velocity</a>
        <li><a href="#WGDarcyEquationdimcompute_pressure_error">WGDarcyEquation<dim>::compute_pressure_error</a>
        <li><a href="#WGDarcyEquationdimcompute_velocity_error">WGDarcyEquation<dim>::compute_velocity_error</a>
        <li><a href="#WGDarcyEquationoutput_results">WGDarcyEquation::output_results</a>
        <li><a href="#WGDarcyEquationrun">WGDarcyEquation::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#TestresultsoniWGQsub0subQsub0subRTsub0subi">Test results on <i>WG(Q<sub>0</sub>,Q<sub>0</sub>;RT<sub>[0]</sub>)</i></a>
      <ul>
        <li><a href="#Convergencetableforik0i">Convergence table for <i>k=0</i></a>
      </ul>
        <li><a href="#TestresultsoniWGQsub1subQsub1subRTsub1subi">Test results on <i>WG(Q<sub>1</sub>,Q<sub>1</sub>;RT<sub>[1]</sub>)</i></a>
      <ul>
        <li><a href="#Convergencetableforik1i">Convergence table for <i>k=1</i></a>
      </ul>
        <li><a href="#TestresultsoniWGQsub2subQsub2subRTsub2subi">Test results on <i>WG(Q<sub>2</sub>,Q<sub>2</sub>;RT<sub>[2]</sub>)</i></a>
      <ul>
        <li><a href="#Convergencetableforik2i">Convergence table for <i>k=2</i></a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em> This program was contributed by Zhuoran Wang. Some more information about this program, as well as more numerical results, are presented in <b>[Wang2019]</b> . </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This tutorial program presents an implementation of the "weak Galerkin" finite element method for the Poisson equation. In some sense, the motivation for considering this method starts from the same point as in <a class="el" href="step_51.html">step-51</a>: We would like to consider discontinuous shape functions, but then need to address the fact that the resulting problem has a much larger number of degrees of freedom compared to the usual continuous Galerkin method (because, for example, each vertex carries as many degrees of freedom as there are adjacent cells). We also have to address the fact that, unlike in the continuous Galerkin method, <em>every</em> degree of freedom on one cell couples with all of the degrees of freedom on each of its face neighbor cells. Consequently, the matrix one gets from the "traditional" discontinuous Galerkin methods are both large and relatively dense.</p>
<p>Both the hybridized discontinuous Galerkin method (HDG) in <a class="el" href="step_51.html">step-51</a> and the weak Galerkin (WG) method in this tutorial address the issue of coupling by introducing additional degrees of freedom whose shape functions only live on a face between cells (i.e., on the "skeleton" of the mesh), and which therefore "insulate" the degrees of freedom on the adjacent cells from each other: cell degrees of freedom only couple with other cell degrees of freedom on the same cell, as well as face degrees of freedom, but not with cell degrees of freedom on neighboring cells. Consequently, the coupling of shape functions for these cell degrees of freedom indeed couple on exactly one cell and the degrees of freedom defined on its faces.</p>
<p>For a given equation, say the second order Poisson equation, the difference between the HDG and the WG method is how precisely one formulates the problem that connects all of these different shape functions. (Indeed, for some WG and HDG formulation, it is possible to show that they are equivalent.) The HDG does things by reformulating second order problems in terms of a system of first order equations and then conceptually considers the face degrees of freedom to be "fluxes" of this first order system. In contrast, the WG method keeps things in second order form and considers the face degrees of freedom as of the same type as the primary solution variable, just restricted to the lower-dimensional faces. For the purposes of the equation, one then needs to somehow "extend" these shape functions into the interior of the cell when defining what it means to apply a differential operator to them. Compared to the HDG, the method has the advantage that it does not lead to a proliferation of unknowns due to rewriting the equation as a first-order system, but it is also not quite as easy to implement. However, as we will see in the following, this additional effort is not prohibitive.</p>
<p><a class="anchor" id="WeakGalerkinfiniteelementmethods"></a></p><h3>Weak Galerkin finite element methods </h3>
<p>Weak Galerkin Finite Element Methods (WGFEMs) use discrete weak functions to approximate scalar unknowns, and discrete weak gradients to approximate classical gradients. The method was originally introduced by Junping Wang and Xiu Ye in the paper <a href="https://doi.org/10.1016/j.cam.2012.10.003"><em>A weak Galerkin finite element method for second order elliptic problems</em>, J. Comput. Appl. Math., 103-115, 2013</a>. Compared to the continuous Galerkin method, the weak Galerkin method satisfies important physical properties, namely local mass conservation and bulk normal flux continuity. It results in a SPD linear system, and optimal convergence rates can be obtained with mesh refinement.</p>
<p><a class="anchor" id="Theequationtosolve"></a></p><h3>The equation to solve </h3>
<p>This program solves the Poisson equation using the weak Galerkin finite element method: </p><p class="formulaDsp">
\begin{align*} \nabla \cdot \left( -\mathbf{K} \nabla p \right) &amp;= f, \qquad \mathbf{x} \in \Omega, \\ p &amp;= p_D,\qquad \mathbf{x} \in \Gamma^D, \\ \mathbf{u} \cdot \mathbf{n} &amp;= u_N, \qquad \mathbf{x} \in \Gamma^N, \end{align*}
</p>
<p> where \(\Omega \subset \mathbb{R}^n (n=2,3)\) is a bounded domain. In the context of the flow of a fluid through a porous medium, \(p\) is the pressure, \(\mathbf{K}\) is a permeability tensor, \(f\) is the source term, and \(p_D, u_N\) represent Dirichlet and Neumann boundary conditions. We can introduce a flux, \(\mathbf{u} = -\mathbf{K} \nabla p\), that corresponds to the Darcy velocity (in the way we did in <a class="el" href="step_20.html">step-20</a>) and this variable will be important in the considerations below.</p>
<p>In this program, we will consider a test case where the exact pressure is \(p = \sin \left( \pi x\right)\sin\left(\pi y \right)\) on the unit square domain, with homogeneous Dirichelet boundary conditions and \(\mathbf{K}\) the identity matrix. Then we will calculate \(L_2\) errors of pressure, velocity, and flux.</p>
<p><a class="anchor" id="WeakGalerkinscheme"></a></p><h3>Weak Galerkin scheme </h3>
<p>The Poisson equation above has a solution \(p\) that needs to satisfy the weak formulation of the problem, </p><p class="formulaDsp">
\begin{equation*} \mathcal{A}\left(p,q \right) = \mathcal{F} \left(q \right), \end{equation*}
</p>
<p> for all test functions \(q\), where </p><p class="formulaDsp">
\begin{equation*} \mathcal{A}\left(p,q\right) \dealcoloneq \int_\Omega \left(\mathbf{K} \nabla p\right) \cdot \nabla q \;\mathrm{d}x, \end{equation*}
</p>
<p> and </p><p class="formulaDsp">
\begin{equation*} \mathcal{F}\left(q\right) \dealcoloneq \int_\Omega f \, q \;\mathrm{d}x - \int_{\Gamma^N} u_N q \; \mathrm{d}x. \end{equation*}
</p>
<p> Here, we have integrated by parts in the bilinear form, and we are evaluating the gradient of \(p,p\) in the interior and the values of \(q\) on the boundary of the domain. All of this is well defined because we assume that the solution is in \(H^1\) for which taking the gradient and evaluating boundary values are valid operations.</p>
<p>The idea of the weak Galerkin method is now to approximate the exact \(p\) solution with a <em>discontinuous function</em> \(p_h\). This function may only be discontinuous along interfaces between cells, and because we will want to evaluate this function also along interfaces, we have to prescribe not only what values it is supposed to have in the cell interiors but also its values along interfaces. We do this by saying that \(p_h\) is actually a tuple, \(p_h=(p^\circ,p^\partial)\), though it's really just a single function that is either equal to \(p^\circ(x)\) or \(p^\partial(x)\), depending on whether it is evaluated at a point \(x\) that lies in the cell interior or on cell interfaces.</p>
<p>We would then like to simply stick this approximation into the bilinear form above. This works for the case where we have to evaluate the test function \(q_h\) on the boundary (where we would simply take its interface part \(q_h^\partial\)) but we have to be careful with the gradient because that is only defined in cell interiors. Consequently, the weak Galerkin scheme for the Poisson equation is defined by </p><p class="formulaDsp">
\begin{equation*} \mathcal{A}_h\left(p_h,q \right) = \mathcal{F} \left(q_h \right), \end{equation*}
</p>
<p> for all discrete test functions \(q_h\), where </p><p class="formulaDsp">
\begin{equation*} \mathcal{A}_h\left(p_h,q_h\right) \dealcoloneq \sum_{K \in \mathbb{T}} \int_K \mathbf{K} \nabla_{w,d} p_h \cdot \nabla_{w,d} q_h \;\mathrm{d}x, \end{equation*}
</p>
<p> and </p><p class="formulaDsp">
\begin{equation*} \mathcal{F}\left(q_h\right) \dealcoloneq \sum_{K \in \mathbb{T}} \int_K f \, q_h^\circ \;\mathrm{d}x - \sum_{\gamma \in \Gamma_h^N} \int_\gamma u_N q_h^\partial \;\mathrm{d}x, \end{equation*}
</p>
<p> The key point is that here, we have replaced the gradient \(\nabla p_h\) by the <em>discrete weak gradient</em> operator \(\nabla_{w,d} p_h\) that makes sense for our peculiarly defined approximation \(p_h\).</p>
<p>The question is then how that operator works. For this, let us first say how we think of the discrete approximation \(p_h\) of the pressure. As mentioned above, the "function" \(p_h\) actually consists of two parts: the values \(p_h^\circ\) in the interior of cells, and \(p_h^\partial\) on the interfaces. We have to define discrete (finite-dimensional) function spaces for both of these; in this program, we will use <a class="el" href="classFE__DGQ.html">FE_DGQ</a> for \(p_h^\circ\) as the space in the interior of cells (defined on each cell, but in general discontinuous along interfaces), and <a class="el" href="classFE__FaceQ.html">FE_FaceQ</a> for \(p_h^\partial\) as the space on the interfaces.</p>
<p>Then let us consider just a single cell (because the integrals above are all defined cell-wise, and because the weak discrete gradient is defined cell-by-cell). The restriction of \(p_h\) to cell \(K\), \(p_h|_K\) then consists of the pair \((p_h^\circ|_K,p_h^\partial|_{\partial K})\). In essence, we can think of \(\nabla_{w,d} p_h\) of some function defined on \(K\) that approximates the gradient; in particular, if \(p_h|_K\) was the restriction of a differentiable function (to the interior and boundary of \(K\) &ndash; which would make it continuous between the interior and boundary), then \(\nabla_{w,d} p_h\) would simply be the exact gradient \(\nabla p_h\). But, since \(p_h|_K\) is not continuous between interior and boundary of \(K\), we need a more general definition; furthermore, we can not deal with arbitrary functions, and so require that \(\nabla_{w,d} p_h\) is also in a finite element space (which, since the gradient is a vector, has to be vector-valued, and because the weak gradient is defined on each cell separately, will also be discontinuous between cells).</p>
<p>The way this is done is to define this weak gradient operator \(\nabla_{w,d}|_K : DGQ_k(K) \times DGQ_r(\partial K) \rightarrow RT_s(K)\) (where \(RT_s(K)\) is the vector-valued Raviart-Thomas space of order \(s\) on cell \(K\)) in the following way: </p><p class="formulaDsp">
\begin{equation*} \int_K \mathbf v_h \cdot (\nabla_{w,d} p_h) = -\int_K (\nabla \cdot \mathbf v_h) p_h^\circ +\int_{\partial K} (\mathbf v_h \cdot \mathbf n) p_h^\partial, \end{equation*}
</p>
<p> for all test functions \(\mathbf v_h \in RT_s(K)\). This is, in essence, simply an application of the integration-by-parts formula. In other words, for a given \(p_h=(p^\circ_h,p^\partial_h)\), we need to think of \(\nabla_{w,d} p_h|_K\) as that Raviart-Thomas function of degree \(s\) for which the left hand side and right hand side are equal for all test functions.</p>
<p>A key point to make is then the following: While the usual gradient \(\nabla\) is a <em>local</em> operator that computes derivatives based simply on the value of a function at a point and its (infinitesimal) neighborhood, the weak discrete gradient \(\nabla_{w,d}\) does not have this property: It depends on the values of the function it is applied to on the entire cell, including the cell's boundary. Both are, however, linear operators as is clear from the definition of \(\nabla_{w,d}\) above, and that will allow us to represent \(\nabla_{w,d}\) via a matrix in the discussion below.</p>
<dl class="section note"><dt>Note</dt><dd>It may be worth pointing out that while the weak discrete gradient is an element of the Raviart-Thomas space \(RT_s(K)\) on each cell \(K\), it is discontinuous between cells. On the other hand, the Raviart-Thomas space \(RT_s=RT_s({\mathbb T})\) defined on the entire mesh and implemented by the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> class represents functions that have continuous normal components at interfaces between cells. This means that <em>globally</em>, \(\nabla_{w,d} p_h\) is not in \(RT_s\), even though it is on every cell \(K\) in \(RT_s(K)\). Rather, it is in a "broken" Raviart-Thomas space that below we will represent by the symbol \(DGRT_s\). (The term "broken" here refers to the process of "breaking something apart", and not to the synonym to the expression "not functional".) One might therefore (rightfully) argue that the notation used in the weak Galerkin literature is a bit misleading, but as so often it all depends on the context in which a certain notation is used &ndash; in the current context, references to the Raviart-Thomas space or element are always understood to be to the "broken" spaces.</dd>
<dd>
deal.II happens to have an implementation of this broken Raviart-Thomas space: The FE_DGRT class. As a consequence, in this tutorial we will simply always use the FE_DGRT class, even though in all of those places where we have to compute cell-local matrices and vectors, it makes no difference.</dd></dl>
<p><a class="anchor" id="Representingtheweakgradient"></a></p><h3>Representing the weak gradient </h3>
<p>Since \(p_h\) is an element of a finite element space, we can expand it in a basis as we always do, i.e., we can write </p><p class="formulaDsp">
\begin{equation*} p_h(\mathbf x) = \sum_j P_j \varphi_j(\mathbf x). \end{equation*}
</p>
<p> Here, since \(p_h\) has two components (the interior and the interface components), the same must hold true for the basis functions \(\varphi_j(\mathbf x)\), which we can write as \(\varphi_j = (\varphi_j^\circ,\varphi_j^\partial)\). If you've followed the descriptions in <a class="el" href="step_8.html">step-8</a>, <a class="el" href="step_20.html">step-20</a>, and the <a class="el" href="group__vector__valued.html">documentation module on vector-valued problems</a>, it will be no surprise that for some values of \(j\), \(\varphi_j^\circ\) will be zero, whereas for other values of \(j\), \(\varphi_j^\partial\) will be zero &ndash; i.e., shape functions will be of either one or the other kind. That is not important, here, however. What is important is that we need to wonder how we can represent \(\nabla_{w,d} \varphi_j\) because that is clearly what will appear in the problem when we want to implement the bilinear form </p><p class="formulaDsp">
\begin{equation*} \mathcal{A}_h\left(p_h,q_h\right) = \sum_{K \in \mathbb{T}} \int_K \mathbf{K} \nabla_{w,d} p_h \cdot \nabla_{w,d} q_h \;\mathrm{d}x, \end{equation*}
</p>
<p>The key point is that \(\nabla_{w,d} \varphi_j\) is known to be a member of the "broken" Raviart-Thomas space \(DGRT_s\). What this means is that we can represent (on each cell \(K\) separately) </p><p class="formulaDsp">
\begin{equation*} \nabla_{w,d} \varphi_j|_K = \sum_k C_{jk}^K \mathbf v_k|_K \end{equation*}
</p>
<p> where the functions \(\mathbf v_k \in DGRT_s\), and where \(C^K\) is a matrix of dimension </p><p class="formulaDsp">
\begin{align*} \text{dim}\left(DGQ_k(K) \times DGQ_r(K)\right) &amp;\times \text{dim}\left(RT_s(K)\right) \\ &amp;= \left(\text{dim}(DGQ_k(K)) + \text{dim}(DGQ_r(K))\right) \times \text{dim}\left(RT_s(K)\right). \end{align*}
</p>
<p> (That the weak discrete gradient can be represented as a matrix should not come as a surprise: It is a linear operator from one finite dimensional space to another finite dimensional space. If one chooses bases for both of these spaces, then <em>every linear operator</em> can of course be written as a matrix mapping the vector of expansion coefficients with regards to the basis of the domain space of the operator, to the vector of expansion coefficients with regards to the basis in the image space.)</p>
<p>Using this expansion, we can easily use the definition of the weak discrete gradient above to define what the matrix is going to be: </p><p class="formulaDsp">
\begin{equation*} \int_K \mathbf v_i \cdot \left(\sum_k C_{jk}^K \mathbf v_k\right) = -\int_K (\nabla \cdot \mathbf v_i) \varphi_j^\circ +\int_{\partial K} (\mathbf v_i \cdot \mathbf n) \varphi_j^\partial, \end{equation*}
</p>
<p> for all test functions \(\mathbf v_i \in DGRT_s\).</p>
<p>This clearly leads to a linear system of the form </p><p class="formulaDsp">
\begin{equation*} \sum_k M_{ik}^K C_{jk}^K = G_{ij}^K \end{equation*}
</p>
<p> with </p><p class="formulaDsp">
\begin{equation*} M_{ik}^K = \int_K \mathbf v_i \cdot \mathbf v_k, \qquad\qquad G_{ij}^K = -\int_K (\nabla \cdot \mathbf v_i) \varphi_j^\circ +\int_{\partial K} (\mathbf v_i \cdot \mathbf n) \varphi_j^\partial, \end{equation*}
</p>
<p> and consequently </p><p class="formulaDsp">
\begin{equation*} \left(C^K\right)^T = \left(M^K\right)^{-1} G^K. \end{equation*}
</p>
<p> (In this last step, we have assumed that the indices \(i,j,k\) only range over those degrees of freedom active on cell \(K\), thereby ensuring that the mass matrix on the space \(RT_s(K)\) is invertible.) Equivalently, using the symmetry of the matrix \(M\), we have that </p><p class="formulaDsp">
\begin{equation*} C^K = \left(G^K\right)^{T} \left(M^K\right)^{-1}. \end{equation*}
</p>
<p> Also worth pointing out is that the matrices \(C^K\) and \(G^K\) are of course not square but rectangular.</p>
<p><a class="anchor" id="Assemblingthelinearsystem"></a></p><h3>Assembling the linear system </h3>
<p>Having explained how the weak discrete gradient is defined, we can now come back to the question of how the linear system for the equation in question should be assembled. Specifically, using the definition of the bilinear form \({\cal A}_h\) shown above, we then need to compute the elements of the local contribution to the global matrix, </p><p class="formulaDsp">
\begin{equation*} A^K_{ij} = \int_K \left({\mathbf K} \nabla_{w,d} \varphi_i\right) \cdot \nabla_{w,d} \varphi_j. \end{equation*}
</p>
<p> As explained above, we can expand \(\nabla_{w,d} \varphi_i\) in terms of the Raviart-Thomas basis on each cell, and similarly for \(\nabla_{w,d} \varphi_j\): </p><p class="formulaDsp">
\begin{equation*} A^K_{ij} = \int_K \left( {\mathbf K} \sum_k C_{ik}^K \mathbf v_k|_K \right) \cdot \sum_l C_{jl}^K \mathbf v_l|_K. \end{equation*}
</p>
<p> By re-arranging sums, this yields the following expression: </p><p class="formulaDsp">
\begin{equation*} A^K_{ij} = \sum_k \sum_l C_{ik}^K C_{jl}^K \int_K \left( {\mathbf K} \mathbf v_k|_K \right) \cdot \mathbf v_l|_K. \end{equation*}
</p>
<p> So, if we have the matrix \(C^K\) for each cell \(K\), then we can easily compute the contribution \(A^K\) for cell \(K\) to the matrix \(A\) as follows: </p><p class="formulaDsp">
\begin{equation*} A^K_{ij} = \sum_k \sum_l C_{ik}^K C_{jl}^K H^K_{kl} = \sum_k \sum_l C_{ik}^K H^K_{kl} C_{jl}^K = \left(C^K H^K (C^K)^T \right)_{ij}. \end{equation*}
</p>
<p> Here, </p><p class="formulaDsp">
\begin{equation*} H^K_{kl} = \int_K \left( {\mathbf K} \mathbf v_k|_K \right) \cdot \mathbf v_l|_K, \end{equation*}
</p>
<p> which is really just the mass matrix on cell \(K\) using the Raviart-Thomas basis and weighting by the permeability tensor \(\mathbf K\). The derivation here then shows that the weak Galerkin method really just requires us to compute these \(C^K\) and \(H^K\) matrices on each cell \(K\), and then \(A^K = C^K H^K (C^K)^T\), which is easily computed. The code to be shown below does exactly this.</p>
<p>Having so computed the contribution \(A^K\) of cell \(K\) to the global matrix, all we have to do is to "distribute" these local contributions into the global matrix. How this is done is first shown in <a class="el" href="step_3.html">step-3</a> and <a class="el" href="step_4.html">step-4</a>. In the current program, this will be facilitated by calling <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a>.</p>
<p>A linear system of course also needs a right hand side. There is no difficulty associated with computing the right hand side here other than the fact that we only need to use the cell-interior part \(\varphi_i^\circ\) for each shape function \(\varphi_i\).</p>
<p><a class="anchor" id="PostprocessingandiLsub2subierrors"></a></p><h3>Post-processing and <em>L<sub>2</sub></em>-errors </h3>
<p>The discussions in the previous sections have given us a linear system that we can solve for the numerical pressure \(p_h\). We can use this to compute an approximation to the variable \(\mathbf u = -{\mathbf K}\nabla p\) that corresponds to the velocity with which the medium flows in a porous medium if this is the model we are trying to solve. This kind of step &ndash; computing a derived quantity from the solution of the discrete problem &ndash; is typically called "post-processing".</p>
<p>Here, instead of using the exact gradient of \(p_h\), let us instead use the discrete weak gradient of \(p_h\) to calculate the velocity on each element. As discussed above, on each element the gradient of the numerical pressure \(\nabla p\) can be approximated by discrete weak gradients \( \nabla_{w,d}\phi_i\): </p><p class="formulaDsp">
\begin{equation*} \nabla_{w,d} p_h = \nabla_{w,d} \left(\sum_{i} P_i \phi_i\right) = \sum_{i} P_i \nabla_{w,d}\phi_i. \end{equation*}
</p>
<p>On cell \(K\), the numerical velocity \( \mathbf{u}_h = -\mathbf{K} \nabla_{w,d}p_h\) can be written as </p><p class="formulaDsp">
\begin{align*} \mathbf{u}_h &amp;= -\mathbf{K} \nabla_{w,d} p_h = -\mathbf{K}\sum_{i} \sum_{j} P_i C^K_{ij}\mathbf{v}_j, \end{align*}
</p>
<p> where \(C^K\) is the expansion matrix from above, and \(\mathbf{v}_j\) is the basis function of the \(RT\) space on a cell.</p>
<p>Unfortunately, \(\mathbf{K} \mathbf{v}_j\) may not be in the \(RT\) space (unless, of course, if \(\mathbf K\) is constant times the identity matrix). So, in order to represent it in a finite element program, we need to project it back into a finite dimensional space we can work with. Here, we will use the \(L_2\)-projection to project it back to the (broken) \(RT\) space.</p>
<p>We define the projection as \( \mathbf{Q}_h \left( \mathbf{K}\mathbf{v}_j \right) = \sum_{k} d_{jk}\mathbf{v}_k\) on each cell \(K\). For any \(j\), \(\left( \mathbf{Q}_h \left( \mathbf{Kv}_j \right),\mathbf{v}_k \right)_K = \left( \mathbf{Kv}_j,\mathbf{v}_k \right)_K.\) So, rather than the formula shown above, the numerical velocity on cell \(K\) instead becomes </p><p class="formulaDsp">
\begin{equation*} \mathbf{u}_h = \mathbf{Q}_h \left( -\mathbf{K}\nabla_{w,d}p_h \right) = -\sum_i \sum_j P_i B^K_{ij}\mathbf{Q}_h \left( \mathbf{K}\mathbf{v}_j \right), \end{equation*}
</p>
<p> and we have the following system to solve for the coefficients \(d_{jk}\): </p><p class="formulaDsp">
\begin{equation*} \sum_j \left(\mathbf{v}_i,\mathbf{v}_j\right) d_{jk} = \left( \mathbf{Kv}_j,\mathbf{v}_k \right). \end{equation*}
</p>
<p> In the implementation below, the matrix with elements \( d_{jk} \) is called <code>cell_matrix_D</code>, whereas the matrix with elements \( \left( \mathbf{Kv}_j,\mathbf{v}_k \right) \) is called <code>cell_matrix_E</code>.</p>
<p>Then the elementwise velocity is </p><p class="formulaDsp">
\begin{equation*} \mathbf{u}_h = -\sum_{i} \sum_{j}P_ic_{ij}\sum_{k}d_{jk}\mathbf{v}_k = \sum_{k}- \left(\sum_{j} \sum_{i} P_ic_{ij}d_{jk} \right)\mathbf{v}_k, \end{equation*}
</p>
<p> where \(-\sum_{j} \sum_{i} P_ic_{ij}d_{jk}\) is called <code>cell_velocity</code> in the code.</p>
<p>Using this velocity obtained by "postprocessing" the solution, we can define the \(L_2\)-errors of pressure, velocity, and flux by the following formulas: </p><p class="formulaDsp">
\begin{align*} \|p-p_h^\circ\|^2 &amp;= \sum_{K \in \mathbb{T}} \|p-p_h^\circ\|_{L_2(K)}^2, \\ \|\mathbf{u}-\mathbf{u}_h\|^2 &amp;= \sum_{K \in \mathbb{T}} \|\mathbf{u}-\mathbf{u}_h\|_{L_2(K)^2}^d,\\ \|(\mathbf{u}-\mathbf{u}_h) \cdot \mathbf{n}\|^2 &amp;= \sum_{K \in \mathbb{T}} \sum_{\gamma \subset \partial K} \frac{|K|}{|\gamma|} \|\mathbf{u} \cdot \mathbf{n} - \mathbf{u}_h \cdot \mathbf{n}\|_{L_2(\gamma)}^2, \end{align*}
</p>
<p> where \(| K |\) is the area of the element, \(\gamma\) are faces of the element, \(\mathbf{n}\) are unit normal vectors of each face. The last of these norms measures the accuracy of the normal component of the velocity vectors over the interfaces between the cells of the mesh. The scaling factor \(|K|/|\gamma|\) is chosen so as to scale out the difference in the length (or area) of the collection of interfaces as the mesh size changes.</p>
<p>The first of these errors above is easily computed using <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>. The others require a bit more work and are implemented in the code below.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>This program is based on <a class="el" href="step_7.html">step-7</a>, <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_51.html">step-51</a>, so most of the following header files are familiar. We need the following, of which only the one that imports the <a class="el" href="classFE__DGRaviartThomas.html">FE_DGRaviartThomas</a> class (namely, <code>deal.II/fe/fe_dg_vector.h</code>) is really new; the <a class="el" href="classFE__DGRaviartThomas.html">FE_DGRaviartThomas</a> implements the "broken" Raviart-Thomas space discussed in the introduction:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2quadrature_8h.html">deal.II/base/quadrature.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2point_8h.html">deal.II/base/point.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__raviart__thomas_8h.html">deal.II/fe/fe_raviart_thomas.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dg__vector_8h.html">deal.II/fe/fe_dg_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__face_8h.html">deal.II/fe/fe_face.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="component__mask_8h.html">deal.II/fe/component_mask.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="data__out__faces_8h.html">deal.II/numerics/data_out_faces.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>Our first step, as always, is to put everything related to this tutorial program into its own namespace:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step61</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="TheWGDarcyEquationclasstemplate"></a> </p><h3>The WGDarcyEquation class template</h3>
<p>This is the main class of this program. We will solve for the numerical pressure in the interior and on faces using the weak Galerkin (WG) method, and calculate the \(L_2\) error of pressure. In the post-processing step, we will also calculate \(L_2\)-errors of the velocity and flux.</p>
<p>The structure of the class is not fundamentally different from that of previous tutorial programs, so there is little need to comment on the details with one exception: The class has a member variable <code>fe_dgrt</code> that corresponds to the "broken" Raviart-Thomas space mentioned in the introduction. There is a matching <code>dof_handler_dgrt</code> that represents a global enumeration of a finite element field created from this element, and a vector <code>darcy_velocity</code> that holds nodal values for this field. We will use these three variables after solving for the pressure to compute a postprocessed velocity field for which we can then evaluate the error and which we can output for visualization.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>WGDarcyEquation</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  WGDarcyEquation(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> compute_postprocessed_velocity();</div><div class="line">  <span class="keywordtype">void</span> compute_velocity_errors();</div><div class="line">  <span class="keywordtype">void</span> compute_pressure_error();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>   fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; solution;</div><div class="line">  Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">  <a class="code" href="classFE__DGRaviartThomas.html">FE_DGRaviartThomas&lt;dim&gt;</a> fe_dgrt;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>         dof_handler_dgrt;</div><div class="line">  Vector&lt;double&gt;          darcy_velocity;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Righthandsideboundaryvaluesandexactsolution"></a> </p><h3>Right hand side, boundary values, and exact solution</h3>
<p>Next, we define the coefficient matrix \(\mathbf{K}\) (here, the identity matrix), Dirichlet boundary conditions, the right-hand side \(f = 2\pi^2 \sin(\pi x) \sin(\pi y)\), and the exact solution that corresponds to these choices for \(K\) and \(f\), namely \(p = \sin(\pi x) \sin(\pi y)\).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Coefficient()</div><div class="line">    : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTensorFunction.html#a3afbbe3ba38a517e8a97db9adf2cb340">value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                          std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;values) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Coefficient&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                  std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">    values[p] = unit_symmetric_tensor&lt;dim&gt;();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (2 * numbers::PI * numbers::PI * std::sin(numbers::PI * p[0]) *</div><div class="line">          std::sin(numbers::PI * p[1]));</div><div class="line">}</div></div><!-- fragment --><p>The class that implements the exact pressure solution has an oddity in that we implement it as a vector-valued one with two components. (We say that it has two components in the constructor where we call the constructor of the base <a class="el" href="classFunction.html">Function</a> class.) In the <code>value()</code> function, we do not test for the value of the <code>component</code> argument, which implies that we return the same value for both components of the vector-valued function. We do this because we describe the finite element in use in this program as a vector-valued system that contains the interior and the interface pressures, and when we compute errors, we will want to use the same pressure solution to test both of these components.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ExactPressure : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ExactPressure()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> ExactPressure&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[0]) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[1]);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ExactVelocity : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ExactVelocity()</div><div class="line">    : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;()</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ExactVelocity&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> return_value;</div><div class="line">  return_value[0] = -numbers::PI * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI * p[0]) *</div><div class="line">                    <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[1]);</div><div class="line">  return_value[1] = -numbers::PI * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[0]) *</div><div class="line">                    <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI * p[1]);</div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationclassimplementation"></a> </p><h3>WGDarcyEquation class implementation</h3>
<p><a class="anchor" id="WGDarcyEquationWGDarcyEquation"></a> </p><h4>WGDarcyEquation::WGDarcyEquation</h4>
<p>In this constructor, we create a finite element space for vector valued functions, which will here include the ones used for the interior and interface pressures, \(p^\circ\) and \(p^\partial\).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">WGDarcyEquation&lt;dim&gt;::WGDarcyEquation(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1, <a class="code" href="classFE__FaceQ.html">FE_FaceQ</a>&lt;dim&gt;(degree), 1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , fe_dgrt(degree)</div><div class="line">  , dof_handler_dgrt(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationmake_grid"></a> </p><h4>WGDarcyEquation::make_grid</h4>
<p>We generate a mesh on the unit square domain and refine it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(5);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationsetup_system"></a> </p><h4>WGDarcyEquation::setup_system</h4>
<p>After we have created the mesh above, we distribute degrees of freedom and resize matrices and vectors. The only piece of interest in this function is how we interpolate the boundary values for the pressure. Since the pressure consists of interior and interface components, we need to make sure that we only interpolate onto that component of the vector-valued solution space that corresponds to the interface pressures (as these are the only ones that are defined on the boundary of the domain). We do this via a component mask object for only the interface pressures.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  dof_handler_dgrt.distribute_dofs(fe_dgrt);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of pressure degrees of freedom: &quot;</span></div><div class="line">            &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line"></div><div class="line">  {</div><div class="line">    constraints.clear();</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> interface_pressure(1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a>              interface_pressure_mask =</div><div class="line">      fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(interface_pressure);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             constraints,</div><div class="line">                                             interface_pressure_mask);</div><div class="line">    constraints.close();</div><div class="line">  }</div></div><!-- fragment --><p>In the bilinear form, there is no integration term over faces between two neighboring cells, so we can just use <code><a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></code> to calculate the sparse matrix.</p>
<div class="fragment"><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints);</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationassemble_system"></a> </p><h4>WGDarcyEquation::assemble_system</h4>
<p>This function is more interesting. As detailed in the introduction, the assembly of the linear system requires us to evaluate the weak gradient of the shape functions, which is an element in the Raviart-Thomas space. As a consequence, we need to define a Raviart-Thomas finite element object, and have <a class="el" href="classFEValues.html">FEValues</a> objects that evaluate it at quadrature points. We then need to compute the matrix \(C^K\) on every cell \(K\), for which we need the matrices \(M^K\) and \(G^K\) mentioned in the introduction.</p>
<p>A point that may not be obvious is that in all previous tutorial programs, we have always called <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> with a cell iterator from a <a class="el" href="classDoFHandler.html">DoFHandler</a>. This is so that one can call functions such as <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> that extract the values of a finite element function (represented by a vector of DoF values) on the quadrature points of a cell. For this operation to work, one needs to know which vector elements correspond to the degrees of freedom on a given cell &ndash; i.e., exactly the kind of information and operation provided by the <a class="el" href="classDoFHandler.html">DoFHandler</a> class.</p>
<p>We could create a <a class="el" href="classDoFHandler.html">DoFHandler</a> object for the "broken" Raviart-Thomas space (using the FE_DGRT class), but we really don't want to here: At least in the current function, we have no need for any globally defined degrees of freedom associated with this broken space, but really only need to reference the shape functions of such a space on the current cell. As a consequence, we use the fact that one can call <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> also with cell iterators into <a class="el" href="classTriangulation.html">Triangulation</a> objects (rather than <a class="el" href="classDoFHandler.html">DoFHandler</a> objects). In this case, <a class="el" href="classFEValues.html">FEValues</a> can of course only provide us with information that only references information about cells, rather than degrees of freedom enumerated on these cells. So we can't use <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a>, but we can use <a class="el" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">FEValues::shape_value()</a> to obtain the values of shape functions at quadrature points on the current cell. It is this kind of functionality we will make use of below. The variable that will give us this information about the Raviart-Thomas functions below is then the <code>fe_values_rt</code> (and corresponding <code>fe_face_values_rt</code>) object.</p>
<p>Given this introduction, the following declarations should be pretty obvious:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values_dgrt(fe_dgrt,</div><div class="line">                               quadrature_formula,</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                        face_quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell      = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = fe_face_values.<a class="code" href="classFEFaceValuesBase.html#ab460150cda793c93abfc6eac1314de31">get_quadrature</a>().<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  RightHandSide&lt;dim&gt;  right_hand_side;</div><div class="line">  std::vector&lt;double&gt; right_hand_side_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Coefficient&lt;dim&gt;      coefficient;</div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt;&gt; coefficient_values(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div></div><!-- fragment --><p>Next, let us declare the various cell matrices discussed in the introduction:</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">Vector&lt;double&gt;     cell_solution(dofs_per_cell);</div></div><!-- fragment --><p>We need <code><a class="el" href="namespaceFEValuesExtractors.html">FEValuesExtractors</a></code> to access the <code>interior</code> and <code>face</code> component of the shape functions.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_interior(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_face(1);</div></div><!-- fragment --><p>This finally gets us in position to loop over all cells. On each cell, we will first calculate the various cell matrices used to construct the local matrix &ndash; as they depend on the cell in question, they need to be re-computed on each cell. We need shape functions for the Raviart-Thomas space as well, for which we need to create first an iterator to the cell of the triangulation, which we can obtain by assignment from the cell pointing into the <a class="el" href="classDoFHandler.html">DoFHandler</a>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell_dgrt =</div><div class="line">      cell;</div><div class="line">    fe_values_dgrt.reinit(cell_dgrt);</div><div class="line"></div><div class="line">    right_hand_side.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                               right_hand_side_values);</div><div class="line">    coefficient.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                           coefficient_values);</div></div><!-- fragment --><p>The first cell matrix we will compute is the mass matrix for the Raviart-Thomas space. Hence, we need to loop over all the quadrature points for the velocity <a class="el" href="classFEValues.html">FEValues</a> object.</p>
<div class="fragment"><div class="line">cell_matrix_M = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i = fe_values_dgrt[velocities].value(i, q);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">            fe_values_dgrt[velocities].value(k, q);</div><div class="line">          cell_matrix_M(i, k) += (v_i * v_k * fe_values_dgrt.JxW(q));</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>Next we take the inverse of this matrix by using <a class="el" href="classFullMatrix.html#a898466c57e11e6f2599165071ffe5df3">FullMatrix::gauss_jordan()</a>. It will be used to calculate the coefficient matrix \(C^K\) later. It is worth recalling later that <code>cell_matrix_M</code> actually contains the <em>inverse</em> of \(M^K\) after this call.</p>
<div class="fragment"><div class="line">cell_matrix_M.gauss_jordan();</div></div><!-- fragment --><p>From the introduction, we know that the right hand side \(G^K\) of the equation that defines \(C^K\) is the difference between a face integral and a cell integral. Here, we approximate the negative of the contribution in the interior. Each component of this matrix is the integral of a product between a basis function of the polynomial space and the divergence of a basis function of the Raviart-Thomas space. These basis functions are defined in the interior.</p>
<div class="fragment"><div class="line">cell_matrix_G = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> div_v_i =</div><div class="line">        fe_values_dgrt[velocities].divergence(i, q);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_interior =</div><div class="line">            fe_values[pressure_interior].value(j, q);</div><div class="line"></div><div class="line">          cell_matrix_G(i, j) -=</div><div class="line">            (div_v_i * phi_j_interior * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>Next, we approximate the integral on faces by quadrature. Each component is the integral of a product between a basis function of the polynomial space and the dot product of a basis function of the Raviart-Thomas space and the normal vector. So we loop over all the faces of the element and obtain the normal vector.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">  {</div><div class="line">    fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">    fe_face_values_dgrt.reinit(cell_dgrt, face);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal = fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i =</div><div class="line">              fe_face_values_dgrt[velocities].value(i, q);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_face =</div><div class="line">                  fe_face_values[pressure_face].value(j, q);</div><div class="line"></div><div class="line">                cell_matrix_G(i, j) +=</div><div class="line">                  ((v_i * normal) * phi_j_face * fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p><code>cell_matrix_C</code> is then the matrix product between the transpose of \(G^K\) and the inverse of the mass matrix (where this inverse is stored in <code>cell_matrix_M</code>):</p>
<div class="fragment"><div class="line">cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M);</div></div><!-- fragment --><p>Finally we can compute the local matrix \(A^K\). Element \(A^K_{ij}\) is given by \(\int_{E} \sum_{k,l} C_{ik} C_{jl} (\mathbf{K} \mathbf{v}_k) \cdot \mathbf{v}_l \mathrm{d}x\). We have calculated the coefficients \(C\) in the previous step, and so obtain the following after suitably re-arranging the loops:</p>
<div class="fragment"><div class="line">local_matrix = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">          fe_values_dgrt[velocities].value(k, q);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dofs_per_cell_dgrt; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_l =</div><div class="line">              fe_values_dgrt[velocities].value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                local_matrix(i, j) +=</div><div class="line">                  (coefficient_values[q] * cell_matrix_C[i][k] * v_k) *</div><div class="line">                  cell_matrix_C[j][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] * v_l * fe_values_dgrt.JxW(q);</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Next, we calculate the right hand side, \(\int_{K} f q \mathrm{d}x\):</p>
<div class="fragment"><div class="line">cell_rhs = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      cell_rhs(i) += (fe_values[pressure_interior].value(i, q) *</div><div class="line">                      right_hand_side_values[q] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">    }</div></div><!-- fragment --><p>The last step is to distribute components of the local matrix into the system matrix and transfer components of the cell right hand side into the system right hand side:</p>
<div class="fragment"><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      constraints.distribute_local_to_global(</div><div class="line">        local_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationdimsolve"></a> </p><h4>WGDarcyEquation&lt;dim&gt;::solve</h4>
<p>This step is rather trivial and the same as in many previous tutorial programs:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-8 * system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">  solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">  constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationdimcompute_postprocessed_velocity"></a> </p><h4>WGDarcyEquation&lt;dim&gt;::compute_postprocessed_velocity</h4>
<p>In this function, compute the velocity field from the pressure solution previously computed. The velocity is defined as \(\mathbf{u}_h = \mathbf{Q}_h \left( -\mathbf{K}\nabla_{w,d}p_h \right)\), which requires us to compute many of the same terms as in the assembly of the system matrix. There are also the matrices \(E^K,D^K\) we need to assemble (see the introduction) but they really just follow the same kind of pattern.</p>
<p>Computing the same matrices here as we have already done in the <code>assemble_system()</code> function is of course wasteful in terms of CPU time. Likewise, we copy some of the code from there to this function, and this is also generally a poor idea. A better implementation might provide for a function that encapsulates this duplicated code. One could also think of using the classic trade-off between computing efficiency and memory efficiency to only compute the \(C^K\) matrices once per cell during the assembly, storing them somewhere on the side, and re-using them here. (This is what <a class="el" href="step_51.html">step-51</a> does, for example, where the <code>assemble_system()</code> function takes an argument that determines whether the local matrices are recomputed, and a similar approach &ndash; maybe with storing local matrices elsewhere &ndash; could be adapted for the current program.)</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_postprocessed_velocity()</div><div class="line">{</div><div class="line">  darcy_velocity.reinit(dof_handler_dgrt.n_dofs());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_dgrt(fe_dgrt,</div><div class="line">                               quadrature_formula,</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                        face_quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell      = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = fe_face_values.<a class="code" href="classFEFaceValuesBase.html#ab460150cda793c93abfc6eac1314de31">get_quadrature</a>().<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices_dgrt(</div><div class="line">    dofs_per_cell_dgrt);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_D(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_E(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line"></div><div class="line">  Vector&lt;double&gt; cell_solution(dofs_per_cell);</div><div class="line">  Vector&lt;double&gt; cell_velocity(dofs_per_cell_dgrt);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Coefficient&lt;dim&gt;      coefficient;</div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt;&gt; coefficient_values(n_q_points_dgrt);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_interior(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_face(1);</div></div><!-- fragment --><p>In the introduction, we explained how to calculate the numerical velocity on the cell. We need the pressure solution values on each cell, coefficients of the Gram matrix and coefficients of the \(L_2\) projection. We have already calculated the global solution, so we will extract the cell solution from the global solution. The coefficients of the Gram matrix have been calculated when we assembled the system matrix for the pressures. We will do the same way here. For the coefficients of the projection, we do matrix multiplication, i.e., the inverse of the Gram matrix times the matrix with \((\mathbf{K} \mathbf{w}, \mathbf{w})\) as components. Then, we multiply all these coefficients and call them beta. The numerical velocity is the product of beta and the basis functions of the Raviart-Thomas space.</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(), cell_dgrt = dof_handler_dgrt.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell != endc; ++cell, ++cell_dgrt)</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">    fe_values_dgrt.reinit(cell_dgrt);</div><div class="line"></div><div class="line">    coefficient.value_list(fe_values_dgrt.get_quadrature_points(),</div><div class="line">                           coefficient_values);</div></div><!-- fragment --><p>The component of this <code>cell_matrix_E</code> is the integral of \((\mathbf{K} \mathbf{w}, \mathbf{w})\). <code>cell_matrix_M</code> is the Gram matrix.</p>
<div class="fragment"><div class="line">cell_matrix_M = 0;</div><div class="line">cell_matrix_E = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i = fe_values_dgrt[velocities].value(i, q);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">            fe_values_dgrt[velocities].value(k, q);</div><div class="line"></div><div class="line">          cell_matrix_E(i, k) +=</div><div class="line">            (coefficient_values[q] * v_i * v_k * fe_values_dgrt.JxW(q));</div><div class="line"></div><div class="line">          cell_matrix_M(i, k) += (v_i * v_k * fe_values_dgrt.JxW(q));</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>To compute the matrix \(D\) mentioned in the introduction, we then need to evaluate \(D=M^{-1}E\) as explained in the introduction:</p>
<div class="fragment"><div class="line">cell_matrix_M.gauss_jordan();</div><div class="line">cell_matrix_M.mmult(cell_matrix_D, cell_matrix_E);</div></div><!-- fragment --><p>Then we also need, again, to compute the matrix \(C\) that is used to evaluate the weak discrete gradient. This is the exact same code as used in the assembly of the system matrix, so we just copy it from there:</p>
<div class="fragment"><div class="line">cell_matrix_G = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> div_v_i =</div><div class="line">        fe_values_dgrt[velocities].divergence(i, q);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_interior =</div><div class="line">            fe_values[pressure_interior].value(j, q);</div><div class="line"></div><div class="line">          cell_matrix_G(i, j) -=</div><div class="line">            (div_v_i * phi_j_interior * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">  {</div><div class="line">    fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">    fe_face_values_dgrt.reinit(cell_dgrt, face);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal = fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i =</div><div class="line">              fe_face_values_dgrt[velocities].value(i, q);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_face =</div><div class="line">                  fe_face_values[pressure_face].value(j, q);</div><div class="line"></div><div class="line">                cell_matrix_G(i, j) +=</div><div class="line">                  ((v_i * normal) * phi_j_face * fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line">cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M);</div></div><!-- fragment --><p>Finally, we need to extract the pressure unknowns that correspond to the current cell:</p>
<div class="fragment"><div class="line">cell-&gt;get_dof_values(solution, cell_solution);</div></div><!-- fragment --><p>We are now in a position to compute the local velocity unknowns (with respect to the Raviart-Thomas space we are projecting the term \(-\mathbf K \nabla_{w,d} p_h\) into):</p>
<div class="fragment"><div class="line">cell_velocity = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell_dgrt; ++j)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      cell_velocity(k) +=</div><div class="line">        -(cell_solution(i) * cell_matrix_C(i, j) * cell_matrix_D(k, j));</div></div><!-- fragment --><p>We compute Darcy velocity. This is same as cell_velocity but used to graph Darcy velocity.</p>
<div class="fragment"><div class="line">      cell_dgrt-&gt;get_dof_indices(local_dof_indices_dgrt);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell_dgrt; ++j)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            darcy_velocity(local_dof_indices_dgrt[k]) +=</div><div class="line">              -(cell_solution(i) * cell_matrix_C(i, j) * cell_matrix_D(k, j));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationdimcompute_pressure_error"></a> </p><h4>WGDarcyEquation&lt;dim&gt;::compute_pressure_error</h4>
<p>This part is to calculate the \(L_2\) error of the pressure. We define a vector that holds the norm of the error on each cell. Next, we use <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTool::integrate_difference()</a> to compute the error in the \(L_2\) norm on each cell. However, we really only care about the error in the interior component of the solution vector (we can't even evaluate the interface pressures at the quadrature points because these are all located in the interior of cells) and consequently have to use a weight function that ensures that the interface component of the solution variable is ignored. This is done by using the <a class="el" href="classComponentSelectFunction.html">ComponentSelectFunction</a> whose arguments indicate which component we want to select (component zero, i.e., the interior pressures) and how many components there are in total (two).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_pressure_error()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> select_interior_pressure(0, 2);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler,</div><div class="line">                                    solution,</div><div class="line">                                    ExactPressure&lt;dim&gt;(),</div><div class="line">                                    difference_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                    &amp;select_interior_pressure);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> L2_error = difference_per_cell.l2_norm();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;L2_error_pressure &quot;</span> &lt;&lt; L2_error &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationdimcompute_velocity_error"></a> </p><h4>WGDarcyEquation&lt;dim&gt;::compute_velocity_error</h4>
<p>In this function, we evaluate \(L_2\) errors for the velocity on each cell, and \(L_2\) errors for the flux on faces. The function relies on the <code>compute_postprocessed_velocity()</code> function having previous computed, which computes the velocity field based on the pressure solution that has previously been computed.</p>
<p>We are going to evaluate velocities on each cell and calculate the difference between numerical and exact velocities.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_velocity_errors()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_dgrt(fe_dgrt,</div><div class="line">                               quadrature_formula,</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                        face_quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points_dgrt =</div><div class="line">    fe_face_values_dgrt.get_quadrature().size();</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points_dgrt);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_face_values(n_face_q_points_dgrt);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ExactVelocity&lt;dim&gt; exact_velocity;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> L2_err_velocity_cell_sqr_global = 0;</div><div class="line">  <span class="keywordtype">double</span> L2_err_flux_sqr                 = 0;</div></div><!-- fragment --><p>Having previously computed the postprocessed velocity, we here only have to extract the corresponding values on each cell and face and compare it to the exact values.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell_dgrt : dof_handler_dgrt.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    fe_values_dgrt.reinit(cell_dgrt);</div></div><!-- fragment --><p>First compute the \(L_2\) error between the postprocessed velocity field and the exact one:</p>
<div class="fragment"><div class="line">fe_values_dgrt[velocities].get_function_values(darcy_velocity,</div><div class="line">                                               velocity_values);</div><div class="line"><span class="keywordtype">double</span> L2_err_velocity_cell_sqr_local = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity = velocity_values[q];</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> true_velocity =</div><div class="line">      exact_velocity.value(fe_values_dgrt.quadrature_point(q));</div><div class="line"></div><div class="line">    L2_err_velocity_cell_sqr_local +=</div><div class="line">      ((velocity - true_velocity) * (velocity - true_velocity) *</div><div class="line">       fe_values_dgrt.JxW(q));</div><div class="line">  }</div><div class="line">L2_err_velocity_cell_sqr_global += L2_err_velocity_cell_sqr_local;</div></div><!-- fragment --><p>For reconstructing the flux we need the size of cells and faces. Since fluxes are calculated on faces, we have the loop over all four faces of each cell. To calculate the face velocity, we extract values at the quadrature points from the <code>darcy_velocity</code> which we have computed previously. Then, we calculate the squared velocity error in normal direction. Finally, we calculate the \(L_2\) flux error on the cell by appropriately scaling with face and cell areas and add it to the global error.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> cell_area = cell_dgrt-&gt;measure();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face_dgrt : cell_dgrt-&gt;face_iterators())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> face_length = face_dgrt-&gt;measure();</div><div class="line">      fe_face_values_dgrt.reinit(cell_dgrt, face_dgrt);</div><div class="line">      fe_face_values_dgrt[velocities].get_function_values(</div><div class="line">        darcy_velocity, velocity_face_values);</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> L2_err_flux_face_sqr_local = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points_dgrt; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity = velocity_face_values[q];</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> true_velocity =</div><div class="line">            exact_velocity.value(fe_face_values_dgrt.quadrature_point(q));</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal =</div><div class="line">            fe_face_values_dgrt.normal_vector(q);</div><div class="line"></div><div class="line">          L2_err_flux_face_sqr_local +=</div><div class="line">            ((velocity * normal - true_velocity * normal) *</div><div class="line">             (velocity * normal - true_velocity * normal) *</div><div class="line">             fe_face_values_dgrt.JxW(q));</div><div class="line">        }</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> err_flux_each_face =</div><div class="line">        L2_err_flux_face_sqr_local / face_length * cell_area;</div><div class="line">      L2_err_flux_sqr += err_flux_each_face;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>After adding up errors over all cells and faces, we take the square root and get the \(L_2\) errors of velocity and flux. These we output to screen.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> L2_err_velocity_cell =</div><div class="line">    <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(L2_err_velocity_cell_sqr_global);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> L2_err_flux_face = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(L2_err_flux_sqr);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;L2_error_vel:  &quot;</span> &lt;&lt; L2_err_velocity_cell &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;L2_error_flux: &quot;</span> &lt;&lt; L2_err_flux_face &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationoutput_results"></a> </p><h4>WGDarcyEquation::output_results</h4>
<p>We have two sets of results to output: the interior solution and the skeleton solution. We use <code><a class="el" href="classDataOut.html">DataOut</a></code> to visualize interior results. The graphical output for the skeleton results is done by using the <a class="el" href="classDataOutFaces.html">DataOutFaces</a> class.</p>
<p>In both of the output files, both the interior and the face variables are stored. For the interface output, the output file simply contains the interpolation of the interior pressures onto the faces, but because it is undefined which of the two interior pressure variables you get from the two adjacent cells, it is best to ignore the interior pressure in the interface output file. Conversely, for the cell interior output file, it is of course impossible to show any interface pressures \(p^\partial\), because these are only available on interfaces and not cell interiors. Consequently, you will see them shown as an invalid value (such as an infinity).</p>
<p>For the cell interior output, we also want to output the velocity variables. This is a bit tricky since it lives on the same mesh but uses a different <a class="el" href="classDoFHandler.html">DoFHandler</a> object (the pressure variables live on the <code>dof_handler</code> object, the Darcy velocity on the <code>dof_handler_dgrt</code> object). Fortunately, there are variations of the <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector()</a> function that allow specifying which <a class="el" href="classDoFHandler.html">DoFHandler</a> a vector corresponds to, and consequently we can visualize the data from both <a class="el" href="classDoFHandler.html">DoFHandler</a> objects within the same file.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  {</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div></div><!-- fragment --><p>First attach the pressure solution to the <a class="el" href="classDataOut.html">DataOut</a> object:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::string&gt; solution_names = {<span class="stringliteral">&quot;interior_pressure&quot;</span>,</div><div class="line">                                                 <span class="stringliteral">&quot;interface_pressure&quot;</span>};</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler, solution, solution_names);</div></div><!-- fragment --><p>Then do the same with the Darcy velocity field, and continue with writing everything out into a file.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> std::vector&lt;std::string&gt; velocity_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    <span class="keyword">const</span> std::vector&lt;</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;</div><div class="line">      velocity_component_interpretation(</div><div class="line">        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_dgrt,</div><div class="line">                             darcy_velocity,</div><div class="line">                             velocity_names,</div><div class="line">                             velocity_component_interpretation);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution_interior.vtu&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classDataOutFaces.html">DataOutFaces&lt;dim&gt;</a> data_out_faces(<span class="keyword">false</span>);</div><div class="line">    data_out_faces.attach_dof_handler(dof_handler);</div><div class="line">    data_out_faces.add_data_vector(solution, <span class="stringliteral">&quot;Pressure_Face&quot;</span>);</div><div class="line">    data_out_faces.build_patches(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    std::ofstream face_output(<span class="stringliteral">&quot;solution_interface.vtu&quot;</span>);</div><div class="line">    data_out_faces.write_vtu(face_output);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationrun"></a> </p><h4>WGDarcyEquation::run</h4>
<p>This is the final function of the main class. It calls the other functions of our class.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WGDarcyEquation&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Solving problem in &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot; space dimensions.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    compute_postprocessed_velocity();</div><div class="line">    compute_pressure_error();</div><div class="line">    compute_velocity_errors();</div><div class="line">    output_results();</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace Step61</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>This is the main function. We can change the dimension here to run in 3d.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step61::WGDarcyEquation&lt;2&gt; wg_darcy(0);</div><div class="line">      wg_darcy.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>We run the program with a right hand side that will produce the solution \(p = \sin(\pi x) \sin(\pi y)\) and with homogeneous Dirichlet boundary conditions in the domain \(\Omega = (0,1)^2\). In addition, we choose the coefficient matrix in the differential operator \(\mathbf{K}\) as the identity matrix. We test this setup using \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\), \(\mbox{WG}(Q_1,Q_1;RT_{[1]})\) and \(\mbox{WG}(Q_2,Q_2;RT_{[2]})\) element combinations, which one can select by using the appropriate constructor argument for the <code>WGDarcyEquation</code> object in <code>main()</code>. We will then visualize pressure values in interiors of cells and on faces. We want to see that the pressure maximum is around 1 and the minimum is around 0. With mesh refinement, the convergence rates of pressure, velocity and flux should then be around 1 for \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) , 2 for \(\mbox{WG}(Q_1,Q_1;RT_{[1]})\), and 3 for \(\mbox{WG}(Q_2,Q_2;RT_{[2]})\).</p>
<p><a class="anchor" id="TestresultsoniWGQsub0subQsub0subRTsub0subi"></a></p><h3>Test results on <em>WG(Q<sub>0</sub>,Q<sub>0</sub>;RT<sub>[0]</sub>)</em></h3>
<p>The following figures show interior pressures and face pressures using the \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) element. The mesh is refined 2 times (top) and 4 times (bottom), respectively. (This number can be adjusted in the <code>make_grid()</code> function.) When the mesh is coarse, one can see the face pressures \(p^\partial\) neatly between the values of the interior pressures \(p^\circ\) on the two adjacent cells.</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg000_2d_2.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg000_3d_2.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg000_2d_4.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg000_3d_4.png"/>
</div>
  </td></tr>
</table>
<p>From the figures, we can see that with the mesh refinement, the maximum and minimum pressure values are approaching the values we expect. Since the mesh is a rectangular mesh and numbers of cells in each direction is even, we have symmetric solutions. From the 3d figures on the right, we can see that on \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\), the pressure is a constant in the interior of the cell, as expected.</p>
<p><a class="anchor" id="Convergencetableforik0i"></a></p><h4>Convergence table for <em>k=0</em></h4>
<p>We run the code with differently refined meshes (chosen in the <code>make_grid()</code> function) and get the following convergence rates of pressure, velocity, and flux (as defined in the introduction).</p>
<table align="center" class="doxtable">
<tr>
<th>number of refinements </th><th>\(\|p-p_h^\circ\|\) </th><th>\(\|\mathbf{u}-\mathbf{u}_h\|\) </th><th>\(\|(\mathbf{u}-\mathbf{u}_h) \cdot \mathbf{n}\|\)   </th></tr>
<tr>
<td>2 </td><td>1.587e-01 </td><td>5.113e-01 </td><td>7.062e-01   </td></tr>
<tr>
<td>3 </td><td>8.000e-02 </td><td>2.529e-01 </td><td>3.554e-01   </td></tr>
<tr>
<td>4 </td><td>4.006e-02 </td><td>1.260e-01 </td><td>1.780e-01   </td></tr>
<tr>
<td>5 </td><td>2.004e-02 </td><td>6.297e-02 </td><td>8.902e-02   </td></tr>
<tr>
<th>Conv.rate </th><th>1.00 </th><th>1.00 </th><th>1.00   </th></tr>
</table>
<p>We can see that the convergence rates of \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) are around 1. This, of course, matches our theoretical expectations.</p>
<p><a class="anchor" id="TestresultsoniWGQsub1subQsub1subRTsub1subi"></a></p><h3>Test results on <em>WG(Q<sub>1</sub>,Q<sub>1</sub>;RT<sub>[1]</sub>)</em></h3>
<p>We can repeat the experiment from above using the next higher polynomial degree: The following figures are interior pressures and face pressures implemented using \(\mbox{WG}(Q_1,Q_1;RT_{[1]})\). The mesh is refined 4 times. Compared to the previous figures using \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\), on each cell, the solution is no longer constant on each cell, as we now use bilinear polynomials to do the approximation. Consequently, there are 4 pressure values in one interior, 2 pressure values on each face.</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg111_2d_4.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg111_3d_4.png"/>
</div>
  </td></tr>
</table>
<p>Compared to the corresponding image for the \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) combination, the solution is now substantially more accurate and, in particular so close to being continuous at the interfaces that we can no longer distinguish the interface pressures \(p^\partial\) from the interior pressures \(p^\circ\) on the adjacent cells.</p>
<p><a class="anchor" id="Convergencetableforik1i"></a></p><h4>Convergence table for <em>k=1</em></h4>
<p>The following are the convergence rates of pressure, velocity, and flux we obtain from using the \(\mbox{WG}(Q_1,Q_1;RT_{[1]})\) element combination:</p>
<table align="center" class="doxtable">
<tr>
<th>number of refinements </th><th>\(\|p-p_h^\circ\|\) </th><th>\(\|\mathbf{u}-\mathbf{u}_h\|\) </th><th>\(\|(\mathbf{u}-\mathbf{u}_h) \cdot \mathbf{n}\|\)   </th></tr>
<tr>
<td>2 </td><td>1.613e-02 </td><td>5.093e-02 </td><td>7.167e-02   </td></tr>
<tr>
<td>3 </td><td>4.056e-03 </td><td>1.276e-02 </td><td>1.802e-02   </td></tr>
<tr>
<td>4 </td><td>1.015e-03 </td><td>3.191e-03 </td><td>4.512e-03   </td></tr>
<tr>
<td>5 </td><td>2.540e-04 </td><td>7.979e-04 </td><td>1.128e-03   </td></tr>
<tr>
<th>Conv.rate </th><th>2.00 </th><th>2.00 </th><th>2.00   </th></tr>
</table>
<p>The convergence rates of \(WG(Q_1,Q_1;RT_{[1]})\) are around 2, as expected.</p>
<p><a class="anchor" id="TestresultsoniWGQsub2subQsub2subRTsub2subi"></a></p><h3>Test results on <em>WG(Q<sub>2</sub>,Q<sub>2</sub>;RT<sub>[2]</sub>)</em></h3>
<p>Let us go one polynomial degree higher. The following are interior pressures and face pressures implemented using \(WG(Q_2,Q_2;RT_{[2]})\), with mesh size \(h = 1/32\) (i.e., 5 global mesh refinement steps). In the program, we use <code>data_out_face.build_patches(fe.degree)</code> when generating graphical output (see the documentation of <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>), which here implies that we divide each 2d cell interior into 4 subcells in order to provide a better visualization of the quadratic polynomials. </p><table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg222_2d_5.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg222_3d_5.png"/>
</div>
  </td></tr>
</table>
<p><a class="anchor" id="Convergencetableforik2i"></a></p><h4>Convergence table for <em>k=2</em></h4>
<p>As before, we can generate convergence data for the \(L_2\) errors of pressure, velocity, and flux using the \(\mbox{WG}(Q_2,Q_2;RT_{[2]})\) combination:</p>
<table align="center" class="doxtable">
<tr>
<th>number of refinements </th><th>\(\|p-p_h^\circ\|\) </th><th>\(\|\mathbf{u}-\mathbf{u}_h\|\) </th><th>\(\|(\mathbf{u}-\mathbf{u}_h) \cdot \mathbf{n}\|\)   </th></tr>
<tr>
<td>2 </td><td>1.072e-03 </td><td>3.375e-03 </td><td>4.762e-03   </td></tr>
<tr>
<td>3 </td><td>1.347e-04 </td><td>4.233e-04 </td><td>5.982e-04   </td></tr>
<tr>
<td>4 </td><td>1.685e-05 </td><td>5.295e-05 </td><td>7.487e-05   </td></tr>
<tr>
<td>5 </td><td>2.107e-06 </td><td>6.620e-06 </td><td>9.362e-06   </td></tr>
<tr>
<th>Conv.rate </th><th>3.00 </th><th>3.00 </th><th>3.00   </th></tr>
</table>
<p>Once more, the convergence rates of \(\mbox{WG}(Q_2,Q_2;RT_{[2]})\) is as expected, with values around 3.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2018 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *      Author: Zhuoran Wang, Colorado State University, 2018</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2quadrature_8h.html">deal.II/base/quadrature.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2point_8h.html">deal.II/base/point.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__raviart__thomas_8h.html">deal.II/fe/fe_raviart_thomas.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dg__vector_8h.html">deal.II/fe/fe_dg_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__face_8h.html">deal.II/fe/fe_face.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="component__mask_8h.html">deal.II/fe/component_mask.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="data__out__faces_8h.html">deal.II/numerics/data_out_faces.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step61</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>WGDarcyEquation</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    WGDarcyEquation(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> compute_postprocessed_velocity();</div><div class="line">    <span class="keywordtype">void</span> compute_velocity_errors();</div><div class="line">    <span class="keywordtype">void</span> compute_pressure_error();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>   fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classFE__DGRaviartThomas.html">FE_DGRaviartThomas&lt;dim&gt;</a> fe_dgrt;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>         dof_handler_dgrt;</div><div class="line">    Vector&lt;double&gt;          darcy_velocity;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Coefficient()</div><div class="line">      : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                            std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;values) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Coefficient&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                    std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">      values[p] = unit_symmetric_tensor&lt;dim&gt;();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (2 * numbers::PI * numbers::PI * std::sin(numbers::PI * p[0]) *</div><div class="line">            std::sin(numbers::PI * p[1]));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ExactPressure : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ExactPressure()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> ExactPressure&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[0]) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[1]);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ExactVelocity : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ExactVelocity()</div><div class="line">      : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ExactVelocity&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> return_value;</div><div class="line">    return_value[0] = -numbers::PI * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI * p[0]) *</div><div class="line">                      <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[1]);</div><div class="line">    return_value[1] = -numbers::PI * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[0]) *</div><div class="line">                      <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI * p[1]);</div><div class="line">    <span class="keywordflow">return</span> return_value;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  WGDarcyEquation&lt;dim&gt;::WGDarcyEquation(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1, <a class="code" href="classFE__FaceQ.html">FE_FaceQ</a>&lt;dim&gt;(degree), 1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , fe_dgrt(degree)</div><div class="line">    , dof_handler_dgrt(triangulation)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(5);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    dof_handler_dgrt.distribute_dofs(fe_dgrt);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of pressure degrees of freedom: &quot;</span></div><div class="line">              &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line"></div><div class="line">    {</div><div class="line">      constraints.clear();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> interface_pressure(1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a>              interface_pressure_mask =</div><div class="line">        fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(interface_pressure);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               0,</div><div class="line">                                               BoundaryValues&lt;dim&gt;(),</div><div class="line">                                               constraints,</div><div class="line">                                               interface_pressure_mask);</div><div class="line">      constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values_dgrt(fe_dgrt,</div><div class="line">                                 quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                          face_quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell      = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = fe_face_values.<a class="code" href="classFEFaceValuesBase.html#ab460150cda793c93abfc6eac1314de31">get_quadrature</a>().<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    RightHandSide&lt;dim&gt;  right_hand_side;</div><div class="line">    std::vector&lt;double&gt; right_hand_side_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Coefficient&lt;dim&gt;      coefficient;</div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; coefficient_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_solution(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_interior(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_face(1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell_dgrt =</div><div class="line">          cell;</div><div class="line">        fe_values_dgrt.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(cell_dgrt);</div><div class="line"></div><div class="line">        right_hand_side.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                   right_hand_side_values);</div><div class="line">        coefficient.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                               coefficient_values);</div><div class="line"></div><div class="line">        cell_matrix_M = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i = fe_values_dgrt[velocities].value(i, q);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">                    fe_values_dgrt[velocities].value(k, q);</div><div class="line">                  cell_matrix_M(i, k) += (v_i * v_k * fe_values_dgrt.JxW(q));</div><div class="line">                }</div><div class="line">            }</div><div class="line">        cell_matrix_M.gauss_jordan();</div><div class="line"></div><div class="line">        cell_matrix_G = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> div_v_i =</div><div class="line">                fe_values_dgrt[velocities].divergence(i, q);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_interior =</div><div class="line">                    fe_values[pressure_interior].value(j, q);</div><div class="line"></div><div class="line">                  cell_matrix_G(i, j) -=</div><div class="line">                    (div_v_i * phi_j_interior * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">            fe_face_values_dgrt.reinit(cell_dgrt, face);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal = fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i =</div><div class="line">                      fe_face_values_dgrt[velocities].value(i, q);</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_face =</div><div class="line">                          fe_face_values[pressure_face].value(j, q);</div><div class="line"></div><div class="line">                        cell_matrix_G(i, j) +=</div><div class="line">                          ((v_i * normal) * phi_j_face * fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M);</div><div class="line"></div><div class="line">        local_matrix = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">                  fe_values_dgrt[velocities].value(k, q);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dofs_per_cell_dgrt; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_l =</div><div class="line">                      fe_values_dgrt[velocities].value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q);</div><div class="line"></div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                        local_matrix(i, j) +=</div><div class="line">                          (coefficient_values[q] * cell_matrix_C[i][k] * v_k) *</div><div class="line">                          cell_matrix_C[j][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] * v_l * fe_values_dgrt.JxW(q);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell_rhs = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              cell_rhs(i) += (fe_values[pressure_interior].value(i, q) *</div><div class="line">                              right_hand_side_values[q] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.distribute_local_to_global(</div><div class="line">          local_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-8 * system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">    solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">    constraints.distribute(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_postprocessed_velocity()</div><div class="line">  {</div><div class="line">    darcy_velocity.reinit(dof_handler_dgrt.n_dofs());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_dgrt(fe_dgrt,</div><div class="line">                                 quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                          face_quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell      = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = fe_face_values.<a class="code" href="classFEFaceValuesBase.html#ab460150cda793c93abfc6eac1314de31">get_quadrature</a>().<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices_dgrt(</div><div class="line">      dofs_per_cell_dgrt);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_D(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_E(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; cell_solution(dofs_per_cell);</div><div class="line">    Vector&lt;double&gt; cell_velocity(dofs_per_cell_dgrt);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Coefficient&lt;dim&gt;      coefficient;</div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; coefficient_values(n_q_points_dgrt);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_interior(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_face(1);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">      cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">      endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(), cell_dgrt = dof_handler_dgrt.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++cell_dgrt)</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values_dgrt.reinit(cell_dgrt);</div><div class="line"></div><div class="line">        coefficient.value_list(fe_values_dgrt.get_quadrature_points(),</div><div class="line">                               coefficient_values);</div><div class="line"></div><div class="line">        cell_matrix_M = 0;</div><div class="line">        cell_matrix_E = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i = fe_values_dgrt[velocities].value(i, q);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">                    fe_values_dgrt[velocities].value(k, q);</div><div class="line"></div><div class="line">                  cell_matrix_E(i, k) +=</div><div class="line">                    (coefficient_values[q] * v_i * v_k * fe_values_dgrt.JxW(q));</div><div class="line"></div><div class="line">                  cell_matrix_M(i, k) += (v_i * v_k * fe_values_dgrt.JxW(q));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        cell_matrix_M.gauss_jordan();</div><div class="line">        cell_matrix_M.mmult(cell_matrix_D, cell_matrix_E);</div><div class="line"></div><div class="line">        cell_matrix_G = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> div_v_i =</div><div class="line">                fe_values_dgrt[velocities].divergence(i, q);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_interior =</div><div class="line">                    fe_values[pressure_interior].value(j, q);</div><div class="line"></div><div class="line">                  cell_matrix_G(i, j) -=</div><div class="line">                    (div_v_i * phi_j_interior * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">            fe_face_values_dgrt.reinit(cell_dgrt, face);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal = fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i =</div><div class="line">                      fe_face_values_dgrt[velocities].value(i, q);</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_face =</div><div class="line">                          fe_face_values[pressure_face].value(j, q);</div><div class="line"></div><div class="line">                        cell_matrix_G(i, j) +=</div><div class="line">                          ((v_i * normal) * phi_j_face * fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">        cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M);</div><div class="line"></div><div class="line">        cell-&gt;get_dof_values(solution, cell_solution);</div><div class="line"></div><div class="line">        cell_velocity = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell_dgrt; ++j)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              cell_velocity(k) +=</div><div class="line">                -(cell_solution(i) * cell_matrix_C(i, j) * cell_matrix_D(k, j));</div><div class="line"></div><div class="line">        cell_dgrt-&gt;get_dof_indices(local_dof_indices_dgrt);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell_dgrt; ++j)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              darcy_velocity(local_dof_indices_dgrt[k]) +=</div><div class="line">                -(cell_solution(i) * cell_matrix_C(i, j) * cell_matrix_D(k, j));</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_pressure_error()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> select_interior_pressure(0, 2);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler,</div><div class="line">                                      solution,</div><div class="line">                                      ExactPressure&lt;dim&gt;(),</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                      &amp;select_interior_pressure);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> L2_error = difference_per_cell.l2_norm();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;L2_error_pressure &quot;</span> &lt;&lt; L2_error &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_velocity_errors()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_dgrt(fe_dgrt,</div><div class="line">                                 quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                          face_quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points_dgrt =</div><div class="line">      fe_face_values_dgrt.get_quadrature().size();</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points_dgrt);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_face_values(n_face_q_points_dgrt);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ExactVelocity&lt;dim&gt; exact_velocity;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> L2_err_velocity_cell_sqr_global = 0;</div><div class="line">    <span class="keywordtype">double</span> L2_err_flux_sqr                 = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell_dgrt : dof_handler_dgrt.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values_dgrt.reinit(cell_dgrt);</div><div class="line"></div><div class="line">        fe_values_dgrt[velocities].get_function_values(darcy_velocity,</div><div class="line">                                                       velocity_values);</div><div class="line">        <span class="keywordtype">double</span> L2_err_velocity_cell_sqr_local = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity = velocity_values[q];</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> true_velocity =</div><div class="line">              exact_velocity.value(fe_values_dgrt.quadrature_point(q));</div><div class="line"></div><div class="line">            L2_err_velocity_cell_sqr_local +=</div><div class="line">              ((velocity - true_velocity) * (velocity - true_velocity) *</div><div class="line">               fe_values_dgrt.JxW(q));</div><div class="line">          }</div><div class="line">        L2_err_velocity_cell_sqr_global += L2_err_velocity_cell_sqr_local;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> cell_area = cell_dgrt-&gt;measure();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face_dgrt : cell_dgrt-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> face_length = face_dgrt-&gt;measure();</div><div class="line">            fe_face_values_dgrt.reinit(cell_dgrt, face_dgrt);</div><div class="line">            fe_face_values_dgrt[velocities].get_function_values(</div><div class="line">              darcy_velocity, velocity_face_values);</div><div class="line"></div><div class="line">            <span class="keywordtype">double</span> L2_err_flux_face_sqr_local = 0;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points_dgrt; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity = velocity_face_values[q];</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> true_velocity =</div><div class="line">                  exact_velocity.value(fe_face_values_dgrt.quadrature_point(q));</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal =</div><div class="line">                  fe_face_values_dgrt.normal_vector(q);</div><div class="line"></div><div class="line">                L2_err_flux_face_sqr_local +=</div><div class="line">                  ((velocity * normal - true_velocity * normal) *</div><div class="line">                   (velocity * normal - true_velocity * normal) *</div><div class="line">                   fe_face_values_dgrt.JxW(q));</div><div class="line">              }</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> err_flux_each_face =</div><div class="line">              L2_err_flux_face_sqr_local / face_length * cell_area;</div><div class="line">            L2_err_flux_sqr += err_flux_each_face;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> L2_err_velocity_cell =</div><div class="line">      <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(L2_err_velocity_cell_sqr_global);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> L2_err_flux_face = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(L2_err_flux_sqr);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;L2_error_vel:  &quot;</span> &lt;&lt; L2_err_velocity_cell &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;L2_error_flux: &quot;</span> &lt;&lt; L2_err_flux_face &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    {</div><div class="line">      <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt; solution_names = {<span class="stringliteral">&quot;interior_pressure&quot;</span>,</div><div class="line">                                                       <span class="stringliteral">&quot;interface_pressure&quot;</span>};</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler, solution, solution_names);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt; velocity_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">      <span class="keyword">const</span> std::vector&lt;</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;</div><div class="line">        velocity_component_interpretation(</div><div class="line">          dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_dgrt,</div><div class="line">                               darcy_velocity,</div><div class="line">                               velocity_names,</div><div class="line">                               velocity_component_interpretation);</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">      std::ofstream output(<span class="stringliteral">&quot;solution_interior.vtu&quot;</span>);</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classDataOutFaces.html">DataOutFaces&lt;dim&gt;</a> data_out_faces(<span class="keyword">false</span>);</div><div class="line">      data_out_faces.attach_dof_handler(dof_handler);</div><div class="line">      data_out_faces.add_data_vector(solution, <span class="stringliteral">&quot;Pressure_Face&quot;</span>);</div><div class="line">      data_out_faces.build_patches(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">      std::ofstream face_output(<span class="stringliteral">&quot;solution_interface.vtu&quot;</span>);</div><div class="line">      data_out_faces.write_vtu(face_output);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WGDarcyEquation&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Solving problem in &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot; space dimensions.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    compute_postprocessed_velocity();</div><div class="line">    compute_pressure_error();</div><div class="line">    compute_velocity_errors();</div><div class="line">    output_results();</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace Step61</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step61::WGDarcyEquation&lt;2&gt; wg_darcy(0);</div><div class="line">      wg_darcy.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_51.html">step-51</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#WeakGalerkinfiniteelementmethods"> Weak Galerkin finite element methods </a><a href="#WeakGalerkinfiniteelementmethods"> Weak Galerkin finite element methods </a>
        <li><a href="#Theequationtosolve"> The equation to solve </a><a href="#Theequationtosolve"> The equation to solve </a>
        <li><a href="#WeakGalerkinscheme"> Weak Galerkin scheme </a><a href="#WeakGalerkinscheme"> Weak Galerkin scheme </a>
        <li><a href="#Representingtheweakgradient"> Representing the weak gradient </a><a href="#Representingtheweakgradient"> Representing the weak gradient </a>
        <li><a href="#Assemblingthelinearsystem"> Assembling the linear system </a><a href="#Assemblingthelinearsystem"> Assembling the linear system </a>
        <li><a href="#PostprocessingandiLsub2subierrors"> Post-processing and <i>L<sub>2</sub></i><a href="#PostprocessingandiLsub2subierrors"> Post-processing and <i>L<sub>2</sub></i>-errors </a><i>L<sub>2</sub></i>-errors </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#TheWGDarcyEquationclasstemplate">The WGDarcyEquation class template</a><a href="#TheWGDarcyEquationclasstemplate">The WGDarcyEquation class template</a>
        <li><a href="#Righthandsideboundaryvaluesandexactsolution">Right hand side, boundary values, and exact solution</a><a href="#Righthandsideboundaryvaluesandexactsolution">Right hand side, boundary values, and exact solution</a>
        <li><a href="#WGDarcyEquationclassimplementation">WGDarcyEquation class implementation</a><a href="#WGDarcyEquationclassimplementation">WGDarcyEquation class implementation</a>
      <ul>
        <li><a href="#WGDarcyEquationWGDarcyEquation">WGDarcyEquation::WGDarcyEquation</a><a href="#WGDarcyEquationWGDarcyEquation">WGDarcyEquation::WGDarcyEquation</a>
        <li><a href="#WGDarcyEquationmake_grid">WGDarcyEquation::make_grid</a><a href="#WGDarcyEquationmake_grid">WGDarcyEquation::make_grid</a>
        <li><a href="#WGDarcyEquationsetup_system">WGDarcyEquation::setup_system</a><a href="#WGDarcyEquationsetup_system">WGDarcyEquation::setup_system</a>
        <li><a href="#WGDarcyEquationassemble_system">WGDarcyEquation::assemble_system</a><a href="#WGDarcyEquationassemble_system">WGDarcyEquation::assemble_system</a>
        <li><a href="#WGDarcyEquationdimsolve">WGDarcyEquation<dim>::solve</a><a href="#WGDarcyEquationdimsolve">WGDarcyEquation<dim>::solve</a>
        <li><a href="#WGDarcyEquationdimcompute_postprocessed_velocity">WGDarcyEquation<dim>::compute_postprocessed_velocity</a><a href="#WGDarcyEquationdimcompute_postprocessed_velocity">WGDarcyEquation<dim>::compute_postprocessed_velocity</a>
        <li><a href="#WGDarcyEquationdimcompute_pressure_error">WGDarcyEquation<dim>::compute_pressure_error</a><a href="#WGDarcyEquationdimcompute_pressure_error">WGDarcyEquation<dim>::compute_pressure_error</a>
        <li><a href="#WGDarcyEquationdimcompute_velocity_error">WGDarcyEquation<dim>::compute_velocity_error</a><a href="#WGDarcyEquationdimcompute_velocity_error">WGDarcyEquation<dim>::compute_velocity_error</a>
        <li><a href="#WGDarcyEquationoutput_results">WGDarcyEquation::output_results</a><a href="#WGDarcyEquationoutput_results">WGDarcyEquation::output_results</a>
        <li><a href="#WGDarcyEquationrun">WGDarcyEquation::run</a><a href="#WGDarcyEquationrun">WGDarcyEquation::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#TestresultsoniWGQsub0subQsub0subRTsub0subi">Test results on <i>WG(Q<sub>0</sub>,Q<sub>0</sub>;RT<sub>[0]</sub>)</i><a href="#TestresultsoniWGQsub0subQsub0subRTsub0subi">Test results on <i>WG(Q<sub>0</sub>,Q<sub>0</sub>;RT<sub>[0]</sub>)</i></a><i>WG(Q<sub>0</sub>,Q<sub>0</sub>;RT<sub>[0]</sub>)</i></a>
      <ul>
        <li><a href="#Convergencetableforik0i">Convergence table for <i>k=0</i><a href="#Convergencetableforik0i">Convergence table for <i>k=0</i></a><i>k=0</i></a>
      </ul>
        <li><a href="#TestresultsoniWGQsub1subQsub1subRTsub1subi">Test results on <i>WG(Q<sub>1</sub>,Q<sub>1</sub>;RT<sub>[1]</sub>)</i><a href="#TestresultsoniWGQsub1subQsub1subRTsub1subi">Test results on <i>WG(Q<sub>1</sub>,Q<sub>1</sub>;RT<sub>[1]</sub>)</i></a><i>WG(Q<sub>1</sub>,Q<sub>1</sub>;RT<sub>[1]</sub>)</i></a>
      <ul>
        <li><a href="#Convergencetableforik1i">Convergence table for <i>k=1</i><a href="#Convergencetableforik1i">Convergence table for <i>k=1</i></a><i>k=1</i></a>
      </ul>
        <li><a href="#TestresultsoniWGQsub2subQsub2subRTsub2subi">Test results on <i>WG(Q<sub>2</sub>,Q<sub>2</sub>;RT<sub>[2]</sub>)</i><a href="#TestresultsoniWGQsub2subQsub2subRTsub2subi">Test results on <i>WG(Q<sub>2</sub>,Q<sub>2</sub>;RT<sub>[2]</sub>)</i></a><i>WG(Q<sub>2</sub>,Q<sub>2</sub>;RT<sub>[2]</sub>)</i></a>
      <ul>
        <li><a href="#Convergencetableforik2i">Convergence table for <i>k=2</i><a href="#Convergencetableforik2i">Convergence table for <i>k=2</i></a><i>k=2</i></a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
 <em> This program was contributed by Zhuoran Wang. Some more information about this program, as well as more numerical results, are presented in <b>[Wang2019]</b> . </em> <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This tutorial program presents an implementation of the "weak Galerkin"finite element method for the Poisson equation. In some sense, the motivation forconsidering this method starts from the same point as in <a class="el" href="step_51.html">step-51</a> : We would like toconsider discontinuous shape functions, but then need to address the fact thatthe resulting problem has a much larger number of degrees of freedom compared tothe usual continuous Galerkin method (because, forexample, each vertex carries as many degrees of freedom as there are adjacent cells).We also have to address the fact that, unlike in the continuousGalerkin method, <em>every</em> degree of freedomon one cell couples with all of the degrees of freedom on each of its face neighborcells. Consequently, the matrix one gets from the "traditional" discontinuousGalerkin methods are both large and relatively dense. Both the hybridized discontinuous Galerkin method (HDG) in <a class="el" href="step_51.html">step-51</a> and the weakGalerkin (WG) method in this tutorial address the issue of coupling by introducingadditional degrees of freedom whose shape functions only live on a face betweencells (i.e., on the "skeleton" of the mesh), and which therefore "insulate" thedegrees of freedom on the adjacent cells from each other: cell degrees of freedomonly couple with other cell degrees of freedom on the same cell, as well as facedegrees of freedom, but not with cell degrees of freedom on neighboring cells.Consequently, the coupling of shape functions for these cell degrees of freedomindeed couple on exactly one cell and the degrees of freedom defined on itsfaces. For a given equation, say the second order Poisson equation,the difference between the HDG and the WG method is how precisely one formulatesthe problem that connects all of these different shape functions. (Indeed,for some WG and HDG formulation, it is possible to show that they are equivalent.)The HDG does things by reformulating second order problems in terms of a system of firstorder equations and then conceptually considers the face degrees of freedomto be "fluxes" of this first order system. In contrast, the WG method keeps thingsin second order form and considers the face degrees of freedom as of the sametype as the primary solution variable, just restricted to the lower-dimensionalfaces. For the purposes of the equation, one then needs to somehow "extend"these shape functions into the interior of the cell when defining what it meansto apply a differential operator to them. Compared to the HDG, the methodhas the advantage that it does not lead to a proliferation of unknowns dueto rewriting the equation as a first-order system, but it is also not quiteas easy to implement. However, as we will see in the following, thisadditional effort is not prohibitive.</p>
<p><a class="anchor" id="WeakGalerkinfiniteelementmethods"></a></p><h3>Weak Galerkin finite element methods </h3>
<p>Weak Galerkin Finite Element Methods (WGFEMs) use discrete weak functionsto approximate scalar unknowns, and discrete weak gradients toapproximate classical gradients.The method was originally introduced by Junping Wang and Xiu Yein the paper<a href="https://doi.org/10.1016/j.cam.2012.10.003"><em>A weak Galerkin finite element method for second order elliptic problems</em><em>A weak Galerkin finite element method for second order elliptic problems</em>, J. Comput. Appl. Math., 103-115, 2013</a>.Compared to the continuous Galerkin method,the weak Galerkin method satisfies important physical properties, namelylocal mass conservation and bulk normal flux continuity.It results in a SPD linear system, and optimal convergence rates canbe obtained with mesh refinement.</p>
<p><a class="anchor" id="Theequationtosolve"></a></p><h3>The equation to solve </h3>
<p>This program solves the Poisson equationusing the weak Galerkin finite element method: </p><p class="formulaDsp">
\begin{align*} \nabla \cdot \left( -\mathbf{K} \nabla p \right) &amp;= f, \qquad \mathbf{x} \in \Omega, \\ p &amp;= p_D,\qquad \mathbf{x} \in \Gamma^D, \\ \mathbf{u} \cdot \mathbf{n} &amp;= u_N, \qquad \mathbf{x} \in \Gamma^N, \end{align*}
</p>
<p> where \(\Omega \subset \mathbb{R}^n (n=2,3)\) is a bounded domain.In the context of the flow of a fluid through a porous medium, \(p\) is the pressure, \(\mathbf{K}\) is a permeability tensor, \(f\) is the source term, and \(p_D, u_N\) represent Dirichlet and Neumann boundary conditions.We can introduce a flux, \(\mathbf{u} = -\mathbf{K} \nabla p\) , that correspondsto the Darcy velocity (in the way we did in <a class="el" href="step_20.html">step-20</a> ) and this variable willbe important in the considerations below. In this program, we will consider a test case where the exact pressureis \(p = \sin \left( \pi x\right)\sin\left(\pi y \right)\) on the unit square domain,with homogeneous Dirichelet boundary conditions and \(\mathbf{K}\) the identity matrix.Then we will calculate \(L_2\) errors of pressure, velocity, and flux.</p>
<p><a class="anchor" id="WeakGalerkinscheme"></a></p><h3>Weak Galerkin scheme </h3>
<p>The Poisson equation above has a solution \(p\) that needs to satisfy the weakformulation of the problem, </p><p class="formulaDsp">
\begin{equation*} \mathcal{A}\left(p,q \right) = \mathcal{F} \left(q \right), \end{equation*}
</p>
<p> for all test functions \(q\) , where </p><p class="formulaDsp">
\begin{equation*} \mathcal{A}\left(p,q\right) \dealcoloneq \int_\Omega \left(\mathbf{K} \nabla p\right) \cdot \nabla q \;\mathrm{d}x, \end{equation*}
</p>
<p> and </p><p class="formulaDsp">
\begin{equation*} \mathcal{F}\left(q\right) \dealcoloneq \int_\Omega f \, q \;\mathrm{d}x - \int_{\Gamma^N} u_N q \; \mathrm{d}x. \end{equation*}
</p>
<p> Here, we have integrated by parts in the bilinear form, and we are evaluatingthe gradient of \(p,p\) in the interior and the values of \(q\) on the boundaryof the domain. All of this is well defined because we assume that the solutionis in \(H^1\) for which taking the gradient and evaluating boundary valuesare valid operations. The idea of the weak Galerkin method is now to approximate the exact \(p\) solution with a <em>discontinuous function</em> \(p_h\) . This function may only bediscontinuous along interfaces between cells, and because we will want toevaluate this function also along interfaces, we have toprescribe not only what values it is supposed to have in the cell interiorsbut also its values along interfaces. We do this by saying that \(p_h\) isactually a tuple, \(p_h=(p^\circ,p^\partial)\) , though it's really justa single function that is either equal to \(p^\circ(x)\) or \(p^\partial(x)\) ,depending on whether it is evaluated at a point \(x\) that lies in the cellinterior or on cell interfaces. We would then like to simply stick this approximation into the bilinearform above. This works for the case where we have to evaluate thetest function \(q_h\) on the boundary (where we would simply take its interfacepart \(q_h^\partial\) ) but we have to be careful with the gradient becausethat is only defined in cell interiors. Consequently,the weak Galerkin scheme for the Poisson equation is defined by </p><p class="formulaDsp">
\begin{equation*} \mathcal{A}_h\left(p_h,q \right) = \mathcal{F} \left(q_h \right), \end{equation*}
</p>
<p> for all discrete test functions \(q_h\) , where </p><p class="formulaDsp">
\begin{equation*} \mathcal{A}_h\left(p_h,q_h\right) \dealcoloneq \sum_{K \in \mathbb{T}} \int_K \mathbf{K} \nabla_{w,d} p_h \cdot \nabla_{w,d} q_h \;\mathrm{d}x, \end{equation*}
</p>
<p> and </p><p class="formulaDsp">
\begin{equation*} \mathcal{F}\left(q_h\right) \dealcoloneq \sum_{K \in \mathbb{T}} \int_K f \, q_h^\circ \;\mathrm{d}x - \sum_{\gamma \in \Gamma_h^N} \int_\gamma u_N q_h^\partial \;\mathrm{d}x, \end{equation*}
</p>
<p> The key point is that here, we have replaced the gradient \(\nabla p_h\) by the<em>discrete weak gradient</em> operator \(\nabla_{w,d} p_h\) that makes sense for our peculiarly defined approximation \(p_h\) . The question is then how that operator works. For this, let us first say how wethink of the discrete approximation \(p_h\) of the pressure. As mentioned above,the "function" \(p_h\) actually consists of two parts: the values \(p_h^\circ\) inthe interior of cells, and \(p_h^\partial\) on the interfaces. We have to definediscrete (finite-dimensional) function spaces for both of these; in thisprogram, we will use <a class="el" href="classFE__DGQ.html">FE_DGQ</a> for \(p_h^\circ\) as the space in the interior ofcells (defined on each cell, but in general discontinuous along interfaces),and <a class="el" href="classFE__FaceQ.html">FE_FaceQ</a> for \(p_h^\partial\) as the space on the interfaces. Then let us consider just a single cell (because the integrals above are alldefined cell-wise, and because the weak discrete gradient is defined cell-by-cell).The restriction of \(p_h\) to cell \(K\) , \(p_h|_K\) then consistsof the pair \((p_h^\circ|_K,p_h^\partial|_{\partial K})\) . In essence, we canthink of \(\nabla_{w,d} p_h\) of some function defined on \(K\) that approximatesthe gradient; in particular, if \(p_h|_K\) was the restriction of a differentiablefunction (to the interior and boundary of \(K\)</p>
<ul>
<li>which would make it continuousbetween the interior and boundary), then \(\nabla_{w,d} p_h\) would simply be the exact gradient \(\nabla p_h\) . But, since \(p_h|_K\) is not continuous between interior and boundary of \(K\) , we need a moregeneral definition; furthermore, we can not deal with arbitrary functions, andso require that \(\nabla_{w,d} p_h\) is also in a finite element space (which, sincethe gradient is a vector, has to be vector-valued, and because the weak gradientis defined on each cell separately, will also be discontinuous between cells). The way this is done is to define this weak gradient operator \(\nabla_{w,d}|_K : DGQ_k(K) \times DGQ_r(\partial K) \rightarrow RT_s(K)\) (where \(RT_s(K)\) is thevector-valued Raviart-Thomas space of order \(s\) on cell \(K\) ) in the following way: <p class="formulaDsp">
\begin{equation*} \int_K \mathbf v_h \cdot (\nabla_{w,d} p_h) = -\int_K (\nabla \cdot \mathbf v_h) p_h^\circ +\int_{\partial K} (\mathbf v_h \cdot \mathbf n) p_h^\partial, \end{equation*}
</p>
 for all test functions \(\mathbf v_h \in RT_s(K)\) .This is, in essence, simply an application of the integration-by-partsformula. In other words, for a given \(p_h=(p^\circ_h,p^\partial_h)\) ,we need to think of \(\nabla_{w,d} p_h|_K\) as thatRaviart-Thomas function of degree \(s\) for which the left hand side and right hand sideare equal for all test functions. A key point to make is then the following: While the usual gradient \(\nabla\) isalocal* operator that computes derivatives based simply on the value ofa function at a point and its (infinitesimal) neighborhood, the weak discrete gradient \(\nabla_{w,d}\) does not have this property: It depends on the values of the functionit is applied to on the entire cell, including the cell's boundary. Both are,however, linear operators as is clear from the definition of \(\nabla_{w,d}\) above, and that will allow us to represent \(\nabla_{w,d}\) via a matrixin the discussion below. <dl class="section note"><dt>Note</dt><dd>It may be worth pointing out that while the weak discrete gradient is an element of the Raviart-Thomas space \(RT_s(K)\) on each cell \(K\) , it is discontinuous between cells. On the other hand, the Raviart-Thomas space \(RT_s=RT_s({\mathbb T})\) defined on the entire mesh and implemented by the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> class represents functions that have continuous normal components at interfaces between cells. This means that <em>globally</em>, \(\nabla_{w,d} p_h\) is not in \(RT_s\) , even though it is on every cell \(K\) in \(RT_s(K)\) . Rather, it is in a "broken" Raviart-Thomas space that below we will represent by the symbol \(DGRT_s\) . (The term "broken" here refers to the process of "breaking something apart", and not to the synonym to the expression "not functional".) One might therefore (rightfully) argue that the notation used in the weak Galerkin literature is a bit misleading, but as so often it all depends on the context in which a certain notation is used</dd></dl>
</li>
<li>in the current context, references to the Raviart-Thomas space or element are always understood to be to the "broken" spaces. <dl class="section note"><dt>Note</dt><dd>deal.II happens to have an implementation of this broken Raviart-Thomas space: The FE_DGRT class. As a consequence, in this tutorial we will simply always use the FE_DGRT class, even though in all of those places where we have to compute cell-local matrices and vectors, it makes no difference.</dd></dl>
<a class="anchor" id="Representingtheweakgradient"></a><h3>Representing the weak gradient </h3>
</li>
</ul>
<p>Since \(p_h\) is an element of a finite element space, we can expand it in a basisas we always do, i.e., we can write </p><p class="formulaDsp">
\begin{equation*} p_h(\mathbf x) = \sum_j P_j \varphi_j(\mathbf x). \end{equation*}
</p>
<p> Here, since \(p_h\) has two components (the interior and the interface components),the same must hold true for the basis functions \(\varphi_j(\mathbf x)\) , which wecan write as \(\varphi_j = (\varphi_j^\circ,\varphi_j^\partial)\) . If you'vefollowed the descriptions in <a class="el" href="step_8.html">step-8</a> , <a class="el" href="step_20.html">step-20</a> , and the <a class="el" href="group__vector__valued.html">documentation module on vector-valued problems</a>,it will be no surprise that for some values of \(j\) , \(\varphi_j^\circ\) will bezero, whereas for other values of \(j\) , \(\varphi_j^\partial\) will be zero</p>
<ul>
<li>i.e.,shape functions will be of either one or the other kind. That is not important,here, however. What is important is that we need to wonder how we can represent \(\nabla_{w,d} \varphi_j\) because that is clearly what will appear in theproblem when we want to implement the bilinear form <p class="formulaDsp">
\begin{equation*} \mathcal{A}_h\left(p_h,q_h\right) = \sum_{K \in \mathbb{T}} \int_K \mathbf{K} \nabla_{w,d} p_h \cdot \nabla_{w,d} q_h \;\mathrm{d}x, \end{equation*}
</p>
</li>
</ul>
<p>The key point is that \(\nabla_{w,d} \varphi_j\) is known to be a member of the"broken" Raviart-Thomas space \(DGRT_s\) . What this means is that we canrepresent (on each cell \(K\) separately) </p><p class="formulaDsp">
\begin{equation*} \nabla_{w,d} \varphi_j|_K = \sum_k C_{jk}^K \mathbf v_k|_K \end{equation*}
</p>
<p> where the functions \(\mathbf v_k \in DGRT_s\) , and where \(C^K\) is a matrix ofdimension </p><p class="formulaDsp">
\begin{align*} \text{dim}\left(DGQ_k(K) \times DGQ_r(K)\right) &amp;\times \text{dim}\left(RT_s(K)\right) \\ &amp;= \left(\text{dim}(DGQ_k(K)) + \text{dim}(DGQ_r(K))\right) \times \text{dim}\left(RT_s(K)\right). \end{align*}
</p>
<p> (That the weak discrete gradient can be represented as a matrix should not comeas a surprise: It is a linear operator from one finite dimensionalspace to another finite dimensional space. If one chooses basesfor both of these spaces, then <em>every linear operator</em> canof course be written as a matrix mapping the vector of expansion coefficientswith regards to the basis of the domain space of the operator, tothe vector of expansion coefficients with regards to the basis in the imagespace.) Using this expansion, we can easily use the definition of the weakdiscrete gradient above to define what the matrix is going to be: </p><p class="formulaDsp">
\begin{equation*} \int_K \mathbf v_i \cdot \left(\sum_k C_{jk}^K \mathbf v_k\right) = -\int_K (\nabla \cdot \mathbf v_i) \varphi_j^\circ +\int_{\partial K} (\mathbf v_i \cdot \mathbf n) \varphi_j^\partial, \end{equation*}
</p>
<p> for all test functions \(\mathbf v_i \in DGRT_s\) . This clearly leads to a linear system of the form </p><p class="formulaDsp">
\begin{equation*} \sum_k M_{ik}^K C_{jk}^K = G_{ij}^K \end{equation*}
</p>
<p> with </p><p class="formulaDsp">
\begin{equation*} M_{ik}^K = \int_K \mathbf v_i \cdot \mathbf v_k, \qquad\qquad G_{ij}^K = -\int_K (\nabla \cdot \mathbf v_i) \varphi_j^\circ +\int_{\partial K} (\mathbf v_i \cdot \mathbf n) \varphi_j^\partial, \end{equation*}
</p>
<p> and consequently </p><p class="formulaDsp">
\begin{equation*} \left(C^K\right)^T = \left(M^K\right)^{-1} G^K. \end{equation*}
</p>
<p> (In this last step, we have assumed that the indices \(i,j,k\) only rangeover those degrees of freedom active on cell \(K\) ,thereby ensuring that the mass matrix on the space \(RT_s(K)\) is invertible.)Equivalently, using the symmetry of the matrix \(M\) , we have that </p><p class="formulaDsp">
\begin{equation*} C^K = \left(G^K\right)^{T} \left(M^K\right)^{-1}. \end{equation*}
</p>
<p> Also worth pointing out is that thematrices \(C^K\) and \(G^K\) are of course not square but rectangular.</p>
<p><a class="anchor" id="Assemblingthelinearsystem"></a></p><h3>Assembling the linear system </h3>
<p>Having explained how the weak discrete gradient is defined, we can nowcome back to the question of how the linear system for the equation in questionshould be assembled. Specifically, using the definition of the bilinearform \({\cal A}_h\) shown above, we then need to compute the elements of thelocal contribution to the global matrix, </p><p class="formulaDsp">
\begin{equation*} A^K_{ij} = \int_K \left({\mathbf K} \nabla_{w,d} \varphi_i\right) \cdot \nabla_{w,d} \varphi_j. \end{equation*}
</p>
<p> As explained above, we can expand \(\nabla_{w,d} \varphi_i\) in terms of theRaviart-Thomas basis on each cell, and similarly for \(\nabla_{w,d} \varphi_j\) : </p><p class="formulaDsp">
\begin{equation*} A^K_{ij} = \int_K \left( {\mathbf K} \sum_k C_{ik}^K \mathbf v_k|_K \right) \cdot \sum_l C_{jl}^K \mathbf v_l|_K. \end{equation*}
</p>
<p> By re-arranging sums, this yields the following expression: </p><p class="formulaDsp">
\begin{equation*} A^K_{ij} = \sum_k \sum_l C_{ik}^K C_{jl}^K \int_K \left( {\mathbf K} \mathbf v_k|_K \right) \cdot \mathbf v_l|_K. \end{equation*}
</p>
<p> So, if we have the matrix \(C^K\) for each cell \(K\) , then we can easily computethe contribution \(A^K\) for cell \(K\) to the matrix \(A\) as follows: </p><p class="formulaDsp">
\begin{equation*} A^K_{ij} = \sum_k \sum_l C_{ik}^K C_{jl}^K H^K_{kl} = \sum_k \sum_l C_{ik}^K H^K_{kl} C_{jl}^K = \left(C^K H^K (C^K)^T \right)_{ij}. \end{equation*}
</p>
<p> Here, </p><p class="formulaDsp">
\begin{equation*} H^K_{kl} = \int_K \left( {\mathbf K} \mathbf v_k|_K \right) \cdot \mathbf v_l|_K, \end{equation*}
</p>
<p> which is really just the mass matrix on cell \(K\) using the Raviart-Thomasbasis and weighting by the permeability tensor \(\mathbf K\) . The derivationhere then shows that the weak Galerkin method really just requires usto compute these \(C^K\) and \(H^K\) matrices on each cell \(K\) , and then \(A^K = C^K H^K (C^K)^T\) , which is easily computed. The code to be shownbelow does exactly this. Having so computed the contribution \(A^K\) of cell \(K\) to the globalmatrix, all we have to do is to "distribute" these local contributionsinto the global matrix. How this is done is first shown in <a class="el" href="step_3.html">step-3</a> and <a class="el" href="step_4.html">step-4</a> . In the current program, this will be facilitated by calling <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a>. A linear system of course also needs a right hand side. There is no difficultyassociated with computing the right hand side here other than the factthat we only need to use the cell-interior part \(\varphi_i^\circ\) foreach shape function \(\varphi_i\) .</p>
<p><a class="anchor" id="PostprocessingandiLsub2subierrors"></a></p><h3>Post-processing and <em>L<sub>2</sub></em><em>L<sub>2</sub></em>-errors </h3>
<p>The discussions in the previous sections have given us a linearsystem that we can solve for the numerical pressure \(p_h\) . We can usethis to compute an approximation to the variable \(\mathbf u = -{\mathbf K}\nabla p\) that corresponds to the velocity with which the medium flows in a porousmedium if this is the model we are trying to solve. This kind ofstep</p>
<ul>
<li>computing a derived quantity from the solution of the discreteproblem</li>
<li>is typically called "post-processing". Here, instead of using the exact gradient of \(p_h\) , let us insteaduse the discrete weak gradient of \(p_h\) to calculate the velocity on each element.As discussed above,on each element the gradient of the numerical pressure \(\nabla p\) can beapproximated by discrete weak gradients \( \nabla_{w,d}\phi_i\) : <p class="formulaDsp">
\begin{equation*} \nabla_{w,d} p_h = \nabla_{w,d} \left(\sum_{i} P_i \phi_i\right) = \sum_{i} P_i \nabla_{w,d}\phi_i. \end{equation*}
</p>
</li>
</ul>
<p>On cell \(K\) ,the numerical velocity \( \mathbf{u}_h = -\mathbf{K} \nabla_{w,d}p_h\) can be written as </p><p class="formulaDsp">
\begin{align*} \mathbf{u}_h &amp;= -\mathbf{K} \nabla_{w,d} p_h = -\mathbf{K}\sum_{i} \sum_{j} P_i C^K_{ij}\mathbf{v}_j, \end{align*}
</p>
<p> where \(C^K\) is the expansion matrix from above, and \(\mathbf{v}_j\) is the basis function of the \(RT\) space on a cell. Unfortunately, \(\mathbf{K} \mathbf{v}_j\) may not be in the \(RT\) space(unless, of course, if \(\mathbf K\) is constant times the identity matrix).So, in order to represent it in a finite element program, we need toproject it back into a finite dimensional space we can work with. Here,we will use the \(L_2\) -projection to project it back to the (broken) \(RT\) space. We define the projection as \( \mathbf{Q}_h \left( \mathbf{K}\mathbf{v}_j \right) = \sum_{k} d_{jk}\mathbf{v}_k\) on each cell \(K\) .For any \(j\) , \(\left( \mathbf{Q}_h \left( \mathbf{Kv}_j \right),\mathbf{v}_k \right)_K = \left( \mathbf{Kv}_j,\mathbf{v}_k \right)_K.\) So, rather than the formula shown above, the numerical velocity on cell \(K\) instead becomes </p><p class="formulaDsp">
\begin{equation*} \mathbf{u}_h = \mathbf{Q}_h \left( -\mathbf{K}\nabla_{w,d}p_h \right) = -\sum_i \sum_j P_i B^K_{ij}\mathbf{Q}_h \left( \mathbf{K}\mathbf{v}_j \right), \end{equation*}
</p>
<p> and we have the following system to solve for the coefficients \(d_{jk}\) : </p><p class="formulaDsp">
\begin{equation*} \sum_j \left(\mathbf{v}_i,\mathbf{v}_j\right) d_{jk} = \left( \mathbf{Kv}_j,\mathbf{v}_k \right). \end{equation*}
</p>
<p> In the implementation below, the matrix with elements \( d_{jk} \) is called <code>cell_matrix_D</code> ,whereas the matrix with elements \( \left( \mathbf{Kv}_j,\mathbf{v}_k \right) \) is called <code>cell_matrix_E</code> . Then the elementwise velocity is </p><p class="formulaDsp">
\begin{equation*} \mathbf{u}_h = -\sum_{i} \sum_{j}P_ic_{ij}\sum_{k}d_{jk}\mathbf{v}_k = \sum_{k}- \left(\sum_{j} \sum_{i} P_ic_{ij}d_{jk} \right)\mathbf{v}_k, \end{equation*}
</p>
<p> where \(-\sum_{j} \sum_{i} P_ic_{ij}d_{jk}\) is called<code>cell_velocity</code> in the code. Using this velocity obtained by "postprocessing" the solution, we candefine the \(L_2\) -errors of pressure, velocity, and fluxby the following formulas: </p><p class="formulaDsp">
\begin{align*} \|p-p_h^\circ\|^2 &amp;= \sum_{K \in \mathbb{T}} \|p-p_h^\circ\|_{L_2(K)}^2, \\ \|\mathbf{u}-\mathbf{u}_h\|^2 &amp;= \sum_{K \in \mathbb{T}} \|\mathbf{u}-\mathbf{u}_h\|_{L_2(K)^2}^d,\\ \|(\mathbf{u}-\mathbf{u}_h) \cdot \mathbf{n}\|^2 &amp;= \sum_{K \in \mathbb{T}} \sum_{\gamma \subset \partial K} \frac{|K|}{|\gamma|} \|\mathbf{u} \cdot \mathbf{n} - \mathbf{u}_h \cdot \mathbf{n}\|_{L_2(\gamma)}^2, \end{align*}
</p>
<p> where \(| K |\) is the area of the element, \(\gamma\) are faces of the element, \(\mathbf{n}\) are unit normal vectors of each face. The last of thesenorms measures the accuracy of the normal component of the velocityvectors over the interfaces between the cells of the mesh. The scalingfactor \(|K|/|\gamma|\) is chosen so as to scale out the difference inthe length (or area) of the collection of interfaces as the mesh sizechanges. The first of these errors above is easily computed using <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>. The others require a bit more workand are implemented in the code below.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>This program is based on step-7 , step-20 and step-51 , so most of the following header files are familiar. We need the following, of which only the one that imports the <a class="el" href="classFE__DGRaviartThomas.html">FE_DGRaviartThomas</a> class (namely, <code>deal.II/fe/fe_dg_vector.h</code>) is really new; the <a class="el" href="classFE__DGRaviartThomas.html">FE_DGRaviartThomas</a> implements the "broken" Raviart-Thomas space discussed in the introduction:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2quadrature_8h.html">deal.II/base/quadrature.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2point_8h.html">deal.II/base/point.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__raviart__thomas_8h.html">deal.II/fe/fe_raviart_thomas.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dg__vector_8h.html">deal.II/fe/fe_dg_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__face_8h.html">deal.II/fe/fe_face.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="component__mask_8h.html">deal.II/fe/component_mask.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="data__out__faces_8h.html">deal.II/numerics/data_out_faces.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>Our first step, as always, is to put everything related to this tutorial program into its own namespace:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step61</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="TheWGDarcyEquationclasstemplate"></a> </p><h3>The WGDarcyEquation class template</h3>
<p>This is the main class of this program. We will solve for the numerical pressure in the interior and on faces using the weak Galerkin (WG) method, and calculate the \(L_2\) error of pressure. In the post-processing step, we will also calculate \(L_2\) -errors of the velocity and flux. The structure of the class is not fundamentally different from that of previous tutorial programs, so there is little need to comment on the details with one exception: The class has a member variable <code>fe_dgrt</code> that corresponds to the "broken" Raviart-Thomas space mentioned in the introduction. There is a matching <code>dof_handler_dgrt</code> that represents a global enumeration of a finite element field created from this element, and a vector <code>darcy_velocity</code> that holds nodal values for this field. We will use these three variables after solving for the pressure to compute a postprocessed velocity field for which we can then evaluate the error and which we can output for visualization.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>WGDarcyEquation</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  WGDarcyEquation(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> compute_postprocessed_velocity();</div><div class="line">  <span class="keywordtype">void</span> compute_velocity_errors();</div><div class="line">  <span class="keywordtype">void</span> compute_pressure_error();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>   fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; solution;</div><div class="line">  Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">  <a class="code" href="classFE__DGRaviartThomas.html">FE_DGRaviartThomas&lt;dim&gt;</a> fe_dgrt;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>         dof_handler_dgrt;</div><div class="line">  Vector&lt;double&gt;          darcy_velocity;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Righthandsideboundaryvaluesandexactsolution"></a> </p><h3>Right hand side, boundary values, and exact solution</h3>
<p>Next, we define the coefficient matrix \(\mathbf{K}\) (here, the identity matrix), Dirichlet boundary conditions, the right-hand side \(f = 2\pi^2 \sin(\pi x) \sin(\pi y)\) , and the exact solution that corresponds to these choices for \(K\) and \(f\) , namely \(p = \sin(\pi x) \sin(\pi y)\) .</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Coefficient()</div><div class="line">    : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTensorFunction.html#a3afbbe3ba38a517e8a97db9adf2cb340">value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                          std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;values) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Coefficient&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                  std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">    values[p] = unit_symmetric_tensor&lt;dim&gt;();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;  <span class="comment">/*p*/</span> ,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span> )<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span> )<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (2 numbers::PI numbers::PI std::sin(numbers::PI p[0])</div><div class="line">          std::sin(numbers::PI p[1]));</div><div class="line">}</div></div><!-- fragment --><p>The class that implements the exact pressure solution has an oddity in that we implement it as a vector-valued one with two components. (We say that it has two components in the constructor where we call the constructor of the base <a class="el" href="classFunction.html">Function</a> class.) In the <code>value()</code> function, we do not test for the value of the <code>component</code> argument, which implies that we return the same value for both components of the vector-valued function. We do this because we describe the finite element in use in this program as a vector-valued system that contains the interior and the interface pressures, and when we compute errors, we will want to use the same pressure solution to test both of these components.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>ExactPressure : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     ExactPressure()</div><div class="line">       : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">     {}</div><div class="line">  </div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">   };</div><div class="line">  </div><div class="line"> </div><div class="line">  </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">double</span> ExactPressure&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span> )<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI p[0]) <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI p[1]);</div><div class="line">   }</div><div class="line">  </div><div class="line"> </div><div class="line">  </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>ExactVelocity : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     ExactVelocity()</div><div class="line">       : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;()</div><div class="line">     {}</div><div class="line">  </div><div class="line">     <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p) <span class="keyword">const override</span>;</div><div class="line">   };</div><div class="line">  </div><div class="line"> </div><div class="line">  </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ExactVelocity&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> return_value;</div><div class="line">     return_value[0] =</div><div class="line">  </div><div class="line">-numbers::PI <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI p[0])</div><div class="line">                       <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI p[1]);</div><div class="line">     return_value[1] =</div><div class="line">  </div><div class="line">-numbers::PI <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI p[0])</div><div class="line">                       <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI p[1]);</div><div class="line">     <span class="keywordflow">return</span> return_value;</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationclassimplementation"></a> </p><h3>WGDarcyEquation class implementation</h3>
<pre class="fragment">&lt;a name="WGDarcyEquationWGDarcyEquation"&gt;&lt;/a&gt;  &lt;h4&gt;WGDarcyEquation::WGDarcyEquation&lt;/h4&gt;
</pre><p>In this constructor, we create a finite element space for vector valued functions, which will here include the ones used for the interior and interface pressures, \(p^\circ\) and \(p^\partial\) .</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">WGDarcyEquation&lt;dim&gt;::WGDarcyEquation(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1, <a class="code" href="classFE__FaceQ.html">FE_FaceQ</a>&lt;dim&gt;(degree), 1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , fe_dgrt(degree)</div><div class="line">  , dof_handler_dgrt(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationmake_grid"></a> </p><h4>WGDarcyEquation::make_grid</h4>
<p>We generate a mesh on the unit square domain and refine it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(5);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationsetup_system"></a> </p><h4>WGDarcyEquation::setup_system</h4>
<p>After we have created the mesh above, we distribute degrees of freedom and resize matrices and vectors. The only piece of interest in this function is how we interpolate the boundary values for the pressure. Since the pressure consists of interior and interface components, we need to make sure that we only interpolate onto that component of the vector-valued solution space that corresponds to the interface pressures (as these are the only ones that are defined on the boundary of the domain). We do this via a component mask object for only the interface pressures.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  dof_handler_dgrt.distribute_dofs(fe_dgrt);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of pressure degrees of freedom: &quot;</span></div><div class="line">            &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line"></div><div class="line">  {</div><div class="line">    constraints.clear();</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> interface_pressure(1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a>              interface_pressure_mask =</div><div class="line">      fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(interface_pressure);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             constraints,</div><div class="line">                                             interface_pressure_mask);</div><div class="line">    constraints.close();</div><div class="line">  }</div></div><!-- fragment --><p>In the bilinear form, there is no integration term over faces between two neighboring cells, so we can just use <code><a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></code> to calculate the sparse matrix.</p>
<div class="fragment"><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints);</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationassemble_system"></a> </p><h4>WGDarcyEquation::assemble_system</h4>
<p>This function is more interesting. As detailed in the introduction, the assembly of the linear system requires us to evaluate the weak gradient of the shape functions, which is an element in the Raviart-Thomas space. As a consequence, we need to define a Raviart-Thomas finite element object, and have <a class="el" href="classFEValues.html">FEValues</a> objects that evaluate it at quadrature points. We then need to compute the matrix \(C^K\) on every cell \(K\) , for which we need the matrices \(M^K\) and \(G^K\) mentioned in the introduction. A point that may not be obvious is that in all previous tutorial programs, we have always called <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> with a cell iterator from a <a class="el" href="classDoFHandler.html">DoFHandler</a>. This is so that one can call functions such as <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> that extract the values of a finite element function (represented by a vector of DoF values) on the quadrature points of a cell. For this operation to work, one needs to know which vector elements correspond to the degrees of freedom on a given cell</p>
<ul>
<li>i.e., exactly the kind of information and operation provided by the <a class="el" href="classDoFHandler.html">DoFHandler</a> class. We could create a <a class="el" href="classDoFHandler.html">DoFHandler</a> object for the "broken" Raviart-Thomas space (using the FE_DGRT class), but we really don't want to here: At least in the current function, we have no need for any globally defined degrees of freedom associated with this broken space, but really only need to reference the shape functions of such a space on the current cell. As a consequence, we use the fact that one can call <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> also with cell iterators into <a class="el" href="classTriangulation.html">Triangulation</a> objects (rather than <a class="el" href="classDoFHandler.html">DoFHandler</a> objects). In this case, <a class="el" href="classFEValues.html">FEValues</a> can of course only provide us with information that only references information about cells, rather than degrees of freedom enumerated on these cells. So we can't use <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a>, but we can use <a class="el" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">FEValues::shape_value()</a> to obtain the values of shape functions at quadrature points on the current cell. It is this kind of functionality we will make use of below. The variable that will give us this information about the Raviart-Thomas functions below is then the <code>fe_values_rt</code> (and corresponding <code>fe_face_values_rt</code>) object. Given this introduction, the following declarations should be pretty obvious:</li>
</ul>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::assemble_system()</div><div class="line">   {</div><div class="line">     <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">     <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">  </div><div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                             quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">     <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                      face_quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values_dgrt(fe_dgrt,</div><div class="line">                                  quadrature_formula,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">     <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                           face_quadrature_formula,</div><div class="line">                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell      = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell();</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = fe_face_values.<a class="code" href="classFEFaceValuesBase.html#ab460150cda793c93abfc6eac1314de31">get_quadrature</a>().<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  </div><div class="line">     RightHandSide&lt;dim&gt;  right_hand_side;</div><div class="line">     std::vector&lt;double&gt; right_hand_side_values(n_q_points);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> Coefficient&lt;dim&gt;      coefficient;</div><div class="line">     std::vector&lt;Tensor&lt;2, dim&gt;&gt; coefficient_values(n_q_points);</div><div class="line">  </div><div class="line">     std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div></div><!-- fragment --><p>Next, let us declare the various cell matrices discussed in the introduction:</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">Vector&lt;double&gt;     cell_solution(dofs_per_cell);</div></div><!-- fragment --><p>We need <code><a class="el" href="namespaceFEValuesExtractors.html">FEValuesExtractors</a></code> to access the <code>interior</code> and <code>face</code> component of the shape functions.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_interior(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_face(1);</div></div><!-- fragment --><p>This finally gets us in position to loop over all cells. On each cell, we will first calculate the various cell matrices used to construct the local matrix</p>
<ul>
<li>as they depend on the cell in question, they need to be re-computed on each cell. We need shape functions for the Raviart-Thomas space as well, for which we need to create first an iterator to the cell of the triangulation, which we can obtain by assignment from the cell pointing into the <a class="el" href="classDoFHandler.html">DoFHandler</a>.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell_dgrt =</div><div class="line">      cell;</div><div class="line">    fe_values_dgrt.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(cell_dgrt);</div><div class="line"></div><div class="line">    right_hand_side.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                               right_hand_side_values);</div><div class="line">    coefficient.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                           coefficient_values);</div></div><!-- fragment --><p>The first cell matrix we will compute is the mass matrix for the Raviart-Thomas space. Hence, we need to loop over all the quadrature points for the velocity <a class="el" href="classFEValues.html">FEValues</a> object.</p>
<div class="fragment"><div class="line">cell_matrix_M = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i = fe_values_dgrt[velocities].value(i, q);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">            fe_values_dgrt[velocities].value(k, q);</div><div class="line">          cell_matrix_M(i, k) += (v_i v_k fe_values_dgrt.JxW(q));</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>Next we take the inverse of this matrix by using <a class="el" href="classFullMatrix.html#a898466c57e11e6f2599165071ffe5df3">FullMatrix::gauss_jordan()</a>. It will be used to calculate the coefficient matrix \(C^K\) later. It is worth recalling later that <code>cell_matrix_M</code> actually contains theinverse* of \(M^K\) after this call.</p>
<div class="fragment"><div class="line">cell_matrix_M.gauss_jordan();</div></div><!-- fragment --><p>From the introduction, we know that the right hand side \(G^K\) of the equation that defines \(C^K\) is the difference between a face integral and a cell integral. Here, we approximate the negative of the contribution in the interior. Each component of this matrix is the integral of a product between a basis function of the polynomial space and the divergence of a basis function of the Raviart-Thomas space. These basis functions are defined in the interior.</p>
<div class="fragment"><div class="line">         cell_matrix_G = 0;</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">             {</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">double</span> div_v_i =</div><div class="line">                 fe_values_dgrt[velocities].divergence(i, q);</div><div class="line">               <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                 {</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_interior =</div><div class="line">                     fe_values[pressure_interior].value(j, q);</div><div class="line">  </div><div class="line">                   cell_matrix_G(i, j)</div><div class="line">  </div><div class="line">-=</div><div class="line">                     (div_v_i phi_j_interior fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                 }</div><div class="line">             }</div></div><!-- fragment --><p>Next, we approximate the integral on faces by quadrature. Each component is the integral of a product between a basis function of the polynomial space and the dot product of a basis function of the Raviart-Thomas space and the normal vector. So we loop over all the faces of the element and obtain the normal vector.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">  {</div><div class="line">    fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">    fe_face_values_dgrt.reinit(cell_dgrt, face);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal = fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i =</div><div class="line">              fe_face_values_dgrt[velocities].value(i, q);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_face =</div><div class="line">                  fe_face_values[pressure_face].value(j, q);</div><div class="line"></div><div class="line">                cell_matrix_G(i, j) +=</div><div class="line">                  ((v_i normal) phi_j_face fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --> <pre class="fragment">@p cell_matrix_C   is then the matrix product between the transpose of \form#5720   and the inverse of the mass matrix (where this inverse is stored in   @p cell_matrix_M):  
</pre><div class="fragment"><div class="line">cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M);</div></div><!-- fragment --><p>Finally we can compute the local matrix \(A^K\) . Element \(A^K_{ij}\) is given by \(\int_{E} \sum_{k,l} C_{ik} C_{jl} (\mathbf{K} \mathbf{v}_k) \cdot \mathbf{v}_l \mathrm{d}x\) . We have calculated the coefficients \(C\) in the previous step, and so obtain the following after suitably re-arranging the loops:</p>
<div class="fragment"><div class="line">local_matrix = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">          fe_values_dgrt[velocities].value(k, q);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dofs_per_cell_dgrt; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_l =</div><div class="line">              fe_values_dgrt[velocities].value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                local_matrix(i, j) +=</div><div class="line">                  (coefficient_values[q] cell_matrix_C[i][k] v_k)</div><div class="line">                  cell_matrix_C[j][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] v_l fe_values_dgrt.JxW(q);</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Next, we calculate the right hand side, \(\int_{K} f q \mathrm{d}x\) :</p>
<div class="fragment"><div class="line">cell_rhs = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      cell_rhs(i) += (fe_values[pressure_interior].value(i, q)</div><div class="line">                      right_hand_side_values[q] fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">    }</div></div><!-- fragment --><p>The last step is to distribute components of the local matrix into the system matrix and transfer components of the cell right hand side into the system right hand side:</p>
<div class="fragment"><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      constraints.distribute_local_to_global(</div><div class="line">        local_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationdimsolve"></a> </p><h4>WGDarcyEquation&lt;dim&gt;::solve</h4>
<p>This step is rather trivial and the same as in many previous tutorial programs:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-8 system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">  solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">  constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationdimcompute_postprocessed_velocity"></a> </p><h4>WGDarcyEquation&lt;dim&gt;::compute_postprocessed_velocity</h4>
<p>In this function, compute the velocity field from the pressure solution previously computed. The velocity is defined as \(\mathbf{u}_h = \mathbf{Q}_h \left( -\mathbf{K}\nabla_{w,d}p_h \right)\) , which requires us to compute many of the same terms as in the assembly of the system matrix. There are also the matrices \(E^K,D^K\) we need to assemble (see the introduction) but they really just follow the same kind of pattern. Computing the same matrices here as we have already done in the <code>assemble_system()</code> function is of course wasteful in terms of CPU time. Likewise, we copy some of the code from there to this function, and this is also generally a poor idea. A better implementation might provide for a function that encapsulates this duplicated code. One could also think of using the classic trade-off between computing efficiency and memory efficiency to only compute the \(C^K\) matrices once per cell during the assembly, storing them somewhere on the side, and re-using them here. (This is what <a class="el" href="step_51.html">step-51</a> does, for example, where the <code>assemble_system()</code> function takes an argument that determines whether the local matrices are recomputed, and a similar approach</p>
<ul>
<li>maybe with storing local matrices elsewhere</li>
<li>could be adapted for the current program.)</li>
</ul>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_postprocessed_velocity()</div><div class="line">   {</div><div class="line">     darcy_velocity.reinit(dof_handler_dgrt.n_dofs());</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">     <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">  </div><div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                             quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">     <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                      face_quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_dgrt(fe_dgrt,</div><div class="line">                                  quadrature_formula,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">     <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                           face_quadrature_formula,</div><div class="line">                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell      = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell();</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = fe_face_values.<a class="code" href="classFEFaceValuesBase.html#ab460150cda793c93abfc6eac1314de31">get_quadrature</a>().<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  </div><div class="line"> </div><div class="line">     std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">     std::vector&lt;types::global_dof_index&gt; local_dof_indices_dgrt(</div><div class="line">       dofs_per_cell_dgrt);</div><div class="line">  </div><div class="line">     <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line">     <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell);</div><div class="line">     <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt);</div><div class="line">     <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_D(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line">     <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_E(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line">  </div><div class="line">     Vector&lt;double&gt; cell_solution(dofs_per_cell);</div><div class="line">     Vector&lt;double&gt; cell_velocity(dofs_per_cell_dgrt);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> Coefficient&lt;dim&gt;      coefficient;</div><div class="line">     std::vector&lt;Tensor&lt;2, dim&gt;&gt; coefficient_values(n_q_points_dgrt);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">     <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_interior(0);</div><div class="line">     <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_face(1);</div></div><!-- fragment --><p>In the introduction, we explained how to calculate the numerical velocity on the cell. We need the pressure solution values on each cell, coefficients of the Gram matrix and coefficients of the \(L_2\) projection. We have already calculated the global solution, so we will extract the cell solution from the global solution. The coefficients of the Gram matrix have been calculated when we assembled the system matrix for the pressures. We will do the same way here. For the coefficients of the projection, we do matrix multiplication, i.e., the inverse of the Gram matrix times the matrix with \((\mathbf{K} \mathbf{w}, \mathbf{w})\) as components. Then, we multiply all these coefficients and call them beta. The numerical velocity is the product of beta and the basis functions of the Raviart-Thomas space.</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(), cell_dgrt = dof_handler_dgrt.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell != endc; ++cell, ++cell_dgrt)</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">    fe_values_dgrt.reinit(cell_dgrt);</div><div class="line"></div><div class="line">    coefficient.value_list(fe_values_dgrt.get_quadrature_points(),</div><div class="line">                           coefficient_values);</div></div><!-- fragment --><p>The component of this <code>cell_matrix_E</code> is the integral of \((\mathbf{K} \mathbf{w}, \mathbf{w})\) . <code>cell_matrix_M</code> is the Gram matrix.</p>
<div class="fragment"><div class="line">cell_matrix_M = 0;</div><div class="line">cell_matrix_E = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i = fe_values_dgrt[velocities].value(i, q);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">            fe_values_dgrt[velocities].value(k, q);</div><div class="line"></div><div class="line">          cell_matrix_E(i, k) +=</div><div class="line">            (coefficient_values[q] v_i v_k fe_values_dgrt.JxW(q));</div><div class="line"></div><div class="line">          cell_matrix_M(i, k) += (v_i v_k fe_values_dgrt.JxW(q));</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>To compute the matrix \(D\) mentioned in the introduction, we then need to evaluate \(D=M^{-1}E\) as explained in the introduction:</p>
<div class="fragment"><div class="line">cell_matrix_M.gauss_jordan();</div><div class="line">cell_matrix_M.mmult(cell_matrix_D, cell_matrix_E);</div></div><!-- fragment --><p>Then we also need, again, to compute the matrix \(C\) that is used to evaluate the weak discrete gradient. This is the exact same code as used in the assembly of the system matrix, so we just copy it from there:</p>
<div class="fragment"><div class="line">         cell_matrix_G = 0;</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">             {</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">double</span> div_v_i =</div><div class="line">                 fe_values_dgrt[velocities].divergence(i, q);</div><div class="line">               <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                 {</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_interior =</div><div class="line">                     fe_values[pressure_interior].value(j, q);</div><div class="line">  </div><div class="line">                   cell_matrix_G(i, j)</div><div class="line">  </div><div class="line">-=</div><div class="line">                     (div_v_i phi_j_interior fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                 }</div><div class="line">             }</div><div class="line">  </div><div class="line">         <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">           {</div><div class="line">             fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">             fe_face_values_dgrt.reinit(cell_dgrt, face);</div><div class="line">  </div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">               {</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal = fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line">  </div><div class="line">                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">                   {</div><div class="line">                     <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i =</div><div class="line">                       fe_face_values_dgrt[velocities].value(i, q);</div><div class="line">                     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                       {</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_face =</div><div class="line">                           fe_face_values[pressure_face].value(j, q);</div><div class="line">  </div><div class="line">                         cell_matrix_G(i, j) +=</div><div class="line">                           ((v_i normal) phi_j_face fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                       }</div><div class="line">                   }</div><div class="line">               }</div><div class="line">           }</div><div class="line">         cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M);</div></div><!-- fragment --><p>Finally, we need to extract the pressure unknowns that correspond to the current cell:</p>
<div class="fragment"><div class="line">cell-&gt;get_dof_values(solution, cell_solution);</div></div><!-- fragment --><p>We are now in a position to compute the local velocity unknowns (with respect to the Raviart-Thomas space we are projecting the term \(-\mathbf K \nabla_{w,d} p_h\) into):</p>
<div class="fragment"><div class="line">         cell_velocity = 0;</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell_dgrt; ++j)</div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">               cell_velocity(k) +=</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-(cell_solution(i) cell_matrix_C(i, j) cell_matrix_D(k, j));</div></div><!-- fragment --><p>We compute Darcy velocity. This is same as cell_velocity but used to graph Darcy velocity.</p>
<div class="fragment"><div class="line">         cell_dgrt-&gt;get_dof_indices(local_dof_indices_dgrt);</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell_dgrt; ++j)</div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">               darcy_velocity(local_dof_indices_dgrt[k]) +=</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-(cell_solution(i) cell_matrix_C(i, j) cell_matrix_D(k, j));</div><div class="line">       }</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationdimcompute_pressure_error"></a> </p><h4>WGDarcyEquation&lt;dim&gt;::compute_pressure_error</h4>
<p>This part is to calculate the \(L_2\) error of the pressure. We define a vector that holds the norm of the error on each cell. Next, we use <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTool::integrate_difference()</a> to compute the error in the \(L_2\) norm on each cell. However, we really only care about the error in the interior component of the solution vector (we can't even evaluate the interface pressures at the quadrature points because these are all located in the interior of cells) and consequently have to use a weight function that ensures that the interface component of the solution variable is ignored. This is done by using the <a class="el" href="classComponentSelectFunction.html">ComponentSelectFunction</a> whose arguments indicate which component we want to select (component zero, i.e., the interior pressures) and how many components there are in total (two).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_pressure_error()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> select_interior_pressure(0, 2);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler,</div><div class="line">                                    solution,</div><div class="line">                                    ExactPressure&lt;dim&gt;(),</div><div class="line">                                    difference_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                    &amp;select_interior_pressure);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> L2_error = difference_per_cell.l2_norm();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;L2_error_pressure &quot;</span> &lt;&lt; L2_error &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationdimcompute_velocity_error"></a> </p><h4>WGDarcyEquation&lt;dim&gt;::compute_velocity_error</h4>
<p>In this function, we evaluate \(L_2\) errors for the velocity on each cell, and \(L_2\) errors for the flux on faces. The function relies on the <code>compute_postprocessed_velocity()</code> function having previous computed, which computes the velocity field based on the pressure solution that has previously been computed. We are going to evaluate velocities on each cell and calculate the difference between numerical and exact velocities.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_velocity_errors()</div><div class="line">   {</div><div class="line">     <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">     <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">  </div><div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_dgrt(fe_dgrt,</div><div class="line">                                  quadrature_formula,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">     <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                           face_quadrature_formula,</div><div class="line">                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points_dgrt =</div><div class="line">       fe_face_values_dgrt.get_quadrature().size();</div><div class="line">  </div><div class="line">     std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points_dgrt);</div><div class="line">     std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_face_values(n_face_q_points_dgrt);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> ExactVelocity&lt;dim&gt; exact_velocity;</div><div class="line">  </div><div class="line">     <span class="keywordtype">double</span> L2_err_velocity_cell_sqr_global = 0;</div><div class="line">     <span class="keywordtype">double</span> L2_err_flux_sqr                 = 0;</div></div><!-- fragment --><p>Having previously computed the postprocessed velocity, we here only have to extract the corresponding values on each cell and face and compare it to the exact values.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell_dgrt : dof_handler_dgrt.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    fe_values_dgrt.reinit(cell_dgrt);</div></div><!-- fragment --><p>First compute the \(L_2\) error between the postprocessed velocity field and the exact one:</p>
<div class="fragment"><div class="line">         fe_values_dgrt[velocities].get_function_values(darcy_velocity,</div><div class="line">                                                        velocity_values);</div><div class="line">         <span class="keywordtype">double</span> L2_err_velocity_cell_sqr_local = 0;</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">           {</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity = velocity_values[q];</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> true_velocity =</div><div class="line">               exact_velocity.value(fe_values_dgrt.quadrature_point(q));</div><div class="line">  </div><div class="line">             L2_err_velocity_cell_sqr_local +=</div><div class="line">               ((velocity</div><div class="line">  </div><div class="line">- true_velocity) (velocity</div><div class="line">  </div><div class="line">- true_velocity)</div><div class="line">                fe_values_dgrt.JxW(q));</div><div class="line">           }</div><div class="line">         L2_err_velocity_cell_sqr_global += L2_err_velocity_cell_sqr_local;</div></div><!-- fragment --><p>For reconstructing the flux we need the size of cells and faces. Since fluxes are calculated on faces, we have the loop over all four faces of each cell. To calculate the face velocity, we extract values at the quadrature points from the <code>darcy_velocity</code> which we have computed previously. Then, we calculate the squared velocity error in normal direction. Finally, we calculate the \(L_2\) flux error on the cell by appropriately scaling with face and cell areas and add it to the global error.</p>
<div class="fragment"><div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span> cell_area = cell_dgrt-&gt;measure();</div><div class="line">         <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face_dgrt : cell_dgrt-&gt;face_iterators())</div><div class="line">           {</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">double</span> face_length = face_dgrt-&gt;measure();</div><div class="line">             fe_face_values_dgrt.reinit(cell_dgrt, face_dgrt);</div><div class="line">             fe_face_values_dgrt[velocities].get_function_values(</div><div class="line">               darcy_velocity, velocity_face_values);</div><div class="line">  </div><div class="line">             <span class="keywordtype">double</span> L2_err_flux_face_sqr_local = 0;</div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points_dgrt; ++q)</div><div class="line">               {</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity = velocity_face_values[q];</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> true_velocity =</div><div class="line">                   exact_velocity.value(fe_face_values_dgrt.quadrature_point(q));</div><div class="line">  </div><div class="line">                 <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal =</div><div class="line">                   fe_face_values_dgrt.normal_vector(q);</div><div class="line">  </div><div class="line">                 L2_err_flux_face_sqr_local +=</div><div class="line">                   ((velocity normal</div><div class="line">  </div><div class="line">- true_velocity normal)</div><div class="line">                    (velocity normal</div><div class="line">  </div><div class="line">- true_velocity normal)</div><div class="line">                    fe_face_values_dgrt.JxW(q));</div><div class="line">               }</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">double</span> err_flux_each_face =</div><div class="line">               L2_err_flux_face_sqr_local / face_length cell_area;</div><div class="line">             L2_err_flux_sqr += err_flux_each_face;</div><div class="line">           }</div><div class="line">       }</div></div><!-- fragment --><p>After adding up errors over all cells and faces, we take the square root and get the \(L_2\) errors of velocity and flux. These we output to screen.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> L2_err_velocity_cell =</div><div class="line">    <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(L2_err_velocity_cell_sqr_global);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> L2_err_flux_face = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(L2_err_flux_sqr);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;L2_error_vel:  &quot;</span> &lt;&lt; L2_err_velocity_cell &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;L2_error_flux: &quot;</span> &lt;&lt; L2_err_flux_face &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationoutput_results"></a> </p><h4>WGDarcyEquation::output_results</h4>
<p>We have two sets of results to output: the interior solution and the skeleton solution. We use <code><a class="el" href="classDataOut.html">DataOut</a></code> to visualize interior results. The graphical output for the skeleton results is done by using the <a class="el" href="classDataOutFaces.html">DataOutFaces</a> class. In both of the output files, both the interior and the face variables are stored. For the interface output, the output file simply contains the interpolation of the interior pressures onto the faces, but because it is undefined which of the two interior pressure variables you get from the two adjacent cells, it is best to ignore the interior pressure in the interface output file. Conversely, for the cell interior output file, it is of course impossible to show any interface pressures \(p^\partial\) , because these are only available on interfaces and not cell interiors. Consequently, you will see them shown as an invalid value (such as an infinity). For the cell interior output, we also want to output the velocity variables. This is a bit tricky since it lives on the same mesh but uses a different <a class="el" href="classDoFHandler.html">DoFHandler</a> object (the pressure variables live on the <code>dof_handler</code> object, the Darcy velocity on the <code>dof_handler_dgrt</code> object). Fortunately, there are variations of the <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector()</a> function that allow specifying which <a class="el" href="classDoFHandler.html">DoFHandler</a> a vector corresponds to, and consequently we can visualize the data from both <a class="el" href="classDoFHandler.html">DoFHandler</a> objects within the same file.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  {</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div></div><!-- fragment --><p>First attach the pressure solution to the <a class="el" href="classDataOut.html">DataOut</a> object:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::string&gt; solution_names = {<span class="stringliteral">&quot;interior_pressure&quot;</span>,</div><div class="line">                                                 <span class="stringliteral">&quot;interface_pressure&quot;</span>};</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler, solution, solution_names);</div></div><!-- fragment --><p>Then do the same with the Darcy velocity field, and continue with writing everything out into a file.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> std::vector&lt;std::string&gt; velocity_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    <span class="keyword">const</span> std::vector&lt;</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;</div><div class="line">      velocity_component_interpretation(</div><div class="line">        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_dgrt,</div><div class="line">                             darcy_velocity,</div><div class="line">                             velocity_names,</div><div class="line">                             velocity_component_interpretation);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution_interior.vtu&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classDataOutFaces.html">DataOutFaces&lt;dim&gt;</a> data_out_faces(<span class="keyword">false</span>);</div><div class="line">    data_out_faces.attach_dof_handler(dof_handler);</div><div class="line">    data_out_faces.add_data_vector(solution, <span class="stringliteral">&quot;Pressure_Face&quot;</span>);</div><div class="line">    data_out_faces.build_patches(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    std::ofstream face_output(<span class="stringliteral">&quot;solution_interface.vtu&quot;</span>);</div><div class="line">    data_out_faces.write_vtu(face_output);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationrun"></a> </p><h4>WGDarcyEquation::run</h4>
<p>This is the final function of the main class. It calls the other functions of our class.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WGDarcyEquation&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Solving problem in &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot; space dimensions.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    compute_postprocessed_velocity();</div><div class="line">    compute_pressure_error();</div><div class="line">    compute_velocity_errors();</div><div class="line">    output_results();</div><div class="line">  }</div><div class="line"> </div><div class="line">} <span class="comment">// namespace Step61</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>This is the main function. We can change the dimension here to run in 3d.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step61::WGDarcyEquation&lt;2&gt; wg_darcy(0);</div><div class="line">      wg_darcy.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"> </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>We run the program with a right hand side that will produce thesolution \(p = \sin(\pi x) \sin(\pi y)\) and with homogeneous Dirichletboundary conditions in the domain \(\Omega = (0,1)^2\) . In addition, wechoose the coefficient matrix in the differential operator \(\mathbf{K}\) as the identity matrix. We test this setup using \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) , \(\mbox{WG}(Q_1,Q_1;RT_{[1]})\) and \(\mbox{WG}(Q_2,Q_2;RT_{[2]})\) element combinations, which one canselect by using the appropriate constructor argument for the<code>WGDarcyEquation</code> object in <code>main()</code>. We will then visualize pressurevalues in interiors of cells and on faces. We want to see that thepressure maximum is around 1 and the minimum is around 0. With meshrefinement, the convergence rates of pressure, velocity and fluxshould then be around 1 for \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) , 2 for \(\mbox{WG}(Q_1,Q_1;RT_{[1]})\) , and 3 for \(\mbox{WG}(Q_2,Q_2;RT_{[2]})\) .</p>
<p><a class="anchor" id="TestresultsoniWGQsub0subQsub0subRTsub0subi"></a></p><h3>Test results on <em>WG(Q<sub>0</sub>,Q<sub>0</sub>;RT<sub>[0]</sub>)</em><em>WG(Q<sub>0</sub>,Q<sub>0</sub>;RT<sub>[0]</sub>)</em></h3>
<p>The following figures show interior pressures and face pressures using the \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) element. The mesh is refined 2 times (top)and 4 times (bottom), respectively. (This number can be adjusted in the<code>make_grid()</code> function.) When the mesh is coarse, one can seethe face pressures \(p^\partial\) neatly between the values of the interiorpressures \(p^\circ\) on the two adjacent cells. </p><table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg000_2d_2.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg000_3d_2.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg000_2d_4.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg000_3d_4.png"/>
</div>
  </td></tr>
</table>
<p>From the figures, we can see that with the mesh refinement, the maximum andminimum pressure values are approaching the values we expect.Since the mesh is a rectangular mesh and numbers of cells in each direction is even, wehave symmetric solutions. From the 3d figures on the right,we can see that on \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) , the pressure is a constantin the interior of the cell, as expected. <a class="anchor" id="Convergencetableforik0i"></a></p><h4>Convergence table for <em>k=0</em><em>k=0</em></h4>
<p>We run the code with differently refined meshes (chosen in the <code>make_grid()</code> function)and get the following convergence rates of pressure,velocity, and flux (as defined in the introduction). </p><table align="center" class="doxtable">
<tr>
<th>number of refinements </th><th>\(\|p-p_h^\circ\|\) </th><th>\(\|\mathbf{u}-\mathbf{u}_h\|\) </th><th>\(\|(\mathbf{u}-\mathbf{u}_h) \cdot \mathbf{n}\|\)   </th></tr>
<tr>
<td>2 </td><td>1.587e-01 </td><td>5.113e-01 </td><td>7.062e-01   </td></tr>
<tr>
<td>3 </td><td>8.000e-02 </td><td>2.529e-01 </td><td>3.554e-01   </td></tr>
<tr>
<td>4 </td><td>4.006e-02 </td><td>1.260e-01 </td><td>1.780e-01   </td></tr>
<tr>
<td>5 </td><td>2.004e-02 </td><td>6.297e-02 </td><td>8.902e-02   </td></tr>
<tr>
<th>Conv.rate </th><th>1.00 </th><th>1.00 </th><th>1.00   </th></tr>
</table>
<p>We can see that the convergence rates of \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) are around 1.This, of course, matches our theoretical expectations.</p>
<p><a class="anchor" id="TestresultsoniWGQsub1subQsub1subRTsub1subi"></a></p><h3>Test results on <em>WG(Q<sub>1</sub>,Q<sub>1</sub>;RT<sub>[1]</sub>)</em><em>WG(Q<sub>1</sub>,Q<sub>1</sub>;RT<sub>[1]</sub>)</em></h3>
<p>We can repeat the experiment from above using the next higher polynomialdegree:The following figures are interior pressures and face pressures implemented using \(\mbox{WG}(Q_1,Q_1;RT_{[1]})\) . The mesh is refined 4 times. Compared to theprevious figures using \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) , on each cell, the solution is no longer constanton each cell, as we now use bilinear polynomials to do the approximation.Consequently, there are 4 pressure values in one interior, 2 pressure values oneach face. </p><table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg111_2d_4.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg111_3d_4.png"/>
</div>
  </td></tr>
</table>
<p>Compared to the corresponding image for the \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) combination, the solution is now substantially more accurate and, inparticular so close to being continuous at the interfaces that we canno longer distinguish the interface pressures \(p^\partial\) from theinterior pressures \(p^\circ\) on the adjacent cells. <a class="anchor" id="Convergencetableforik1i"></a></p><h4>Convergence table for <em>k=1</em><em>k=1</em></h4>
<p>The following are the convergence rates of pressure, velocity, and fluxwe obtain from using the \(\mbox{WG}(Q_1,Q_1;RT_{[1]})\) element combination: </p><table align="center" class="doxtable">
<tr>
<th>number of refinements </th><th>\(\|p-p_h^\circ\|\) </th><th>\(\|\mathbf{u}-\mathbf{u}_h\|\) </th><th>\(\|(\mathbf{u}-\mathbf{u}_h) \cdot \mathbf{n}\|\)   </th></tr>
<tr>
<td>2 </td><td>1.613e-02 </td><td>5.093e-02 </td><td>7.167e-02   </td></tr>
<tr>
<td>3 </td><td>4.056e-03 </td><td>1.276e-02 </td><td>1.802e-02   </td></tr>
<tr>
<td>4 </td><td>1.015e-03 </td><td>3.191e-03 </td><td>4.512e-03   </td></tr>
<tr>
<td>5 </td><td>2.540e-04 </td><td>7.979e-04 </td><td>1.128e-03   </td></tr>
<tr>
<th>Conv.rate </th><th>2.00 </th><th>2.00 </th><th>2.00   </th></tr>
</table>
<p>The convergence rates of \(WG(Q_1,Q_1;RT_{[1]})\) are around 2, as expected.</p>
<p><a class="anchor" id="TestresultsoniWGQsub2subQsub2subRTsub2subi"></a></p><h3>Test results on <em>WG(Q<sub>2</sub>,Q<sub>2</sub>;RT<sub>[2]</sub>)</em><em>WG(Q<sub>2</sub>,Q<sub>2</sub>;RT<sub>[2]</sub>)</em></h3>
<p>Let us go one polynomial degree higher.The following are interior pressures and face pressures implemented using \(WG(Q_2,Q_2;RT_{[2]})\) , with mesh size \(h = 1/32\) (i.e., 5 global meshrefinement steps). In the program, we use<code>data_out_face.build_patches(fe.degree)</code> when generating graphical output(see the documentation of   DataOut::build_patches()), which here implies thatwe divide each 2d cell interior into 4 subcells in order to provide a bettervisualization of the quadratic polynomials. </p><table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg222_2d_5.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg222_3d_5.png"/>
</div>
  </td></tr>
</table>
<p><a class="anchor" id="Convergencetableforik2i"></a></p><h4>Convergence table for <em>k=2</em><em>k=2</em></h4>
<p>As before, we can generate convergence data for the \(L_2\) errors of pressure, velocity, and fluxusing the \(\mbox{WG}(Q_2,Q_2;RT_{[2]})\) combination: </p><table align="center" class="doxtable">
<tr>
<th>number of refinements </th><th>\(\|p-p_h^\circ\|\) </th><th>\(\|\mathbf{u}-\mathbf{u}_h\|\) </th><th>\(\|(\mathbf{u}-\mathbf{u}_h) \cdot \mathbf{n}\|\)   </th></tr>
<tr>
<td>2 </td><td>1.072e-03 </td><td>3.375e-03 </td><td>4.762e-03   </td></tr>
<tr>
<td>3 </td><td>1.347e-04 </td><td>4.233e-04 </td><td>5.982e-04   </td></tr>
<tr>
<td>4 </td><td>1.685e-05 </td><td>5.295e-05 </td><td>7.487e-05   </td></tr>
<tr>
<td>5 </td><td>2.107e-06 </td><td>6.620e-06 </td><td>9.362e-06   </td></tr>
<tr>
<th>Conv.rate </th><th>3.00 </th><th>3.00 </th><th>3.00   </th></tr>
</table>
<p>Once more, the convergence rates of \(\mbox{WG}(Q_2,Q_2;RT_{[2]})\) isas expected, with values around 3.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2018 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *      Author: Zhuoran Wang, Colorado State University, 2018</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2quadrature_8h.html">deal.II/base/quadrature.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2point_8h.html">deal.II/base/point.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__raviart__thomas_8h.html">deal.II/fe/fe_raviart_thomas.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dg__vector_8h.html">deal.II/fe/fe_dg_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__face_8h.html">deal.II/fe/fe_face.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="component__mask_8h.html">deal.II/fe/component_mask.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="data__out__faces_8h.html">deal.II/numerics/data_out_faces.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step61</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>WGDarcyEquation</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    WGDarcyEquation(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> compute_postprocessed_velocity();</div><div class="line">    <span class="keywordtype">void</span> compute_velocity_errors();</div><div class="line">    <span class="keywordtype">void</span> compute_pressure_error();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>   fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classFE__DGRaviartThomas.html">FE_DGRaviartThomas&lt;dim&gt;</a> fe_dgrt;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>         dof_handler_dgrt;</div><div class="line">    Vector&lt;double&gt;          darcy_velocity;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Coefficient()</div><div class="line">      : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                            std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;values) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Coefficient&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                    std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">      values[p] = unit_symmetric_tensor&lt;dim&gt;();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (2 * numbers::PI * numbers::PI * std::sin(numbers::PI * p[0]) *</div><div class="line">            std::sin(numbers::PI * p[1]));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ExactPressure : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ExactPressure()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> ExactPressure&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[0]) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[1]);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ExactVelocity : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ExactVelocity()</div><div class="line">      : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ExactVelocity&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> return_value;</div><div class="line">    return_value[0] = -numbers::PI * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI * p[0]) *</div><div class="line">                      <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[1]);</div><div class="line">    return_value[1] = -numbers::PI * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[0]) *</div><div class="line">                      <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI * p[1]);</div><div class="line">    <span class="keywordflow">return</span> return_value;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  WGDarcyEquation&lt;dim&gt;::WGDarcyEquation(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1, <a class="code" href="classFE__FaceQ.html">FE_FaceQ</a>&lt;dim&gt;(degree), 1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , fe_dgrt(degree)</div><div class="line">    , dof_handler_dgrt(triangulation)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(5);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    dof_handler_dgrt.distribute_dofs(fe_dgrt);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of pressure degrees of freedom: &quot;</span></div><div class="line">              &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line"></div><div class="line">    {</div><div class="line">      constraints.clear();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> interface_pressure(1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a>              interface_pressure_mask =</div><div class="line">        fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(interface_pressure);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               0,</div><div class="line">                                               BoundaryValues&lt;dim&gt;(),</div><div class="line">                                               constraints,</div><div class="line">                                               interface_pressure_mask);</div><div class="line">      constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values_dgrt(fe_dgrt,</div><div class="line">                                 quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                          face_quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell      = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = fe_face_values.<a class="code" href="classFEFaceValuesBase.html#ab460150cda793c93abfc6eac1314de31">get_quadrature</a>().<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    RightHandSide&lt;dim&gt;  right_hand_side;</div><div class="line">    std::vector&lt;double&gt; right_hand_side_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Coefficient&lt;dim&gt;      coefficient;</div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; coefficient_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_solution(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_interior(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_face(1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell_dgrt =</div><div class="line">          cell;</div><div class="line">        fe_values_dgrt.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(cell_dgrt);</div><div class="line"></div><div class="line">        right_hand_side.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                   right_hand_side_values);</div><div class="line">        coefficient.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                               coefficient_values);</div><div class="line"></div><div class="line">        cell_matrix_M = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i = fe_values_dgrt[velocities].value(i, q);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">                    fe_values_dgrt[velocities].value(k, q);</div><div class="line">                  cell_matrix_M(i, k) += (v_i * v_k * fe_values_dgrt.JxW(q));</div><div class="line">                }</div><div class="line">            }</div><div class="line">        cell_matrix_M.gauss_jordan();</div><div class="line"></div><div class="line">        cell_matrix_G = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> div_v_i =</div><div class="line">                fe_values_dgrt[velocities].divergence(i, q);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_interior =</div><div class="line">                    fe_values[pressure_interior].value(j, q);</div><div class="line"></div><div class="line">                  cell_matrix_G(i, j) -=</div><div class="line">                    (div_v_i * phi_j_interior * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">            fe_face_values_dgrt.reinit(cell_dgrt, face);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal = fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i =</div><div class="line">                      fe_face_values_dgrt[velocities].value(i, q);</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_face =</div><div class="line">                          fe_face_values[pressure_face].value(j, q);</div><div class="line"></div><div class="line">                        cell_matrix_G(i, j) +=</div><div class="line">                          ((v_i * normal) * phi_j_face * fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M);</div><div class="line"></div><div class="line">        local_matrix = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">                  fe_values_dgrt[velocities].value(k, q);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dofs_per_cell_dgrt; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_l =</div><div class="line">                      fe_values_dgrt[velocities].value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q);</div><div class="line"></div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                        local_matrix(i, j) +=</div><div class="line">                          (coefficient_values[q] * cell_matrix_C[i][k] * v_k) *</div><div class="line">                          cell_matrix_C[j][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] * v_l * fe_values_dgrt.JxW(q);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell_rhs = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              cell_rhs(i) += (fe_values[pressure_interior].value(i, q) *</div><div class="line">                              right_hand_side_values[q] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.distribute_local_to_global(</div><div class="line">          local_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-8 * system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">    solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">    constraints.distribute(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_postprocessed_velocity()</div><div class="line">  {</div><div class="line">    darcy_velocity.reinit(dof_handler_dgrt.n_dofs());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_dgrt(fe_dgrt,</div><div class="line">                                 quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                          face_quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell      = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = fe_face_values.<a class="code" href="classFEFaceValuesBase.html#ab460150cda793c93abfc6eac1314de31">get_quadrature</a>().<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices_dgrt(</div><div class="line">      dofs_per_cell_dgrt);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_D(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_E(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; cell_solution(dofs_per_cell);</div><div class="line">    Vector&lt;double&gt; cell_velocity(dofs_per_cell_dgrt);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Coefficient&lt;dim&gt;      coefficient;</div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; coefficient_values(n_q_points_dgrt);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_interior(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_face(1);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">      cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">      endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(), cell_dgrt = dof_handler_dgrt.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++cell_dgrt)</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values_dgrt.reinit(cell_dgrt);</div><div class="line"></div><div class="line">        coefficient.value_list(fe_values_dgrt.get_quadrature_points(),</div><div class="line">                               coefficient_values);</div><div class="line"></div><div class="line">        cell_matrix_M = 0;</div><div class="line">        cell_matrix_E = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i = fe_values_dgrt[velocities].value(i, q);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">                    fe_values_dgrt[velocities].value(k, q);</div><div class="line"></div><div class="line">                  cell_matrix_E(i, k) +=</div><div class="line">                    (coefficient_values[q] * v_i * v_k * fe_values_dgrt.JxW(q));</div><div class="line"></div><div class="line">                  cell_matrix_M(i, k) += (v_i * v_k * fe_values_dgrt.JxW(q));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        cell_matrix_M.gauss_jordan();</div><div class="line">        cell_matrix_M.mmult(cell_matrix_D, cell_matrix_E);</div><div class="line"></div><div class="line">        cell_matrix_G = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> div_v_i =</div><div class="line">                fe_values_dgrt[velocities].divergence(i, q);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_interior =</div><div class="line">                    fe_values[pressure_interior].value(j, q);</div><div class="line"></div><div class="line">                  cell_matrix_G(i, j) -=</div><div class="line">                    (div_v_i * phi_j_interior * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">            fe_face_values_dgrt.reinit(cell_dgrt, face);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal = fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i =</div><div class="line">                      fe_face_values_dgrt[velocities].value(i, q);</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_face =</div><div class="line">                          fe_face_values[pressure_face].value(j, q);</div><div class="line"></div><div class="line">                        cell_matrix_G(i, j) +=</div><div class="line">                          ((v_i * normal) * phi_j_face * fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">        cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M);</div><div class="line"></div><div class="line">        cell-&gt;get_dof_values(solution, cell_solution);</div><div class="line"></div><div class="line">        cell_velocity = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell_dgrt; ++j)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              cell_velocity(k) +=</div><div class="line">                -(cell_solution(i) * cell_matrix_C(i, j) * cell_matrix_D(k, j));</div><div class="line"></div><div class="line">        cell_dgrt-&gt;get_dof_indices(local_dof_indices_dgrt);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell_dgrt; ++j)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              darcy_velocity(local_dof_indices_dgrt[k]) +=</div><div class="line">                -(cell_solution(i) * cell_matrix_C(i, j) * cell_matrix_D(k, j));</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_pressure_error()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> select_interior_pressure(0, 2);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler,</div><div class="line">                                      solution,</div><div class="line">                                      ExactPressure&lt;dim&gt;(),</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                      &amp;select_interior_pressure);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> L2_error = difference_per_cell.l2_norm();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;L2_error_pressure &quot;</span> &lt;&lt; L2_error &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_velocity_errors()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_dgrt(fe_dgrt,</div><div class="line">                                 quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                          face_quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points_dgrt =</div><div class="line">      fe_face_values_dgrt.get_quadrature().size();</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points_dgrt);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_face_values(n_face_q_points_dgrt);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ExactVelocity&lt;dim&gt; exact_velocity;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> L2_err_velocity_cell_sqr_global = 0;</div><div class="line">    <span class="keywordtype">double</span> L2_err_flux_sqr                 = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell_dgrt : dof_handler_dgrt.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values_dgrt.reinit(cell_dgrt);</div><div class="line"></div><div class="line">        fe_values_dgrt[velocities].get_function_values(darcy_velocity,</div><div class="line">                                                       velocity_values);</div><div class="line">        <span class="keywordtype">double</span> L2_err_velocity_cell_sqr_local = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity = velocity_values[q];</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> true_velocity =</div><div class="line">              exact_velocity.value(fe_values_dgrt.quadrature_point(q));</div><div class="line"></div><div class="line">            L2_err_velocity_cell_sqr_local +=</div><div class="line">              ((velocity - true_velocity) * (velocity - true_velocity) *</div><div class="line">               fe_values_dgrt.JxW(q));</div><div class="line">          }</div><div class="line">        L2_err_velocity_cell_sqr_global += L2_err_velocity_cell_sqr_local;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> cell_area = cell_dgrt-&gt;measure();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face_dgrt : cell_dgrt-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> face_length = face_dgrt-&gt;measure();</div><div class="line">            fe_face_values_dgrt.reinit(cell_dgrt, face_dgrt);</div><div class="line">            fe_face_values_dgrt[velocities].get_function_values(</div><div class="line">              darcy_velocity, velocity_face_values);</div><div class="line"></div><div class="line">            <span class="keywordtype">double</span> L2_err_flux_face_sqr_local = 0;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points_dgrt; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity = velocity_face_values[q];</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> true_velocity =</div><div class="line">                  exact_velocity.value(fe_face_values_dgrt.quadrature_point(q));</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal =</div><div class="line">                  fe_face_values_dgrt.normal_vector(q);</div><div class="line"></div><div class="line">                L2_err_flux_face_sqr_local +=</div><div class="line">                  ((velocity * normal - true_velocity * normal) *</div><div class="line">                   (velocity * normal - true_velocity * normal) *</div><div class="line">                   fe_face_values_dgrt.JxW(q));</div><div class="line">              }</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> err_flux_each_face =</div><div class="line">              L2_err_flux_face_sqr_local / face_length * cell_area;</div><div class="line">            L2_err_flux_sqr += err_flux_each_face;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> L2_err_velocity_cell =</div><div class="line">      <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(L2_err_velocity_cell_sqr_global);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> L2_err_flux_face = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(L2_err_flux_sqr);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;L2_error_vel:  &quot;</span> &lt;&lt; L2_err_velocity_cell &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;L2_error_flux: &quot;</span> &lt;&lt; L2_err_flux_face &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    {</div><div class="line">      <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt; solution_names = {<span class="stringliteral">&quot;interior_pressure&quot;</span>,</div><div class="line">                                                       <span class="stringliteral">&quot;interface_pressure&quot;</span>};</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler, solution, solution_names);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt; velocity_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">      <span class="keyword">const</span> std::vector&lt;</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;</div><div class="line">        velocity_component_interpretation(</div><div class="line">          dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_dgrt,</div><div class="line">                               darcy_velocity,</div><div class="line">                               velocity_names,</div><div class="line">                               velocity_component_interpretation);</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">      std::ofstream output(<span class="stringliteral">&quot;solution_interior.vtu&quot;</span>);</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classDataOutFaces.html">DataOutFaces&lt;dim&gt;</a> data_out_faces(<span class="keyword">false</span>);</div><div class="line">      data_out_faces.attach_dof_handler(dof_handler);</div><div class="line">      data_out_faces.add_data_vector(solution, <span class="stringliteral">&quot;Pressure_Face&quot;</span>);</div><div class="line">      data_out_faces.build_patches(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">      std::ofstream face_output(<span class="stringliteral">&quot;solution_interface.vtu&quot;</span>);</div><div class="line">      data_out_faces.write_vtu(face_output);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WGDarcyEquation&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Solving problem in &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot; space dimensions.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    compute_postprocessed_velocity();</div><div class="line">    compute_pressure_error();</div><div class="line">    compute_velocity_errors();</div><div class="line">    output_results();</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace Step61</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step61::WGDarcyEquation&lt;2&gt; wg_darcy(0);</div><div class="line">      wg_darcy.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_51.html">step-51</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#WeakGalerkinfiniteelementmethods"> Weak Galerkin finite element methods </a>
        <li><a href="#Theequationtosolve"> The equation to solve </a>
        <li><a href="#WeakGalerkinscheme"> Weak Galerkin scheme </a>
        <li><a href="#Representingtheweakgradient"> Representing the weak gradient </a>
        <li><a href="#Assemblingthelinearsystem"> Assembling the linear system </a>
        <li><a href="#PostprocessingandiLsub2subiiLsub2subierrors"> Post-processing and <i>L<sub>2</sub></i><i>L<sub>2</sub></i>-errors </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#TheWGDarcyEquationclasstemplate">The WGDarcyEquation class template</a>
        <li><a href="#Righthandsideboundaryvaluesandexactsolution">Right hand side, boundary values, and exact solution</a>
        <li><a href="#WGDarcyEquationclassimplementation">WGDarcyEquation class implementation</a>
      <ul>
        <li><a href="#WGDarcyEquationWGDarcyEquation">WGDarcyEquation::WGDarcyEquation</a>
        <li><a href="#WGDarcyEquationmake_grid">WGDarcyEquation::make_grid</a>
        <li><a href="#WGDarcyEquationsetup_system">WGDarcyEquation::setup_system</a>
        <li><a href="#WGDarcyEquationassemble_system">WGDarcyEquation::assemble_system</a>
        <li><a href="#WGDarcyEquationdimsolve">WGDarcyEquation<dim>::solve</a>
        <li><a href="#WGDarcyEquationdimcompute_postprocessed_velocity">WGDarcyEquation<dim>::compute_postprocessed_velocity</a>
        <li><a href="#WGDarcyEquationdimcompute_pressure_error">WGDarcyEquation<dim>::compute_pressure_error</a>
        <li><a href="#WGDarcyEquationdimcompute_velocity_error">WGDarcyEquation<dim>::compute_velocity_error</a>
        <li><a href="#WGDarcyEquationoutput_results">WGDarcyEquation::output_results</a>
        <li><a href="#WGDarcyEquationrun">WGDarcyEquation::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#TestresultsoniWGQsub0subQsub0subRTsub0subiiWGQsub0subQsub0subRTsub0subi">Test results on <i>WG(Q<sub>0</sub>,Q<sub>0</sub>;RT<sub>[0]</sub>)</i><i>WG(Q<sub>0</sub>,Q<sub>0</sub>;RT<sub>[0]</sub>)</i></a>
      <ul>
        <li><a href="#Convergencetableforik0iik0i">Convergence table for <i>k=0</i><i>k=0</i></a>
      </ul>
        <li><a href="#TestresultsoniWGQsub1subQsub1subRTsub1subiiWGQsub1subQsub1subRTsub1subi">Test results on <i>WG(Q<sub>1</sub>,Q<sub>1</sub>;RT<sub>[1]</sub>)</i><i>WG(Q<sub>1</sub>,Q<sub>1</sub>;RT<sub>[1]</sub>)</i></a>
      <ul>
        <li><a href="#Convergencetableforik1iik1i">Convergence table for <i>k=1</i><i>k=1</i></a>
      </ul>
        <li><a href="#TestresultsoniWGQsub2subQsub2subRTsub2subiiWGQsub2subQsub2subRTsub2subi">Test results on <i>WG(Q<sub>2</sub>,Q<sub>2</sub>;RT<sub>[2]</sub>)</i><i>WG(Q<sub>2</sub>,Q<sub>2</sub>;RT<sub>[2]</sub>)</i></a>
      <ul>
        <li><a href="#Convergencetableforik2iik2i">Convergence table for <i>k=2</i><i>k=2</i></a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-61/doc/intro.dox</p>
<p><br />
</p>
<p><em> This program was contributed by Zhuoran Wang. Some more information about this program, as well as more numerical results, are presented in <b>[Wang2019]</b> . </em></p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>本教程程序介绍了泊松方程的 "弱加勒金 "有限元方法的实现。从某种意义上说，考虑这种方法的动机与步骤51中的动机相同：我们想考虑不连续的形状函数，但又需要解决这样一个事实：与通常的连续Galerkin方法相比，所产生的问题有更多的自由度（因为，例如，每个顶点携带的自由度与相邻单元一样多）。我们还必须解决这样一个事实：与连续Galerkin方法不同，<em>every</em>一个单元上的自由度与它的每个面邻单元上的所有自由度相耦合。因此，从 "传统的 "非连续Galerkin方法得到的矩阵既大又相对密集。</p>
<p><a class="el" href="step_51.html">step-51</a>中的混合非连续Galerkin方法（HDG）和本教程中的弱Galerkin（WG）方法都是通过引入额外的自由度来解决耦合问题的，这些自由度的形状函数只存在于单元间的一个面上（即网格的 "骨架 "上），因此它们将相邻单元上的自由度相互 "隔离"：单元自由度只与同一单元上的其他单元自由度以及面自由度耦合，而与相邻单元上的单元自由度不耦合。因此，这些细胞自由度的形状函数的耦合确实正好耦合在一个细胞和定义在其面上的自由度上。</p>
<p>对于一个给定的方程，例如二阶泊松方程，HDG和WG方法的区别在于如何精确地制定连接所有这些不同形状函数的问题。事实上，对于某些WG和HDG的表述，有可能表明它们是等价的）。HDG的做法是用一阶方程系统重新表述二阶问题，然后在概念上把面的自由度看作是这个一阶系统的 "通量"。相比之下，WG方法保持二阶形式，并将面的自由度视为与主解变量相同的类型，只是限制在低维的面。为了方程的目的，在定义对其应用微分算子的含义时，人们需要以某种方式将这些形状函数 "扩展 "到单元的内部。与HDG相比，该方法的优势在于它不会因为将方程重写为一阶系统而导致未知数的增加，但它也不太容易实现。然而，正如我们在下文中所看到的，这种额外的努力并不可怕。</p>
<p><a class="anchor" id="WeakGalerkinfiniteelementmethods"></a></p><h3>Weak Galerkin finite element methods </h3>
<p>弱加勒金有限元方法（WGFEMs）使用离散的弱函数来近似标量未知数，使用离散的弱梯度来近似经典梯度。该方法最初是由王俊平和叶秀在论文<a href="https://doi.org/10.1016/j.cam.2012.10.003"><em>A weak Galerkin finite element method for second order elliptic problems</em><em>A weak Galerkin finite element method for second order elliptic problems</em>, J. Comput. Appl. Math., 103-115, 2013</a>中提出。与连续Galerkin方法相比，弱Galerkin方法满足重要的物理特性，即局部质量守恒和体法通量连续。它的结果是一个SPD线性系统，并且通过网格细化可以获得最佳收敛率。</p>
<p><a class="anchor" id="Theequationtosolve"></a></p><h3>The equation to solve </h3>
<p>该程序使用弱加尔金有限元法求解泊松方程。</p>
<p class="formulaDsp">
\begin{align*} \nabla \cdot \left( -\mathbf{K} \nabla p \right) &amp;= f, \qquad \mathbf{x} \in \Omega, \\ p &amp;= p_D,\qquad \mathbf{x} \in \Gamma^D, \\ \mathbf{u} \cdot \mathbf{n} &amp;= u_N, \qquad \mathbf{x} \in \Gamma^N, \end{align*}
</p>
<p>其中 \(\Omega \subset \mathbb{R}^n (n=2,3)\) 是一个有界域。在流体流经多孔介质的背景下， \(p\) 是压力， \(\mathbf{K}\) 是渗透性张量， \(f\) 是源项， \(p_D, u_N\) 代表Dirichlet和Neumann边界条件。我们可以引入一个通量， \(\mathbf{u} = -\mathbf{K} \nabla p\) ，对应于达西速度（以我们在步骤20中的方式），这个变量在下面的考虑中很重要。</p>
<p>在这个程序中，我们将考虑一个测试案例，即在单位平方域上的确切压力为 \(p = \sin \left( \pi x\right)\sin\left(\pi y \right)\) ，具有同质Dirichelet边界条件和 \(\mathbf{K}\) 身份矩阵。然后我们将计算压力、速度和通量的 \(L_2\) 误差。</p>
<p><a class="anchor" id="WeakGalerkinscheme"></a></p><h3>Weak Galerkin scheme </h3>
<p>上面的泊松方程有一个解 \(p\) ，需要满足问题的弱表述。</p>
<p class="formulaDsp">
\begin{equation*} \mathcal{A}\left(p,q \right) = \mathcal{F} \left(q \right), \end{equation*}
</p>
<p>为所有测试函数 \(q\) ，其中</p>
<p class="formulaDsp">
\begin{equation*} \mathcal{A}\left(p,q\right) \dealcoloneq \int_\Omega \left(\mathbf{K} \nabla p\right) \cdot \nabla q \;\mathrm{d}x, \end{equation*}
</p>
<p>和</p>
<p class="formulaDsp">
\begin{equation*} \mathcal{F}\left(q\right) \dealcoloneq \int_\Omega f \, q \;\mathrm{d}x - \int_{\Gamma^N} u_N q \; \mathrm{d}x. \end{equation*}
</p>
<p>在这里，我们以双线性形式进行了部分积分，我们在内部评估 \(p,p\) 的梯度，在域的边界评估 \(q\) 的值。所有这些都是很好的定义，因为我们假设解是在 \(H^1\) 中，对它来说，取梯度和评估边界值是有效的操作。</p>
<p>弱Galerkin方法的想法是用一个<em>discontinuous function</em> \(p_h\) 来近似精确的 \(p\) 解。这个函数可能只在单元格之间的界面上不连续，由于我们也想沿着界面评估这个函数，我们不仅要规定它在单元格内部应该有什么值，还要规定它在界面上的值。我们通过说 \(p_h\) 实际上是一个元组， \(p_h=(p^\circ,p^\partial)\) ，尽管它实际上只是一个单一的函数，它要么等于 \(p^\circ(x)\) ，要么等于 \(p^\partial(x)\) ，这取决于它是在位于细胞内部还是在细胞界面的某一点 \(x\) 上被评估。</p>
<p>然后我们想把这个近似值简单地贴到上面的双线性表格中。这适用于我们必须在边界上评估测试函数 \(q_h\) 的情况（我们只需取其界面部分 \(q_h^\partial\) ），但我们必须小心处理梯度，因为它只在单元格内部定义。因此，泊松方程的弱Galerkin方案被定义为</p>
<p class="formulaDsp">
\begin{equation*} \mathcal{A}_h\left(p_h,q \right) = \mathcal{F} \left(q_h \right), \end{equation*}
</p>
<p>对于所有离散测试函数 \(q_h\) ，其中</p>
<p class="formulaDsp">
\begin{equation*} \mathcal{A}_h\left(p_h,q_h\right) \dealcoloneq \sum_{K \in \mathbb{T}} \int_K \mathbf{K} \nabla_{w,d} p_h \cdot \nabla_{w,d} q_h \;\mathrm{d}x, \end{equation*}
</p>
<p>和</p>
<p class="formulaDsp">
\begin{equation*} \mathcal{F}\left(q_h\right) \dealcoloneq \sum_{K \in \mathbb{T}} \int_K f \, q_h^\circ \;\mathrm{d}x - \sum_{\gamma \in \Gamma_h^N} \int_\gamma u_N q_h^\partial \;\mathrm{d}x, \end{equation*}
</p>
<p>关键的一点是，在这里，我们用<em>discrete weak gradient</em>算子 \(\nabla_{w,d} p_h\) 代替了梯度 \(\nabla p_h\) ，这对于我们特殊定义的近似 \(p_h\) 是有意义的。</p>
<p>那么问题是该算子如何工作。为此，让我们首先说说我们是如何看待压力的离散近似值 \(p_h\) 的。如上所述，"函数" \(p_h\) 实际上由两部分组成：单元内部的值 \(p_h^\circ\) 和界面上的 \(p_h^\partial\) 。我们必须为这两部分定义离散的（有限维）函数空间；在这个程序中，我们将用FE_DGQ来表示 \(p_h^\circ\) 作为细胞内部的空间（在每个细胞上定义，但一般沿界面是不连续的），用FE_FaceQ表示 \(p_h^\partial\) 作为界面上的空间。</p>
<p>那么让我们只考虑一个单元（因为上面的积分都是逐个单元定义的，而且弱离散梯度是逐个单元定义的）。 \(p_h\) 对 \(K\) , \(p_h|_K\) 的限制由一对 \((p_h^\circ|_K,p_h^\partial|_{\partial K})\) 组成。从本质上讲，我们可以认为 \(\nabla_{w,d} p_h\) 是定义在 \(K\) 上的某个函数，它近似于梯度；特别是，如果 \(p_h|_K\) 是一个可微函数的限制（对 \(K\) 的内部和边界&ndash;这将使它在内部和边界之间连续），那么 \(\nabla_{w,d} p_h\) 将只是精确梯度 \(\nabla p_h\) 。但是，由于 \(p_h|_K\) 在 \(K\) 的内部和边界之间不连续，我们需要一个更一般的定义；此外，我们不能处理任意函数，因此要求 \(\nabla_{w,d} p_h\) 也在一个有限元空间中（由于梯度是一个矢量，必须是矢量值，而且由于弱梯度是在每个单元上单独定义的，因此在单元之间也将是不连续的）。</p>
<p>这样做的方法是以下列方式定义这个弱梯度算子 \(\nabla_{w,d}|_K : DGQ_k(K) \times DGQ_r(\partial K) \rightarrow RT_s(K)\) （其中 \(RT_s(K)\) 是单元格 \(K\) 上阶为 \(s\) 的矢量值Raviart-Thomas空间）。</p>
<p class="formulaDsp">
\begin{equation*} \int_K \mathbf v_h \cdot (\nabla_{w,d} p_h) = -\int_K (\nabla \cdot \mathbf v_h) p_h^\circ +\int_{\partial K} (\mathbf v_h \cdot \mathbf n) p_h^\partial, \end{equation*}
</p>
<p>为所有测试函数 \(\mathbf v_h \in RT_s(K)\) 。从本质上讲，这只是一个逐部积分公式的应用。换句话说，对于一个给定的 \(p_h=(p^\circ_h,p^\partial_h)\) ，我们需要把 \(\nabla_{w,d} p_h|_K\) 看作是度数为 \(s\) 的Raviart-Thomas函数，对于这个函数，左手边和右手边在所有测试函数中是相等的。</p>
<p>那么，需要说明的一个关键点是以下几点。通常的梯度 \(\nabla\) 是一个*本地*算子，它仅仅根据一个函数在某一点及其（无限小）邻域的值来计算导数，而弱离散梯度 \(\nabla_{w,d}\) 却没有这个特性。它取决于它所应用的函数在整个单元上的值，包括单元的边界。然而，两者都是线性算子，从上面 \(\nabla_{w,d}\) 的定义可以看出，这将允许我们在下面的讨论中通过矩阵来表示 \(\nabla_{w,d}\) 。</p>
<dl class="section note"><dt>Note</dt><dd>值得指出的是，虽然弱的离散梯度是Raviart-Thomas空间 \(RT_s(K)\) 在每个单元 \(K\) 的一个元素，但它在单元之间是不连续的。另一方面，定义在整个网格上并由FE_RaviartThomas类实现的Raviart-Thomas空间 \(RT_s=RT_s({\mathbb T})\) 代表在单元间界面上具有连续法线分量的函数。这意味着<em>globally</em>, \(\nabla_{w,d} p_h\) 不在 \(RT_s\) 中，尽管它在 \(K\) 中的每个单元上。 相反，它是在一个 "破碎的 "拉维-托马斯空间中，下面我们将用符号 \(DGRT_s\) 来表示。 这里的术语 "破碎 "指的是 "把东西打碎 "的过程，而不是表达 "没有功能 "的同义词。因此，人们可能会（理所当然地）争辩说，在弱加尔金文献中使用的符号有点误导，但这往往取决于使用某种符号的背景&ndash;在目前的背景下，对Raviart-Thomas空间或元素的提及总是被理解为对 "破碎 "空间的提及。</dd>
<dd>
deal.II恰好有一个实现了这个破碎的Raviart-Thomas空间。FE_DGRT类。因此，在本教程中，我们将简单地一直使用FE_DGRT类，尽管在所有那些我们必须计算单元格本地矩阵和向量的地方，它没有任何区别。</dd></dl>
<p><a class="anchor" id="Representingtheweakgradient"></a></p><h3>Representing the weak gradient </h3>
<p>由于 \(p_h\) 是有限元空间的一个元素，我们可以像往常一样在一个基础上展开它，也就是说，我们可以写出</p>
<p class="formulaDsp">
\begin{equation*} p_h(\mathbf x) = \sum_j P_j \varphi_j(\mathbf x). \end{equation*}
</p>
<p>这里，由于 \(p_h\) 有两个分量（内部分量和界面分量），对于基函数 \(\varphi_j(\mathbf x)\) 也必须如此，我们可以写成 \(\varphi_j = (\varphi_j^\circ,\varphi_j^\partial)\) 。如果你按照步骤8、步骤20和 <a class="el" href="group__vector__valued.html">向量值问题文件模块 </a>中的描述，就不会感到奇怪，对于 \(j\) 的某些值， \(\varphi_j^\circ\) 将为零，而对于 \(j\) 的其他值， \(\varphi_j^\partial\) 将为零&ndash;也就是说，形状函数将是一种或另一种类型。然而，这在这里并不重要。重要的是，我们需要思考如何表示 \(\nabla_{w,d} \varphi_j\) ，因为当我们想实现双线性形式时，这显然是问题中会出现的东西</p>
<p class="formulaDsp">
\begin{equation*} \mathcal{A}_h\left(p_h,q_h\right) = \sum_{K \in \mathbb{T}} \int_K \mathbf{K} \nabla_{w,d} p_h \cdot \nabla_{w,d} q_h \;\mathrm{d}x, \end{equation*}
</p>
<p>关键的一点是，已知 \(\nabla_{w,d} \varphi_j\) 是 "破碎的 "Raviart-Thomas空间 \(DGRT_s\) 的一个成员。这意味着我们可以（在每个单元 \(K\) 上分别表示</p>
<p class="formulaDsp">
\begin{equation*} \nabla_{w,d} \varphi_j|_K = \sum_k C_{jk}^K \mathbf v_k|_K \end{equation*}
</p>
<p>其中，函数 \(\mathbf v_k \in DGRT_s\) ，以及 \(C^K\) 是一个维数的矩阵</p>
<p class="formulaDsp">
\begin{align*} \text{dim}\left(DGQ_k(K) \times DGQ_r(K)\right) &amp;\times \text{dim}\left(RT_s(K)\right) \\ &amp;= \left(\text{dim}(DGQ_k(K)) + \text{dim}(DGQ_r(K))\right) \times \text{dim}\left(RT_s(K)\right). \end{align*}
</p>
<p>弱离散梯度可以被表示为一个矩阵，这不应该是一个惊喜：它是一个从一个有限维空间到另一个有限维空间的线性算子。如果为这两个空间都选择基数，那么<em>every linear operator</em>当然可以写成一个矩阵，将与算子的域空间的基数有关的扩展系数向量映射到与图像空间的基数有关的扩展系数向量）。)</p>
<p>利用这个扩展，我们可以很容易地使用上面的弱离散梯度的定义来定义矩阵要做什么。</p>
<p class="formulaDsp">
\begin{equation*} \int_K \mathbf v_i \cdot \left(\sum_k C_{jk}^K \mathbf v_k\right) = -\int_K (\nabla \cdot \mathbf v_i) \varphi_j^\circ +\int_{\partial K} (\mathbf v_i \cdot \mathbf n) \varphi_j^\partial, \end{equation*}
</p>
<p>对于所有的测试功能 \(\mathbf v_i \in DGRT_s\) 。</p>
<p>这显然导致了一个线性系统，其形式为</p>
<p class="formulaDsp">
\begin{equation*} \sum_k M_{ik}^K C_{jk}^K = G_{ij}^K \end{equation*}
</p>
<p>与</p>
<p class="formulaDsp">
\begin{equation*} M_{ik}^K = \int_K \mathbf v_i \cdot \mathbf v_k, \qquad\qquad G_{ij}^K = -\int_K (\nabla \cdot \mathbf v_i) \varphi_j^\circ +\int_{\partial K} (\mathbf v_i \cdot \mathbf n) \varphi_j^\partial, \end{equation*}
</p>
<p>因此</p>
<p class="formulaDsp">
\begin{equation*} \left(C^K\right)^T = \left(M^K\right)^{-1} G^K. \end{equation*}
</p>
<p>(在这最后一步中，我们假设指数 \(i,j,k\) 只涉及在单元 \(K\) 上活动的自由度，从而确保空间 \(RT_s(K)\) 上的质量矩阵是可逆的。)等价地，利用矩阵 \(M\) 的对称性，我们可以看到</p>
<p class="formulaDsp">
\begin{equation*} C^K = \left(G^K\right)^{T} \left(M^K\right)^{-1}. \end{equation*}
</p>
<p>另外值得指出的是，矩阵 \(C^K\) 和 \(G^K\) 当然不是正方形而是长方形。</p>
<p><a class="anchor" id="Assemblingthelinearsystem"></a></p><h3>Assembling the linear system </h3>
<p>在解释了弱离散梯度是如何定义的之后，我们现在可以回到有关方程的线性系统应该如何组装的问题上。具体来说，利用上面显示的双线性形式 \({\cal A}_h\) 的定义，我们就需要计算局部对全局矩阵的贡献元素。</p>
<p class="formulaDsp">
\begin{equation*} A^K_{ij} = \int_K \left({\mathbf K} \nabla_{w,d} \varphi_i\right) \cdot \nabla_{w,d} \varphi_j. \end{equation*}
</p>
<p>如上所述，我们可以用Raviart-Thomas基础在每个单元格上展开 \(\nabla_{w,d} \varphi_i\) ，同样，对于 \(\nabla_{w,d} \varphi_j\) 也是如此。</p>
<p class="formulaDsp">
\begin{equation*} A^K_{ij} = \int_K \left( {\mathbf K} \sum_k C_{ik}^K \mathbf v_k|_K \right) \cdot \sum_l C_{jl}^K \mathbf v_l|_K. \end{equation*}
</p>
<p>通过重新排列和，可以得到以下表达式。</p>
<p class="formulaDsp">
\begin{equation*} A^K_{ij} = \sum_k \sum_l C_{ik}^K C_{jl}^K \int_K \left( {\mathbf K} \mathbf v_k|_K \right) \cdot \mathbf v_l|_K. \end{equation*}
</p>
<p>因此，如果我们有每个单元格 \(K\) 的矩阵 \(C^K\) ，那么我们可以很容易地计算出单元格 \(K\) 对矩阵 \(A\) 的贡献 \(A^K\) ，如下所示。</p>
<p class="formulaDsp">
\begin{equation*} A^K_{ij} = \sum_k \sum_l C_{ik}^K C_{jl}^K H^K_{kl} = \sum_k \sum_l C_{ik}^K H^K_{kl} C_{jl}^K = \left(C^K H^K (C^K)^T \right)_{ij}. \end{equation*}
</p>
<p>在这里。</p>
<p class="formulaDsp">
\begin{equation*} H^K_{kl} = \int_K \left( {\mathbf K} \mathbf v_k|_K \right) \cdot \mathbf v_l|_K, \end{equation*}
</p>
<p>这实际上只是单元 \(K\) 上的质量矩阵，使用Raviart-Thomas基础并通过渗透性张量 \(\mathbf K\) 加权。这里的推导表明，弱加尔金法实际上只需要我们计算每个单元 \(C^K\) 和 \(H^K\) 的矩阵，然后再计算 \(A^K = C^K H^K (C^K)^T\) ，这很容易计算出来。下面要显示的代码正是这样做的。</p>
<p>在计算出单元格 \(A^K\) 对全局矩阵的贡献后，我们要做的就是将这些局部贡献 "分配 "到全局矩阵中。如何做到这一点，首先显示在步骤3和步骤4中。在目前的程序中，这将通过调用 <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a>. 来促进。</p>
<p>一个线性系统当然也需要一个右手边。除了我们只需要对每个形状函数 \(\varphi_i^\circ\) 使用单元格内部部分外，这里没有与计算右手边有关的困难。</p>
<p><a class="anchor" id="PostprocessingandiLsub2subiiLsub2subierrors"></a></p><h3>Post-processing and <em>L<sub>2</sub></em><em>L<sub>2</sub></em>-errors </h3>
<p>。</p>
<p>前面几节的讨论已经给了我们一个线性系统，我们可以求解数值压力 \(p_h\) 。我们可以用它来计算变量 \(\mathbf u = -{\mathbf K}\nabla p\) 的近似值，如果这是我们要解决的模型，它对应于介质在多孔介质中的流动速度。这种步骤&ndash;从离散问题的解中计算一个派生量&ndash;通常被称为 "后处理"。</p>
<p>这里，我们不使用 \(p_h\) 的精确梯度，而是使用 \(p_h\) 的离散弱梯度来计算每个元素上的速度。如上所述，在每个元素上，数值压力 \(\nabla p\) 的梯度可以用离散弱梯度 \( \nabla_{w,d}\phi_i\) 来近似。</p>
<p class="formulaDsp">
\begin{equation*} \nabla_{w,d} p_h = \nabla_{w,d} \left(\sum_{i} P_i \phi_i\right) = \sum_{i} P_i \nabla_{w,d}\phi_i. \end{equation*}
</p>
<p>在单元格 \(K\) 上，数值速度 \( \mathbf{u}_h = -\mathbf{K} \nabla_{w,d}p_h\) 可写为</p>
<p class="formulaDsp">
\begin{align*} \mathbf{u}_h &amp;= -\mathbf{K} \nabla_{w,d} p_h = -\mathbf{K}\sum_{i} \sum_{j} P_i C^K_{ij}\mathbf{v}_j, \end{align*}
</p>
<p>其中 \(C^K\) 是上面的扩展矩阵， \(\mathbf{v}_j\) 是 \(RT\) 空间在一个单元上的基函数。</p>
<p>不幸的是， \(\mathbf{K} \mathbf{v}_j\) 可能不在 \(RT\) 空间中（当然，除非如果 \(\mathbf K\) 是常数乘以身份矩阵）。因此，为了在有限元程序中表示它，我们需要把它投射回我们可以处理的有限维空间。在这里，我们将使用 \(L_2\) 投影法将其投影回（破碎的） \(RT\) 空间。</p>
<p>我们将每个单元格 \(K\) 上的投影定义为 \( \mathbf{Q}_h \left( \mathbf{K}\mathbf{v}_j \right) = \sum_{k} d_{jk}\mathbf{v}_k\) 。对于任何 \(j\) , \(\left( \mathbf{Q}_h \left( \mathbf{Kv}_j \right),\mathbf{v}_k \right)_K = \left( \mathbf{Kv}_j,\mathbf{v}_k \right)_K.\) 所以，与其说是上面的公式，不如说是 \(K\) 单元上的数字速度变成了</p>
<p class="formulaDsp">
\begin{equation*} \mathbf{u}_h = \mathbf{Q}_h \left( -\mathbf{K}\nabla_{w,d}p_h \right) = -\sum_i \sum_j P_i B^K_{ij}\mathbf{Q}_h \left( \mathbf{K}\mathbf{v}_j \right), \end{equation*}
</p>
<p>我们有以下系统来解决系数问题 \(d_{jk}\) 。</p>
<p class="formulaDsp">
\begin{equation*} \sum_j \left(\mathbf{v}_i,\mathbf{v}_j\right) d_{jk} = \left( \mathbf{Kv}_j,\mathbf{v}_k \right). \end{equation*}
</p>
<p>在下面的实现中，元素为 \( d_{jk} \) 的矩阵被称为 <code>cell_matrix_D</code> ，而元素为 \( \left( \mathbf{Kv}_j,\mathbf{v}_k \right) \) 的矩阵被称为 <code>cell_matrix_E</code> 。</p>
<p>那么元素速度为</p>
<p class="formulaDsp">
\begin{equation*} \mathbf{u}_h = -\sum_{i} \sum_{j}P_ic_{ij}\sum_{k}d_{jk}\mathbf{v}_k = \sum_{k}- \left(\sum_{j} \sum_{i} P_ic_{ij}d_{jk} \right)\mathbf{v}_k, \end{equation*}
</p>
<p>其中 \(-\sum_{j} \sum_{i} P_ic_{ij}d_{jk}\) 在代码中被称为`细胞速度'。</p>
<p>利用这个通过 "后处理 "得到的速度，我们可以通过以下公式定义压力、速度和通量的 \(L_2\) 误差。</p>
<p class="formulaDsp">
\begin{align*} \|p-p_h^\circ\|^2 &amp;= \sum_{K \in \mathbb{T}} \|p-p_h^\circ\|_{L_2(K)}^2, \\ \|\mathbf{u}-\mathbf{u}_h\|^2 &amp;= \sum_{K \in \mathbb{T}} \|\mathbf{u}-\mathbf{u}_h\|_{L_2(K)^2}^d,\\ \|(\mathbf{u}-\mathbf{u}_h) \cdot \mathbf{n}\|^2 &amp;= \sum_{K \in \mathbb{T}} \sum_{\gamma \subset \partial K} \frac{|K|}{|\gamma|} \|\mathbf{u} \cdot \mathbf{n} - \mathbf{u}_h \cdot \mathbf{n}\|_{L_2(\gamma)}^2, \end{align*}
</p>
<p>其中 \(| K |\) 为元素的面积， \(\gamma\) 为元素的面， \(\mathbf{n}\) 为每个面的单位法向量。这些规范中的最后一条衡量了网格单元之间界面上速度向量的法向分量的精度。缩放因子 \(|K|/|\gamma|\) 的选择是为了随着网格大小的变化，缩放出界面集合的长度（或面积）的差异。</p>
<p>上面的第一个错误很容易用 <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>. 计算出来，其他的需要多做一些工作，在下面的代码中实现。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>This program is based on <a class="el" href="step_7.html">step-7</a>, <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_51.html">step-51</a>, so most of the following header files are familiar. We need the following, of which only the one that imports the <a class="el" href="classFE__DGRaviartThomas.html">FE_DGRaviartThomas</a> class (namely, <code>deal.II/fe/fe_dg_vector.h</code>) is really new; the <a class="el" href="classFE__DGRaviartThomas.html">FE_DGRaviartThomas</a> implements the "broken" Raviart-Thomas space discussed in the introduction:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2quadrature_8h.html">deal.II/base/quadrature.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2point_8h.html">deal.II/base/point.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__raviart__thomas_8h.html">deal.II/fe/fe_raviart_thomas.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dg__vector_8h.html">deal.II/fe/fe_dg_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__face_8h.html">deal.II/fe/fe_face.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="component__mask_8h.html">deal.II/fe/component_mask.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="data__out__faces_8h.html">deal.II/numerics/data_out_faces.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>Our first step, as always, is to put everything related to this tutorial program into its own namespace:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step61</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="TheWGDarcyEquationclasstemplate"></a> </p><h3>The WGDarcyEquation class template</h3>
<p>This is the main class of this program. We will solve for the numerical pressure in the interior and on faces using the weak Galerkin (WG) method, and calculate the \(L_2\) error of pressure. In the post-processing step, we will also calculate \(L_2\)-errors of the velocity and flux.</p>
<p>The structure of the class is not fundamentally different from that of previous tutorial programs, so there is little need to comment on the details with one exception: The class has a member variable <code>fe_dgrt</code> that corresponds to the "broken" Raviart-Thomas space mentioned in the introduction. There is a matching <code>dof_handler_dgrt</code> that represents a global enumeration of a finite element field created from this element, and a vector <code>darcy_velocity</code> that holds nodal values for this field. We will use these three variables after solving for the pressure to compute a postprocessed velocity field for which we can then evaluate the error and which we can output for visualization.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>WGDarcyEquation</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  WGDarcyEquation(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> make_grid();</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> compute_postprocessed_velocity();</div><div class="line">  <span class="keywordtype">void</span> compute_velocity_errors();</div><div class="line">  <span class="keywordtype">void</span> compute_pressure_error();</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>   fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; solution;</div><div class="line">  Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">  <a class="code" href="classFE__DGRaviartThomas.html">FE_DGRaviartThomas&lt;dim&gt;</a> fe_dgrt;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>         dof_handler_dgrt;</div><div class="line">  Vector&lt;double&gt;          darcy_velocity;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Righthandsideboundaryvaluesandexactsolution"></a> </p><h3>Right hand side, boundary values, and exact solution</h3>
<p>Next, we define the coefficient matrix \(\mathbf{K}\) (here, the identity matrix), Dirichlet boundary conditions, the right-hand side \(f = 2\pi^2 \sin(\pi x) \sin(\pi y)\), and the exact solution that corresponds to these choices for \(K\) and \(f\), namely \(p = \sin(\pi x) \sin(\pi y)\).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Coefficient()</div><div class="line">    : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classTensorFunction.html#a3afbbe3ba38a517e8a97db9adf2cb340">value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                          std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;values) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> Coefficient&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                  std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">    values[p] = unit_symmetric_tensor&lt;dim&gt;();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> (2 * numbers::PI * numbers::PI * std::sin(numbers::PI * p[0]) *</div><div class="line">          std::sin(numbers::PI * p[1]));</div><div class="line">}</div></div><!-- fragment --><p>The class that implements the exact pressure solution has an oddity in that we implement it as a vector-valued one with two components. (We say that it has two components in the constructor where we call the constructor of the base <a class="el" href="classFunction.html">Function</a> class.) In the <code>value()</code> function, we do not test for the value of the <code>component</code> argument, which implies that we return the same value for both components of the vector-valued function. We do this because we describe the finite element in use in this program as a vector-valued system that contains the interior and the interface pressures, and when we compute errors, we will want to use the same pressure solution to test both of these components.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ExactPressure : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ExactPressure()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> ExactPressure&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[0]) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[1]);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>ExactVelocity : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ExactVelocity()</div><div class="line">    : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;()</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ExactVelocity&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> return_value;</div><div class="line">  return_value[0] = -numbers::PI * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI * p[0]) *</div><div class="line">                    <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[1]);</div><div class="line">  return_value[1] = -numbers::PI * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[0]) *</div><div class="line">                    <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI * p[1]);</div><div class="line">  <span class="keywordflow">return</span> return_value;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationclassimplementation"></a> </p><h3>WGDarcyEquation class implementation</h3>
<p><a class="anchor" id="WGDarcyEquationWGDarcyEquation"></a> </p><h4>WGDarcyEquation::WGDarcyEquation</h4>
<p>In this constructor, we create a finite element space for vector valued functions, which will here include the ones used for the interior and interface pressures, \(p^\circ\) and \(p^\partial\).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">WGDarcyEquation&lt;dim&gt;::WGDarcyEquation(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1, <a class="code" href="classFE__FaceQ.html">FE_FaceQ</a>&lt;dim&gt;(degree), 1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , fe_dgrt(degree)</div><div class="line">  , dof_handler_dgrt(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationmake_grid"></a> </p><h4>WGDarcyEquation::make_grid</h4>
<p>We generate a mesh on the unit square domain and refine it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::make_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(5);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationsetup_system"></a> </p><h4>WGDarcyEquation::setup_system</h4>
<p>After we have created the mesh above, we distribute degrees of freedom and resize matrices and vectors. The only piece of interest in this function is how we interpolate the boundary values for the pressure. Since the pressure consists of interior and interface components, we need to make sure that we only interpolate onto that component of the vector-valued solution space that corresponds to the interface pressures (as these are the only ones that are defined on the boundary of the domain). We do this via a component mask object for only the interface pressures.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  dof_handler_dgrt.distribute_dofs(fe_dgrt);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of pressure degrees of freedom: &quot;</span></div><div class="line">            &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line"></div><div class="line">  {</div><div class="line">    constraints.clear();</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> interface_pressure(1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a>              interface_pressure_mask =</div><div class="line">      fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(interface_pressure);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             constraints,</div><div class="line">                                             interface_pressure_mask);</div><div class="line">    constraints.close();</div><div class="line">  }</div></div><!-- fragment --><p>In the bilinear form, there is no integration term over faces between two neighboring cells, so we can just use <code><a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></code> to calculate the sparse matrix.</p>
<div class="fragment"><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints);</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationassemble_system"></a> </p><h4>WGDarcyEquation::assemble_system</h4>
<p>This function is more interesting. As detailed in the introduction, the assembly of the linear system requires us to evaluate the weak gradient of the shape functions, which is an element in the Raviart-Thomas space. As a consequence, we need to define a Raviart-Thomas finite element object, and have <a class="el" href="classFEValues.html">FEValues</a> objects that evaluate it at quadrature points. We then need to compute the matrix \(C^K\) on every cell \(K\), for which we need the matrices \(M^K\) and \(G^K\) mentioned in the introduction.</p>
<p>A point that may not be obvious is that in all previous tutorial programs, we have always called <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> with a cell iterator from a <a class="el" href="classDoFHandler.html">DoFHandler</a>. This is so that one can call functions such as <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> that extract the values of a finite element function (represented by a vector of DoF values) on the quadrature points of a cell. For this operation to work, one needs to know which vector elements correspond to the degrees of freedom on a given cell &ndash; i.e., exactly the kind of information and operation provided by the <a class="el" href="classDoFHandler.html">DoFHandler</a> class.</p>
<p>We could create a <a class="el" href="classDoFHandler.html">DoFHandler</a> object for the "broken" Raviart-Thomas space (using the FE_DGRT class), but we really don't want to here: At least in the current function, we have no need for any globally defined degrees of freedom associated with this broken space, but really only need to reference the shape functions of such a space on the current cell. As a consequence, we use the fact that one can call <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> also with cell iterators into <a class="el" href="classTriangulation.html">Triangulation</a> objects (rather than <a class="el" href="classDoFHandler.html">DoFHandler</a> objects). In this case, <a class="el" href="classFEValues.html">FEValues</a> can of course only provide us with information that only references information about cells, rather than degrees of freedom enumerated on these cells. So we can't use <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a>, but we can use <a class="el" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">FEValues::shape_value()</a> to obtain the values of shape functions at quadrature points on the current cell. It is this kind of functionality we will make use of below. The variable that will give us this information about the Raviart-Thomas functions below is then the <code>fe_values_rt</code> (and corresponding <code>fe_face_values_rt</code>) object.</p>
<p>Given this introduction, the following declarations should be pretty obvious:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values_dgrt(fe_dgrt,</div><div class="line">                               quadrature_formula,</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                        face_quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell      = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = fe_face_values.<a class="code" href="classFEFaceValuesBase.html#ab460150cda793c93abfc6eac1314de31">get_quadrature</a>().<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  RightHandSide&lt;dim&gt;  right_hand_side;</div><div class="line">  std::vector&lt;double&gt; right_hand_side_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Coefficient&lt;dim&gt;      coefficient;</div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt;&gt; coefficient_values(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div></div><!-- fragment --><p>Next, let us declare the various cell matrices discussed in the introduction:</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">Vector&lt;double&gt;     cell_solution(dofs_per_cell);</div></div><!-- fragment --><p>We need <code><a class="el" href="namespaceFEValuesExtractors.html">FEValuesExtractors</a></code> to access the <code>interior</code> and <code>face</code> component of the shape functions.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_interior(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_face(1);</div></div><!-- fragment --><p>This finally gets us in position to loop over all cells. On each cell, we will first calculate the various cell matrices used to construct the local matrix &ndash; as they depend on the cell in question, they need to be re-computed on each cell. We need shape functions for the Raviart-Thomas space as well, for which we need to create first an iterator to the cell of the triangulation, which we can obtain by assignment from the cell pointing into the <a class="el" href="classDoFHandler.html">DoFHandler</a>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell_dgrt =</div><div class="line">      cell;</div><div class="line">    fe_values_dgrt.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(cell_dgrt);</div><div class="line"></div><div class="line">    right_hand_side.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                               right_hand_side_values);</div><div class="line">    coefficient.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                           coefficient_values);</div></div><!-- fragment --><p>The first cell matrix we will compute is the mass matrix for the Raviart-Thomas space. Hence, we need to loop over all the quadrature points for the velocity <a class="el" href="classFEValues.html">FEValues</a> object.</p>
<div class="fragment"><div class="line">cell_matrix_M = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i = fe_values_dgrt[velocities].value(i, q);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">            fe_values_dgrt[velocities].value(k, q);</div><div class="line">          cell_matrix_M(i, k) += (v_i * v_k * fe_values_dgrt.JxW(q));</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>Next we take the inverse of this matrix by using <a class="el" href="classFullMatrix.html#a898466c57e11e6f2599165071ffe5df3">FullMatrix::gauss_jordan()</a>. It will be used to calculate the coefficient matrix \(C^K\) later. It is worth recalling later that <code>cell_matrix_M</code> actually contains the <em>inverse</em> of \(M^K\) after this call.</p>
<div class="fragment"><div class="line">cell_matrix_M.gauss_jordan();</div></div><!-- fragment --><p>From the introduction, we know that the right hand side \(G^K\) of the equation that defines \(C^K\) is the difference between a face integral and a cell integral. Here, we approximate the negative of the contribution in the interior. Each component of this matrix is the integral of a product between a basis function of the polynomial space and the divergence of a basis function of the Raviart-Thomas space. These basis functions are defined in the interior.</p>
<div class="fragment"><div class="line">cell_matrix_G = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> div_v_i =</div><div class="line">        fe_values_dgrt[velocities].divergence(i, q);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_interior =</div><div class="line">            fe_values[pressure_interior].value(j, q);</div><div class="line"></div><div class="line">          cell_matrix_G(i, j) -=</div><div class="line">            (div_v_i * phi_j_interior * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>Next, we approximate the integral on faces by quadrature. Each component is the integral of a product between a basis function of the polynomial space and the dot product of a basis function of the Raviart-Thomas space and the normal vector. So we loop over all the faces of the element and obtain the normal vector.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">  {</div><div class="line">    fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">    fe_face_values_dgrt.reinit(cell_dgrt, face);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal = fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i =</div><div class="line">              fe_face_values_dgrt[velocities].value(i, q);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_face =</div><div class="line">                  fe_face_values[pressure_face].value(j, q);</div><div class="line"></div><div class="line">                cell_matrix_G(i, j) +=</div><div class="line">                  ((v_i * normal) * phi_j_face * fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p><code>cell_matrix_C</code> is then the matrix product between the transpose of \(G^K\) and the inverse of the mass matrix (where this inverse is stored in <code>cell_matrix_M</code>):</p>
<div class="fragment"><div class="line">cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M);</div></div><!-- fragment --><p>Finally we can compute the local matrix \(A^K\). Element \(A^K_{ij}\) is given by \(\int_{E} \sum_{k,l} C_{ik} C_{jl} (\mathbf{K} \mathbf{v}_k) \cdot \mathbf{v}_l \mathrm{d}x\). We have calculated the coefficients \(C\) in the previous step, and so obtain the following after suitably re-arranging the loops:</p>
<div class="fragment"><div class="line">local_matrix = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">          fe_values_dgrt[velocities].value(k, q);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dofs_per_cell_dgrt; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_l =</div><div class="line">              fe_values_dgrt[velocities].value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                local_matrix(i, j) +=</div><div class="line">                  (coefficient_values[q] * cell_matrix_C[i][k] * v_k) *</div><div class="line">                  cell_matrix_C[j][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] * v_l * fe_values_dgrt.JxW(q);</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>Next, we calculate the right hand side, \(\int_{K} f q \mathrm{d}x\):</p>
<div class="fragment"><div class="line">cell_rhs = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      cell_rhs(i) += (fe_values[pressure_interior].value(i, q) *</div><div class="line">                      right_hand_side_values[q] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">    }</div></div><!-- fragment --><p>The last step is to distribute components of the local matrix into the system matrix and transfer components of the cell right hand side into the system right hand side:</p>
<div class="fragment"><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      constraints.distribute_local_to_global(</div><div class="line">        local_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationdimsolve"></a> </p><h4>WGDarcyEquation&lt;dim&gt;::solve</h4>
<p>This step is rather trivial and the same as in many previous tutorial programs:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-8 * system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">  solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">  constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationdimcompute_postprocessed_velocity"></a> </p><h4>WGDarcyEquation&lt;dim&gt;::compute_postprocessed_velocity</h4>
<p>In this function, compute the velocity field from the pressure solution previously computed. The velocity is defined as \(\mathbf{u}_h = \mathbf{Q}_h \left( -\mathbf{K}\nabla_{w,d}p_h \right)\), which requires us to compute many of the same terms as in the assembly of the system matrix. There are also the matrices \(E^K,D^K\) we need to assemble (see the introduction) but they really just follow the same kind of pattern.</p>
<p>Computing the same matrices here as we have already done in the <code>assemble_system()</code> function is of course wasteful in terms of CPU time. Likewise, we copy some of the code from there to this function, and this is also generally a poor idea. A better implementation might provide for a function that encapsulates this duplicated code. One could also think of using the classic trade-off between computing efficiency and memory efficiency to only compute the \(C^K\) matrices once per cell during the assembly, storing them somewhere on the side, and re-using them here. (This is what <a class="el" href="step_51.html">step-51</a> does, for example, where the <code>assemble_system()</code> function takes an argument that determines whether the local matrices are recomputed, and a similar approach &ndash; maybe with storing local matrices elsewhere &ndash; could be adapted for the current program.)</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_postprocessed_velocity()</div><div class="line">{</div><div class="line">  darcy_velocity.reinit(dof_handler_dgrt.n_dofs());</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                   face_quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_dgrt(fe_dgrt,</div><div class="line">                               quadrature_formula,</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                        face_quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell      = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = fe_face_values.<a class="code" href="classFEFaceValuesBase.html#ab460150cda793c93abfc6eac1314de31">get_quadrature</a>().<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices_dgrt(</div><div class="line">    dofs_per_cell_dgrt);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_D(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_E(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line"></div><div class="line">  Vector&lt;double&gt; cell_solution(dofs_per_cell);</div><div class="line">  Vector&lt;double&gt; cell_velocity(dofs_per_cell_dgrt);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> Coefficient&lt;dim&gt;      coefficient;</div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt;&gt; coefficient_values(n_q_points_dgrt);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_interior(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_face(1);</div></div><!-- fragment --><p>In the introduction, we explained how to calculate the numerical velocity on the cell. We need the pressure solution values on each cell, coefficients of the Gram matrix and coefficients of the \(L_2\) projection. We have already calculated the global solution, so we will extract the cell solution from the global solution. The coefficients of the Gram matrix have been calculated when we assembled the system matrix for the pressures. We will do the same way here. For the coefficients of the projection, we do matrix multiplication, i.e., the inverse of the Gram matrix times the matrix with \((\mathbf{K} \mathbf{w}, \mathbf{w})\) as components. Then, we multiply all these coefficients and call them beta. The numerical velocity is the product of beta and the basis functions of the Raviart-Thomas space.</p>
<div class="fragment"><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">  endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(), cell_dgrt = dof_handler_dgrt.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line"><span class="keywordflow">for</span> (; cell != endc; ++cell, ++cell_dgrt)</div><div class="line">  {</div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">    fe_values_dgrt.reinit(cell_dgrt);</div><div class="line"></div><div class="line">    coefficient.value_list(fe_values_dgrt.get_quadrature_points(),</div><div class="line">                           coefficient_values);</div></div><!-- fragment --><p>The component of this <code>cell_matrix_E</code> is the integral of \((\mathbf{K} \mathbf{w}, \mathbf{w})\). <code>cell_matrix_M</code> is the Gram matrix.</p>
<div class="fragment"><div class="line">cell_matrix_M = 0;</div><div class="line">cell_matrix_E = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i = fe_values_dgrt[velocities].value(i, q);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">            fe_values_dgrt[velocities].value(k, q);</div><div class="line"></div><div class="line">          cell_matrix_E(i, k) +=</div><div class="line">            (coefficient_values[q] * v_i * v_k * fe_values_dgrt.JxW(q));</div><div class="line"></div><div class="line">          cell_matrix_M(i, k) += (v_i * v_k * fe_values_dgrt.JxW(q));</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>To compute the matrix \(D\) mentioned in the introduction, we then need to evaluate \(D=M^{-1}E\) as explained in the introduction:</p>
<div class="fragment"><div class="line">cell_matrix_M.gauss_jordan();</div><div class="line">cell_matrix_M.mmult(cell_matrix_D, cell_matrix_E);</div></div><!-- fragment --><p>Then we also need, again, to compute the matrix \(C\) that is used to evaluate the weak discrete gradient. This is the exact same code as used in the assembly of the system matrix, so we just copy it from there:</p>
<div class="fragment"><div class="line">cell_matrix_G = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> div_v_i =</div><div class="line">        fe_values_dgrt[velocities].divergence(i, q);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_interior =</div><div class="line">            fe_values[pressure_interior].value(j, q);</div><div class="line"></div><div class="line">          cell_matrix_G(i, j) -=</div><div class="line">            (div_v_i * phi_j_interior * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">  {</div><div class="line">    fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">    fe_face_values_dgrt.reinit(cell_dgrt, face);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal = fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i =</div><div class="line">              fe_face_values_dgrt[velocities].value(i, q);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_face =</div><div class="line">                  fe_face_values[pressure_face].value(j, q);</div><div class="line"></div><div class="line">                cell_matrix_G(i, j) +=</div><div class="line">                  ((v_i * normal) * phi_j_face * fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">              }</div><div class="line">          }</div><div class="line">      }</div><div class="line">  }</div><div class="line">cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M);</div></div><!-- fragment --><p>Finally, we need to extract the pressure unknowns that correspond to the current cell:</p>
<div class="fragment"><div class="line">cell-&gt;get_dof_values(solution, cell_solution);</div></div><!-- fragment --><p>We are now in a position to compute the local velocity unknowns (with respect to the Raviart-Thomas space we are projecting the term \(-\mathbf K \nabla_{w,d} p_h\) into):</p>
<div class="fragment"><div class="line">cell_velocity = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell_dgrt; ++j)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      cell_velocity(k) +=</div><div class="line">        -(cell_solution(i) * cell_matrix_C(i, j) * cell_matrix_D(k, j));</div></div><!-- fragment --><p>We compute Darcy velocity. This is same as cell_velocity but used to graph Darcy velocity.</p>
<div class="fragment"><div class="line">      cell_dgrt-&gt;get_dof_indices(local_dof_indices_dgrt);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell_dgrt; ++j)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            darcy_velocity(local_dof_indices_dgrt[k]) +=</div><div class="line">              -(cell_solution(i) * cell_matrix_C(i, j) * cell_matrix_D(k, j));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationdimcompute_pressure_error"></a> </p><h4>WGDarcyEquation&lt;dim&gt;::compute_pressure_error</h4>
<p>This part is to calculate the \(L_2\) error of the pressure. We define a vector that holds the norm of the error on each cell. Next, we use <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTool::integrate_difference()</a> to compute the error in the \(L_2\) norm on each cell. However, we really only care about the error in the interior component of the solution vector (we can't even evaluate the interface pressures at the quadrature points because these are all located in the interior of cells) and consequently have to use a weight function that ensures that the interface component of the solution variable is ignored. This is done by using the <a class="el" href="classComponentSelectFunction.html">ComponentSelectFunction</a> whose arguments indicate which component we want to select (component zero, i.e., the interior pressures) and how many components there are in total (two).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_pressure_error()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> select_interior_pressure(0, 2);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler,</div><div class="line">                                    solution,</div><div class="line">                                    ExactPressure&lt;dim&gt;(),</div><div class="line">                                    difference_per_cell,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                    &amp;select_interior_pressure);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> L2_error = difference_per_cell.l2_norm();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;L2_error_pressure &quot;</span> &lt;&lt; L2_error &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationdimcompute_velocity_error"></a> </p><h4>WGDarcyEquation&lt;dim&gt;::compute_velocity_error</h4>
<p>In this function, we evaluate \(L_2\) errors for the velocity on each cell, and \(L_2\) errors for the flux on faces. The function relies on the <code>compute_postprocessed_velocity()</code> function having previous computed, which computes the velocity field based on the pressure solution that has previously been computed.</p>
<p>We are going to evaluate velocities on each cell and calculate the difference between numerical and exact velocities.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_velocity_errors()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_dgrt(fe_dgrt,</div><div class="line">                               quadrature_formula,</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                        face_quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points_dgrt =</div><div class="line">    fe_face_values_dgrt.get_quadrature().size();</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points_dgrt);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_face_values(n_face_q_points_dgrt);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ExactVelocity&lt;dim&gt; exact_velocity;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> L2_err_velocity_cell_sqr_global = 0;</div><div class="line">  <span class="keywordtype">double</span> L2_err_flux_sqr                 = 0;</div></div><!-- fragment --><p>Having previously computed the postprocessed velocity, we here only have to extract the corresponding values on each cell and face and compare it to the exact values.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell_dgrt : dof_handler_dgrt.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    fe_values_dgrt.reinit(cell_dgrt);</div></div><!-- fragment --><p>First compute the \(L_2\) error between the postprocessed velocity field and the exact one:</p>
<div class="fragment"><div class="line">fe_values_dgrt[velocities].get_function_values(darcy_velocity,</div><div class="line">                                               velocity_values);</div><div class="line"><span class="keywordtype">double</span> L2_err_velocity_cell_sqr_local = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity = velocity_values[q];</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> true_velocity =</div><div class="line">      exact_velocity.value(fe_values_dgrt.quadrature_point(q));</div><div class="line"></div><div class="line">    L2_err_velocity_cell_sqr_local +=</div><div class="line">      ((velocity - true_velocity) * (velocity - true_velocity) *</div><div class="line">       fe_values_dgrt.JxW(q));</div><div class="line">  }</div><div class="line">L2_err_velocity_cell_sqr_global += L2_err_velocity_cell_sqr_local;</div></div><!-- fragment --><p>For reconstructing the flux we need the size of cells and faces. Since fluxes are calculated on faces, we have the loop over all four faces of each cell. To calculate the face velocity, we extract values at the quadrature points from the <code>darcy_velocity</code> which we have computed previously. Then, we calculate the squared velocity error in normal direction. Finally, we calculate the \(L_2\) flux error on the cell by appropriately scaling with face and cell areas and add it to the global error.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> cell_area = cell_dgrt-&gt;measure();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face_dgrt : cell_dgrt-&gt;face_iterators())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> face_length = face_dgrt-&gt;measure();</div><div class="line">      fe_face_values_dgrt.reinit(cell_dgrt, face_dgrt);</div><div class="line">      fe_face_values_dgrt[velocities].get_function_values(</div><div class="line">        darcy_velocity, velocity_face_values);</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> L2_err_flux_face_sqr_local = 0;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points_dgrt; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity = velocity_face_values[q];</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> true_velocity =</div><div class="line">            exact_velocity.value(fe_face_values_dgrt.quadrature_point(q));</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal =</div><div class="line">            fe_face_values_dgrt.normal_vector(q);</div><div class="line"></div><div class="line">          L2_err_flux_face_sqr_local +=</div><div class="line">            ((velocity * normal - true_velocity * normal) *</div><div class="line">             (velocity * normal - true_velocity * normal) *</div><div class="line">             fe_face_values_dgrt.JxW(q));</div><div class="line">        }</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> err_flux_each_face =</div><div class="line">        L2_err_flux_face_sqr_local / face_length * cell_area;</div><div class="line">      L2_err_flux_sqr += err_flux_each_face;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>After adding up errors over all cells and faces, we take the square root and get the \(L_2\) errors of velocity and flux. These we output to screen.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> L2_err_velocity_cell =</div><div class="line">    <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(L2_err_velocity_cell_sqr_global);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> L2_err_flux_face = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(L2_err_flux_sqr);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;L2_error_vel:  &quot;</span> &lt;&lt; L2_err_velocity_cell &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;L2_error_flux: &quot;</span> &lt;&lt; L2_err_flux_face &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationoutput_results"></a> </p><h4>WGDarcyEquation::output_results</h4>
<p>We have two sets of results to output: the interior solution and the skeleton solution. We use <code><a class="el" href="classDataOut.html">DataOut</a></code> to visualize interior results. The graphical output for the skeleton results is done by using the <a class="el" href="classDataOutFaces.html">DataOutFaces</a> class.</p>
<p>In both of the output files, both the interior and the face variables are stored. For the interface output, the output file simply contains the interpolation of the interior pressures onto the faces, but because it is undefined which of the two interior pressure variables you get from the two adjacent cells, it is best to ignore the interior pressure in the interface output file. Conversely, for the cell interior output file, it is of course impossible to show any interface pressures \(p^\partial\), because these are only available on interfaces and not cell interiors. Consequently, you will see them shown as an invalid value (such as an infinity).</p>
<p>For the cell interior output, we also want to output the velocity variables. This is a bit tricky since it lives on the same mesh but uses a different <a class="el" href="classDoFHandler.html">DoFHandler</a> object (the pressure variables live on the <code>dof_handler</code> object, the Darcy velocity on the <code>dof_handler_dgrt</code> object). Fortunately, there are variations of the <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector()</a> function that allow specifying which <a class="el" href="classDoFHandler.html">DoFHandler</a> a vector corresponds to, and consequently we can visualize the data from both <a class="el" href="classDoFHandler.html">DoFHandler</a> objects within the same file.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  {</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div></div><!-- fragment --><p>First attach the pressure solution to the <a class="el" href="classDataOut.html">DataOut</a> object:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::string&gt; solution_names = {<span class="stringliteral">&quot;interior_pressure&quot;</span>,</div><div class="line">                                                 <span class="stringliteral">&quot;interface_pressure&quot;</span>};</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler, solution, solution_names);</div></div><!-- fragment --><p>Then do the same with the Darcy velocity field, and continue with writing everything out into a file.</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> std::vector&lt;std::string&gt; velocity_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    <span class="keyword">const</span> std::vector&lt;</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;</div><div class="line">      velocity_component_interpretation(</div><div class="line">        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_dgrt,</div><div class="line">                             darcy_velocity,</div><div class="line">                             velocity_names,</div><div class="line">                             velocity_component_interpretation);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution_interior.vtu&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classDataOutFaces.html">DataOutFaces&lt;dim&gt;</a> data_out_faces(<span class="keyword">false</span>);</div><div class="line">    data_out_faces.attach_dof_handler(dof_handler);</div><div class="line">    data_out_faces.add_data_vector(solution, <span class="stringliteral">&quot;Pressure_Face&quot;</span>);</div><div class="line">    data_out_faces.build_patches(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">    std::ofstream face_output(<span class="stringliteral">&quot;solution_interface.vtu&quot;</span>);</div><div class="line">    data_out_faces.write_vtu(face_output);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="WGDarcyEquationrun"></a> </p><h4>WGDarcyEquation::run</h4>
<p>This is the final function of the main class. It calls the other functions of our class.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WGDarcyEquation&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Solving problem in &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot; space dimensions.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    compute_postprocessed_velocity();</div><div class="line">    compute_pressure_error();</div><div class="line">    compute_velocity_errors();</div><div class="line">    output_results();</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace Step61</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>This is the main function. We can change the dimension here to run in 3d.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step61::WGDarcyEquation&lt;2&gt; wg_darcy(0);</div><div class="line">      wg_darcy.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-61/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>我们在运行程序时，右手边会产生解 \(p = \sin(\pi x) \sin(\pi y)\) ，并且在域 \(\Omega = (0,1)^2\) 中具有同质的迪里希特边界条件。此外，我们选择微分算子 \(\mathbf{K}\) 中的系数矩阵作为身份矩阵。我们使用 \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) 、 \(\mbox{WG}(Q_1,Q_1;RT_{[1]})\) 和 \(\mbox{WG}(Q_2,Q_2;RT_{[2]})\) 元素组合测试这一设置，可以通过使用<code>main()</code>中<code>WGDarcyEquation</code>对象的适当构造参数来选择。然后我们将可视化单元内部和面上的压力值。随着网格的细化，压力、速度和流量的收敛率对于 \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) 应该是1，对于 \(\mbox{WG}(Q_1,Q_1;RT_{[1]})\) 是2，对于 \(\mbox{WG}(Q_2,Q_2;RT_{[2]})\) 是3。</p>
<p><a class="anchor" id="TestresultsoniWGQsub0subQsub0subRTsub0subiiWGQsub0subQsub0subRTsub0subi"></a></p><h3>Test results on <em>WG(Q<sub>0</sub>,Q<sub>0</sub>;RT<sub>[0]</sub>)</em><em>WG(Q<sub>0</sub>,Q<sub>0</sub>;RT<sub>[0]</sub>)</em></h3>
<p>。</p>
<p>下面的数字显示了使用 \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) 元素的内部压力和表面压力。网格分别细化了2倍（顶部）和4倍（底部）。(这个数字可以在<code>make_grid()</code>函数中调整)。当网格较粗时，可以看到面压 \(p^\partial\) 整齐地位于两个相邻单元的内压 \(p^\circ\) 的数值之间。</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg000_2d_2.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg000_3d_2.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg000_2d_4.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg000_3d_4.png"/>
</div>
  </td></tr>
</table>
<p>从图中我们可以看出，随着网格的细化，最大和最小的压力值正在接近我们的预期值。由于网格是一个矩形网格，每个方向的单元数是偶数，所以我们有对称的解决方案。从右边的三维图中，我们可以看到在 \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) 上，压力在单元的内部是一个常数，正如预期的那样。</p>
<p><a class="anchor" id="Convergencetableforik0iik0i"></a></p><h4>Convergence table for <em>k=0</em><em>k=0</em></h4>
<p>。</p>
<p>我们用不同的细化网格（在 "make_grid() "函数中选择）运行代码，得到压力、速度和通量（如引言中定义的）的以下收敛率。</p>
<table align="center" class="doxtable">
<tr>
<th>number of refinements </th><th>\(\|p-p_h^\circ\|\) </th><th>\(\|\mathbf{u}-\mathbf{u}_h\|\) </th><th>\(\|(\mathbf{u}-\mathbf{u}_h) \cdot \mathbf{n}\|\)   </th></tr>
<tr>
<td>2 </td><td>1.587e-01 </td><td>5.113e-01 </td><td>7.062e-01   </td></tr>
<tr>
<td>3 </td><td>8.000e-02 </td><td>2.529e-01 </td><td>3.554e-01   </td></tr>
<tr>
<td>4 </td><td>4.006e-02 </td><td>1.260e-01 </td><td>1.780e-01   </td></tr>
<tr>
<td>5 </td><td>2.004e-02 </td><td>6.297e-02 </td><td>8.902e-02   </td></tr>
<tr>
<th>Conv.rate </th><th>1.00 </th><th>1.00 </th><th>1.00   </th></tr>
</table>
<p>我们可以看到， \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) 的收敛率在1左右。当然，这与我们的理论预期相符。</p>
<p><a class="anchor" id="TestresultsoniWGQsub1subQsub1subRTsub1subiiWGQsub1subQsub1subRTsub1subi"></a></p><h3>Test results on <em>WG(Q<sub>1</sub>,Q<sub>1</sub>;RT<sub>[1]</sub>)</em><em>WG(Q<sub>1</sub>,Q<sub>1</sub>;RT<sub>[1]</sub>)</em></h3>
<p>。</p>
<p>我们可以用下一个更高的多项式度数重复上面的实验。下面的数字是使用 \(\mbox{WG}(Q_1,Q_1;RT_{[1]})\) 实现的内部压力和表面压力。网格被细化了4次。 与之前使用 \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) 的数字相比，在每个单元上，解决方案不再是恒定的，因为我们现在使用双线性多项式来做近似。因此，在一个内部有4个压力值，在每个面上有2个压力值。</p>
<table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg111_2d_4.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg111_3d_4.png"/>
</div>
  </td></tr>
</table>
<p>与 \(\mbox{WG}(Q_0,Q_0;RT_{[0]})\) 组合的相应图像相比，现在的解决方案大大增加了准确性，特别是在界面上如此接近于连续，以至于我们不再能够区分相邻单元上的界面压力 \(p^\partial\) 和内部压力 \(p^\circ\) 。</p>
<p><a class="anchor" id="Convergencetableforik1iik1i"></a></p><h4>Convergence table for <em>k=1</em><em>k=1</em></h4>
<p>。</p>
<p>以下是我们使用 \(\mbox{WG}(Q_1,Q_1;RT_{[1]})\) 元素组合得到的压力、速度和通量的收敛率。</p>
<table align="center" class="doxtable">
<tr>
<th>number of refinements </th><th>\(\|p-p_h^\circ\|\) </th><th>\(\|\mathbf{u}-\mathbf{u}_h\|\) </th><th>\(\|(\mathbf{u}-\mathbf{u}_h) \cdot \mathbf{n}\|\)   </th></tr>
<tr>
<td>2 </td><td>1.613e-02 </td><td>5.093e-02 </td><td>7.167e-02   </td></tr>
<tr>
<td>3 </td><td>4.056e-03 </td><td>1.276e-02 </td><td>1.802e-02   </td></tr>
<tr>
<td>4 </td><td>1.015e-03 </td><td>3.191e-03 </td><td>4.512e-03   </td></tr>
<tr>
<td>5 </td><td>2.540e-04 </td><td>7.979e-04 </td><td>1.128e-03   </td></tr>
<tr>
<th>Conv.rate </th><th>2.00 </th><th>2.00 </th><th>2.00   </th></tr>
</table>
<p>\(WG(Q_1,Q_1;RT_{[1]})\) 的收敛率在2左右，符合预期。</p>
<p><a class="anchor" id="TestresultsoniWGQsub2subQsub2subRTsub2subiiWGQsub2subQsub2subRTsub2subi"></a></p><h3>Test results on <em>WG(Q<sub>2</sub>,Q<sub>2</sub>;RT<sub>[2]</sub>)</em><em>WG(Q<sub>2</sub>,Q<sub>2</sub>;RT<sub>[2]</sub>)</em></h3>
<p>。</p>
<p>让我们再提高一个多项式等级。以下是使用 \(WG(Q_2,Q_2;RT_{[2]})\) 实现的内部压力和表面压力，网格大小为 \(h = 1/32\) （即5个全局网格细化步骤）。在程序中，我们在生成图形输出时使用<code>data_out_face.build_patches(fe.degree)</code>（参见 <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a>), 的文档，这里意味着我们将每个2d单元内部分成4个子单元，以便提供更好的二次多项式的可视化。 </p><table align="center">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg222_2d_5.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-61.wg222_3d_5.png"/>
</div>
  </td></tr>
</table>
<p><a class="anchor" id="Convergencetableforik2iik2i"></a></p><h4>Convergence table for <em>k=2</em><em>k=2</em></h4>
<p>。</p>
<p>和以前一样，我们可以使用 \(L_2\) 组合生成压力、速度和流量的 \(\mbox{WG}(Q_2,Q_2;RT_{[2]})\) 误差的收敛数据。</p>
<table align="center" class="doxtable">
<tr>
<th>number of refinements </th><th>\(\|p-p_h^\circ\|\) </th><th>\(\|\mathbf{u}-\mathbf{u}_h\|\) </th><th>\(\|(\mathbf{u}-\mathbf{u}_h) \cdot \mathbf{n}\|\)   </th></tr>
<tr>
<td>2 </td><td>1.072e-03 </td><td>3.375e-03 </td><td>4.762e-03   </td></tr>
<tr>
<td>3 </td><td>1.347e-04 </td><td>4.233e-04 </td><td>5.982e-04   </td></tr>
<tr>
<td>4 </td><td>1.685e-05 </td><td>5.295e-05 </td><td>7.487e-05   </td></tr>
<tr>
<td>5 </td><td>2.107e-06 </td><td>6.620e-06 </td><td>9.362e-06   </td></tr>
<tr>
<th>Conv.rate </th><th>3.00 </th><th>3.00 </th><th>3.00   </th></tr>
</table>
<p>再一次， \(\mbox{WG}(Q_2,Q_2;RT_{[2]})\) 的收敛率符合预期，其数值在3左右。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2018 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *      Author: Zhuoran Wang, Colorado State University, 2018</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2quadrature_8h.html">deal.II/base/quadrature.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2point_8h.html">deal.II/base/point.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__vector_8h.html">deal.II/lac/block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparse__matrix_8h.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__raviart__thomas_8h.html">deal.II/fe/fe_raviart_thomas.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dg__vector_8h.html">deal.II/fe/fe_dg_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__face_8h.html">deal.II/fe/fe_face.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="component__mask_8h.html">deal.II/fe/component_mask.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="data__out__faces_8h.html">deal.II/numerics/data_out_faces.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step61</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>WGDarcyEquation</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    WGDarcyEquation(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> make_grid();</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> compute_postprocessed_velocity();</div><div class="line">    <span class="keywordtype">void</span> compute_velocity_errors();</div><div class="line">    <span class="keywordtype">void</span> compute_pressure_error();</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>   fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classFE__DGRaviartThomas.html">FE_DGRaviartThomas&lt;dim&gt;</a> fe_dgrt;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>         dof_handler_dgrt;</div><div class="line">    Vector&lt;double&gt;          darcy_velocity;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>Coefficient : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Coefficient()</div><div class="line">      : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                            std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;values) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> Coefficient&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                    std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">      values[p] = unit_symmetric_tensor&lt;dim&gt;();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> (2 * numbers::PI * numbers::PI * std::sin(numbers::PI * p[0]) *</div><div class="line">            std::sin(numbers::PI * p[1]));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ExactPressure : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ExactPressure()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(2)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> ExactPressure&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[0]) * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[1]);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>ExactVelocity : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    ExactVelocity()</div><div class="line">      : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;1, dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ExactVelocity&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> return_value;</div><div class="line">    return_value[0] = -numbers::PI * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI * p[0]) *</div><div class="line">                      <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[1]);</div><div class="line">    return_value[1] = -numbers::PI * <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(numbers::PI * p[0]) *</div><div class="line">                      <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(numbers::PI * p[1]);</div><div class="line">    <span class="keywordflow">return</span> return_value;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  WGDarcyEquation&lt;dim&gt;::WGDarcyEquation(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : fe(<a class="code" href="classFE__DGQ.html">FE_DGQ</a>&lt;dim&gt;(degree), 1, <a class="code" href="classFE__FaceQ.html">FE_FaceQ</a>&lt;dim&gt;(degree), 1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , fe_dgrt(degree)</div><div class="line">    , dof_handler_dgrt(triangulation)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::make_grid()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(5);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Total number of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#abea687f123f3f5a8b09d7485cf03be72">n_cells</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    dof_handler_dgrt.distribute_dofs(fe_dgrt);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of pressure degrees of freedom: &quot;</span></div><div class="line">              &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line"></div><div class="line">    {</div><div class="line">      constraints.clear();</div><div class="line">      <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> interface_pressure(1);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a>              interface_pressure_mask =</div><div class="line">        fe.<a class="code" href="classFiniteElement.html#a4409f54175f279ac24cc982cfcfcbd2f">component_mask</a>(interface_pressure);</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               0,</div><div class="line">                                               BoundaryValues&lt;dim&gt;(),</div><div class="line">                                               constraints,</div><div class="line">                                               interface_pressure_mask);</div><div class="line">      constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values_dgrt(fe_dgrt,</div><div class="line">                                 quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                          face_quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell      = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = fe_face_values.<a class="code" href="classFEFaceValuesBase.html#ab460150cda793c93abfc6eac1314de31">get_quadrature</a>().<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    RightHandSide&lt;dim&gt;  right_hand_side;</div><div class="line">    std::vector&lt;double&gt; right_hand_side_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Coefficient&lt;dim&gt;      coefficient;</div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; coefficient_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_rhs(dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     cell_solution(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_interior(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_face(1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::active_cell_iterator</a> cell_dgrt =</div><div class="line">          cell;</div><div class="line">        fe_values_dgrt.<a class="code" href="classDoFHandler.html#a84b803d7c74ab87a3eb2e1367611246b">reinit</a>(cell_dgrt);</div><div class="line"></div><div class="line">        right_hand_side.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                                   right_hand_side_values);</div><div class="line">        coefficient.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                               coefficient_values);</div><div class="line"></div><div class="line">        cell_matrix_M = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i = fe_values_dgrt[velocities].value(i, q);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">                    fe_values_dgrt[velocities].value(k, q);</div><div class="line">                  cell_matrix_M(i, k) += (v_i * v_k * fe_values_dgrt.JxW(q));</div><div class="line">                }</div><div class="line">            }</div><div class="line">        cell_matrix_M.gauss_jordan();</div><div class="line"></div><div class="line">        cell_matrix_G = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> div_v_i =</div><div class="line">                fe_values_dgrt[velocities].divergence(i, q);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_interior =</div><div class="line">                    fe_values[pressure_interior].value(j, q);</div><div class="line"></div><div class="line">                  cell_matrix_G(i, j) -=</div><div class="line">                    (div_v_i * phi_j_interior * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">            fe_face_values_dgrt.reinit(cell_dgrt, face);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal = fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i =</div><div class="line">                      fe_face_values_dgrt[velocities].value(i, q);</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_face =</div><div class="line">                          fe_face_values[pressure_face].value(j, q);</div><div class="line"></div><div class="line">                        cell_matrix_G(i, j) +=</div><div class="line">                          ((v_i * normal) * phi_j_face * fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M);</div><div class="line"></div><div class="line">        local_matrix = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">                  fe_values_dgrt[velocities].value(k, q);</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dofs_per_cell_dgrt; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_l =</div><div class="line">                      fe_values_dgrt[velocities].value(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>, q);</div><div class="line"></div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                        local_matrix(i, j) +=</div><div class="line">                          (coefficient_values[q] * cell_matrix_C[i][k] * v_k) *</div><div class="line">                          cell_matrix_C[j][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] * v_l * fe_values_dgrt.JxW(q);</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell_rhs = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              cell_rhs(i) += (fe_values[pressure_interior].value(i, q) *</div><div class="line">                              right_hand_side_values[q] * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">            }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.distribute_local_to_global(</div><div class="line">          local_matrix, cell_rhs, local_dof_indices, system_matrix, system_rhs);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1e-8 * system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line">    solver.solve(system_matrix, solution, system_rhs, <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div><div class="line">    constraints.distribute(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_postprocessed_velocity()</div><div class="line">  {</div><div class="line">    darcy_velocity.reinit(dof_handler_dgrt.n_dofs());</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values(fe,</div><div class="line">                                     face_quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_dgrt(fe_dgrt,</div><div class="line">                                 quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                          face_quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell      = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell_dgrt = fe_dgrt.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = fe_values.<a class="code" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a>().size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = fe_face_values.<a class="code" href="classFEFaceValuesBase.html#ab460150cda793c93abfc6eac1314de31">get_quadrature</a>().<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices_dgrt(</div><div class="line">      dofs_per_cell_dgrt);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_M(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_G(dofs_per_cell_dgrt, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_C(dofs_per_cell, dofs_per_cell_dgrt);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_D(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_matrix_E(dofs_per_cell_dgrt, dofs_per_cell_dgrt);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; cell_solution(dofs_per_cell);</div><div class="line">    Vector&lt;double&gt; cell_velocity(dofs_per_cell_dgrt);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> Coefficient&lt;dim&gt;      coefficient;</div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; coefficient_values(n_q_points_dgrt);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_interior(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure_face(1);</div><div class="line"></div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">      cell = dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">      endc = dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(), cell_dgrt = dof_handler_dgrt.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++cell_dgrt)</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values_dgrt.reinit(cell_dgrt);</div><div class="line"></div><div class="line">        coefficient.value_list(fe_values_dgrt.get_quadrature_points(),</div><div class="line">                               coefficient_values);</div><div class="line"></div><div class="line">        cell_matrix_M = 0;</div><div class="line">        cell_matrix_E = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i = fe_values_dgrt[velocities].value(i, q);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_k =</div><div class="line">                    fe_values_dgrt[velocities].value(k, q);</div><div class="line"></div><div class="line">                  cell_matrix_E(i, k) +=</div><div class="line">                    (coefficient_values[q] * v_i * v_k * fe_values_dgrt.JxW(q));</div><div class="line"></div><div class="line">                  cell_matrix_M(i, k) += (v_i * v_k * fe_values_dgrt.JxW(q));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        cell_matrix_M.gauss_jordan();</div><div class="line">        cell_matrix_M.mmult(cell_matrix_D, cell_matrix_E);</div><div class="line"></div><div class="line">        cell_matrix_G = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> div_v_i =</div><div class="line">                fe_values_dgrt[velocities].divergence(i, q);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_interior =</div><div class="line">                    fe_values[pressure_interior].value(j, q);</div><div class="line"></div><div class="line">                  cell_matrix_G(i, j) -=</div><div class="line">                    (div_v_i * phi_j_interior * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">            fe_face_values_dgrt.reinit(cell_dgrt, face);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal = fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell_dgrt; ++i)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> v_i =</div><div class="line">                      fe_face_values_dgrt[velocities].value(i, q);</div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                      {</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_face =</div><div class="line">                          fe_face_values[pressure_face].value(j, q);</div><div class="line"></div><div class="line">                        cell_matrix_G(i, j) +=</div><div class="line">                          ((v_i * normal) * phi_j_face * fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                      }</div><div class="line">                  }</div><div class="line">              }</div><div class="line">          }</div><div class="line">        cell_matrix_G.Tmmult(cell_matrix_C, cell_matrix_M);</div><div class="line"></div><div class="line">        cell-&gt;get_dof_values(solution, cell_solution);</div><div class="line"></div><div class="line">        cell_velocity = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell_dgrt; ++j)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              cell_velocity(k) +=</div><div class="line">                -(cell_solution(i) * cell_matrix_C(i, j) * cell_matrix_D(k, j));</div><div class="line"></div><div class="line">        cell_dgrt-&gt;get_dof_indices(local_dof_indices_dgrt);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell_dgrt; ++k)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell_dgrt; ++j)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              darcy_velocity(local_dof_indices_dgrt[k]) +=</div><div class="line">                -(cell_solution(i) * cell_matrix_C(i, j) * cell_matrix_D(k, j));</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_pressure_error()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; difference_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classComponentSelectFunction.html">ComponentSelectFunction&lt;dim&gt;</a> select_interior_pressure(0, 2);</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler,</div><div class="line">                                      solution,</div><div class="line">                                      ExactPressure&lt;dim&gt;(),</div><div class="line">                                      difference_per_cell,</div><div class="line">                                      <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 2),</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>,</div><div class="line">                                      &amp;select_interior_pressure);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> L2_error = difference_per_cell.l2_norm();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;L2_error_pressure &quot;</span> &lt;&lt; L2_error &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::compute_velocity_errors()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(fe_dgrt.degree + 1);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(fe_dgrt.degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values_dgrt(fe_dgrt,</div><div class="line">                                 quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> fe_face_values_dgrt(fe_dgrt,</div><div class="line">                                          face_quadrature_formula,</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points_dgrt = fe_values_dgrt.get_quadrature().size();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points_dgrt =</div><div class="line">      fe_face_values_dgrt.get_quadrature().size();</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points_dgrt);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_face_values(n_face_q_points_dgrt);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> ExactVelocity&lt;dim&gt; exact_velocity;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> L2_err_velocity_cell_sqr_global = 0;</div><div class="line">    <span class="keywordtype">double</span> L2_err_flux_sqr                 = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell_dgrt : dof_handler_dgrt.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values_dgrt.reinit(cell_dgrt);</div><div class="line"></div><div class="line">        fe_values_dgrt[velocities].get_function_values(darcy_velocity,</div><div class="line">                                                       velocity_values);</div><div class="line">        <span class="keywordtype">double</span> L2_err_velocity_cell_sqr_local = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points_dgrt; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity = velocity_values[q];</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> true_velocity =</div><div class="line">              exact_velocity.value(fe_values_dgrt.quadrature_point(q));</div><div class="line"></div><div class="line">            L2_err_velocity_cell_sqr_local +=</div><div class="line">              ((velocity - true_velocity) * (velocity - true_velocity) *</div><div class="line">               fe_values_dgrt.JxW(q));</div><div class="line">          }</div><div class="line">        L2_err_velocity_cell_sqr_global += L2_err_velocity_cell_sqr_local;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> cell_area = cell_dgrt-&gt;measure();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face_dgrt : cell_dgrt-&gt;face_iterators())</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> face_length = face_dgrt-&gt;measure();</div><div class="line">            fe_face_values_dgrt.reinit(cell_dgrt, face_dgrt);</div><div class="line">            fe_face_values_dgrt[velocities].get_function_values(</div><div class="line">              darcy_velocity, velocity_face_values);</div><div class="line"></div><div class="line">            <span class="keywordtype">double</span> L2_err_flux_face_sqr_local = 0;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points_dgrt; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity = velocity_face_values[q];</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> true_velocity =</div><div class="line">                  exact_velocity.value(fe_face_values_dgrt.quadrature_point(q));</div><div class="line"></div><div class="line">                <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> &amp;normal =</div><div class="line">                  fe_face_values_dgrt.normal_vector(q);</div><div class="line"></div><div class="line">                L2_err_flux_face_sqr_local +=</div><div class="line">                  ((velocity * normal - true_velocity * normal) *</div><div class="line">                   (velocity * normal - true_velocity * normal) *</div><div class="line">                   fe_face_values_dgrt.JxW(q));</div><div class="line">              }</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> err_flux_each_face =</div><div class="line">              L2_err_flux_face_sqr_local / face_length * cell_area;</div><div class="line">            L2_err_flux_sqr += err_flux_each_face;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> L2_err_velocity_cell =</div><div class="line">      <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(L2_err_velocity_cell_sqr_global);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> L2_err_flux_face = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(L2_err_flux_sqr);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;L2_error_vel:  &quot;</span> &lt;&lt; L2_err_velocity_cell &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;L2_error_flux: &quot;</span> &lt;&lt; L2_err_flux_face &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> WGDarcyEquation&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    {</div><div class="line">      <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt; solution_names = {<span class="stringliteral">&quot;interior_pressure&quot;</span>,</div><div class="line">                                                       <span class="stringliteral">&quot;interface_pressure&quot;</span>};</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler, solution, solution_names);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt; velocity_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">      <span class="keyword">const</span> std::vector&lt;</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;</div><div class="line">        velocity_component_interpretation(</div><div class="line">          dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler_dgrt,</div><div class="line">                               darcy_velocity,</div><div class="line">                               velocity_names,</div><div class="line">                               velocity_component_interpretation);</div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">      std::ofstream output(<span class="stringliteral">&quot;solution_interior.vtu&quot;</span>);</div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classDataOutFaces.html">DataOutFaces&lt;dim&gt;</a> data_out_faces(<span class="keyword">false</span>);</div><div class="line">      data_out_faces.attach_dof_handler(dof_handler);</div><div class="line">      data_out_faces.add_data_vector(solution, <span class="stringliteral">&quot;Pressure_Face&quot;</span>);</div><div class="line">      data_out_faces.build_patches(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a>);</div><div class="line">      std::ofstream face_output(<span class="stringliteral">&quot;solution_interface.vtu&quot;</span>);</div><div class="line">      data_out_faces.write_vtu(face_output);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WGDarcyEquation&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Solving problem in &quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot; space dimensions.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    make_grid();</div><div class="line">    setup_system();</div><div class="line">    assemble_system();</div><div class="line">    solve();</div><div class="line">    compute_postprocessed_velocity();</div><div class="line">    compute_pressure_error();</div><div class="line">    compute_velocity_errors();</div><div class="line">    output_results();</div><div class="line">  }</div><div class="line"></div><div class="line">} <span class="comment">// namespace Step61</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step61::WGDarcyEquation&lt;2&gt; wg_darcy(0);</div><div class="line">      wg_darcy.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
