<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_49.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-49 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-49 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_1.html">step-1</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Generalconcernsaboutmeshes">General concerns about meshes</a>
        <li><a href="#Howtocreatemeshes">How to create meshes</a>
      <ul>
        <li><a href="#UsingGridGenerator">Using GridGenerator</a>
        <li><a href="#Constructingyourownmeshprogrammatically">Constructing your own mesh programmatically</a>
        <li><a href="#Importingfromexternalprograms">Importing from external programs</a>
      </ul>
        <li><a href="#ModifyingaMesh">Modifying a Mesh</a>
      <ul>
        <li><a href="#Transformations">Transformations</a>
        <li><a href="#MergingMeshes">Merging Meshes</a>
        <li><a href="#MovingVertices">Moving Vertices</a>
        <li><a href="#ExtrudingMeshes">Extruding Meshes</a>
      </ul>
        <li><a href="#Afteryouhaveacoarsemesh"> After you have a coarse mesh </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Generatingoutputforagivenmesh">Generating output for a given mesh</a>
        <li><a href="#Mainroutines">Main routines</a>
      <ul>
        <li><a href="#grid_1Loadingameshgeneratedbygmsh">grid_1: Loading a mesh generated by gmsh</a>
        <li><a href="#grid_2Mergingtriangulations">grid_2: Merging triangulations</a>
        <li><a href="#grid_3Movingvertices">grid_3: Moving vertices</a>
        <li><a href="#grid_4Demonstratingextrude_triangulation">grid_4: Demonstrating extrude_triangulation</a>
        <li><a href="#grid_5DemonstratingGridToolstransformpart1">grid_5: Demonstrating GridTools::transform, part 1</a>
        <li><a href="#grid_6DemonstratingGridToolstransformpart2">grid_6: Demonstrating GridTools::transform, part 2</a>
        <li><a href="#grid_7Demonstratingdistort_random">grid_7: Demonstrating distort_random</a>
      </ul>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#NextstepsCurvedCells">Next steps: Curved Cells</a>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
      <ul>
        <li><a href="#Assigningdifferentboundaryids"> Assigning different boundary ids </a>
        <li><a href="#Extractingaboundarymesh"> Extracting a boundary mesh </a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <em>This program was contributed by Timo Heister. Parts of the results section were contributed by Yuhan Zhou, Wolfgang Bangerth, and David Wells.</em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction </h1>
<p>This tutorial is an extension to <a class="el" href="step_1.html">step-1</a> and demonstrates several ways to obtain more involved meshes than the ones shown there.</p>
<dl class="section note"><dt>Note</dt><dd>This tutorial is also available as a Jupyter Python notebook that uses the deal.II python interface. The notebook is available in the same directory as the original C++ program.</dd></dl>
<p>Generating complex geometries is a challenging task, especially in three space dimensions. We will discuss several ways to do this, but this list is not exhaustive. Additionally, there is not one approach that fits all problems.</p>
<p>This example program shows some of ways to create and modify meshes for computations and outputs them as <code>.vtu</code> files in much the same way as we do in <a class="el" href="step_1.html">step-1</a>. No other computations or adaptive refinements are done; the idea is that you can use the techniques used here as building blocks in other, more involved simulators. Please note that the example program does not show all the ways to generate meshes that are discussed in this introduction.</p>
<p><a class="anchor" id="Generalconcernsaboutmeshes"></a></p><h3>General concerns about meshes</h3>
<p>When you use adaptive mesh refinement, you definitely want the initial mesh to be as coarse as possible. The reason is that you can make it as fine as you want using adaptive refinement as long as you have memory and CPU time available. However, this requires that you don't waste mesh cells in parts of the domain where they don't pay off. As a consequence, you don't want to start with a mesh that is too fine to start with, because that takes up a good part of your cell budget already, and because you can't coarsen away cells that are in the initial mesh.</p>
<p>That said, your mesh needs to capture the given geometry adequately.</p>
<p><a class="anchor" id="Howtocreatemeshes"></a></p><h3>How to create meshes</h3>
<p>There are several ways to create an initial mesh. Meshes can be modified or combined in many ways as discussed later on.</p>
<p><a class="anchor" id="UsingGridGenerator"></a></p><h4>Using <a class="el" href="namespaceGridGenerator.html">GridGenerator</a></h4>
<p>The easiest way to generate meshes is to use the functions in namespace <a class="el" href="namespaceGridGenerator.html">GridGenerator</a>, as already discussed in <a class="el" href="step_1.html">step-1</a>. There are many different helper functions available, including <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>, <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a>, <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball()</a>, and <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole()</a>.</p>
<p><a class="anchor" id="Constructingyourownmeshprogrammatically"></a></p><h4>Constructing your own mesh programmatically</h4>
<p>If there is no good fit in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace for what you want to do, you can always create a <a class="el" href="classTriangulation.html">Triangulation</a> in your program "by hand". For that, you need a list of vertices with their coordinates and a list of cells referencing those vertices. You can find an example in the function <code>create_coarse_grid()</code> in <a class="el" href="step_14.html">step-14</a>. All the functions in <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> are implemented in this fashion.</p>
<p>We are happy to accept more functions to be added to <a class="el" href="namespaceGridGenerator.html">GridGenerator</a>. So, if you end up writing a function that might be useful for a larger audience, please contribute it.</p>
<p><a class="anchor" id="Importingfromexternalprograms"></a></p><h4>Importing from external programs</h4>
<p>The class <a class="el" href="classGridIn.html">GridIn</a> can read many different mesh formats from a file from disk. How this is done is explained in <a class="el" href="step_5.html">step-5</a> and can be seen in the function <code>grid_1</code> in this example, see the code below.</p>
<p>Meshes can be generated from different tools like <a href="http://gmsh.info" target="_top">gmsh</a>, <a href="https://lagrit.lanl.gov/" target="_top">lagrit</a> and <a href="http://cubit.sandia.gov/" target="_top">cubit</a>. See the documentation of <a class="el" href="classGridIn.html">GridIn</a> for more information. The problem is that deal.II needs meshes that only consist of quadrilaterals and hexahedra &ndash; tetrahedral meshes won't work (this means tools like tetgen can not be used directly).</p>
<p>We will describe a possible workflow using Gmsh. Gmsh is the smallest and most quickly set up open source tool we are aware of. It can generate unstructured 2d quad meshes. In 3d, it can extrude 2d meshes to get hexahedral meshes; 3D meshing of unstructured geometry into hexahedra is possible, though there are some issues with the quality of these meshes that imply that these meshes only sometimes work in deal.II.</p>
<p>In Gmsh, a mesh is fundamentally described in a text-based <code>.geo</code> file whose format can contain computations, loops, variables, etc. This format is quite flexible in allowing the description of complex geometries. The mesh is then generated from a surface representation, which is built from a list of line loops, which is built from a list of lines, which are in turn built from points. The <code>.geo</code> script can be written and edited by hand or it can be generated automatically by creating objects graphically inside Gmsh. In many cases it is best to combine both approaches. The file can be easily reloaded by pressing "reload" under the "Geometry" tab if you want to write it by hand and see the effects in the graphical user interface of gmsh.</p>
<p>This tutorial contains an example <code>.geo</code> file that describes a box with two objects cut out in the interior. This is how <code>example.geo</code> looks like in Gmsh (displaying the boundary indicators as well as the mesh discussed further down below):</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.gmsh_picture.png"/>
</div>
<p>You might want to open the <code>example.geo</code> file in a text editor (it is located in the same directory as the <code><a class="el" href="step_49.html">step-49</a>.cc</code> source file) to see how it is structured. You can see how the boundary of the domain is composed of a number of lines and how later on we combine several lines into "physical lines" (or "physical surfaces") that list the logical lines' numbers. "Physical" object are the ones that carry information about the boundary indicator (see <a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">this glossary entry</a>).</p>
<dl class="section note"><dt>Note</dt><dd>It is important that this file contain "physical lines" and "physical
  surfaces". These give the boundary indicators and material ids for use in deal.II. Without these physical entities, nothing will be imported into deal.II.</dd></dl>
<p>deal.II's <a class="el" href="classGridIn.html">GridIn</a> class can read the <code>.msh</code> format written by Gmsh and that contains a mesh created for the geometry described by the <code>.geo</code> file. You generate the <code>.msh</code> from the <code>.geo</code> by running the commands</p>
<div class="fragment"><div class="line">gmsh -2 example.geo</div></div><!-- fragment --><p>on the command line, or by clicking "Mesh" and then "2D" inside Gmsh after loading the file. Now this is the mesh read from the <code>.msh</code> file and saved again by deal.II as an image (see the <code>grid_1</code> function of the current program):</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-1.png"/>
</div>
<dl class="section note"><dt>Note</dt><dd>Gmsh has a number of other interfaces by which one can describe geometries to it. In particular, it has the ability to interface with scripting languages like Python and Julia, but it can also be scripted from C++. These interfaces are useful if one doesn't just want to generate a mesh for a single geometry (in which case the graphical interface or, in simple cases, a hand-written <code>.geo</code> file is probably the simplest approach), but instead wants to do parametric studies over the geometry for which it is necessary to generate many meshes for geometries that differ in certain parameters. Another case where this is useful is if there is already a CAD geometry for which one only needs a mesh; indeed, this can be done from within deal.II using the <a class="el" href="namespaceGmsh.html#ab65eb217368d006b66bcfcc6fa0f2894">Gmsh::create_triangulation_from_boundary_curve()</a> function.</dd></dl>
<p><a class="anchor" id="ModifyingaMesh"></a></p><h3>Modifying a Mesh</h3>
<p>After acquiring one (or several) meshes in the ways described above, there are many ways to manipulate them before using them in a finite element computation.</p>
<p><a class="anchor" id="Transformations"></a></p><h4>Transformations</h4>
<p>The <a class="el" href="namespaceGridTools.html">GridTools</a> namespace contains a collection of small functions to transform a given mesh in various ways. The usage of the functions <a class="el" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>, <a class="el" href="namespaceGridTools.html#a910bb99ec34eac082da97c08e7dd17c3">GridTools::rotate</a>, <a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">GridTools::scale</a> is fairly obvious, so we won't discuss those functions here.</p>
<p>The function <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a> allows you to transform the vertices of a given mesh using a smooth function. An example of its use is also given in the results section of <a class="el" href="step_38.html">step-38</a> but let us show a simpler example here: In the function <code>grid_5()</code> of the current program, we perturb the y coordinate of a mesh with a sine curve:</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-5a.png"/>
</div>
 regular input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-5.png"/>
</div>
 output mesh   </td></tr>
</table>
<p>Similarly, we can transform a regularly refined unit square to a wall-adapted mesh in y direction using the formula \((x,y) \mapsto (x,\tanh(2 y)/\tanh(2))\). This is done in <code>grid_6()</code> of this tutorial: </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-6a.png"/>
</div>
 regular input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-6.png"/>
</div>
 wall-adapted output mesh   </td></tr>
</table>
<p>Finally, the function <a class="el" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random</a> allows you to move vertices in the mesh (optionally ignoring boundary nodes) by a random amount. This is demonstrated in <code>grid_7()</code> and the result is as follows:</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-7a.png"/>
</div>
 regular input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-7.png"/>
</div>
 perturbed output mesh   </td></tr>
</table>
<p>This function is primarily intended to negate some of the superconvergence effects one gets when studying convergence on regular meshes, as well as to suppress some optimizations in deal.II that can exploit the fact that cells are similar in shape. (Superconvergence refers to the fact that if a mesh has certain symmetries &ndash; for example, if the edges running into a vertex are symmetric to this vertex, and if this is so for all vertices of a cell &ndash; that the solution is then often convergent with a higher order than one would have expected from the usual error analysis. In the end, this is a result of the fact that if one were to make a Taylor expansion of the error, the symmetry leads to the fact that the expected next term of the expansion happens to be zero, and the error order is determined by the second next* term. A distorted mesh does not have these symmetries and consequently the error reflects what one will see when solving the equation on <em>any</em> kind of mesh, rather than showing something that is only reflective of a particular situation.)</p>
<p><a class="anchor" id="MergingMeshes"></a></p><h4>Merging Meshes</h4>
<p>The function <a class="el" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations()</a> allows you to merge two given <a class="el" href="classTriangulation.html">Triangulation</a> objects into a single one. For this to work, the vertices of the shared edge or face have to match exactly. Lining up the two meshes can be achieved using <a class="el" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a> and <a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">GridTools::scale</a>. In the function <code>grid_2()</code> of this tutorial, we merge a square with a round hole (generated with <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole()</a>) and a rectangle (generated with <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle()</a>). The function <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle()</a> allows you to specify the number of repetitions and the positions of the corners, so there is no need to shift the triangulation manually here. You should inspect the mesh graphically to make sure that cells line up correctly and no unpaired nodes exist in the merged <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<p>These are the input meshes and the output mesh:</p>
<table width="80%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2a.png" height="200px"/>
</div>
input mesh 1 </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2b.png" height="200px"/>
</div>
input mesh 2 </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2.png" height="200px"/>
</div>
merged mesh  </td></tr>
</table>
<p><a class="anchor" id="MovingVertices"></a></p><h4>Moving Vertices</h4>
<p>The function <code>grid_3()</code> demonstrates the ability to pick individual vertices and move them around in an existing mesh. Note that this has the potential to produce degenerate or inverted cells and you shouldn't expect anything useful to come of using such meshes. Here, we create a box with a cylindrical hole that is not exactly centered by moving the top vertices upwards:</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-3a.png" height="200px"/>
</div>
 input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-3.png" height="200px"/>
</div>
 top vertices moved upwards   </td></tr>
</table>
<p>For the exact way how this is done, see the code below.</p>
<p><a class="anchor" id="ExtrudingMeshes"></a></p><h4>Extruding Meshes</h4>
<p>If you need a 3d mesh that can be created by extruding a given 2d mesh (that can be created in any of the ways given above), you can use the function <a class="el" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation()</a>. See the <code>grid_4()</code> function in this tutorial for an example. Note that for this particular case, the given result could also be achieved using the 3d version of <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole()</a>. The main usage is a 2d mesh, generated for example with Gmsh, that is read in from a <code>.msh</code> file as described above. This is the output from grid_4():</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-4base.png"/>
</div>
 input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-4.png"/>
</div>
 extruded output mesh   </td></tr>
</table>
<p><a class="anchor" id="Afteryouhaveacoarsemesh"></a></p><h3>After you have a coarse mesh </h3>
<p>Creating a coarse mesh using the methods discussed above is only the first step. When you have it, it will typically serve as the basis for further mesh refinement. This is not difficult &mdash; in fact, there is nothing else to do &mdash; if your geometry consists of only straight faces. However, this is often not the case if you have a more complex geometry and more steps than just creating the mesh are necessary. We will go over some of these steps in the <a href="#Results">results section</a> below.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>This tutorial program is odd in the sense that, unlike for most other steps, the introduction already provides most of the information on how to use the various strategies to generate meshes. Consequently, there is little that remains to be commented on here, and we intersperse the code with relatively little text. In essence, the code here simply provides a reference implementation of what has already been described in the introduction.</p>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Generatingoutputforagivenmesh"></a> </p><h3>Generating output for a given mesh</h3>
<p>The following function generates some output for any of the meshes we will be generating in the remainder of this program. In particular, it generates the following information:</p>
<ul>
<li>Some general information about the number of space dimensions in which this mesh lives and its number of cells.</li>
<li>The number of boundary faces that use each boundary indicator, so that it can be compared with what we expect.</li>
</ul>
<p>Finally, the function outputs the mesh in VTU format that can easily be visualized in Paraview or VisIt.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> print_mesh_info(<span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;triangulation,</div><div class="line">                     <span class="keyword">const</span> std::string &amp;       filename)</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh info:&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; dimension: &quot;</span> &lt;&lt; dim &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; no. of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl;</div></div><!-- fragment --><p>Next loop over all faces of all cells and find how often each boundary indicator is used (recall that if you access an element of a std::map object that doesn't exist, it is implicitly created and default initialized &ndash; to zero, in the current case &ndash; before we then increment it):</p>
<div class="fragment"><div class="line">{</div><div class="line">  std::map&lt;types::boundary_id, unsigned int&gt; boundary_count;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : triangulation.<a class="code" href="group__CPP11.html#ga1bf11e9e1e5c2ff59a9c7b3f5a2bc5ad">active_face_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">      boundary_count[face-&gt;boundary_id()]++;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; boundary indicators: &quot;</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;const types::boundary_id, unsigned int&gt; &amp;pair :</div><div class="line">       boundary_count)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; pair.first &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="stringliteral">&quot; times) &quot;</span>;</div><div class="line">    }</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Finally, produce a graphical representation of the mesh to an output file :</p>
<div class="fragment"><div class="line">  std::ofstream out(filename);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a8bd3a74b86d7c0eb792d2efca7f945f1">write_vtu</a>(triangulation, out);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; written to &quot;</span> &lt;&lt; filename &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Mainroutines"></a> </p><h3>Main routines</h3>
<p><a class="anchor" id="grid_1Loadingameshgeneratedbygmsh"></a> </p><h4>grid_1: Loading a mesh generated by gmsh</h4>
<p>In this first example, we show how to load the mesh for which we have discussed in the introduction how to generate it. This follows the same pattern as used in <a class="el" href="step_5.html">step-5</a> to load a mesh, although there it was written in a different file format (UCD instead of MSH).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_1()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classGridIn.html">GridIn&lt;2&gt;</a> gridin;</div><div class="line">  gridin.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(triangulation);</div><div class="line">  std::ifstream f(<span class="stringliteral">&quot;example.msh&quot;</span>);</div><div class="line">  gridin.<a class="code" href="group__simplex.html#ga83872db02e04f52ac52d578912f6da5e">read_msh</a>(f);</div><div class="line"></div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-1.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_2Mergingtriangulations"></a> </p><h4>grid_2: Merging triangulations</h4>
<p>Here, we first create two triangulations and then merge them into one. As discussed in the introduction, it is important to ensure that the vertices at the common interface are located at the same coordinates.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_2()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria1;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(tria1, 0.25, 1.0);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          tria2;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = 3;</div><div class="line">  repetitions[1] = 2;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(tria2,</div><div class="line">                                            repetitions,</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, -1.0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(4.0, 1.0));</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(tria1, tria2, triangulation);</div><div class="line"></div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-2.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_3Movingvertices"></a> </p><h4>grid_3: Moving vertices</h4>
<p>In this function, we move vertices of a mesh. This is simpler than one usually expects: if you ask a cell using <code>cell-&gt;vertex(i)</code> for the coordinates of its <code>i</code>th vertex, it doesn't just provide the location of this vertex but in fact a reference to the location where these coordinates are stored. We can then modify the value stored there.</p>
<p>So this is what we do in the first part of this function: We create a square of geometry \([-1,1]^2\) with a circular hole with radius 0.25 located at the origin. We then loop over all cells and all vertices and if a vertex has a \(y\) coordinate equal to one, we move it upward by 0.5.</p>
<p>Note that this sort of procedure does not usually work this way because one will typically encounter the same vertices multiple times and may move them more than once. It works here because we select the vertices we want to use based on their geometric location, and a vertex moved once will fail this test in the future. A more general approach to this problem would have been to keep a std::set of those vertex indices that we have already moved (which we can obtain using <code>cell-&gt;vertex_index(i)</code> and only move those vertices whose index isn't in the set yet.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_3()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(triangulation, 0.25, 1.0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : cell-&gt;vertex_indices())</div><div class="line">        {</div><div class="line">          <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;v = cell-&gt;vertex(i);</div><div class="line">          <span class="keywordflow">if</span> (std::abs(v(1) - 1.0) &lt; 1e-5)</div><div class="line">            v(1) += 0.5;</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>In the second step we will refine the mesh twice. To do this correctly, we should place new points on the interior boundary along the surface of a circle centered at the origin. Fortunately, <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a> already attaches a <a class="el" href="classManifold.html">Manifold</a> object to the interior boundary, so we do not need to do anything but refine the mesh (see the <a href="#Results">results section</a> for a fully worked example where we <em>do</em> attach a <a class="el" href="classManifold.html">Manifold</a> object).</p>
<div class="fragment"><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-3.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>There is one snag to doing things as shown above: If one moves the nodes on the boundary as shown here, one often ends up with cells in the interior that are badly distorted since the interior nodes were not moved around. This is not that much of a problem in the current case since the mesh did not contain any internal nodes when the nodes were moved &ndash; it was the coarse mesh and it so happened that all vertices are at the boundary. It's also the case that the movement we had here was, compared to the average cell size not overly dramatic. Nevertheless, sometimes one does want to move vertices by a significant distance, and in that case one needs to move internal nodes as well. One way to do that automatically is to call the function <a class="el" href="namespaceGridTools.html#a7ed2aaa1aea3ac22b1e1807ce6d0b5f3">GridTools::laplace_transform</a> that takes a set of transformed vertex coordinates and moves all of the other vertices in such a way that the resulting mesh has, in some sense, a small distortion.</p>
<p><a class="anchor" id="grid_4Demonstratingextrude_triangulation"></a> </p><h4>grid_4: Demonstrating extrude_triangulation</h4>
<p>This example takes the initial grid from the previous function and simply extrudes it into the third space dimension:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_4()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> out;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(triangulation, 0.25, 1.0);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation</a>(triangulation, 3, 2.0, out);</div><div class="line">  print_mesh_info(out, <span class="stringliteral">&quot;grid-4.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_5DemonstratingGridToolstransformpart1"></a> </p><h4>grid_5: Demonstrating <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>, part 1</h4>
<p>This and the next example first create a mesh and then transform it by moving every node of the mesh according to a function that takes a point and returns a mapped point. In this case, we transform \((x,y) \mapsto (x,y+\sin(\pi x/5))\).</p>
<p><a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform()</a> takes a triangulation and an argument that can be called like a function taking a <a class="el" href="classPoint.html">Point</a> and returning a <a class="el" href="classPoint.html">Point</a>. There are different ways of providing such an argument: It could be a pointer to a function; it could be an object of a class that has an <code>operator()</code>; it could be a lambda function; or it could be anything that is described via a <code>std::function&lt;<a class="el" href="classPoint.html">Point</a>&lt;2&gt;(const <a class="el" href="classPoint.html">Point</a>&lt;2&gt;)&gt;</code> object.</p>
<p>Decidedly the more modern way is to use a lambda function that takes a <a class="el" href="classPoint.html">Point</a> and returns a <a class="el" href="classPoint.html">Point</a>, and that is what we do in the following:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_5()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = 14;</div><div class="line">  repetitions[1] = 2;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            repetitions,</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(10.0, 1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(</div><div class="line">    [](<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in) {</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(in[0], in[1] + <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * in[0] / 5.0));</div><div class="line">    },</div><div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-5.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_6DemonstratingGridToolstransformpart2"></a> </p><h4>grid_6: Demonstrating <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>, part 2</h4>
<p>In this second example of transforming points from an original to a new mesh, we will use the mapping \((x,y) \mapsto (x,\tanh(2y)/\tanh(2))\). To make things more interesting, rather than doing so in a single function as in the previous example, we here create an object with an <code>operator()</code> that will be called by <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>. Of course, this object may in reality be much more complex: the object may have member variables that play a role in computing the new locations of vertices.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Grid6Func</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> trans(<span class="keyword">const</span> <span class="keywordtype">double</span> y)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(2 * y) / <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">tanh</a>(2);</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;2&gt;</a> operator()(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> {in(0), trans(in(1))};</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_6()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = repetitions[1] = 40;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            repetitions,</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, 1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(Grid6Func(), triangulation);</div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-6.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_7Demonstratingdistort_random"></a> </p><h4>grid_7: Demonstrating distort_random</h4>
<p>In this last example, we create a mesh and then distort its (interior) vertices by a random perturbation. This is not something you want to do for production computations (because results are generally better on meshes with "nicely shaped" cells than on the deformed cells produced by <a class="el" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random()</a>), but it is a useful tool for testing discretizations and codes to make sure they don't work just by accident because the mesh happens to be uniformly structured and supporting superconvergence properties.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_7()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = repetitions[1] = 16;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            repetitions,</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, 1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random</a>(0.3, triangulation, <span class="keyword">true</span>);</div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-7.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>Finally, the main function. There isn't much to do here, only to call all the various functions we wrote above.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      grid_1();</div><div class="line">      grid_2();</div><div class="line">      grid_3();</div><div class="line">      grid_4();</div><div class="line">      grid_5();</div><div class="line">      grid_6();</div><div class="line">      grid_7();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The program produces a series of <code>.vtu</code> files of the triangulations. The methods are discussed above.</p>
<p><a class="anchor" id="NextstepsCurvedCells"></a></p><h3>Next steps: Curved Cells</h3>
<p>As mentioned in the introduction, creating a coarse mesh using the methods discussed here is only the first step. In order to refine a mesh, the <a class="el" href="classTriangulation.html">Triangulation</a> needs to know where to put new vertices on the mid-points of edges, faces, and cells. By default, these new points will be placed at the arithmetic mean of the surrounding points, but this isn't what you want if you need curved boundaries that aren't already adequately resolved by the coarse mesh. For example, for this mesh the central hole is supposed to be round:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2a.png" height="200px"/>
</div>
<p>If you simply refine it, the <a class="el" href="classTriangulation.html">Triangulation</a> class can not know whether you wanted the hole to be round or to be an octagon. The default is to place new points along existing straight lines. After two mesh refinement steps, this would yield the following mesh, which is not what we wanted:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2d-refined.png" height="200px"/>
</div>
<p>What needs to happen is that you tell the triangulation that you in fact want to use a curved geometry. The way to do this requires three steps:</p><ul>
<li>Create an object that describes the desired geometry. This object will be queried when refining the <a class="el" href="classTriangulation.html">Triangulation</a> for new point placement. It will also be used to calculate shape function values if a high degree mapping, like <a class="el" href="classMappingQ.html">MappingQ</a> or <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>, is used during system assembly. In deal.II the <a class="el" href="classManifold.html">Manifold</a> class and classes inheriting from it (e.g., <a class="el" href="classPolarManifold.html">PolarManifold</a> and <a class="el" href="classFlatManifold.html">FlatManifold</a>) perform these calculations.</li>
<li>Notify the <a class="el" href="classTriangulation.html">Triangulation</a> object which <a class="el" href="classManifold.html">Manifold</a> classes to use. By default, a <a class="el" href="classTriangulation.html">Triangulation</a> uses <a class="el" href="classFlatManifold.html">FlatManifold</a> to do all geometric calculations, which assumes that all cell edges are straight lines and all quadrilaterals are flat. You can attach <a class="el" href="classManifold.html">Manifold</a> classes to a <a class="el" href="classTriangulation.html">Triangulation</a> by calling <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold</a> function, which associates a <code>manifold_id</code> with a <a class="el" href="classManifold.html">Manifold</a> object. For more information on this see the <a class="el" href="DEALGlossary.html#GlossManifoldIndicator">glossary entry on this topic</a>.</li>
<li>Finally, you must mark cells and cell faces with the correct <code>manifold_id</code>. For example, you could get an annular sector with curved cells in Cartesian coordinates (but rectangles in polar coordinates) by doing the following: <div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(tria);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell = tria.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">cell-&gt;vertex(2) = <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, 1.0);</div><div class="line">cell-&gt;vertex(3) = <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.5, 1.0);</div><div class="line">tria.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(42);</div><div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(42, <a class="code" href="classPolarManifold.html">PolarManifold&lt;2&gt;</a>(<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.5, -1.0)));</div><div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3);</div></div><!-- fragment --> Now, when the grid is refined, all cell splitting calculations will be done in polar coordinates.</li>
</ul>
<p>All functions in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace which create a mesh where some cells should be curved also attach the correct <a class="el" href="classManifold.html">Manifold</a> object to the provided <a class="el" href="classTriangulation.html">Triangulation</a>: i.e., for those functions we get the correct behavior by default. For a hand-generated mesh, however, the situation is much more interesting.</p>
<p>To illustrate this process in more detail, let us consider an example created by Yuhan Zhou as part of a 2013 semester project at Texas A&amp;M University. The goal was to generate (and use) a geometry that describes a microstructured electric device. In a CAD program, the geometry looks like this:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.1.png"/>
</div>
<p>In the following, we will walk you through the entire process of creating a mesh for this geometry, including a number of common pitfalls by showing the things that can go wrong.</p>
<p>The first step in getting there was to create a coarse mesh, which was done by creating a 2d coarse mesh for each of cross sections, extruding them into the third direction, and gluing them together. The following code does this, using the techniques previously described:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> create_2d_grid(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;2&gt;</a>&gt; &amp;vertices,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;</div><div class="line">    std::array&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;2&gt;::vertices_per_cell</a>&gt;&gt;</div><div class="line">    &amp;               <a class="code" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>,</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;coarse_grid)</div><div class="line">{</div><div class="line">  std::vector&lt;CellData&lt;2&gt;&gt; cells(<a class="code" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>.size());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; cells.size(); ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>[i].size(); ++j)</div><div class="line">        cells[i].vertices[j] = <a class="code" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>[i][j];</div><div class="line">    }</div><div class="line"></div><div class="line">  coarse_grid.<a class="code" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">create_triangulation</a>(vertices, cells, <a class="code" href="structSubCellData.html">SubCellData</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> create_3d_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  <span class="comment">// Generate first cross section</span></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point&lt;2&gt;&gt; vertices_1{{-1.5, 0.},</div><div class="line">                                         {-0.5, 0.},</div><div class="line">                                         {0.5, 0.},</div><div class="line">                                         {1.5, 0.},</div><div class="line"></div><div class="line">                                         {-1.5, 1.5},</div><div class="line">                                         {-0.5, 1.5},</div><div class="line">                                         {0.5, 1.5},</div><div class="line">                                         {1.5, 1.5},</div><div class="line"></div><div class="line">                                         {-1.5, 3.},</div><div class="line">                                         {-0.5, 3.},</div><div class="line">                                         {0.5, 3.},</div><div class="line">                                         {1.5, 3.},</div><div class="line"></div><div class="line">                                         {-0.5, 3 + 0.5 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line">                                         {0.5, 3 + 0.5 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line"></div><div class="line">                                         {-0.75, 3 + 0.75 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line">                                         {0.75, 3 + 0.75 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)}};</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;std::array&lt;unsigned int, GeometryInfo&lt;2&gt;::vertices_per_cell&gt;&gt;</div><div class="line">    cell_vertices_1 = {{{0, 1, 4, 5}},</div><div class="line">                       {{1, 2, 5, 6}},</div><div class="line">                       {{3, 7, 2, 6}},</div><div class="line">                       {{4, 5, 8, 9}},</div><div class="line">                       {{5, 6, 9, 10}},</div><div class="line">                       {{7, 11, 6, 10}},</div><div class="line">                       {{8, 9, 14, 12}},</div><div class="line">                       {{9, 10, 12, 13}},</div><div class="line">                       {{11, 15, 10, 13}},</div><div class="line">                       {{14, 12, 15, 13}}};</div><div class="line"></div><div class="line">  <span class="comment">// Copy vertices into a 2d triangulation</span></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation_2d_1;</div><div class="line">  create_2d_grid(vertices_1, cell_vertices_1, triangulation_2d_1);</div><div class="line"></div><div class="line">  <span class="comment">// Then extrude it into a 3d piece</span></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> triangulation_3d_1;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation</a>(triangulation_2d_1,</div><div class="line">                                       5,</div><div class="line">                                       2.5,</div><div class="line">                                       triangulation_3d_1);</div><div class="line"></div><div class="line">  <span class="comment">// Now do the same with the second volume</span></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point&lt;2&gt;&gt; vertices_2{{-2.5, 0.},</div><div class="line">                                         {-1.5, 0.},</div><div class="line">                                         {-0.5, 0.},</div><div class="line">                                         {0.5, 0.},</div><div class="line">                                         {1.5, 0.},</div><div class="line">                                         {2.5, 0.},</div><div class="line"></div><div class="line">                                         {-2.5, 1.5},</div><div class="line">                                         {-1.5, 1.5},</div><div class="line">                                         {-0.5, 1.5},</div><div class="line">                                         {0.5, 1.5},</div><div class="line">                                         {1.5, 1.5},</div><div class="line">                                         {2.5, 1.5},</div><div class="line"></div><div class="line">                                         {-2.5, 3.},</div><div class="line">                                         {-1.5, 3.},</div><div class="line">                                         {-0.5, 3.},</div><div class="line">                                         {0.5, 3.},</div><div class="line">                                         {1.5, 3.},</div><div class="line">                                         {2.5, 3.},</div><div class="line"></div><div class="line">                                         {-0.5, 3. + 0.5 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line">                                         {0.5, 3. + 0.5 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line"></div><div class="line">                                         {-0.75, 3. + 0.75 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line">                                         {0.75, 3. + 0.75 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line"></div><div class="line">                                         {-1.25, 3. + 1.25 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line">                                         {1.25, 3. + 1.25 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)}};</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;std::array&lt;unsigned int, GeometryInfo&lt;2&gt;::vertices_per_cell&gt;&gt;</div><div class="line">    cell_vertices_2 = {{{0, 1, 6, 7}},</div><div class="line">                       {{1, 2, 7, 8}},</div><div class="line">                       {{2, 3, 8, 9}},</div><div class="line">                       {{4, 10, 3, 9}},</div><div class="line">                       {{5, 11, 4, 10}},</div><div class="line">                       {{6, 7, 12, 13}},</div><div class="line">                       {{7, 8, 13, 14}},</div><div class="line">                       {{8, 9, 14, 15}},</div><div class="line">                       {{10, 16, 9, 15}},</div><div class="line">                       {{11, 17, 10, 16}},</div><div class="line">                       {{12, 13, 22, 20}},</div><div class="line">                       {{13, 14, 20, 18}},</div><div class="line">                       {{14, 15, 18, 19}},</div><div class="line">                       {{16, 21, 15, 19}},</div><div class="line">                       {{17, 23, 16, 21}},</div><div class="line">                       {{20, 18, 21, 19}},</div><div class="line">                       {{22, 20, 23, 21}}};</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation_2d_2;</div><div class="line">  create_2d_grid(vertices_2, cell_vertices_2, triangulation_2d_2);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> triangulation_3d_2;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation</a>(triangulation_2d_2,</div><div class="line">                                       5,</div><div class="line">                                       2.5,</div><div class="line">                                       triangulation_3d_2);</div><div class="line"></div><div class="line">  <span class="comment">// Also shift this triangulation in the z-direction so that it matches the</span></div><div class="line">  <span class="comment">// end face of the first part</span></div><div class="line">  <a class="code" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>(<a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0, 0, 2.5), triangulation_3d_2);</div><div class="line"></div><div class="line">  <span class="comment">// Now first merge these two pieces, then shift the first piece in</span></div><div class="line">  <span class="comment">// z-direction beyond the second, and merge the shifted piece with the two</span></div><div class="line">  <span class="comment">// previously merged one into the final one:</span></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> triangulation_3d_tmp;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(triangulation_3d_1,</div><div class="line">                                      triangulation_3d_2,</div><div class="line">                                      triangulation_3d_tmp);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>(<a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0, 0, 5), triangulation_3d_1);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(triangulation_3d_tmp,</div><div class="line">                                      triangulation_3d_1,</div><div class="line">                                      triangulation);</div><div class="line">}</div></div><!-- fragment --><p>This creates the following mesh:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.8.png" width="400" height="355"/>
</div>
<p>This mesh has the right general shape, but the top cells are now polygonal: their edges are no longer along circles and we do not have a very accurate representation of the original geometry. The next step is to teach the top part of the domain that it should be curved. Put another way, all calculations done on the top boundary cells should be done in cylindrical coordinates rather than Cartesian coordinates. We can do this by creating a <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> object and associating it with the cells above \(y = 3\). This way, when we refine the cells on top, we will place new points along concentric circles instead of straight lines.</p>
<p>In deal.II we describe all geometries with classes that inherit from <a class="el" href="classManifold.html">Manifold</a>. The default geometry is Cartesian and is implemented in the <a class="el" href="classFlatManifold.html">FlatManifold</a> class. As the name suggests, <a class="el" href="classManifold.html">Manifold</a> and its inheriting classes provide a way to describe curves and curved cells in a general way with ideas and terminology from differential geometry: for example, <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> inherits from <a class="el" href="classChartManifold.html">ChartManifold</a>, which describes a geometry through pull backs and push forwards. In general, one should think that the <a class="el" href="classTriangulation.html">Triangulation</a> class describes the topology of a domain (in addition, of course, to storing the locations of the vertices) while the <a class="el" href="classManifold.html">Manifold</a> classes describe the geometry of a domain (e.g., whether or not a pair of vertices lie along a circular arc or a straight line). A <a class="el" href="classTriangulation.html">Triangulation</a> will refine cells by doing computations with the <a class="el" href="classManifold.html">Manifold</a> associated with that cell regardless of whether or not the cell is on the boundary. Put another way: the <a class="el" href="classManifold.html">Manifold</a> classes do not need any information about where the boundary of the <a class="el" href="classTriangulation.html">Triangulation</a> actually is: it is up to the <a class="el" href="classTriangulation.html">Triangulation</a> to query the right <a class="el" href="classManifold.html">Manifold</a> for calculations on a cell. Most <a class="el" href="classManifold.html">Manifold</a> functions (e.g., <a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">Manifold::get_intermediate_point</a>) know nothing about the domain itself and just assume that the points given to it lie along a geodesic. In this case, with the <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> constructed below, the geodesics are arcs along circles orthogonal to the \(z\)-axis centered along the line \((0, 3, z)\).</p>
<p>Since all three top parts of the domain use the same geodesics, we will mark all cells with centers above the \(y = 3\) line as being cylindrical in nature:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a>           axis({0.0, 0.0, 1.0});</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a>               axial_point(0, 3.0, 0.0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classCylindricalManifold.html">CylindricalManifold&lt;3&gt;</a> <a class="code" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a>(axis, axial_point);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::manifold_id</a>     cylinder_id = 8;</div><div class="line"></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">create_3d_grid(triangulation);</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(cylinder_id, <a class="code" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a>);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;center()[1] &gt;= 3.0)</div><div class="line">    cell-&gt;<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(cylinder_id);</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div></div><!-- fragment --><p>With this code, we get a mesh that looks like this:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.9.png" width="400" height="355"/>
</div>
<p>This change fixes the boundary but creates a new problem: the cells adjacent to the cylinder's axis are badly distorted. We should use Cartesian coordinates for calculations on these central cells to avoid this issue. The cells along the center line all have a face that touches the line \((0, 3, z)\) so, to implement this, we go back and overwrite the <code>manifold_id</code>s on these cells to be zero (which is the default):</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a>           axis({0.0, 0.0, 1.0});</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a>               axial_point(0, 3.0, 0.0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classCylindricalManifold.html">CylindricalManifold&lt;3&gt;</a> <a class="code" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a>(axis, axial_point);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::manifold_id</a>     cylinder_id = 8;</div><div class="line"></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">create_3d_grid(triangulation);</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(cylinder_id, <a class="code" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a>);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;center()[1] &gt;= 3.0)</div><div class="line">    cell-&gt;<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(cylinder_id);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> face_center = face-&gt;center();</div><div class="line">      <span class="keywordflow">if</span> (std::abs(face_center[0]) &lt; 1.0e-5 &amp;&amp;</div><div class="line">          std::abs(face_center[1] - 3.0) &lt; 1.0e-5)</div><div class="line">        cell-&gt;<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(<a class="code" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>);</div><div class="line">    }</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div></div><!-- fragment --><p>This gives us the following grid:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.10.png" width="400" height="355"/>
</div>
<p>This gives us a good mesh, where cells at the center of each circle are still Cartesian and cells around the boundary lie along a circle. We can really see the nice detail of the boundary fitted mesh if we refine two more times:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.11.png" width="400" height="355"/>
</div>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p><a class="anchor" id="Assigningdifferentboundaryids"></a></p><h4>Assigning different boundary ids </h4>
<p>It is often useful to assign different boundary ids to a mesh that is generated in one form or another as described in this tutorial to apply different boundary conditions.</p>
<p>For example, you might want to apply a different boundary condition for the right boundary of the first grid in this program. To do this, iterate over the cells and their faces and identify the correct faces (for example using <code>cell-&gt;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center()</a></code> to query the coordinates of the center of a cell as we do in <a class="el" href="step_1.html">step-1</a>, or using <code>cell-&gt;face(f)-&gt;get_boundary_id()</code> to query the current boundary indicator of the \(f\)th face of the cell). You can then use <code>cell-&gt;face(f)-&gt;set_boundary_id()</code> to set the boundary id to something different. You can take a look back at <a class="el" href="step_1.html">step-1</a> how iteration over the meshes is done there.</p>
<p><a class="anchor" id="Extractingaboundarymesh"></a></p><h4>Extracting a boundary mesh </h4>
<p>Computations on manifolds, like they are done in <a class="el" href="step_38.html">step-38</a>, require a surface mesh embedded into a higher dimensional space. While some can be constructed using the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace or loaded from a file, it is sometimes useful to extract a surface mesh from a volume mesh.</p>
<p>Use the function <a class="el" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh()</a> to extract the surface elements of a mesh. Using the function on a 3d mesh (a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;3,3&gt;</code>, for example from <code>grid_4()</code>), this will return a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,3&gt;</code> that you can use in <a class="el" href="step_38.html">step-38</a>. Also try extracting the boundary mesh of a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,2&gt;</code>.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2013 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Timo Heister, Texas A&amp;M University, 2013</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> print_mesh_info(<span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;triangulation,</div><div class="line">                     <span class="keyword">const</span> std::string &amp;       filename)</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh info:&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; dimension: &quot;</span> &lt;&lt; dim &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; no. of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    std::map&lt;types::boundary_id, unsigned int&gt; boundary_count;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : triangulation.<a class="code" href="group__CPP11.html#ga1bf11e9e1e5c2ff59a9c7b3f5a2bc5ad">active_face_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">        boundary_count[face-&gt;boundary_id()]++;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; boundary indicators: &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;const types::boundary_id, unsigned int&gt; &amp;pair :</div><div class="line">         boundary_count)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="stringliteral">&quot; times) &quot;</span>;</div><div class="line">      }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ofstream out(filename);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a8bd3a74b86d7c0eb792d2efca7f945f1">write_vtu</a>(triangulation, out);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; written to &quot;</span> &lt;&lt; filename &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_1()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classGridIn.html">GridIn&lt;2&gt;</a> gridin;</div><div class="line">  gridin.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(triangulation);</div><div class="line">  std::ifstream f(<span class="stringliteral">&quot;example.msh&quot;</span>);</div><div class="line">  gridin.<a class="code" href="group__simplex.html#ga83872db02e04f52ac52d578912f6da5e">read_msh</a>(f);</div><div class="line"></div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-1.vtu&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_2()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria1;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(tria1, 0.25, 1.0);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          tria2;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = 3;</div><div class="line">  repetitions[1] = 2;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(tria2,</div><div class="line">                                            repetitions,</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, -1.0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(4.0, 1.0));</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(tria1, tria2, triangulation);</div><div class="line"></div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-2.vtu&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_3()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(triangulation, 0.25, 1.0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : cell-&gt;vertex_indices())</div><div class="line">        {</div><div class="line">          <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;v = cell-&gt;vertex(i);</div><div class="line">          <span class="keywordflow">if</span> (std::abs(v(1) - 1.0) &lt; 1e-5)</div><div class="line">            v(1) += 0.5;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-3.vtu&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_4()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> out;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(triangulation, 0.25, 1.0);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation</a>(triangulation, 3, 2.0, out);</div><div class="line">  print_mesh_info(out, <span class="stringliteral">&quot;grid-4.vtu&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_5()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = 14;</div><div class="line">  repetitions[1] = 2;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            repetitions,</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(10.0, 1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(</div><div class="line">    [](<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in) {</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(in[0], in[1] + <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * in[0] / 5.0));</div><div class="line">    },</div><div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-5.vtu&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct </span>Grid6Func</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> trans(<span class="keyword">const</span> <span class="keywordtype">double</span> y)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(2 * y) / <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">tanh</a>(2);</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;2&gt;</a> operator()(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> {in(0), trans(in(1))};</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_6()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = repetitions[1] = 40;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            repetitions,</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, 1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(Grid6Func(), triangulation);</div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-6.vtu&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_7()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = repetitions[1] = 16;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            repetitions,</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, 1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random</a>(0.3, triangulation, <span class="keyword">true</span>);</div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-7.vtu&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      grid_1();</div><div class="line">      grid_2();</div><div class="line">      grid_3();</div><div class="line">      grid_4();</div><div class="line">      grid_5();</div><div class="line">      grid_6();</div><div class="line">      grid_7();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_1.html">step-1</a> . <table class="tutorial"
 width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#Generalconcernsaboutmeshes">General concerns about
 meshes</a><a href="#Generalconcernsaboutmeshes">General concerns about
 meshes</a>
 <li><a href="#Howtocreatemeshes">How to create meshes</a><a
 href="#Howtocreatemeshes">How to create meshes</a>
 <ul>
 <li><a href="#UsingGridGenerator">Using GridGenerator</a><a
 href="#UsingGridGenerator">Using GridGenerator</a>
 <li><a href="#Constructingyourownmeshprogrammatically">Constructing your
 own mesh programmatically</a><a
 href="#Constructingyourownmeshprogrammatically">Constructing your own mesh
 programmatically</a>
 <li><a href="#Importingfromexternalprograms">Importing from external
 programs</a><a href="#Importingfromexternalprograms">Importing from
 external programs</a>
 </ul>
 <li><a href="#ModifyingaMesh">Modifying a Mesh</a><a
 href="#ModifyingaMesh">Modifying a Mesh</a>
 <ul>
 <li><a href="#Transformations">Transformations</a><a
 href="#Transformations">Transformations</a>
 <li><a href="#MergingMeshes">Merging Meshes</a><a
 href="#MergingMeshes">Merging Meshes</a>
 <li><a href="#MovingVertices">Moving Vertices</a><a
 href="#MovingVertices">Moving Vertices</a>
 <li><a href="#ExtrudingMeshes">Extruding Meshes</a><a
 href="#ExtrudingMeshes">Extruding Meshes</a>
 </ul>
 <li><a href="#Afteryouhaveacoarsemesh"> After you have a coarse mesh </a><a
 href="#Afteryouhaveacoarsemesh"> After you have a coarse mesh </a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Includefiles">Include files</a><a
 href="#Includefiles">Include files</a>
 <li><a href="#Generatingoutputforagivenmesh">Generating output for a given
 mesh</a><a href="#Generatingoutputforagivenmesh">Generating output for a
 given mesh</a>
 <li><a href="#Mainroutines">Main routines</a><a href="#Mainroutines">Main
 routines</a>
 <ul>
 <li><a href="#grid_1Loadingameshgeneratedbygmsh">grid_1: Loading a mesh
 generated by gmsh</a><a href="#grid_1Loadingameshgeneratedbygmsh">grid_1:
 Loading a mesh generated by gmsh</a>
 <li><a href="#grid_2Mergingtriangulations">grid_2: Merging
 triangulations</a><a href="#grid_2Mergingtriangulations">grid_2: Merging
 triangulations</a>
 <li><a href="#grid_3Movingvertices">grid_3: Moving vertices</a><a
 href="#grid_3Movingvertices">grid_3: Moving vertices</a>
 <li><a href="#grid_4Demonstratingextrude_triangulation">grid_4:
 Demonstrating extrude_triangulation</a><a
 href="#grid_4Demonstratingextrude_triangulation">grid_4: Demonstrating
 extrude_triangulation</a>
 <li><a href="#grid_5DemonstratingGridToolstransformpart1">grid_5:
 Demonstrating GridTools::transform, part 1</a><a
 href="#grid_5DemonstratingGridToolstransformpart1">grid_5: Demonstrating
 GridTools::transform, part 1</a>
 <li><a href="#grid_6DemonstratingGridToolstransformpart2">grid_6:
 Demonstrating GridTools::transform, part 2</a><a
 href="#grid_6DemonstratingGridToolstransformpart2">grid_6: Demonstrating
 GridTools::transform, part 2</a>
 <li><a href="#grid_7Demonstratingdistort_random">grid_7: Demonstrating
 distort_random</a><a href="#grid_7Demonstratingdistort_random">grid_7:
 Demonstrating distort_random</a>
 </ul>
 <li><a href="#Themainfunction">The main function</a><a
 href="#Themainfunction">The main function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#NextstepsCurvedCells">Next steps: Curved Cells</a><a
 href="#NextstepsCurvedCells">Next steps: Curved Cells</a>
 <li><a href="#Possibilitiesforextensions"> Possibilities for extensions
 </a><a href="#Possibilitiesforextensions"> Possibilities for extensions
 </a>
 <ul>
 <li><a href="#Assigningdifferentboundaryids"> Assigning different boundary
 ids </a><a href="#Assigningdifferentboundaryids"> Assigning different
 boundary ids </a>
 <li><a href="#Extractingaboundarymesh"> Extracting a boundary mesh </a><a
 href="#Extractingaboundarymesh"> Extracting a boundary mesh </a>
 </ul>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <em>This program was contributed by Timo Heister. Parts of the results section were contributed by Yuhan Zhou, Wolfgang Bangerth, and David Wells.</em> <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction </h1>
<p>This tutorial is an extension to <a class="el" href="step_1.html">step-1</a> and demonstrates several ways toobtain more involved meshes than the ones shown there. </p><dl class="section note"><dt>Note</dt><dd>This tutorial is also available as a Jupyter Python notebook that uses the deal.II python interface. The notebook is available in the same directory as the original C++ program. Generating complex geometries is a challenging task, especially in three spacedimensions. We will discuss several ways to do this, but this list is notexhaustive. Additionally, there is not one approach that fits all problems. This example program shows some of ways to create and modify meshes forcomputations and outputs them as <code>.vtu</code> files in much the same wayas we do in <a class="el" href="step_1.html">step-1</a> . No other computations or adaptiverefinements are done; the idea is that you can use the techniques used here asbuilding blocks in other, more involved simulators. Please note that theexample program does not show all the ways to generate meshes that arediscussed in this introduction.</dd></dl>
<p><a class="anchor" id="Generalconcernsaboutmeshes"></a></p><h3>General concerns about meshes</h3>
<p>When you use adaptive mesh refinement, you definitely want the initial mesh tobe as coarse as possible. The reason is that you can make it as fine as youwant using adaptive refinement as long as you have memory and CPU timeavailable. However, this requires that you don't waste mesh cells in parts ofthe domain where they don't pay off. As a consequence, you don't want to startwith a mesh that is too fine to start with, because that takes up a good partof your cell budget already, and because you can't coarsen away cells that arein the initial mesh. That said, your mesh needs to capture the given geometry adequately.</p>
<p><a class="anchor" id="Howtocreatemeshes"></a></p><h3>How to create meshes</h3>
<p>There are several ways to create an initial mesh. Meshes can be modified orcombined in many ways as discussed later on. <a class="anchor" id="UsingGridGenerator"></a></p><h4>Using <a class="el" href="namespaceGridGenerator.html">GridGenerator</a></h4>
<p>The easiest way to generate meshes is to use the functions in namespaceGridGenerator, as already discussed in <a class="el" href="step_1.html">step-1</a> . There are many differenthelper functionsavailable, including <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>, <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a>, <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball()</a>, and <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole()</a>.</p>
<p><a class="anchor" id="Constructingyourownmeshprogrammatically"></a></p><h4>Constructing your own mesh programmatically</h4>
<p>If there is no good fit in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace for what you want todo, you can always create aTriangulation in your program "by hand". For that, you need a list of verticeswith their coordinates and a list of cells referencing those vertices. You canfind an example in the function <code>create_coarse_grid()</code> in <a class="el" href="step_14.html">step-14</a> .All the functions in <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> are implemented in this fashion. We are happy to accept more functions to be added to <a class="el" href="namespaceGridGenerator.html">GridGenerator</a>. So, ifyou end up writing a function that might be useful for a larger audience,please contribute it.</p>
<p><a class="anchor" id="Importingfromexternalprograms"></a></p><h4>Importing from external programs</h4>
<p>The class <a class="el" href="classGridIn.html">GridIn</a> can read many different mesh formats from a file fromdisk. How this is done is explained in <a class="el" href="step_5.html">step-5</a> and can be seen in the function <code>grid_1</code> in this example, see the code below. Meshes can be generated from different tools like <a href="http://gmsh.info" target="_top">gmsh</a>, <a href="https://lagrit.lanl.gov/" target="_top">lagrit</a> and <a href="http://cubit.sandia.gov/" target="_top">cubit</a>. See thedocumentation of <a class="el" href="classGridIn.html">GridIn</a> for more information. The problem is that deal.IIneeds meshes that only consist of quadrilaterals and hexahedra</p>
<ul>
<li>tetrahedralmeshes won't work (this means tools like tetgen can not be used directly). We will describe a possible workflow using Gmsh. Gmsh is the smallest andmost quickly set up open source tool we are aware of. It can generateunstructured 2d quad meshes. In 3d, it can extrude 2d meshes toget hexahedral meshes; 3D meshing of unstructured geometry into hexahedra ispossible, though there are some issues with the quality of these meshesthat imply that these meshes only sometimes work in deal.II. In Gmsh, a mesh is fundamentally described in a text-based <code>.geo</code> file whose format cancontain computations, loops, variables, etc. This format is quite flexiblein allowing the description of complex geometries. The mesh is thengenerated from a surface representation, which is built from a list of lineloops, which is built from a list of lines, which are in turn built frompoints. The <code>.geo</code> script can be written and edited by hand or itcan be generated automatically by creating objects graphically inside Gmsh. Inmany cases it is best to combine both approaches. The file can be easilyreloaded by pressing "reload" under the "Geometry" tab if you want to writeit by hand and see the effects in the graphical user interface of gmsh. This tutorial contains an example <code>.geo</code> file that describes a boxwith two objects cut out in the interior. This is how <code>example.geo</code> looks like in Gmsh (displaying the boundaryindicators as well as the mesh discussed further down below): <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.gmsh_picture.png"/>
</div>
 <dl class="section note"><dt>Note</dt><dd>It is important that this file contain "physical lines" and "physical  surfaces". These give the boundary indicators and material ids for use in deal.II. Without these physical entities, nothing will be imported into deal.II. deal.II's <a class="el" href="classGridIn.html">GridIn</a> class can read the <code>.msh</code> format written byGmsh and that contains a mesh created for the geometry described by the <code>.geo</code> file. You generate the <code>.msh</code> from the <code>.geo</code> by running the commands <div class="fragment"><div class="line">gmsh</div><div class="line"></div><div class="line">-2 example.geo</div></div><!-- fragment --></dd></dl>
on the command line, or by clicking "Mesh" and then "2D" inside Gmsh afterloading the file. Now this is the mesh read from the <code>.msh</code> fileand saved again by deal.II as an image (see the <code>grid_1</code> functionof the current program): <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-1.png"/>
</div>
 <dl class="section note"><dt>Note</dt><dd>Gmsh has a number of other interfaces by which one can describe geometries to it. In particular, it has the ability to interface with scripting languages like Python and Julia, but it can also be scripted from C++. These interfaces are useful if one doesn't just want to generate a mesh for a single geometry (in which case the graphical interface or, in simple cases, a hand-written <code>.geo</code> file is probably the simplest approach), but instead wants to do parametric studies over the geometry for which it is necessary to generate many meshes for geometries that differ in certain parameters. Another case where this is useful is if there is already a CAD geometry for which one only needs a mesh; indeed, this can be done from within deal.II using the <a class="el" href="namespaceGmsh.html#ab65eb217368d006b66bcfcc6fa0f2894">Gmsh::create_triangulation_from_boundary_curve()</a> function.</dd></dl>
<a class="anchor" id="ModifyingaMesh"></a><h3>Modifying a Mesh</h3>
</li>
</ul>
<p>After acquiring one (or several) meshes in the ways described above, there aremany ways to manipulate them before using them in a finite elementcomputation.</p>
<p><a class="anchor" id="Transformations"></a></p><h4>Transformations</h4>
<p>The <a class="el" href="namespaceGridTools.html">GridTools</a> namespace contains a collection of small functions to transforma given mesh in various ways. The usage of the functions <a class="el" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>, <a class="el" href="namespaceGridTools.html#a910bb99ec34eac082da97c08e7dd17c3">GridTools::rotate</a>, <a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">GridTools::scale</a> is fairly obvious, so we won't discussthose functions here. The function <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a> allows you to transform the vertices of agiven mesh using a smooth function. An example of its use is also given in theresults section of <a class="el" href="step_38.html">step-38</a> but let us show a simpler example here:In the function <code>grid_5()</code> of the current program, we perturb the ycoordinate of a mesh with a sine curve: </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-5a.png"/>
</div>
 regular input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-5.png"/>
</div>
 output mesh   </td></tr>
</table>
<p>Similarly, we can transform a regularly refinedunit square to a wall-adapted mesh in y direction using the formula \((x,y) \mapsto (x,\tanh(2 y)/\tanh(2))\) . This is done in <code>grid_6()</code> of this tutorial: </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-6a.png"/>
</div>
 regular input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-6.png"/>
</div>
 wall-adapted output mesh   </td></tr>
</table>
<p>Finally, the function <a class="el" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random</a> allows you to move vertices in themesh (optionally ignoring boundary nodes) by a random amount. This isdemonstrated in <code>grid_7()</code> and the result is as follows: </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-7a.png"/>
</div>
 regular input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-7.png"/>
</div>
 perturbed output mesh   </td></tr>
</table>
<p>This function is primarily intended to negate some of the superconvergenceeffects one gets when studying convergence on regular meshes, as well as tosuppress some optimizations in deal.II that can exploit the fact that cellsare similar in shape. (Superconvergence refers to the fact that if a meshhas certain symmetries</p>
<ul>
<li>for example, if the edges running into a vertexare symmetric to this vertex, and if this is so for all vertices of a cell</li>
<li>that the solution is then often convergent with a higher order than onewould have expected from the usual error analysis. In the end, thisis a result of the fact that if one were to make a Taylor expansion of theerror, the symmetry leads to the fact that the expected next term of theexpansion happens to be zero, and the error order is determined by the second next* term. A distorted mesh does not have these symmetries andconsequently the error reflects what one will see when solving the equationonany* kind of mesh, rather than showing something that is only reflectiveof a particular situation.)</li>
</ul>
<p><a class="anchor" id="MergingMeshes"></a></p><h4>Merging Meshes</h4>
<p>The function <a class="el" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations()</a> allows you to merge twogiven <a class="el" href="classTriangulation.html">Triangulation</a> objects into a single one. For this to work, the verticesof the shared edge or face have to match exactly. Lining up the two meshescan be achieved using <a class="el" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a> and <a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">GridTools::scale</a>. In the function <code>grid_2()</code> of this tutorial, we merge a square with a round hole(generated with <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole()</a>) and arectangle (generated with <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle()</a>). Thefunction <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle()</a> allows you to specify thenumber of repetitions and the positions of the corners, so there is no need toshift the triangulation manually here. You should inspect the mesh graphicallyto make sure that cells line up correctly and no unpaired nodes exist in themerged <a class="el" href="classTriangulation.html">Triangulation</a>. These are the input meshes and the output mesh: </p><table width="80%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2a.png" height="200px"/>
</div>
input mesh 1 </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2b.png" height="200px"/>
</div>
input mesh 2 </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2.png" height="200px"/>
</div>
merged mesh  </td></tr>
</table>
<p><a class="anchor" id="MovingVertices"></a></p><h4>Moving Vertices</h4>
<p>The function <code>grid_3()</code> demonstrates the ability to pick individual vertices andmove them around in an existing mesh. Note that this has the potential to produce degenerateor inverted cells and you shouldn't expect anything useful to come of usingsuch meshes. Here, we create a box with a cylindrical hole that is not exactlycentered by moving the top vertices upwards: </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-3a.png" height="200px"/>
</div>
 input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-3.png" height="200px"/>
</div>
 top vertices moved upwards   </td></tr>
</table>
<p>For the exact way how this is done, see the code below.</p>
<p><a class="anchor" id="ExtrudingMeshes"></a></p><h4>Extruding Meshes</h4>
<p>If you need a 3d mesh that can be created by extruding a given 2d mesh (thatcan be created in any of the ways given above), you can use the function <a class="el" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation()</a>. See the <code>grid_4()</code> functionin this tutorial for an example. Note that for this particular case, the givenresult could also be achieved using the 3d version of <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole()</a>. The main usage is a 2dmesh, generated for example with Gmsh, that is read in from a <code>.msh</code> file as described above. This is the output from grid_4(): </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-4base.png"/>
</div>
 input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-4.png"/>
</div>
 extruded output mesh   </td></tr>
</table>
<p><a class="anchor" id="Afteryouhaveacoarsemesh"></a></p><h3>After you have a coarse mesh </h3>
<p>Creating a coarse mesh using the methods discussed above is only the firststep. When you have it, it will typically serve as the basis for further meshrefinement. This is not difficult &mdash; in fact, there is nothing else to do&mdash; if your geometry consists of only straight faces. However, this isoften not the case if you have a more complex geometry and more steps thanjust creating the mesh are necessary. We will go over some of these steps inthe <a href="#Results">results section</a> below.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>This tutorial program is odd in the sense that, unlike for most other steps, the introduction already provides most of the information on how to use the various strategies to generate meshes. Consequently, there is little that remains to be commented on here, and we intersperse the code with relatively little text. In essence, the code here simply provides a reference implementation of what has already been described in the introduction.</p>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Generatingoutputforagivenmesh"></a> </p><h3>Generating output for a given mesh</h3>
<p>The following function generates some output for any of the meshes we will be generating in the remainder of this program. In particular, it generates the following information:</p>
<ul>
<li>Some general information about the number of space dimensions in which this mesh lives and its number of cells.</li>
<li>The number of boundary faces that use each boundary indicator, so that it can be compared with what we expect.</li>
</ul>
<p>Finally, the function outputs the mesh in VTU format that can easily be visualized in Paraview or VisIt.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> print_mesh_info(<span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;triangulation,</div><div class="line">                   <span class="keyword">const</span> std::string &amp;       filename)</div><div class="line">{</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh info:&quot;</span> &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; dimension: &quot;</span> &lt;&lt; dim &lt;&lt; std::endl</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; no. of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl;</div></div><!-- fragment --><p>Next loop over all faces of all cells and find how often each boundary indicator is used (recall that if you access an element of a std::map object that doesn't exist, it is implicitly created and default initialized</p>
<ul>
<li>to zero, in the current case</li>
<li>before we then increment it):</li>
</ul>
<div class="fragment"><div class="line">{</div><div class="line">  std::map&lt;types::boundary_id, unsigned int&gt; boundary_count;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : triangulation.<a class="code" href="group__CPP11.html#ga1bf11e9e1e5c2ff59a9c7b3f5a2bc5ad">active_face_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">      boundary_count[face-&gt;boundary_id()]++;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; boundary indicators: &quot;</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;const types::boundary_id, unsigned int&gt; &amp;pair :</div><div class="line">       boundary_count)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; pair.first &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="stringliteral">&quot; times) &quot;</span>;</div><div class="line">    }</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Finally, produce a graphical representation of the mesh to an output file :</p>
<div class="fragment"><div class="line">std::ofstream out(filename);</div><div class="line"><a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">grid_out.<a class="code" href="classGridOut.html#a8bd3a74b86d7c0eb792d2efca7f945f1">write_vtu</a>(triangulation, out);</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot; written to &quot;</span> &lt;&lt; filename &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Mainroutines"></a> </p><h3>Main routines</h3>
<p><a class="anchor" id="grid_1Loadingameshgeneratedbygmsh"></a> </p><h4>grid_1: Loading a mesh generated by gmsh</h4>
<p>In this first example, we show how to load the mesh for which we have discussed in the introduction how to generate it. This follows the same pattern as used in <a class="el" href="step_5.html">step-5</a> to load a mesh, although there it was written in a different file format (UCD instead of MSH).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_1()</div><div class="line">{</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line"><a class="code" href="classGridIn.html">GridIn&lt;2&gt;</a> gridin;</div><div class="line">gridin.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(triangulation);</div><div class="line">std::ifstream f(<span class="stringliteral">&quot;example.msh&quot;</span>);</div><div class="line">gridin.<a class="code" href="group__simplex.html#ga83872db02e04f52ac52d578912f6da5e">read_msh</a>(f);</div><div class="line"></div><div class="line">print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-1.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_2Mergingtriangulations"></a> </p><h4>grid_2: Merging triangulations</h4>
<p>Here, we first create two triangulations and then merge them into one. As discussed in the introduction, it is important to ensure that the vertices at the common interface are located at the same coordinates.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_2()</div><div class="line">{</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria1;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(tria1, 0.25, 1.0);</div><div class="line"></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          tria2;</div><div class="line">std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">repetitions[0] = 3;</div><div class="line">repetitions[1] = 2;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(tria2,</div><div class="line">                                          repetitions,</div><div class="line">                                          <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0,</div><div class="line"></div><div class="line">-1.0),</div><div class="line">                                          <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(4.0, 1.0));</div><div class="line"></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(tria1, tria2, triangulation);</div><div class="line"></div><div class="line">print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-2.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_3Movingvertices"></a> </p><h4>grid_3: Moving vertices</h4>
<p>In this function, we move vertices of a mesh. This is simpler than one usually expects: if you ask a cell using <code>cell-&gt;vertex(i)</code> for the coordinates of its <code>i</code> th vertex, it doesn't just provide the location of this vertex but in fact a reference to the location where these coordinates are stored. We can then modify the value stored there.</p>
<p>So this is what we do in the first part of this function: We create a square of geometry \([-1,1]^2\) with a circular hole with radius 0.25 located at the origin. We then loop over all cells and all vertices and if a vertex has a \(y\) coordinate equal to one, we move it upward by 0.5.</p>
<p>Note that this sort of procedure does not usually work this way because one will typically encounter the same vertices multiple times and may move them more than once. It works here because we select the vertices we want to use based on their geometric location, and a vertex moved once will fail this test in the future. A more general approach to this problem would have been to keep a std::set of those vertex indices that we have already moved (which we can obtain using <code>cell-&gt;vertex_index(i)</code> and only move those vertices whose index isn't in the set yet.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_3()</div><div class="line">{</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(triangulation, 0.25, 1.0);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : cell-&gt;vertex_indices())</div><div class="line">      {</div><div class="line">        <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;v = cell-&gt;vertex(i);</div><div class="line">        <span class="keywordflow">if</span> (std::abs(v(1)</div><div class="line"></div><div class="line">- 1.0) &lt; 1e-5)</div><div class="line">          v(1) += 0.5;</div><div class="line">      }</div><div class="line">  }</div></div><!-- fragment --><p>In the second step we will refine the mesh twice. To do this correctly, we should place new points on the interior boundary along the surface of a circle centered at the origin. Fortunately, <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a> already attaches a <a class="el" href="classManifold.html">Manifold</a> object to the interior boundary, so we do not need to do anything but refine the mesh (see the <a href="#Results">results section</a> for a fully worked example where we <em> do </em> attach a <a class="el" href="classManifold.html">Manifold</a> object).</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div><div class="line">print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-3.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>There is one snag to doing things as shown above: If one moves the nodes on the boundary as shown here, one often ends up with cells in the interior that are badly distorted since the interior nodes were not moved around. This is not that much of a problem in the current case since the mesh did not contain any internal nodes when the nodes were moved</p>
<ul>
<li>it was the coarse mesh and it so happened that all vertices are at the boundary. It's also the case that the movement we had here was, compared to the average cell size not overly dramatic. Nevertheless, sometimes one does want to move vertices by a significant distance, and in that case one needs to move internal nodes as well. One way to do that automatically is to call the function <a class="el" href="namespaceGridTools.html#a7ed2aaa1aea3ac22b1e1807ce6d0b5f3">GridTools::laplace_transform</a> that takes a set of transformed vertex coordinates and moves all of the other vertices in such a way that the resulting mesh has, in some sense, a small distortion.</li>
</ul>
<p><a class="anchor" id="grid_4Demonstratingextrude_triangulation"></a> </p><h4>grid_4: Demonstrating extrude_triangulation</h4>
<p>This example takes the initial grid from the previous function and simply extrudes it into the third space dimension:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_4()</div><div class="line">{</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> out;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(triangulation, 0.25, 1.0);</div><div class="line"></div><div class="line"><a class="code" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation</a>(triangulation, 3, 2.0, out);</div><div class="line">print_mesh_info(out, <span class="stringliteral">&quot;grid-4.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_5DemonstratingGridToolstransformpart1"></a> </p><h4>grid_5: Demonstrating <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>, part 1</h4>
<p>This and the next example first create a mesh and then transform it by moving every node of the mesh according to a function that takes a point and returns a mapped point. In this case, we transform \((x,y) \mapsto (x,y+\sin(\pi x/5))\) .</p>
<p><a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform()</a> takes a triangulation and an argument that can be called like a function taking a <a class="el" href="classPoint.html">Point</a> and returning a <a class="el" href="classPoint.html">Point</a>. There are different ways of providing such an argument: It could be a pointer to a function; it could be an object of a class that has an <code>operator()</code>; it could be a lambda function; or it could be anything that is described via a <code>std::function&lt;<a class="el" href="classPoint.html">Point</a>&lt;2&gt;(const <a class="el" href="classPoint.html">Point</a>&lt;2&gt;)&gt;</code> object.</p>
<p>Decidedly the more modern way is to use a lambda function that takes a <a class="el" href="classPoint.html">Point</a> and returns a <a class="el" href="classPoint.html">Point</a>, and that is what we do in the following:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_5()</div><div class="line">{</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">repetitions[0] = 14;</div><div class="line">repetitions[1] = 2;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                          repetitions,</div><div class="line">                                          <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div><div class="line">                                          <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(10.0, 1.0));</div><div class="line"></div><div class="line"><a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(</div><div class="line">  [](<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in) {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(in[0], in[1] + <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> in[0] / 5.0));</div><div class="line">  },</div><div class="line">  <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div><div class="line">print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-5.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_6DemonstratingGridToolstransformpart2"></a> </p><h4>grid_6: Demonstrating <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>, part 2</h4>
<p>In this second example of transforming points from an original to a new mesh, we will use the mapping \((x,y) \mapsto (x,\tanh(2y)/\tanh(2))\) . To make things more interesting, rather than doing so in a single function as in the previous example, we here create an object with an <code>operator()</code> that will be called by <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>. Of course, this object may in reality be much more complex: the object may have member variables that play a role in computing the new locations of vertices.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Grid6Func</div><div class="line">{</div><div class="line"><span class="keywordtype">double</span> trans(<span class="keyword">const</span> <span class="keywordtype">double</span> y)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(2 y) / <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">tanh</a>(2);</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="classPoint.html">Point&lt;2&gt;</a> operator()(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> {in(0), trans(in(1))};</div><div class="line">}</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_6()</div><div class="line">{</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">repetitions[0] = repetitions[1] = 40;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                          repetitions,</div><div class="line">                                          <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div><div class="line">                                          <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, 1.0));</div><div class="line"></div><div class="line"><a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(Grid6Func(), triangulation);</div><div class="line">print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-6.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_7Demonstratingdistort_random"></a> </p><h4>grid_7: Demonstrating distort_random</h4>
<p>In this last example, we create a mesh and then distort its (interior) vertices by a random perturbation. This is not something you want to do for production computations (because results are generally better on meshes with "nicely shaped" cells than on the deformed cells produced by <a class="el" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random()</a>), but it is a useful tool for testing discretizations and codes to make sure they don't work just by accident because the mesh happens to be uniformly structured and supporting superconvergence properties.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_7()</div><div class="line">{</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">repetitions[0] = repetitions[1] = 16;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                          repetitions,</div><div class="line">                                          <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div><div class="line">                                          <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, 1.0));</div><div class="line"></div><div class="line"><a class="code" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random</a>(0.3, triangulation, <span class="keyword">true</span>);</div><div class="line">print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-7.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>Finally, the main function. There isn't much to do here, only to call all the various functions we wrote above.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    grid_1();</div><div class="line">    grid_2();</div><div class="line">    grid_3();</div><div class="line">    grid_4();</div><div class="line">    grid_5();</div><div class="line">    grid_6();</div><div class="line">    grid_7();</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The program produces a series of <code>.vtu</code> files of thetriangulations. The methods are discussed above.</p>
<p><a class="anchor" id="NextstepsCurvedCells"></a></p><h3>Next steps: Curved Cells</h3>
<p>As mentioned in the introduction, creating a coarse mesh using the methodsdiscussed here is only the first step. In order to refine a mesh, theTriangulation needs to know where to put new vertices on the mid-points ofedges, faces, and cells. By default, these new points will be placed at thearithmetic mean of the surrounding points, but this isn't what you want if youneed curved boundaries that aren't already adequately resolved by the coarsemesh. For example, for this mesh the central hole is supposed to be round: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2a.png" height="200px"/>
</div>
<p> If you simply refine it, the <a class="el" href="classTriangulation.html">Triangulation</a> class can not know whether you wantedthe hole to be round or to be an octagon. The default is to place new pointsalong existing straight lines. After two mesh refinement steps, this would yieldthe following mesh, which is not what we wanted: </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2d-refined.png" height="200px"/>
</div>
<p> What needs to happen is that you tell the triangulation that you in fact wantto use a curved geometry. The way to do this requires three steps:</p>
<ul>
<li>Create an object that describes the desired geometry. This object will be queried when refining the <a class="el" href="classTriangulation.html">Triangulation</a> for new point placement. It will also be used to calculate shape function values if a high degree mapping, like <a class="el" href="classMappingQ.html">MappingQ</a> or <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>, is used during system assembly. In deal.II the <a class="el" href="classManifold.html">Manifold</a> class and classes inheriting from it (e.g., <a class="el" href="classPolarManifold.html">PolarManifold</a> and <a class="el" href="classFlatManifold.html">FlatManifold</a>) perform these calculations.</li>
<li>Notify the <a class="el" href="classTriangulation.html">Triangulation</a> object which <a class="el" href="classManifold.html">Manifold</a> classes to use. By default, a <a class="el" href="classTriangulation.html">Triangulation</a> uses <a class="el" href="classFlatManifold.html">FlatManifold</a> to do all geometric calculations, which assumes that all cell edges are straight lines and all quadrilaterals are flat. You can attach <a class="el" href="classManifold.html">Manifold</a> classes to a <a class="el" href="classTriangulation.html">Triangulation</a> by calling <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold</a> function, which associates a <code>manifold_id</code> with a <a class="el" href="classManifold.html">Manifold</a> object. For more information on this see the <a class="el" href="DEALGlossary.html#GlossManifoldIndicator">glossary entry on this topic</a>.</li>
<li>Finally, you must mark cells and cell faces with the correct <code>manifold_id</code> . For example, you could get an annular sector with curved cells in Cartesian coordinates (but rectangles in polar coordinates) by doing the following: <div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(tria);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell = tria.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">cell-&gt;vertex(2) = <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, 1.0);</div><div class="line">cell-&gt;vertex(3) = <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.5, 1.0);</div><div class="line">tria.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(42);</div><div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(42, <a class="code" href="classPolarManifold.html">PolarManifold&lt;2&gt;</a>(<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.5,</div><div class="line"></div><div class="line">-1.0)));</div><div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3);</div></div><!-- fragment --> Now, when the grid is refined, all cell splitting calculations will be done in polar coordinates. All functions in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace which create a mesh where somecells should be curved also attach the correct <a class="el" href="classManifold.html">Manifold</a> object to the providedTriangulation: i.e., for those functions we get the correct behavior bydefault. For a hand-generated mesh, however, the situation is much moreinteresting. To illustrate this process in more detail, let us consider an example createdby Yuhan Zhou as part of a 2013 semester project at Texas A&amp;M University.The goal was to generate (and use) a geometry that describes amicrostructured electric device. In a CAD program, the geometry looks likethis: <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.1.png"/>
</div>
 In the following, we will walk you through the entire process of creating amesh for this geometry, including a number of common pitfalls by showing thethings that can go wrong. The first step in getting there was to create a coarse mesh, which was done bycreating a 2d coarse mesh for each of cross sections, extruding them into thethird direction, and gluing them together. The following code does this, usingthe techniques previously described: <div class="fragment"><div class="line"><span class="keywordtype">void</span> create_2d_grid(</div><div class="line"><span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;2&gt;</a>&gt; &amp;vertices,</div><div class="line"><span class="keyword">const</span> std::vector&lt;</div><div class="line"> std::array&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;2&gt;::vertices_per_cell</a>&gt;&gt;</div><div class="line"> &amp;               <a class="code" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>,</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;coarse_grid)</div><div class="line">{</div><div class="line">std::vector&lt;CellData&lt;2&gt;&gt; cells(<a class="code" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>.size());</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; cells.size(); ++i)</div><div class="line"> {</div><div class="line">   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>[i].size(); ++j)</div><div class="line">     cells[i].vertices[j] = <a class="code" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>[i][j];</div><div class="line"> }</div><div class="line"></div><div class="line">coarse_grid.<a class="code" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">create_triangulation</a>(vertices, cells, <a class="code" href="structSubCellData.html">SubCellData</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> create_3d_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line"><span class="comment">// Generate first cross section</span></div><div class="line"><span class="keyword">const</span> std::vector&lt;Point&lt;2&gt;&gt; vertices_1{{-1.5, 0.},</div><div class="line">                                      {-0.5, 0.},</div><div class="line">                                      {0.5, 0.},</div><div class="line">                                      {1.5, 0.},</div><div class="line"></div><div class="line">                                      {-1.5, 1.5},</div><div class="line">                                      {-0.5, 1.5},</div><div class="line">                                      {0.5, 1.5},</div><div class="line">                                      {1.5, 1.5},</div><div class="line"></div><div class="line">                                      {-1.5, 3.},</div><div class="line">                                      {-0.5, 3.},</div><div class="line">                                      {0.5, 3.},</div><div class="line">                                      {1.5, 3.},</div><div class="line"></div><div class="line">                                      {-0.5, 3 + 0.5 <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line">                                      {0.5, 3 + 0.5 <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line"></div><div class="line">                                      {-0.75, 3 + 0.75 <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line">                                      {0.75, 3 + 0.75 <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)}};</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;std::array&lt;unsigned int, GeometryInfo&lt;2&gt;::vertices_per_cell&gt;&gt;</div><div class="line"> cell_vertices_1 = {{{0, 1, 4, 5}},</div><div class="line">                    {{1, 2, 5, 6}},</div><div class="line">                    {{3, 7, 2, 6}},</div><div class="line">                    {{4, 5, 8, 9}},</div><div class="line">                    {{5, 6, 9, 10}},</div><div class="line">                    {{7, 11, 6, 10}},</div><div class="line">                    {{8, 9, 14, 12}},</div><div class="line">                    {{9, 10, 12, 13}},</div><div class="line">                    {{11, 15, 10, 13}},</div><div class="line">                    {{14, 12, 15, 13}}};</div><div class="line"></div><div class="line"><span class="comment">// Copy vertices into a 2d triangulation</span></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation_2d_1;</div><div class="line">create_2d_grid(vertices_1, cell_vertices_1, triangulation_2d_1);</div><div class="line"></div><div class="line"><span class="comment">// Then extrude it into a 3d piece</span></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> triangulation_3d_1;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation</a>(triangulation_2d_1,</div><div class="line">                                    5,</div><div class="line">                                    2.5,</div><div class="line">                                    triangulation_3d_1);</div><div class="line"></div><div class="line"><span class="comment">// Now do the same with the second volume</span></div><div class="line"><span class="keyword">const</span> std::vector&lt;Point&lt;2&gt;&gt; vertices_2{{-2.5, 0.},</div><div class="line">                                      {-1.5, 0.},</div><div class="line">                                      {-0.5, 0.},</div><div class="line">                                      {0.5, 0.},</div><div class="line">                                      {1.5, 0.},</div><div class="line">                                      {2.5, 0.},</div><div class="line"></div><div class="line">                                      {-2.5, 1.5},</div><div class="line">                                      {-1.5, 1.5},</div><div class="line">                                      {-0.5, 1.5},</div><div class="line">                                      {0.5, 1.5},</div><div class="line">                                      {1.5, 1.5},</div><div class="line">                                      {2.5, 1.5},</div><div class="line"></div><div class="line">                                      {-2.5, 3.},</div><div class="line">                                      {-1.5, 3.},</div><div class="line">                                      {-0.5, 3.},</div><div class="line">                                      {0.5, 3.},</div><div class="line">                                      {1.5, 3.},</div><div class="line">                                      {2.5, 3.},</div><div class="line"></div><div class="line">                                      {-0.5, 3. + 0.5 <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line">                                      {0.5, 3. + 0.5 <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line"></div><div class="line">                                      {-0.75, 3. + 0.75 <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line">                                      {0.75, 3. + 0.75 <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line"></div><div class="line">                                      {-1.25, 3. + 1.25 <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line">                                      {1.25, 3. + 1.25 <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)}};</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;std::array&lt;unsigned int, GeometryInfo&lt;2&gt;::vertices_per_cell&gt;&gt;</div><div class="line"> cell_vertices_2 = {{{0, 1, 6, 7}},</div><div class="line">                    {{1, 2, 7, 8}},</div><div class="line">                    {{2, 3, 8, 9}},</div><div class="line">                    {{4, 10, 3, 9}},</div><div class="line">                    {{5, 11, 4, 10}},</div><div class="line">                    {{6, 7, 12, 13}},</div><div class="line">                    {{7, 8, 13, 14}},</div><div class="line">                    {{8, 9, 14, 15}},</div><div class="line">                    {{10, 16, 9, 15}},</div><div class="line">                    {{11, 17, 10, 16}},</div><div class="line">                    {{12, 13, 22, 20}},</div><div class="line">                    {{13, 14, 20, 18}},</div><div class="line">                    {{14, 15, 18, 19}},</div><div class="line">                    {{16, 21, 15, 19}},</div><div class="line">                    {{17, 23, 16, 21}},</div><div class="line">                    {{20, 18, 21, 19}},</div><div class="line">                    {{22, 20, 23, 21}}};</div><div class="line"></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation_2d_2;</div><div class="line">create_2d_grid(vertices_2, cell_vertices_2, triangulation_2d_2);</div><div class="line"></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> triangulation_3d_2;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation</a>(triangulation_2d_2,</div><div class="line">                                    5,</div><div class="line">                                    2.5,</div><div class="line">                                    triangulation_3d_2);</div><div class="line"></div><div class="line"><span class="comment">// Also shift this triangulation in the z-direction so that it matches the</span></div><div class="line"><span class="comment">// end face of the first part</span></div><div class="line"><a class="code" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>(<a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0, 0, 2.5), triangulation_3d_2);</div><div class="line"></div><div class="line"><span class="comment">// Now first merge these two pieces, then shift the first piece in</span></div><div class="line"><span class="comment">// z-direction beyond the second, and merge the shifted piece with the two</span></div><div class="line"><span class="comment">// previously merged one into the final one:</span></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> triangulation_3d_tmp;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(triangulation_3d_1,</div><div class="line">                                   triangulation_3d_2,</div><div class="line">                                   triangulation_3d_tmp);</div><div class="line"></div><div class="line"><a class="code" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>(<a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0, 0, 5), triangulation_3d_1);</div><div class="line"></div><div class="line"><a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(triangulation_3d_tmp,</div><div class="line">                                   triangulation_3d_1,</div><div class="line">                                   triangulation);</div><div class="line">}</div></div><!-- fragment --></li>
</ul>
<p>This creates the following mesh: &lt;img src="https://www.dealii.org/images/steps/developer/  @ref step_49 "step-49"  .yuhan.8.png" alt="" width="400" height="355"&gt; This mesh has the right general shape, but the top cells are now polygonal: theiredges are no longer along circles and we do not have a very accuraterepresentation of the original geometry. The next step is to teach the top partof the domain that it should be curved. Put another way, all calculations doneon the top boundary cells should be done in cylindrical coordinates rather thanCartesian coordinates. We can do this by creating a <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> objectand associating it with the cells above \(y = 3\) . This way, when we refine thecells on top, we will place new points along concentric circles instead ofstraight lines. In deal.II we describe all geometries with classes that inherit fromManifold. The default geometry is Cartesian and is implemented in theFlatManifold class. As the name suggests, <a class="el" href="classManifold.html">Manifold</a> and its inheriting classesprovide a way to describe curves and curved cells in a general way with ideasand terminology from differential geometry: for example, CylindricalManifoldinherits from <a class="el" href="classChartManifold.html">ChartManifold</a>, which describes a geometry through pull backsand push forwards. In general, one should think that the <a class="el" href="classTriangulation.html">Triangulation</a> classdescribes the topology of a domain (in addition, of course, to storing thelocations of the vertices) while the <a class="el" href="classManifold.html">Manifold</a> classes describe the geometry of adomain (e.g., whether or not a pair of vertices lie along a circular arc or astraight line). A <a class="el" href="classTriangulation.html">Triangulation</a> will refine cells by doing computations with theManifold associated with that cell regardless of whether or not the cell is onthe boundary. Put another way: the <a class="el" href="classManifold.html">Manifold</a> classes do not need any informationabout where the boundary of the <a class="el" href="classTriangulation.html">Triangulation</a> actually is: it is up to theTriangulation to query the right <a class="el" href="classManifold.html">Manifold</a> for calculations on a cell. MostManifold functions (e.g., <a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">Manifold::get_intermediate_point</a>) know nothing aboutthe domain itself and just assume that the points given to it lie along ageodesic. In this case, with the <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a> constructed below, thegeodesics are arcs along circles orthogonal to the \(z\) -axis centered along theline \((0, 3, z)\) . Since all three top parts of the domain use the same geodesics, we willmark all cells with centers above the \(y = 3\) line as being cylindrical innature: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a>           axis({0.0, 0.0, 1.0});</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a>               axial_point(0, 3.0, 0.0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classCylindricalManifold.html">CylindricalManifold&lt;3&gt;</a> <a class="code" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a>(axis, axial_point);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::manifold_id</a>     cylinder_id = 8;</div><div class="line"></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">create_3d_grid(triangulation);</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(cylinder_id, <a class="code" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a>);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line"><span class="keywordflow">if</span> (cell-&gt;center()[1] &gt;= 3.0)</div><div class="line"> cell-&gt;<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(cylinder_id);</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div></div><!-- fragment --><p>With this code, we get a mesh that looks like this: &lt;img src="https://www.dealii.org/images/steps/developer/  @ref step_49 "step-49"  .yuhan.9.png" alt="" width="400" height="355"&gt; This change fixes the boundary but creates a new problem: the cells adjacent tothe cylinder's axis are badly distorted. We should use Cartesian coordinates forcalculations on these central cells to avoid this issue. The cells along thecenter line all have a face that touches the line \((0, 3, z)\) so, to implementthis, we go back and overwrite the <code>manifold_id</code> s on these cells tobe zero (which is the default): </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a>           axis({0.0, 0.0, 1.0});</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a>               axial_point(0, 3.0, 0.0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classCylindricalManifold.html">CylindricalManifold&lt;3&gt;</a> <a class="code" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a>(axis, axial_point);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::manifold_id</a>     cylinder_id = 8;</div><div class="line"></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">create_3d_grid(triangulation);</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(cylinder_id, <a class="code" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a>);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line"><span class="keywordflow">if</span> (cell-&gt;center()[1] &gt;= 3.0)</div><div class="line"> cell-&gt;<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(cylinder_id);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line"> {</div><div class="line">   <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> face_center = face-&gt;center();</div><div class="line">   <span class="keywordflow">if</span> (std::abs(face_center[0]) &lt; 1.0e-5 &amp;&amp;</div><div class="line">       std::abs(face_center[1]</div><div class="line"></div><div class="line">- 3.0) &lt; 1.0e-5)</div><div class="line">     cell-&gt;<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(<a class="code" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>);</div><div class="line"> }</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div></div><!-- fragment --><p>This gives us the following grid: &lt;img src="https://www.dealii.org/images/steps/developer/  @ref step_49 "step-49"
 .yuhan.10.png" alt="" width="400" height="355"&gt; This gives us a good mesh, where cells at the center of each circle are stillCartesian and cells around the boundary lie along a circle. We can really seethe nice detail of the boundary fitted mesh if we refine two more times: &lt;img src="https://www.dealii.org/images/steps/developer/  @ref step_49 "step-49"
 .yuhan.11.png" alt="" width="400" height="355"&gt;</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p><a class="anchor" id="Assigningdifferentboundaryids"></a></p><h4>Assigning different boundary ids </h4>
<p>It is often useful to assign different boundary ids to a mesh that isgenerated in one form or another as described in this tutorial to applydifferent boundary conditions. For example, you might want to apply a different boundary condition for theright boundary of the first grid in this program. To do this, iterate over thecells and their faces and identify the correct faces (for example using<code>cell-&gt;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center()</a></code> to query the coordinates of the center of a cell as wedo in <a class="el" href="step_1.html">step-1</a> , or using <code>cell-&gt;face(f)-&gt;get_boundary_id()</code> to query the currentboundary indicator of the \(f\) th face of the cell). You can then use<code>cell-&gt;face(f)-&gt;set_boundary_id()</code> to set the boundary id to something different.You can take a look back at <a class="el" href="step_1.html">step-1</a> how iteration over the meshes is done there. <a class="anchor" id="Extractingaboundarymesh"></a></p><h4>Extracting a boundary mesh </h4>
<p>Computations on manifolds, like they are done in <a class="el" href="step_38.html">step-38</a> , require a surfacemesh embedded into a higher dimensional space. While some can be constructedusing the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace or loaded from a file, it is sometimesuseful to extract a surface mesh from a volume mesh. Use the function <a class="el" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh()</a> to extract the surfaceelements of a mesh. Using the function on a 3d mesh (a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;3,3&gt;</code>, forexample from <code>grid_4()</code>), this will return a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,3&gt;</code> that you can usein <a class="el" href="step_38.html">step-38</a> . Also try extracting the boundary mesh of a <code><a class="el" href="classTriangulation.html">Triangulation</a>&lt;2,2&gt;</code>.</p>
<p>This tutorial depends on <a class="el" href="step_1.html">step-1</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Generalconcernsaboutmeshes">General concerns about meshes</a>
        <li><a href="#Howtocreatemeshes">How to create meshes</a>
      <ul>
        <li><a href="#UsingGridGenerator">Using GridGenerator</a>
        <li><a href="#Constructingyourownmeshprogrammatically">Constructing your own mesh programmatically</a>
        <li><a href="#Importingfromexternalprograms">Importing from external programs</a>
      </ul>
        <li><a href="#ModifyingaMesh">Modifying a Mesh</a>
      <ul>
        <li><a href="#Transformations">Transformations</a>
        <li><a href="#MergingMeshes">Merging Meshes</a>
        <li><a href="#MovingVertices">Moving Vertices</a>
        <li><a href="#ExtrudingMeshes">Extruding Meshes</a>
      </ul>
        <li><a href="#Afteryouhaveacoarsemesh"> After you have a coarse mesh </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Generatingoutputforagivenmesh">Generating output for a given mesh</a>
        <li><a href="#Mainroutines">Main routines</a>
      <ul>
        <li><a href="#grid_1Loadingameshgeneratedbygmsh">grid_1: Loading a mesh generated by gmsh</a>
        <li><a href="#grid_2Mergingtriangulations">grid_2: Merging triangulations</a>
        <li><a href="#grid_3Movingvertices">grid_3: Moving vertices</a>
        <li><a href="#grid_4Demonstratingextrude_triangulation">grid_4: Demonstrating extrude_triangulation</a>
        <li><a href="#grid_5DemonstratingGridToolstransformpart1">grid_5: Demonstrating GridTools::transform, part 1</a>
        <li><a href="#grid_6DemonstratingGridToolstransformpart2">grid_6: Demonstrating GridTools::transform, part 2</a>
        <li><a href="#grid_7Demonstratingdistort_random">grid_7: Demonstrating distort_random</a>
      </ul>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#NextstepsCurvedCells">Next steps: Curved Cells</a>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
      <ul>
        <li><a href="#Assigningdifferentboundaryids"> Assigning different boundary ids </a>
        <li><a href="#Extractingaboundarymesh"> Extracting a boundary mesh </a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-49/doc/intro.dox</p>
<p><em>This program was contributed by Timo Heister. Parts of the results section were contributed by Yuhan Zhou, Wolfgang Bangerth, and David Wells.</em></p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction </h1>
<p>本教程是步骤1的扩展，演示了几种获得比那里显示的更多的网格的方法。</p>
<dl class="section note"><dt>Note</dt><dd>本教程也可作为Jupyter Python笔记本，使用deal.II python接口。该笔记本与原始的C++程序在同一目录下提供。</dd></dl>
<p>生成复杂的几何图形是一项具有挑战性的任务，特别是在三个空间维度。我们将讨论几种方法，但这个清单并不详尽。此外，没有一种方法适合所有的问题。</p>
<p>这个例子程序显示了一些为计算而创建和修改网格的方法，并以与我们在步骤1中相同的方式将它们输出为 <code>.vtu</code> 文件。没有做其他的计算或自适应细化；我们的想法是，你可以在其他更多的模拟器中使用这里的技术作为构建模块。请注意，这个例子程序并没有展示本介绍中讨论的所有生成网格的方法。</p>
<p><a class="anchor" id="Generalconcernsaboutmeshes"></a></p><h3>General concerns about meshes</h3>
<p>当你使用自适应网格细化时，你肯定希望初始网格尽可能地粗大。因为只要你有内存和CPU时间，你就可以用自适应细化技术把它做得越细越好。然而，这就要求你不要把网格单元浪费在域的某些地方，因为这些单元是没有价值的。因此，你不希望从一个太细的网格开始，因为这已经占用了你的单元预算的很大一部分，而且你无法粗化初始网格中的单元。</p>
<p>也就是说，你的网格需要充分捕捉给定的几何体。</p>
<p><a class="anchor" id="Howtocreatemeshes"></a></p><h3>How to create meshes</h3>
<p>有几种方法来创建一个初始网格。网格可以通过多种方式进行修改或组合，这一点将在后面讨论。</p>
<p><a class="anchor" id="UsingGridGenerator"></a></p><h4>Using <a class="el" href="namespaceGridGenerator.html">GridGenerator</a></h4>
<p>生成网格的最简单方法是使用命名空间GridGenerator中的函数，这在步骤1中已经讨论过了。 有许多不同的辅助函数可用，包括 <a class="el" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube()</a>, <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a>, <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball()</a>, 和 <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole()</a>. 。</p>
<p><a class="anchor" id="Constructingyourownmeshprogrammatically"></a></p><h4>Constructing your own mesh programmatically</h4>
<p>如果GridGenerator命名空间中没有适合你想做的事情，你总是可以在你的程序中 "手工 "创建一个三角图。为此，你需要一个带有坐标的顶点列表和一个引用这些顶点的单元格列表。你可以在步骤14的函数<code>create_coarse_grid()</code>中找到一个例子。GridGenerator中的所有函数都以这种方式实现。</p>
<p>我们很乐意接受更多的功能加入到GridGenerator中。因此，如果你最终写了一个可能对更多人有用的函数，请将其贡献出来。</p>
<p><a class="anchor" id="Importingfromexternalprograms"></a></p><h4>Importing from external programs</h4>
<p>GridIn类可以从磁盘的文件中读取许多不同的网格格式。如何做到这一点，在步骤5中有解释，在本例中可以看到函数 <code>grid_1</code> ，见下面的代码。</p>
<p>网格可以由不同的工具生成，如<a href="http://gmsh.info" target="_top">gmsh</a>、<a href="https://lagrit.lanl.gov/" target="_top">lagrit</a>和<a href="http://cubit.sandia.gov/" target="_top">cubit</a>。更多信息见GridIn的文档。问题是，deal.II需要的网格只由四边形和六面体组成&ndash;四面体的网格无法工作（这意味着不能直接使用tetgen等工具）。</p>
<p>我们将描述一个使用Gmsh的可能工作流程。Gmsh是我们所知道的最小和最快速设置的开源工具。它可以生成非结构化的二维四面体网格。在三维中，它可以挤压二维网格以获得六面体网格；将非结构化几何体三维网格化为六面体是可能的，尽管这些网格的质量有一些问题，意味着这些网格有时只能在交易中工作。</p>
<p>在Gmsh中，一个网格的基本描述是基于文本的 <code>.geo</code> 文件，其格式可以包含计算、循环、变量等。这种格式在允许描述复杂的几何图形方面是相当灵活的。然后，网格是由表面表示法生成的，表面表示法是由线条循环列表建立的，线条循环列表又是由点建立的。 <code>.geo</code> 脚本可以用手写和编辑，也可以通过在Gmsh内用图形创建对象来自动生成。在许多情况下，最好是把这两种方法结合起来。如果你想用手写的话，可以在 "几何 "选项卡下按 "重载 "来轻松地重新加载文件，并在gmsh的图形用户界面上看到效果。</p>
<p>本教程包含一个例子 <code>.geo</code> 文件，描述一个内部有两个物体被切割出来的盒子。这就是 <code>example.geo</code> 在Gmsh中的样子（显示边界指标以及下面要讨论的网格）。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.gmsh_picture.png"/>
</div>
<p>你可能想用文本编辑器打开 <code>example.geo</code> 文件（它与<code><a class="el" href="step_49.html">step-49</a>.cc</code>源文件位于同一目录），看看它是如何结构的。你可以看到域的边界是如何由一些线组成的，后来我们把几条线组合成 "物理线"（或 "物理面"），列出逻辑线的编号。"物理 "对象是携带边界指标信息的对象（见 <a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">本词汇表条目</a>）。</p>
<dl class="section note"><dt>Note</dt><dd>这个文件包含 "物理线 "和 "物理面 "是很重要的。它们提供了在deal.II中使用的边界指标和材料ID。没有这些物理实体，任何东西都不会被导入deal.II中。</dd></dl>
<p>deal.II的GridIn类可以读取Gmsh编写的 <code>.msh</code> 格式，该格式包含为 <code>.geo</code> file. You generate the <code>.msh</code> 描述的几何体创建的网格，通过运行指令</p>
<div class="fragment"><div class="line">gmsh -2 example.geo</div></div><!-- fragment --><p>在命令行中，或者在加载文件后点击Gmsh中的 "Mesh "和 "2D"。 现在这是从 <code>.msh</code> 文件中读取的网格，并由deal.II再次保存为图像（见当前程序的 <code>grid_1</code> 功能）。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-1.png"/>
</div>
<dl class="section note"><dt>Note</dt><dd>Gmsh有许多其他接口，人们可以通过这些接口来描述几何图形。特别是，它能够与Python和Julia等脚本语言连接，但也可以用C++编写脚本。这些接口很有用，如果人们不只是想为一个单一的几何体生成网格（在这种情况下，图形界面或者在简单的情况下，手写的".geo "文件可能是最简单的方法），而是想对几何体进行参数化研究，为此需要为某些参数不同的几何体生成许多网格。另一种情况是，如果已经有一个CAD几何体，只需要一个网格；事实上，这可以在deal.II中使用 <a class="el" href="namespaceGmsh.html#ab65eb217368d006b66bcfcc6fa0f2894">Gmsh::create_triangulation_from_boundary_curve()</a> 函数来完成。</dd></dl>
<p><a class="anchor" id="ModifyingaMesh"></a></p><h3>Modifying a Mesh</h3>
<p>在以上述方式获得一个（或几个）网格后，在将其用于有限元计算之前，有许多方法可以对其进行操作。</p>
<p><a class="anchor" id="Transformations"></a></p><h4>Transformations</h4>
<p>GridTools命名空间包含了一系列的小函数，用于以各种方式转换给定的网格。函数 <a class="el" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>, <a class="el" href="namespaceGridTools.html#a910bb99ec34eac082da97c08e7dd17c3">GridTools::rotate</a>, <a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">GridTools::scale</a> 的用法相当明显，所以我们在此不讨论这些函数。</p>
<p>函数 <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a> 允许你使用平滑函数对给定网格的顶点进行变换。在<a class="el" href="step_38.html">step-38</a>的结果部分也给出了它的使用实例，但让我们在这里展示一个更简单的例子。在当前程序的函数 <code>grid_5()</code> 中，我们用正弦曲线对网格的y坐标进行扰动。</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-5a.png"/>
</div>
 regular input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-5.png"/>
</div>
 output mesh   </td></tr>
</table>
<p>同样地，我们可以用公式 \((x,y) \mapsto (x,\tanh(2 y)/\tanh(2))\) 将一个有规律的细化单位方格转换为y方向的墙体适应网格。这在本教程的 <code>grid_6()</code> 中完成。 </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-6a.png"/>
</div>
 regular input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-6.png"/>
</div>
 wall-adapted output mesh   </td></tr>
</table>
<p>最后，函数 <a class="el" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random</a> 允许你将网格中的顶点（可选择忽略边界节点）随机移动。这在 <code>grid_7()</code> 中进行了演示，其结果如下。</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-7a.png"/>
</div>
 regular input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-7.png"/>
</div>
 perturbed output mesh   </td></tr>
</table>
<p>这个函数主要是为了否定在研究常规网格收敛时得到的一些超收敛效应，以及抑制deal.II中的一些优化，这些优化可以利用单元格形状相似的事实。超级收敛是指如果一个网格具有某些对称性&ndash;例如，如果进入一个顶点的边对这个顶点是对称的，并且如果对一个单元的所有顶点都是这样的话</p>
<p>归根结底，这是由于如果对误差进行泰勒扩展，对称性导致了这样一个事实，即预期的扩展的下一个项恰好是零，而误差的阶数是由*第二个下*项决定的。一个扭曲的网格没有这些对称性，因此误差反映了在*任何*种网格上解方程时将会看到的情况，而不是显示只反映特定情况的东西)。</p>
<p><a class="anchor" id="MergingMeshes"></a></p><h4>Merging Meshes</h4>
<p>该函数 <a class="el" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations()</a> 允许你将两个给定的三角形对象合并为一个。 要做到这一点，共享边或面的顶点必须完全匹配。 排列两个网格可以用 <a class="el" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a> 和 <a class="el" href="namespaceGridTools.html#a0967563badadd81f77f62622dd8bc2cd">GridTools::scale</a>. 来实现。 在本教程的函数 <code>grid_2()</code> 中，我们合并了一个带圆孔的正方形（用 <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole()</a>) 生成）和一个矩形（用 <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle()</a>). 生成）。 函数 <a class="el" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle()</a> 允许你指定重复的数量和角的位置，所以这里不需要手动移动三角网格。你应该以图形方式检查网格，以确保单元格排布正确，并且在合并后的三角图中不存在未配对的节点。</p>
<p>这些是输入网格和输出网格。</p>
<table width="80%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2a.png" height="200px"/>
</div>
input mesh 1 </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2b.png" height="200px"/>
</div>
input mesh 2 </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2.png" height="200px"/>
</div>
merged mesh  </td></tr>
</table>
<p><a class="anchor" id="MovingVertices"></a></p><h4>Moving Vertices</h4>
<p>函数 <code>grid_3()</code> 展示了在现有网格中挑选个别顶点并移动它们的能力。请注意，这有可能产生退化的或倒置的单元，你不应该期望使用这样的网格会产生任何有用的东西。在这里，我们通过向上移动顶部顶点来创建一个不完全居中的圆柱形孔的盒子。</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-3a.png" height="200px"/>
</div>
 input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-3.png" height="200px"/>
</div>
 top vertices moved upwards   </td></tr>
</table>
<p>关于如何做到这一点的确切方法，见下面的代码。</p>
<p><a class="anchor" id="ExtrudingMeshes"></a></p><h4>Extruding Meshes</h4>
<p>如果你需要一个可以通过挤压给定的2D网格（可以通过上述任何一种方式创建）来创建的3D网格，你可以使用函数 <a class="el" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation()</a>. 参见本教程中的 <code>grid_4()</code> 函数为例。请注意，对于这个特殊的情况，所给的结果也可以用3D版本的 <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole()</a>. 来实现。主要的用法是一个2D网格，例如用Gmsh生成，如上所述从 <code>.msh</code> 文件中读入。这是grid_4()的输出。</p>
<table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-4base.png"/>
</div>
 input mesh  </td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-4.png"/>
</div>
 extruded output mesh   </td></tr>
</table>
<p><a class="anchor" id="Afteryouhaveacoarsemesh"></a></p><h3>After you have a coarse mesh </h3>
<p>使用上面讨论的方法创建一个粗略的网格只是第一步。当你有了它，它通常可以作为进一步细化网格的基础。这并不困难，事实上，如果你的几何体只由直面组成，那就没有其他事情可做。然而，如果你有一个更复杂的几何体，情况往往就不是这样了，除了创建网格之外，还有更多的步骤是必须的。我们将在下面的<a href="#Results">results section</a>中详细介绍这些步骤。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>This tutorial program is odd in the sense that, unlike for most other steps, the introduction already provides most of the information on how to use the various strategies to generate meshes. Consequently, there is little that remains to be commented on here, and we intersperse the code with relatively little text. In essence, the code here simply provides a reference implementation of what has already been described in the introduction.</p>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Generatingoutputforagivenmesh"></a> </p><h3>Generating output for a given mesh</h3>
<p>The following function generates some output for any of the meshes we will be generating in the remainder of this program. In particular, it generates the following information:</p>
<ul>
<li>Some general information about the number of space dimensions in which this mesh lives and its number of cells.</li>
<li>The number of boundary faces that use each boundary indicator, so that it can be compared with what we expect.</li>
</ul>
<p>Finally, the function outputs the mesh in VTU format that can easily be visualized in Paraview or VisIt.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> print_mesh_info(<span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;triangulation,</div><div class="line">                     <span class="keyword">const</span> std::string &amp;       filename)</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh info:&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; dimension: &quot;</span> &lt;&lt; dim &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; no. of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl;</div></div><!-- fragment --><p>Next loop over all faces of all cells and find how often each boundary indicator is used (recall that if you access an element of a std::map object that doesn't exist, it is implicitly created and default initialized &ndash; to zero, in the current case &ndash; before we then increment it):</p>
<div class="fragment"><div class="line">{</div><div class="line">  std::map&lt;types::boundary_id, unsigned int&gt; boundary_count;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : triangulation.<a class="code" href="group__CPP11.html#ga1bf11e9e1e5c2ff59a9c7b3f5a2bc5ad">active_face_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">      boundary_count[face-&gt;boundary_id()]++;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; boundary indicators: &quot;</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;const types::boundary_id, unsigned int&gt; &amp;pair :</div><div class="line">       boundary_count)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; pair.first &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="stringliteral">&quot; times) &quot;</span>;</div><div class="line">    }</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Finally, produce a graphical representation of the mesh to an output file :</p>
<div class="fragment"><div class="line">  std::ofstream out(filename);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a8bd3a74b86d7c0eb792d2efca7f945f1">write_vtu</a>(triangulation, out);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; written to &quot;</span> &lt;&lt; filename &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Mainroutines"></a> </p><h3>Main routines</h3>
<p><a class="anchor" id="grid_1Loadingameshgeneratedbygmsh"></a> </p><h4>grid_1: Loading a mesh generated by gmsh</h4>
<p>In this first example, we show how to load the mesh for which we have discussed in the introduction how to generate it. This follows the same pattern as used in <a class="el" href="step_5.html">step-5</a> to load a mesh, although there it was written in a different file format (UCD instead of MSH).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_1()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classGridIn.html">GridIn&lt;2&gt;</a> gridin;</div><div class="line">  gridin.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(triangulation);</div><div class="line">  std::ifstream f(<span class="stringliteral">&quot;example.msh&quot;</span>);</div><div class="line">  gridin.<a class="code" href="group__simplex.html#ga83872db02e04f52ac52d578912f6da5e">read_msh</a>(f);</div><div class="line"></div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-1.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_2Mergingtriangulations"></a> </p><h4>grid_2: Merging triangulations</h4>
<p>Here, we first create two triangulations and then merge them into one. As discussed in the introduction, it is important to ensure that the vertices at the common interface are located at the same coordinates.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_2()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria1;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(tria1, 0.25, 1.0);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          tria2;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = 3;</div><div class="line">  repetitions[1] = 2;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(tria2,</div><div class="line">                                            repetitions,</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, -1.0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(4.0, 1.0));</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(tria1, tria2, triangulation);</div><div class="line"></div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-2.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_3Movingvertices"></a> </p><h4>grid_3: Moving vertices</h4>
<p>In this function, we move vertices of a mesh. This is simpler than one usually expects: if you ask a cell using <code>cell-&gt;vertex(i)</code> for the coordinates of its <code>i</code>th vertex, it doesn't just provide the location of this vertex but in fact a reference to the location where these coordinates are stored. We can then modify the value stored there.</p>
<p>So this is what we do in the first part of this function: We create a square of geometry \([-1,1]^2\) with a circular hole with radius 0.25 located at the origin. We then loop over all cells and all vertices and if a vertex has a \(y\) coordinate equal to one, we move it upward by 0.5.</p>
<p>Note that this sort of procedure does not usually work this way because one will typically encounter the same vertices multiple times and may move them more than once. It works here because we select the vertices we want to use based on their geometric location, and a vertex moved once will fail this test in the future. A more general approach to this problem would have been to keep a std::set of those vertex indices that we have already moved (which we can obtain using <code>cell-&gt;vertex_index(i)</code> and only move those vertices whose index isn't in the set yet.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_3()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(triangulation, 0.25, 1.0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : cell-&gt;vertex_indices())</div><div class="line">        {</div><div class="line">          <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;v = cell-&gt;vertex(i);</div><div class="line">          <span class="keywordflow">if</span> (std::abs(v(1) - 1.0) &lt; 1e-5)</div><div class="line">            v(1) += 0.5;</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>In the second step we will refine the mesh twice. To do this correctly, we should place new points on the interior boundary along the surface of a circle centered at the origin. Fortunately, <a class="el" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a> already attaches a <a class="el" href="classManifold.html">Manifold</a> object to the interior boundary, so we do not need to do anything but refine the mesh (see the <a href="#Results">results section</a> for a fully worked example where we <em>do</em> attach a <a class="el" href="classManifold.html">Manifold</a> object).</p>
<div class="fragment"><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-3.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>There is one snag to doing things as shown above: If one moves the nodes on the boundary as shown here, one often ends up with cells in the interior that are badly distorted since the interior nodes were not moved around. This is not that much of a problem in the current case since the mesh did not contain any internal nodes when the nodes were moved &ndash; it was the coarse mesh and it so happened that all vertices are at the boundary. It's also the case that the movement we had here was, compared to the average cell size not overly dramatic. Nevertheless, sometimes one does want to move vertices by a significant distance, and in that case one needs to move internal nodes as well. One way to do that automatically is to call the function <a class="el" href="namespaceGridTools.html#a7ed2aaa1aea3ac22b1e1807ce6d0b5f3">GridTools::laplace_transform</a> that takes a set of transformed vertex coordinates and moves all of the other vertices in such a way that the resulting mesh has, in some sense, a small distortion.</p>
<p><a class="anchor" id="grid_4Demonstratingextrude_triangulation"></a> </p><h4>grid_4: Demonstrating extrude_triangulation</h4>
<p>This example takes the initial grid from the previous function and simply extrudes it into the third space dimension:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_4()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> out;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(triangulation, 0.25, 1.0);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation</a>(triangulation, 3, 2.0, out);</div><div class="line">  print_mesh_info(out, <span class="stringliteral">&quot;grid-4.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_5DemonstratingGridToolstransformpart1"></a> </p><h4>grid_5: Demonstrating <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>, part 1</h4>
<p>This and the next example first create a mesh and then transform it by moving every node of the mesh according to a function that takes a point and returns a mapped point. In this case, we transform \((x,y) \mapsto (x,y+\sin(\pi x/5))\).</p>
<p><a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform()</a> takes a triangulation and an argument that can be called like a function taking a <a class="el" href="classPoint.html">Point</a> and returning a <a class="el" href="classPoint.html">Point</a>. There are different ways of providing such an argument: It could be a pointer to a function; it could be an object of a class that has an <code>operator()</code>; it could be a lambda function; or it could be anything that is described via a <code>std::function&lt;<a class="el" href="classPoint.html">Point</a>&lt;2&gt;(const <a class="el" href="classPoint.html">Point</a>&lt;2&gt;)&gt;</code> object.</p>
<p>Decidedly the more modern way is to use a lambda function that takes a <a class="el" href="classPoint.html">Point</a> and returns a <a class="el" href="classPoint.html">Point</a>, and that is what we do in the following:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_5()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = 14;</div><div class="line">  repetitions[1] = 2;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            repetitions,</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(10.0, 1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(</div><div class="line">    [](<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in) {</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(in[0], in[1] + <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * in[0] / 5.0));</div><div class="line">    },</div><div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-5.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_6DemonstratingGridToolstransformpart2"></a> </p><h4>grid_6: Demonstrating <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>, part 2</h4>
<p>In this second example of transforming points from an original to a new mesh, we will use the mapping \((x,y) \mapsto (x,\tanh(2y)/\tanh(2))\). To make things more interesting, rather than doing so in a single function as in the previous example, we here create an object with an <code>operator()</code> that will be called by <a class="el" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>. Of course, this object may in reality be much more complex: the object may have member variables that play a role in computing the new locations of vertices.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Grid6Func</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> trans(<span class="keyword">const</span> <span class="keywordtype">double</span> y)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(2 * y) / <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">tanh</a>(2);</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;2&gt;</a> operator()(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> {in(0), trans(in(1))};</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_6()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = repetitions[1] = 40;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            repetitions,</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, 1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(Grid6Func(), triangulation);</div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-6.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="grid_7Demonstratingdistort_random"></a> </p><h4>grid_7: Demonstrating distort_random</h4>
<p>In this last example, we create a mesh and then distort its (interior) vertices by a random perturbation. This is not something you want to do for production computations (because results are generally better on meshes with "nicely shaped" cells than on the deformed cells produced by <a class="el" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random()</a>), but it is a useful tool for testing discretizations and codes to make sure they don't work just by accident because the mesh happens to be uniformly structured and supporting superconvergence properties.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> grid_7()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = repetitions[1] = 16;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            repetitions,</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, 1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random</a>(0.3, triangulation, <span class="keyword">true</span>);</div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-7.vtu&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>Finally, the main function. There isn't much to do here, only to call all the various functions we wrote above.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      grid_1();</div><div class="line">      grid_2();</div><div class="line">      grid_3();</div><div class="line">      grid_4();</div><div class="line">      grid_5();</div><div class="line">      grid_6();</div><div class="line">      grid_7();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> examples/step-49/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>该程序产生一系列 <code>.vtu</code> 的三角形文件。这些方法已在上文讨论。</p>
<p><a class="anchor" id="NextstepsCurvedCells"></a></p><h3>Next steps: Curved Cells</h3>
<p>正如介绍中提到的，使用这里讨论的方法创建一个粗略的网格只是第一步。为了细化网格，Triangulation需要知道在边、面和单元格的中点上放置新的顶点。默认情况下，这些新的点会被放置在周围点的算术平均值上，但如果你需要的是粗略网格没有充分解决的弯曲边界，这并不是你想要的。例如，对于这个网格，中心孔应该是圆形的。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2a.png" height="200px"/>
</div>
<p>如果你只是简单地细化它，三角测量类就不能知道你是想让孔变成圆形还是八角形。默认的做法是沿着现有的直线放置新的点。经过两个网格细化步骤后，这将产生以下的网格，这不是我们想要的。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.grid-2d-refined.png" height="200px"/>
</div>
<p>需要发生的是，你告诉三角函数，你实际上是想使用一个弯曲的几何体。做到这一点的方法需要三个步骤。</p>
<ul>
<li>创建一个描述所需几何图形的对象。这个对象将在细化三角图以获得新的点位置时被查询。如果在系统组装过程中使用了MappingQ或MappingQGeneric这样的高阶映射，它也将被用来计算形状函数值。 在deal.II中，Manifold类和继承自它的类（如PolarManifold和FlatManifold）执行这些计算。</li>
<li>通知Triangulation对象使用哪个Manifold类。默认情况下，Triangulation使用FlatManifold来进行所有的几何计算，它假定所有的单元格边缘都是直线，所有的四边形都是平的。你可以通过调用 <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold</a> 函数将Manifold类附加到Triangulation上，该函数将 <code>manifold_id</code> 与Manifold对象关联。关于这方面的更多信息，请参见 <a class="el" href="DEALGlossary.html#GlossManifoldIndicator">关于这个主题的词汇表条目</a>。</li>
<li><p class="startli">最后，你必须用正确的 <code>manifold_id</code> 标记单元和单元面。例如，你可以通过以下方式得到一个在直角坐标中带有弯曲单元的环形扇面（但在极坐标中是矩形）。</p><div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(tria);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell = tria.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">cell-&gt;vertex(2) = <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(-0.5, 1.0);</div><div class="line">cell-&gt;vertex(3) = <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.5, 1.0);</div><div class="line">tria.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(42);</div><div class="line">tria.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(42, <a class="code" href="classPolarManifold.html">PolarManifold&lt;2&gt;</a>(<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.5, -1.0)));</div><div class="line">tria.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3);</div></div><!-- fragment --><p class="startli">现在，当网格被细化时，所有的单元格分割计算都将在极坐标中进行。</p>
</li>
</ul>
<p>GridGenerator命名空间中的所有函数，如果创建的网格中的某些单元应该是弯曲的，也会将正确的Manifold对象附加到所提供的Triangulation上：也就是说，对于这些函数，我们默认会得到正确的行为。然而，对于手工生成的网格，情况要有趣得多。</p>
<p>为了更详细地说明这个过程，让我们考虑一个由Yuhan Zhou创建的例子，作为2013年德克萨斯A&amp;M大学的一个学期项目的一部分。目标是生成（和使用）一个描述微观结构的电气设备的几何体。在一个CAD程序中，这个几何体看起来像这样。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.1.png"/>
</div>
<p>在下文中，我们将引导你完成为这个几何体创建网格的整个过程，包括通过展示可能出错的一些常见陷阱。</p>
<p>实现这一目标的第一步是创建一个粗略的网格，通过为每个截面创建一个2D粗略的网格，将它们挤压到第三个方向，然后将它们粘在一起。下面的代码使用之前描述的技术来完成这个工作。</p>
<div class="fragment"><div class="line"><span class="comment">// Given a list of points and how vertices connect to cells, create a</span></div><div class="line"><span class="comment">// mesh. This is in the same way as we do in step 14.</span></div><div class="line"><span class="keywordtype">void</span> create_2d_grid(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;2&gt;</a>&gt; &amp;vertices,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;</div><div class="line">    std::array&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, <a class="code" href="structGeometryInfo.html">GeometryInfo&lt;2&gt;::vertices_per_cell</a>&gt;&gt;</div><div class="line">    &amp;               <a class="code" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>,</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;coarse_grid)</div><div class="line">{</div><div class="line">  std::vector&lt;CellData&lt;2&gt;&gt; cells(<a class="code" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>.size());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; cells.size(); ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>[i].size(); ++j)</div><div class="line">        cells[i].vertices[j] = <a class="code" href="grid__tools_8cc.html#a9bb17554c06536e62c37d90eb7a28d6a">vertex_indices</a>[i][j];</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">  coarse_grid.<a class="code" href="classTriangulation.html#ab2eeef6a38fa053814433870a9c35a0c">create_triangulation</a>(vertices, cells, <a class="code" href="structSubCellData.html">SubCellData</a>());</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Create a triangulation that covers the entire volume</span></div><div class="line"><span class="keywordtype">void</span> create_3d_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  <span class="comment">// Generate first cross section</span></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point&lt;2&gt;&gt; vertices_1{{-1.5, 0.},</div><div class="line">                                         {-0.5, 0.},</div><div class="line">                                         {0.5, 0.},</div><div class="line">                                         {1.5, 0.},</div><div class="line"></div><div class="line"></div><div class="line">                                         {-1.5, 1.5},</div><div class="line">                                         {-0.5, 1.5},</div><div class="line">                                         {0.5, 1.5},</div><div class="line">                                         {1.5, 1.5},</div><div class="line"></div><div class="line"></div><div class="line">                                         {-1.5, 3.},</div><div class="line">                                         {-0.5, 3.},</div><div class="line">                                         {0.5, 3.},</div><div class="line">                                         {1.5, 3.},</div><div class="line"></div><div class="line"></div><div class="line">                                         {-0.5, 3 + 0.5 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line">                                         {0.5, 3 + 0.5 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line"></div><div class="line"></div><div class="line">                                         {-0.75, 3 + 0.75 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line">                                         {0.75, 3 + 0.75 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)}};</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;std::array&lt;unsigned int, GeometryInfo&lt;2&gt;::vertices_per_cell&gt;&gt;</div><div class="line">    cell_vertices_1 = {{{0, 1, 4, 5}},</div><div class="line">                       {{1, 2, 5, 6}},</div><div class="line">                       {{3, 7, 2, 6}},</div><div class="line">                       {{4, 5, 8, 9}},</div><div class="line">                       {{5, 6, 9, 10}},</div><div class="line">                       {{7, 11, 6, 10}},</div><div class="line">                       {{8, 9, 14, 12}},</div><div class="line">                       {{9, 10, 12, 13}},</div><div class="line">                       {{11, 15, 10, 13}},</div><div class="line">                       {{14, 12, 15, 13}}};</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Copy vertices into a 2d triangulation</span></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation_2d_1;</div><div class="line">  create_2d_grid(vertices_1, cell_vertices_1, triangulation_2d_1);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Then extrude it into a 3d piece</span></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> triangulation_3d_1;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation</a>(triangulation_2d_1,</div><div class="line">                                       5,</div><div class="line">                                       2.5,</div><div class="line">                                       triangulation_3d_1);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Now do the same with the second volume</span></div><div class="line">  <span class="keyword">const</span> std::vector&lt;Point&lt;2&gt;&gt; vertices_2{{-2.5, 0.},</div><div class="line">                                         {-1.5, 0.},</div><div class="line">                                         {-0.5, 0.},</div><div class="line">                                         {0.5, 0.},</div><div class="line">                                         {1.5, 0.},</div><div class="line">                                         {2.5, 0.},</div><div class="line"></div><div class="line"></div><div class="line">                                         {-2.5, 1.5},</div><div class="line">                                         {-1.5, 1.5},</div><div class="line">                                         {-0.5, 1.5},</div><div class="line">                                         {0.5, 1.5},</div><div class="line">                                         {1.5, 1.5},</div><div class="line">                                         {2.5, 1.5},</div><div class="line"></div><div class="line"></div><div class="line">                                         {-2.5, 3.},</div><div class="line">                                         {-1.5, 3.},</div><div class="line">                                         {-0.5, 3.},</div><div class="line">                                         {0.5, 3.},</div><div class="line">                                         {1.5, 3.},</div><div class="line">                                         {2.5, 3.},</div><div class="line"></div><div class="line"></div><div class="line">                                         {-0.5, 3. + 0.5 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line">                                         {0.5, 3. + 0.5 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line"></div><div class="line"></div><div class="line">                                         {-0.75, 3. + 0.75 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line">                                         {0.75, 3. + 0.75 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line"></div><div class="line"></div><div class="line">                                         {-1.25, 3. + 1.25 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)},</div><div class="line">                                         {1.25, 3. + 1.25 * <a class="code" href="numbers_8h.html#ac4a2ed1890a931d0b6a55933310eadca">sqrt</a>(3)}};</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;std::array&lt;unsigned int, GeometryInfo&lt;2&gt;::vertices_per_cell&gt;&gt;</div><div class="line">    cell_vertices_2 = {{{0, 1, 6, 7}},</div><div class="line">                       {{1, 2, 7, 8}},</div><div class="line">                       {{2, 3, 8, 9}},</div><div class="line">                       {{4, 10, 3, 9}},</div><div class="line">                       {{5, 11, 4, 10}},</div><div class="line">                       {{6, 7, 12, 13}},</div><div class="line">                       {{7, 8, 13, 14}},</div><div class="line">                       {{8, 9, 14, 15}},</div><div class="line">                       {{10, 16, 9, 15}},</div><div class="line">                       {{11, 17, 10, 16}},</div><div class="line">                       {{12, 13, 22, 20}},</div><div class="line">                       {{13, 14, 20, 18}},</div><div class="line">                       {{14, 15, 18, 19}},</div><div class="line">                       {{16, 21, 15, 19}},</div><div class="line">                       {{17, 23, 16, 21}},</div><div class="line">                       {{20, 18, 21, 19}},</div><div class="line">                       {{22, 20, 23, 21}}};</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation_2d_2;</div><div class="line">  create_2d_grid(vertices_2, cell_vertices_2, triangulation_2d_2);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> triangulation_3d_2;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation</a>(triangulation_2d_2,</div><div class="line">                                       5,</div><div class="line">                                       2.5,</div><div class="line">                                       triangulation_3d_2);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Also shift this triangulation in the z-direction so that it matches the</span></div><div class="line">  <span class="comment">// end face of the first part</span></div><div class="line">  <a class="code" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>(<a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0, 0, 2.5), triangulation_3d_2);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">// Now first merge these two pieces, then shift the first piece in</span></div><div class="line">  <span class="comment">// z-direction beyond the second, and merge the shifted piece with the two</span></div><div class="line">  <span class="comment">// previously merged one into the final one:</span></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> triangulation_3d_tmp;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(triangulation_3d_1,</div><div class="line">                                      triangulation_3d_2,</div><div class="line">                                      triangulation_3d_tmp);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a4b953611883979e3f920f800bd855df3">GridTools::shift</a>(<a class="code" href="classPoint.html">Point&lt;3&gt;</a>(0, 0, 5), triangulation_3d_1);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(triangulation_3d_tmp,</div><div class="line">                                      triangulation_3d_1,</div><div class="line">                                      triangulation);</div><div class="line">}</div></div><!-- fragment --><p>这就形成了以下的网格。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.8.png" width="400" height="355"/>
</div>
<p>这个网格具有正确的一般形状，但是顶部的单元现在是多边形的：它们的边缘不再是沿着圆的，我们没有非常准确地表示原始几何形状。下一步是教给域的顶部部分，它应该是弯曲的。换句话说，所有在顶部边界单元上进行的计算都应该以圆柱坐标而不是笛卡尔坐标进行。我们可以通过创建一个CylindricalManifold对象并将其与上面的单元格相关联来做到这一点 \(y = 3\) 。这样，当我们细化上面的单元时，我们将沿着同心圆而不是直线来放置新的点。</p>
<p>在deal.II中，我们用继承自Manifold的类来描述所有的几何体。默认的几何图形是笛卡尔的，在FlatManifold类中实现。顾名思义，Manifold及其继承类提供了一种用微分几何的思想和术语来描述曲线和曲线单元的一般方法：例如，CylindricalManifold继承自ChartManifold，它通过回拉和前推来描述几何体。一般来说，人们应该认为Triangulation类描述了一个域的拓扑结构（当然，除了存储顶点的位置之外），而Manifold类描述了一个域的几何结构（例如，一对顶点是否位于圆弧或直线上）。Triangulation将通过对与该单元相关的Manifold进行计算来细化单元，而不管该单元是否在边界上。换句话说：Manifold类不需要任何关于Triangulation边界实际位置的信息：由Triangulation来查询正确的Manifold，以便对单元格进行计算。大多数的Manifold函数（例如， <a class="el" href="classManifold.html#aace84e99db1f4767ce9e524170a1de2c">Manifold::get_intermediate_point</a>) ）对域本身一无所知，只是假设给它的点是沿着测地线的。在这种情况下，在下面构建的CylindricalManifold中，测地线是沿正交于 \(z\) 轴的圆弧，以直线 \((0, 3, z)\) 为中心。</p>
<p>由于领域的三个顶部部分都使用相同的测地线，我们将把所有中心在 \(y = 3\) 线以上的单元格标记为圆柱形的性质。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a>           axis({0.0, 0.0, 1.0});</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a>               axial_point(0, 3.0, 0.0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classCylindricalManifold.html">CylindricalManifold&lt;3&gt;</a> <a class="code" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a>(axis, axial_point);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::manifold_id</a>     cylinder_id = 8;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">create_3d_grid(triangulation);</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(cylinder_id, <a class="code" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;center()[1] &gt;= 3.0)</div><div class="line">    cell-&gt;<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(cylinder_id);</div><div class="line"></div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div></div><!-- fragment --><p>通过这段代码，我们得到一个看起来像这样的网格。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.9.png" width="400" height="355"/>
</div>
<p>这一变化修复了边界，但产生了一个新的问题：与圆柱体轴线相邻的单元格严重扭曲。我们应该使用笛卡尔坐标对这些中心单元进行计算以避免这个问题。沿着中心线的单元格都有一个面接触到线 \((0, 3, z)\) ，所以，为了实现这一点，我们回去把这些单元格上的 <code>manifold_id</code> s改写为0（这是默认的）。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, 3&gt;</a>           axis({0.0, 0.0, 1.0});</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a>               axial_point(0, 3.0, 0.0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classCylindricalManifold.html">CylindricalManifold&lt;3&gt;</a> <a class="code" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a>(axis, axial_point);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::manifold_id</a>     cylinder_id = 8;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">create_3d_grid(triangulation);</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a>(cylinder_id, <a class="code" href="namespaceGridGenerator.html#a5cdda7b4a76d509af7d1a8dc1320ddb0">cylinder</a>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;center()[1] &gt;= 3.0)</div><div class="line">    cell-&gt;<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(cylinder_id);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;3&gt;</a> face_center = face-&gt;center();</div><div class="line">      <span class="keywordflow">if</span> (std::abs(face_center[0]) &lt; 1.0e-5 &amp;&amp;</div><div class="line">          std::abs(face_center[1] - 3.0) &lt; 1.0e-5)</div><div class="line">        cell-&gt;<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(<a class="code" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div></div><!-- fragment --><p>这给了我们以下的网格。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.10.png" width="400" height="355"/>
</div>
<p>这给了我们一个很好的网格，每个圆心的单元仍然是笛卡尔的，而边界周围的单元是沿着圆的。如果我们再细化两次，我们可以真正看到边界拟合网格的良好细节。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-49.yuhan.11.png" width="400" height="355"/>
</div>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p><a class="anchor" id="Assigningdifferentboundaryids"></a></p><h4>Assigning different boundary ids </h4>
<p>为本教程中描述的以某种形式生成的网格分配不同的边界ID，以应用不同的边界条件，通常是很有用的。</p>
<p>例如，你可能想对这个程序中第一个网格的右边边界应用不同的边界条件。要做到这一点，遍历单元格和它们的面，确定正确的面（例如使用<code>cell-&gt;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center()</a></code>来查询单元格中心的坐标，就像我们在步骤1中做的那样，或者使用<code>cell-&gt;face(f)-&gt;get_boundary_id()</code>来查询该单元格第 \(f\) 个面的当前边界指标）。然后你可以使用<code>cell-&gt;face(f)-&gt;set_boundary_id()</code>来设置边界指标为不同的内容。你可以回顾一下步骤1，看看网格的迭代是如何进行的。</p>
<p><a class="anchor" id="Extractingaboundarymesh"></a></p><h4>Extracting a boundary mesh </h4>
<p>在流形上的计算，就像在<a class="el" href="step_38.html">step-38</a>中做的那样，需要一个嵌入到高维空间的曲面网格。虽然有些网格可以用GridGenerator命名空间来构建或者从文件中加载，但有时从体积网格中提取一个表面网格也是很有用的。</p>
<p>使用函数 <a class="el" href="namespaceGridGenerator.html#a45440e91a38475333d937938bbd3b046">GridGenerator::extract_boundary_mesh()</a> 来提取网格的表面元素。在一个三维网格上使用这个函数（一个<code>三角网格&lt;3,3&gt;</code>，例如从<code>grid_4()</code>），这将返回一个<code>三角网格&lt;2,3&gt;</code>，你可以在步骤38中使用。 也可以尝试提取一个<code>三角网格&lt;2,2&gt;</code>的边界网格。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2013 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Timo Heister, Texas A&amp;M University, 2013</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2manifold__lib_8h.html">deal.II/grid/manifold_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__in_8h.html">deal.II/grid/grid_in.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> print_mesh_info(<span class="keyword">const</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> &amp;triangulation,</div><div class="line">                     <span class="keyword">const</span> std::string &amp;       filename)</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh info:&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; dimension: &quot;</span> &lt;&lt; dim &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; no. of cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    std::map&lt;types::boundary_id, unsigned int&gt; boundary_count;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : triangulation.<a class="code" href="group__CPP11.html#ga1bf11e9e1e5c2ff59a9c7b3f5a2bc5ad">active_face_iterators</a>())</div><div class="line">      <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">        boundary_count[face-&gt;boundary_id()]++;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; boundary indicators: &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;const types::boundary_id, unsigned int&gt; &amp;pair :</div><div class="line">         boundary_count)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="stringliteral">&quot; times) &quot;</span>;</div><div class="line">      }</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  std::ofstream out(filename);</div><div class="line">  <a class="code" href="classGridOut.html">GridOut</a>       grid_out;</div><div class="line">  grid_out.<a class="code" href="classGridOut.html#a8bd3a74b86d7c0eb792d2efca7f945f1">write_vtu</a>(triangulation, out);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; written to &quot;</span> &lt;&lt; filename &lt;&lt; std::endl &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_1()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classGridIn.html">GridIn&lt;2&gt;</a> gridin;</div><div class="line">  gridin.<a class="code" href="classGridIn.html#a82ac1c03b0efe87204ad45d2f1d87f7e">attach_triangulation</a>(triangulation);</div><div class="line">  std::ifstream f(<span class="stringliteral">&quot;example.msh&quot;</span>);</div><div class="line">  gridin.<a class="code" href="group__simplex.html#ga83872db02e04f52ac52d578912f6da5e">read_msh</a>(f);</div><div class="line"></div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-1.vtu&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_2()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> tria1;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(tria1, 0.25, 1.0);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          tria2;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = 3;</div><div class="line">  repetitions[1] = 2;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(tria2,</div><div class="line">                                            repetitions,</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, -1.0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(4.0, 1.0));</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a7cd88e7eacd46697dee80ad2b8438d54">GridGenerator::merge_triangulations</a>(tria1, tria2, triangulation);</div><div class="line"></div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-2.vtu&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_3()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(triangulation, 0.25, 1.0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : cell-&gt;vertex_indices())</div><div class="line">        {</div><div class="line">          <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;v = cell-&gt;vertex(i);</div><div class="line">          <span class="keywordflow">if</span> (std::abs(v(1) - 1.0) &lt; 1e-5)</div><div class="line">            v(1) += 0.5;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(2);</div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-3.vtu&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_4()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;3&gt;</a> out;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#add14cab546d033c1eaacc9234c64ebcd">GridGenerator::hyper_cube_with_cylindrical_hole</a>(triangulation, 0.25, 1.0);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a6cc0ff3b4e5226c3e06a4aa6ac79f90c">GridGenerator::extrude_triangulation</a>(triangulation, 3, 2.0, out);</div><div class="line">  print_mesh_info(out, <span class="stringliteral">&quot;grid-4.vtu&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_5()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = 14;</div><div class="line">  repetitions[1] = 2;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            repetitions,</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(10.0, 1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(</div><div class="line">    [](<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in) {</div><div class="line">      <span class="keywordflow">return</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(in[0], in[1] + <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(<a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> * in[0] / 5.0));</div><div class="line">    },</div><div class="line">    <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>);</div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-5.vtu&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct </span>Grid6Func</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> trans(<span class="keyword">const</span> <span class="keywordtype">double</span> y)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">std::tanh</a>(2 * y) / <a class="code" href="namespaceDifferentiation_1_1SD.html#a86151e4842702eb0b667b22122df4597">tanh</a>(2);</div><div class="line">  }</div><div class="line"></div><div class="line">  <a class="code" href="classPoint.html">Point&lt;2&gt;</a> operator()(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;in)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> {in(0), trans(in(1))};</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_6()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = repetitions[1] = 40;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            repetitions,</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, 1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#a212e99cf0d923cebfa04f1d23fa60b04">GridTools::transform</a>(Grid6Func(), triangulation);</div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-6.vtu&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> grid_7()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a>          <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  std::vector&lt;unsigned int&gt; repetitions(2);</div><div class="line">  repetitions[0] = repetitions[1] = 16;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation,</div><div class="line">                                            repetitions,</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0.0, 0.0),</div><div class="line">                                            <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1.0, 1.0));</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridTools.html#ac4e8aecd2cf74d3476e0daa11a00248b">GridTools::distort_random</a>(0.3, triangulation, <span class="keyword">true</span>);</div><div class="line">  print_mesh_info(triangulation, <span class="stringliteral">&quot;grid-7.vtu&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      grid_1();</div><div class="line">      grid_2();</div><div class="line">      grid_3();</div><div class="line">      grid_4();</div><div class="line">      grid_5();</div><div class="line">      grid_6();</div><div class="line">      grid_7();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
