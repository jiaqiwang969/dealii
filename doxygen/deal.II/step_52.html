<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_52.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-52 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-52 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_26.html">step-26</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Problemstatement">Problem statement</a>
        <li><a href="#RungeKuttamethods">Runge-Kutta methods</a>
      <ul>
        <li><a href="#ExplicitRungeKuttamethods">Explicit Runge-Kutta methods</a>
        <li><a href="#EmbeddedRungeKuttamethods">Embedded Runge-Kutta methods</a>
        <li><a href="#ImplicitRungeKuttamethods">Implicit Runge-Kutta methods</a>
      </ul>
        <li><a href="#Spatiallydiscreteformulation">Spatially discrete formulation</a>
        <li><a href="#Notesonthetestcase">Notes on the testcase</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeDiffusioncodeclass">The <code>Diffusion</code> class</a>
      <ul>
        <li><a href="#codeDiffusionsetup_systemcode"><code>Diffusion::setup_system</code></a>
        <li><a href="#codeDiffusionassemble_systemcode"><code>Diffusion::assemble_system</code></a>
        <li><a href="#codeDiffusionget_sourcecode"><code>Diffusion::get_source</code></a>
        <li><a href="#codeDiffusionevaluate_diffusioncode"><code>Diffusion::evaluate_diffusion</code></a>
        <li><a href="#codeDiffusionid_minus_tau_J_inversecode"><code>Diffusion::id_minus_tau_J_inverse</code></a>
        <li><a href="#codeDiffusionoutput_resultscode"><code>Diffusion::output_results</code></a>
        <li><a href="#codeDiffusionexplicit_methodcode"><code>Diffusion::explicit_method</code></a>
        <li><a href="#codeDiffusionimplicit_methodcode"><code>Diffusion::implicit_method</code></a>
        <li><a href="#codeDiffusionembedded_explicit_methodcode"><code>Diffusion::embedded_explicit_method</code></a>
        <li><a href="#codeDiffusionruncode"><code>Diffusion::run</code></a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main()</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Bruno Turcksin and Damien Lebrun-Grandie.</em></p>
<dl class="section note"><dt>Note</dt><dd>In order to run this program, deal.II must be configured to use the UMFPACK sparse direct solver. Refer to the <a href="../../readme.html#umfpack">ReadMe</a> for instructions how to do this.</dd></dl>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This program shows how to use Runge-Kutta methods to solve a time-dependent problem. It solves a small variation of the heat equation discussed first in <a class="el" href="step_26.html">step-26</a> but, since the purpose of this program is only to demonstrate using more advanced ways to interface with deal.II's time stepping algorithms, only solves a simple problem on a uniformly refined mesh.</p>
<p><a class="anchor" id="Problemstatement"></a></p><h3>Problem statement</h3>
<p>In this example, we solve the one-group time-dependent diffusion approximation of the neutron transport equation (see <a class="el" href="step_28.html">step-28</a> for the time-independent multigroup diffusion). This is a model for how neutrons move around highly scattering media, and consequently it is a variant of the time-dependent diffusion equation &ndash; which is just a different name for the heat equation discussed in <a class="el" href="step_26.html">step-26</a>, plus some extra terms. We assume that the medium is not fissible and therefore, the neutron flux satisfies the following equation: </p><p class="formulaDsp">
\begin{eqnarray*} \frac{1}{v}\frac{\partial \phi(x,t)}{\partial t} = \nabla \cdot D(x) \nabla \phi(x,t) - \Sigma_a(x) \phi(x,t) + S(x,t) \end{eqnarray*}
</p>
<p> augmented by appropriate boundary conditions. Here, \(v\) is the velocity of neutrons (for simplicity we assume it is equal to 1 which can be achieved by simply scaling the time variable), \(D\) is the diffusion coefficient, \(\Sigma_a\) is the absorption cross section, and \(S\) is a source. Because we are only interested in the time dependence, we assume that \(D\) and \(\Sigma_a\) are constant.</p>
<p>Since this program only intends to demonstrate how to use advanced time stepping algorithms, we will only look for the solutions of relatively simple problems. Specifically, we are looking for a solution on a square domain \([0,b]\times[0,b]\) of the form </p><p class="formulaDsp">
\begin{eqnarray*} \phi(x,t) = A\sin(\omega t)(bx-x^2). \end{eqnarray*}
</p>
<p> By using quadratic finite elements, we can represent this function exactly at any particular time, and all the error will be due to the time discretization. We do this because it is then easy to observe the order of convergence of the various time stepping schemes we will consider, without having to separate spatial and temporal errors.</p>
<p>We impose the following boundary conditions: homogeneous Dirichlet for \(x=0\) and \(x=b\) and homogeneous Neumann conditions for \(y=0\) and \(y=b\). We choose the source term so that the corresponding solution is in fact of the form stated above: </p><p class="formulaDsp">
\begin{eqnarray*} S=A\left(\frac{1}{v}\omega \cos(\omega t)(bx -x^2) + \sin(\omega t) \left(\Sigma_a (bx-x^2)+2D\right) \right). \end{eqnarray*}
</p>
<p> Because the solution is a sine in time, we know that the exact solution satisfies \(\phi\left(x,\frac{\pi}{\omega}\right) = 0\). Therefore, the error at time \(t=\frac{\pi}{\omega}\) is simply the norm of the numerical solution, i.e., \(\|e(\cdot,t=\frac{\pi}{\omega})\|_{L_2} = \|\phi_h(\cdot,t=\frac{\pi}{\omega})\|_{L_2}\), and is particularly easily evaluated. In the code, we evaluate the \(l_2\) norm of the vector of nodal values of \(\phi_h\) instead of the \(L_2\) norm of the associated spatial function, since the former is simpler to compute; however, on uniform meshes, the two are just related by a constant and we can consequently observe the temporal convergence order with either.</p>
<p><a class="anchor" id="RungeKuttamethods"></a></p><h3>Runge-Kutta methods</h3>
<p>The Runge-Kutta methods implemented in deal.II assume that the equation to be solved can be written as: </p><p class="formulaDsp">
\begin{eqnarray*} \frac{dy}{dt} = g(t,y). \end{eqnarray*}
</p>
<p> On the other hand, when using finite elements, discretized time derivatives always result in the presence of a mass matrix on the left hand side. This can easily be seen by considering that if the solution vector \(y(t)\) in the equation above is in fact the vector of nodal coefficients \(U(t)\) for a variable of the form </p><p class="formulaDsp">
\begin{eqnarray*} u_h(x,t) = \sum_j U_j(t) \varphi_j(x) \end{eqnarray*}
</p>
<p> with spatial shape functions \(\varphi_j(x)\), then multiplying an equation of the form </p><p class="formulaDsp">
\begin{eqnarray*} \frac{\partial u(x,t)}{\partial t} = q(t,u(x,t)) \end{eqnarray*}
</p>
<p> by test functions, integrating over \(\Omega\), substituting \(u\rightarrow u_h\) and restricting the test functions to the \(\varphi_i(x)\) from above, then this spatially discretized equation has the form </p><p class="formulaDsp">
\begin{eqnarray*} M\frac{dU}{dt} = f(t,U), \end{eqnarray*}
</p>
<p> where \(M\) is the mass matrix and \(f(t,U)\) is the spatially discretized version of \(q(t,u(x,t))\) (where \(q\) is typically the place where spatial derivatives appear, but this is not of much concern for the moment given that we only consider time derivatives). In other words, this form fits the general scheme above if we write </p><p class="formulaDsp">
\begin{eqnarray*} \frac{dy}{dt} = g(t,y) = M^{-1}f(t,y). \end{eqnarray*}
</p>
<p>Runke-Kutta methods are time stepping schemes that approximate \(y(t_n)\approx y_{n}\) through a particular one-step approach. They are typically written in the form </p><p class="formulaDsp">
\begin{eqnarray*} y_{n+1} = y_n + \sum_{i=1}^s b_i k_i \end{eqnarray*}
</p>
<p> where for the form of the right hand side above </p><p class="formulaDsp">
\begin{eqnarray*} k_i = h M^{-1} f\left(t_n+c_ih,y_n+\sum_{j=1}^sa_{ij}k_j\right). \end{eqnarray*}
</p>
<p> Here \(a_{ij}\), \(b_i\), and \(c_i\) are known coefficients that identify which particular Runge-Kutta scheme you want to use, and \(h=t_{n+1}-t_n\) is the time step used. Different time stepping methods of the Runge-Kutta class differ in the number of stages \(s\) and the values they use for the coefficients \(a_{ij}\), \(b_i\), and \(c_i\) but are otherwise easy to implement since one can look up tabulated values for these coefficients. (These tables are often called Butcher tableaus.)</p>
<p>At the time of the writing of this tutorial, the methods implemented in deal.II can be divided in three categories: </p><ol>
<li>
Explicit Runge-Kutta; in order for a method to be explicit, it is necessary that in the formula above defining \(k_i\), \(k_i\) does not appear on the right hand side. In other words, these methods have to satisfy \(a_{ii}=0, i=1,\ldots,s\). </li>
<li>
Embedded (or adaptive) Runge-Kutta; we will discuss their properties below. </li>
<li>
Implicit Runge-Kutta; this class of methods require the solution of a possibly nonlinear system the stages \(k_i\) above, i.e., they have \(a_{ii}\neq 0\) for at least one of the stages \(i=1,\ldots,s\). </li>
</ol>
<p>Many well known time stepping schemes that one does not typically associate with the names Runge or Kutta can in fact be written in a way so that they, too, can be expressed in these categories. They oftentimes represent the lowest-order members of these families.</p>
<p><a class="anchor" id="ExplicitRungeKuttamethods"></a></p><h4>Explicit Runge-Kutta methods</h4>
<p>These methods, only require a function to evaluate \(M^{-1}f(t,y)\) but not (as implicit methods) to solve an equation that involves \(f(t,y)\) for \(y\). As all explicit time stepping methods, they become unstable when the time step chosen is too large.</p>
<p>Well known methods in this class include forward Euler, third order Runge-Kutta, and fourth order Runge-Kutta (often abbreviated as RK4).</p>
<p><a class="anchor" id="EmbeddedRungeKuttamethods"></a></p><h4>Embedded Runge-Kutta methods</h4>
<p>These methods use both a lower and a higher order method to estimate the error and decide if the time step needs to be shortened or can be increased. The term "embedded" refers to the fact that the lower-order method does not require additional evaluates of the function \(M^{-1}f(\cdot,\cdot)\) but reuses data that has to be computed for the high order method anyway. It is, in other words, essentially free, and we get the error estimate as a side product of using the higher order method.</p>
<p>This class of methods include Heun-Euler, Bogacki-Shampine, Dormand-Prince (ode45 in Matlab and often abbreviated as RK45 to indicate that the lower and higher order methods used here are 4th and 5th order Runge-Kutta methods, respectively), Fehlberg, and Cash-Karp.</p>
<p>At the time of the writing, only embedded explicit methods have been implemented.</p>
<p><a class="anchor" id="ImplicitRungeKuttamethods"></a></p><h4>Implicit Runge-Kutta methods</h4>
<p>Implicit methods require the solution of (possibly nonlinear) systems of the form \(\alpha y = f(t,y)\) for \(y\) in each (sub-)timestep. Internally, this is done using a Newton-type method and, consequently, they require that the user provide functions that can evaluate \(M^{-1}f(t,y)\) and \(\left(I-\tau M^{-1} \frac{\partial f}{\partial y}\right)^{-1}\) or equivalently \(\left(M - \tau \frac{\partial f}{\partial y}\right)^{-1} M\).</p>
<p>The particular form of this operator results from the fact that each Newton step requires the solution of an equation of the form </p><p class="formulaDsp">
\begin{align*} \left(M - \tau \frac{\partial f}{\partial y}\right) \Delta y = -M h(t,y) \end{align*}
</p>
<p> for some (given) \(h(t,y)\). Implicit methods are always stable, regardless of the time step size, but too large time steps of course affect the <em>accuracy</em> of the solution, even if the numerical solution remains stable and bounded.</p>
<p>Methods in this class include backward Euler, implicit midpoint, Crank-Nicolson, and the two stage SDIRK method (short for "singly diagonally
implicit Runge-Kutta", a term coined to indicate that the diagonal elements \(a_{ii}\) defining the time stepping method are all equal; this property allows for the Newton matrix \(I-\tau M^{-1}\frac{\partial f}{\partial y}\) to be re-used between stages because \(\tau\) is the same every time).</p>
<p><a class="anchor" id="Spatiallydiscreteformulation"></a></p><h3>Spatially discrete formulation</h3>
<p>By expanding the solution of our model problem as always using shape functions \(\psi_j\) and writing </p><p class="formulaDsp">
\begin{eqnarray*} \phi_h(x,t) = \sum_j U_j(t) \psi_j(x), \end{eqnarray*}
</p>
<p> we immediately get the spatially discretized version of the diffusion equation as </p><p class="formulaDsp">
\begin{eqnarray*} M \frac{dU(t)}{dt} = -{\cal D} U(t) - {\cal A} U(t) + {\cal S}(t) \end{eqnarray*}
</p>
<p> where </p><p class="formulaDsp">
\begin{eqnarray*} M_{ij} &amp;=&amp; (\psi_i,\psi_j), \\ {\cal D}_{ij} &amp;=&amp; (D\nabla\psi_i,\nabla\psi_j)_\Omega, \\ {\cal A}_{ij} &amp;=&amp; (\Sigma_a\psi_i,\psi_j)_\Omega, \\ {\cal S}_{i}(t) &amp;=&amp; (\psi_i,S(x,t))_\Omega. \end{eqnarray*}
</p>
<p> See also <a class="el" href="step_24.html">step-24</a> and <a class="el" href="step_26.html">step-26</a> to understand how we arrive here. Boundary terms are not necessary due to the chosen boundary conditions for the current problem. To use the Runge-Kutta methods, we recast this as follows: </p><p class="formulaDsp">
\begin{eqnarray*} f(y) = -{\cal D}y - {\cal A}y + {\cal S}. \end{eqnarray*}
</p>
<p> In the code, we will need to be able to evaluate this function \(f(U)\) along with its derivative, </p><p class="formulaDsp">
\begin{eqnarray*} \frac{\partial f}{\partial y} = -{\cal D} - {\cal A}. \end{eqnarray*}
</p>
<p><a class="anchor" id="Notesonthetestcase"></a></p><h3>Notes on the testcase</h3>
<p>To simplify the problem, the domain is two dimensional and the mesh is uniformly refined (there is no need to adapt the mesh since we use quadratic finite elements and the exact solution is quadratic). Going from a two dimensional domain to a three dimensional domain is not very challenging. However if you intend to solve more complex problems where the mesh must be adapted (as is done, for example, in <a class="el" href="step_26.html">step-26</a>), then it is important to remember the following issues:</p>
<ol>
<li>
You will need to project the solution to the new mesh when the mesh is changed. Of course, the mesh used should be the same from the beginning to the end of each time step, a question that arises because Runge-Kutta methods use multiple evaluations of the equations within each time step. </li>
<li>
You will need to update the mass matrix and its inverse every time the mesh is changed. </li>
</ol>
<p>The techniques for these steps are readily available by looking at <a class="el" href="step_26.html">step-26</a>.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first task as usual is to include the functionality of these well-known deal.II library files and some C++ header files.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div></div><!-- fragment --><p>This is the only include file that is new: It includes all the Runge-Kutta methods.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="time__stepping_8h.html">deal.II/base/time_stepping.h</a>&gt;</span></div></div><!-- fragment --><p>The next step is like in all previous tutorial programs: We put everything into a namespace of its own and then import the deal.II classes and functions into it.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step52</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeDiffusioncodeclass"></a> </p><h3>The <code>Diffusion</code> class</h3>
<p>The next piece is the declaration of the main class. Most of the functions in this class are not new and have been explained in previous tutorials. The only interesting functions are <code>evaluate_diffusion()</code> and <code>id_minus_tau_J_inverse()</code>. <code>evaluate_diffusion()</code> evaluates the diffusion equation, \(M^{-1}(f(t,y))\), at a given time and a given \(y\). <code>id_minus_tau_J_inverse()</code> evaluates \(\left(I-\tau M^{-1} \frac{\partial f(t,y)}{\partial y}\right)^{-1}\) or equivalently \(\left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} M\) at a given time, for a given \(\tau\) and \(y\). This function is needed when an implicit method is used.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Diffusion</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Diffusion();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_source(<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> evaluate_diffusion(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> id_minus_tau_J_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                        <span class="keyword">const</span> <span class="keywordtype">double</span>          tau,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">double</span>                     time,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               time_step,</div><div class="line">                      <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method) <span class="keyword">const</span>;</div></div><!-- fragment --><p>The next three functions are the drivers for the explicit methods, the implicit methods, and the embedded explicit methods respectively. The driver function for embedded explicit methods returns the number of steps executed given that it only takes the number of time steps passed as an argument as a hint, but internally computed the optimal time step itself.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> implicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time);</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">  embedded_explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> diffusion_coefficient;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> absorption_cross_section;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> fe;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraint_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line"></div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> mass_minus_tau_Jacobian;</div><div class="line"></div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> inverse_mass_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">};</div></div><!-- fragment --><p>We choose quadratic finite elements and we initialize the parameters.</p>
<div class="fragment"><div class="line">Diffusion::Diffusion()</div><div class="line">  : fe_degree(2)</div><div class="line">  , diffusion_coefficient(1. / 30.)</div><div class="line">  , absorption_cross_section(1.)</div><div class="line">  , fe(fe_degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionsetup_systemcode"></a> </p><h4><code>Diffusion::setup_system</code></h4>
<p>Now, we create the constraint matrix and the sparsity pattern. Then, we initialize the matrices and the solution vector.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           1,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;2&gt;</a>(),</div><div class="line">                                           constraint_matrix);</div><div class="line">  constraint_matrix.close();</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraint_matrix);</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a>(sparsity_pattern);</div><div class="line">  mass_minus_tau_Jacobian.reinit(sparsity_pattern);</div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionassemble_systemcode"></a> </p><h4><code>Diffusion::assemble_system</code></h4>
<p>In this function, we compute \(-\int D \nabla b_i \cdot \nabla b_j d\boldsymbol{r} - \int \Sigma_a b_i b_j d\boldsymbol{r}\) and the mass matrix \(\int b_i b_j d\boldsymbol{r}\). The mass matrix is then inverted using a direct solver; the <code>inverse_mass_matrix</code> variable will then store the inverse of the mass matrix so that \(M^{-1}\) can be applied to a vector using the <code>vmult()</code> function of that object. (Internally, UMFPACK does not really store the inverse of the matrix, but its LU factors; applying the inverse matrix is then equivalent to doing one forward and one backward solves with these two factors, which has the same complexity as applying an explicit inverse of the matrix).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::assemble_system()</div><div class="line">{</div><div class="line">  system_matrix = 0.;</div><div class="line">  mass_matrix   = 0.;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                        quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_matrix      = 0.;</div><div class="line">      cell_mass_matrix = 0.;</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                ((-diffusion_coefficient *                <span class="comment">// (-D</span></div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *    <span class="comment">//  * grad phi_i</span></div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)      <span class="comment">//  * grad phi_j</span></div><div class="line">                  - absorption_cross_section *            <span class="comment">//  -Sigma</span></div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * <span class="comment">//  * phi_i</span></div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point))  <span class="comment">//  * phi_j)</span></div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));               <span class="comment">// * dx</span></div><div class="line">              cell_mass_matrix(i, j) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                                        fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point) *</div><div class="line">                                        fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">            }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      constraint_matrix.distribute_local_to_global(cell_matrix,</div><div class="line">                                                   local_dof_indices,</div><div class="line">                                                   system_matrix);</div><div class="line">      constraint_matrix.distribute_local_to_global(cell_mass_matrix,</div><div class="line">                                                   local_dof_indices,</div><div class="line">                                                   mass_matrix);</div><div class="line">    }</div><div class="line"></div><div class="line">  inverse_mass_matrix.<a class="code" href="classDoFHandler.html#aeca4a4af5c4d7f7c68a4def9ae87bc7b">initialize</a>(mass_matrix);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionget_sourcecode"></a> </p><h4><code>Diffusion::get_source</code></h4>
<p>In this function, the source term of the equation for a given time and a given point is computed.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> Diffusion::get_source(<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> intensity = 10.;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> frequency = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> / 10.;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> b         = 5.;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> x         = <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> intensity *</div><div class="line">         (frequency * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(frequency * time) * (b * x - x * x) +</div><div class="line">          std::sin(frequency * time) *</div><div class="line">            (absorption_cross_section * (b * x - x * x) +</div><div class="line">             2. * diffusion_coefficient));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionevaluate_diffusioncode"></a> </p><h4><code>Diffusion::evaluate_diffusion</code></h4>
<p>Next, we evaluate the weak form of the diffusion equation at a given time \(t\) and for a given vector \(y\). In other words, as outlined in the introduction, we evaluate \(M^{-1}(-{\cal D}y - {\cal A}y + {\cal S})\). For this, we have to apply the matrix \(-{\cal D} - {\cal A}\) (previously computed and stored in the variable <code>system_matrix</code>) to \(y\) and then add the source term which we integrate as we usually do. (Integrating up the solution could be done using <a class="el" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side()</a> if you wanted to save a few lines of code, or wanted to take advantage of doing the integration in parallel.) The result is then multiplied by \(M^{-1}\).</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> Diffusion::evaluate_diffusion(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                             <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  tmp = 0.;</div><div class="line">  system_matrix.vmult(tmp, y);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                        quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_source(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_source = 0.;</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> source =</div><div class="line">            get_source(time, fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point));</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            cell_source(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * <span class="comment">// phi_i(x)</span></div><div class="line">                              source *                            <span class="comment">// * S(x)</span></div><div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);             <span class="comment">// * dx</span></div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      constraint_matrix.distribute_local_to_global(cell_source,</div><div class="line">                                                   local_dof_indices,</div><div class="line">                                                   tmp);</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> value(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  inverse_mass_matrix.vmult(value, tmp);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> value;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionid_minus_tau_J_inversecode"></a> </p><h4><code>Diffusion::id_minus_tau_J_inverse</code></h4>
<p>We compute \(\left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} M\). This is done in several steps:</p><ul>
<li>compute \(M-\tau \frac{\partial f}{\partial y}\)</li>
<li>invert the matrix to get \(\left(M-\tau \frac{\partial f} {\partial y}\right)^{-1}\)</li>
<li>compute \(tmp=My\)</li>
<li>compute \(z=\left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} tmp = \left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} My\)</li>
<li>return z.</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> Diffusion::id_minus_tau_J_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span> <span class="comment">/*time*/</span>,</div><div class="line">                                                 <span class="keyword">const</span> <span class="keywordtype">double</span>          tau,</div><div class="line">                                                 <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y)</div><div class="line">{</div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> inverse_mass_minus_tau_Jacobian;</div><div class="line"></div><div class="line">  mass_minus_tau_Jacobian.copy_from(mass_matrix);</div><div class="line">  mass_minus_tau_Jacobian.add(-tau, system_matrix);</div><div class="line"></div><div class="line">  inverse_mass_minus_tau_Jacobian.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(mass_minus_tau_Jacobian);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a4aedd84e99cda48dce634a2bbf8763fd">vmult</a>(tmp, y);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> result(y);</div><div class="line">  inverse_mass_minus_tau_Jacobian.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(result, tmp);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionoutput_resultscode"></a> </p><h4><code>Diffusion::output_results</code></h4>
<p>The following function then outputs the solution in vtu files indexed by the number of the time step and the name of the time stepping method. Of course, the (exact) result should really be the same for all time stepping method, but the output here at least allows us to compare them.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::output_results(<span class="keyword">const</span> <span class="keywordtype">double</span>                     time,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               time_step,</div><div class="line">                               <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::string method_name;</div><div class="line"></div><div class="line">  <span class="keywordflow">switch</span> (method)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a037245063b5afdaf23a96ec566373613">TimeStepping::FORWARD_EULER</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;forward_euler&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4acd53dff7339f8bd6d11e3e26ee207894">TimeStepping::RK_THIRD_ORDER</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;rk3&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a32b4e44cc3d0746c448d48f3fcb6f633">TimeStepping::RK_CLASSIC_FOURTH_ORDER</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;rk4&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ada1f653aefa77b5cde1c0a644c283a77">TimeStepping::BACKWARD_EULER</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;backward_euler&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a5cc8559104243d25be4380b76ae5aa62">TimeStepping::IMPLICIT_MIDPOINT</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;implicit_midpoint&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a2102ce2c5306320faa2eb291b505d495">TimeStepping::SDIRK_TWO_STAGES</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;sdirk&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a48a2da10d70ded640369a80770aa8279">TimeStepping::HEUN_EULER</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;heun_euler&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a13ecb8a07303020901221676521de483">TimeStepping::BOGACKI_SHAMPINE</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;bocacki_shampine&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ad502a4be71ee90ce567e0e65d083c595">TimeStepping::DOPRI</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;dopri&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a617cb06295ff4fd24ebc9d2c3228da6e">TimeStepping::FEHLBERG</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;fehlberg&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ab1d63829a0bd48bc67f35dae07d35a22">TimeStepping::CASH_KARP</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;cash_karp&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        {</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(<a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>(time, time_step));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution_&quot;</span> + method_name + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(time_step, 3) +</div><div class="line">                               <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line"></div><div class="line">  <span class="keyword">static</span> std::vector&lt;std::pair&lt;double, std::string&gt;&gt; times_and_names;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> std::string method_name_prev = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">  <span class="keyword">static</span> std::string pvd_filename;</div><div class="line">  <span class="keywordflow">if</span> (method_name_prev != method_name)</div><div class="line">    {</div><div class="line">      times_and_names.clear();</div><div class="line">      method_name_prev = method_name;</div><div class="line">      pvd_filename     = <span class="stringliteral">&quot;solution_&quot;</span> + method_name + <span class="stringliteral">&quot;.pvd&quot;</span>;</div><div class="line">    }</div><div class="line">  times_and_names.emplace_back(time, filename);</div><div class="line">  std::ofstream pvd_output(pvd_filename);</div><div class="line">  <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(pvd_output, times_and_names);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionexplicit_methodcode"></a> </p><h4><code>Diffusion::explicit_method</code></h4>
<p>This function is the driver for all the explicit methods. At the top it initializes the time stepping and the solution (by setting it to zero and then ensuring that boundary value and hanging node constraints are respected; of course, with the mesh we use here, hanging node constraints are not in fact an issue). It then calls <code>evolve_one_time_step</code> which performs one time step. Time is stored and incremented through a <a class="el" href="classDiscreteTime.html">DiscreteTime</a> object.</p>
<p>For explicit methods, <code>evolve_one_time_step</code> needs to evaluate \(M^{-1}(f(t,y))\), i.e, it needs <code>evaluate_diffusion</code>. Because <code>evaluate_diffusion</code> is a member function, it needs to be bound to <code>this</code>. After each evolution step, we again apply the correct boundary values and hanging node constraints.</p>
<p>Finally, the solution is output every 10 time steps.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">    (final_time - initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line"></div><div class="line">  solution = 0.;</div><div class="line">  constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">  <a class="code" href="classTimeStepping_1_1ExplicitRungeKutta.html">TimeStepping::ExplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt; explicit_runge_kutta(</div><div class="line">    method);</div><div class="line">  output_results(initial_time, 0, method);</div><div class="line">  <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">  <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      explicit_runge_kutta.evolve_one_time_step(</div><div class="line">        [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y) {</div><div class="line">          <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">        },</div><div class="line">        time.get_current_time(),</div><div class="line">        time.get_next_step_size(),</div><div class="line">        solution);</div><div class="line">      time.advance_time();</div><div class="line"></div><div class="line">      constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">        output_results(time.get_current_time(),</div><div class="line">                       time.get_step_number(),</div><div class="line">                       method);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionimplicit_methodcode"></a> </p><h4><code>Diffusion::implicit_method</code></h4>
<p>This function is equivalent to <code>explicit_method</code> but for implicit methods. When using implicit methods, we need to evaluate \(M^{-1}(f(t,y))\) and \(\left(I-\tau M^{-1} \frac{\partial f(t,y)}{\partial y}\right)^{-1}\) for which we use the two member functions previously introduced.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::implicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">    (final_time - initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line"></div><div class="line">  solution = 0.;</div><div class="line">  constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">  <a class="code" href="classTimeStepping_1_1ImplicitRungeKutta.html">TimeStepping::ImplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt; implicit_runge_kutta(</div><div class="line">    method);</div><div class="line">  output_results(initial_time, 0, method);</div><div class="line">  <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">  <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      implicit_runge_kutta.evolve_one_time_step(</div><div class="line">        [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y) {</div><div class="line">          <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">        },</div><div class="line">        [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <span class="keywordtype">double</span> tau, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y) {</div><div class="line">          <span class="keywordflow">return</span> this-&gt;id_minus_tau_J_inverse(time, tau, y);</div><div class="line">        },</div><div class="line">        time.get_current_time(),</div><div class="line">        time.get_next_step_size(),</div><div class="line">        solution);</div><div class="line">      time.advance_time();</div><div class="line"></div><div class="line">      constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">        output_results(time.get_current_time(),</div><div class="line">                       time.get_step_number(),</div><div class="line">                       method);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionembedded_explicit_methodcode"></a> </p><h4><code>Diffusion::embedded_explicit_method</code></h4>
<p>This function is the driver for the embedded explicit methods. It requires more parameters:</p><ul>
<li>coarsen_param: factor multiplying the current time step when the error is below the threshold.</li>
<li>refine_param: factor multiplying the current time step when the error is above the threshold.</li>
<li>min_delta: smallest time step acceptable.</li>
<li>max_delta: largest time step acceptable.</li>
<li>refine_tol: threshold above which the time step is refined.</li>
<li>coarsen_tol: threshold below which the time step is coarsen.</li>
</ul>
<p>Embedded methods use a guessed time step. If the error using this time step is too large, the time step will be reduced. If the error is below the threshold, a larger time step will be tried for the next time step. <code>delta_t_guess</code> is the guessed time step produced by the embedded method. In summary, time step size is potentially modified in three ways:</p><ul>
<li>Reducing or increasing time step size within <a class="el" href="classTimeStepping_1_1EmbeddedExplicitRungeKutta.html#accb05cdd9b6519c4d4ffe9ea996cee87">TimeStepping::EmbeddedExplicitRungeKutta::evolve_one_time_step()</a>.</li>
<li>Using the calculated <code>delta_t_guess</code>.</li>
<li>Automatically adjusting the step size of the last time step to ensure simulation ends precisely at <code>final_time</code>. This adjustment is handled inside the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> instance.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Diffusion::embedded_explicit_method(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">    (final_time - initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> coarsen_param = 1.2;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> refine_param  = 0.8;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> min_delta     = 1e-8;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_delta     = 10 * time_step;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> refine_tol    = 1e-1;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> coarsen_tol   = 1e-5;</div><div class="line"></div><div class="line">  solution = 0.;</div><div class="line">  constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">  <a class="code" href="classTimeStepping_1_1EmbeddedExplicitRungeKutta.html">TimeStepping::EmbeddedExplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt;</div><div class="line">    embedded_explicit_runge_kutta(method,</div><div class="line">                                  coarsen_param,</div><div class="line">                                  refine_param,</div><div class="line">                                  min_delta,</div><div class="line">                                  max_delta,</div><div class="line">                                  refine_tol,</div><div class="line">                                  coarsen_tol);</div><div class="line">  output_results(initial_time, 0, method);</div><div class="line">  <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">  <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceAlgorithms_1_1Events.html#a5b1ecab6d684503f48b9542889e7d73b">new_time</a> =</div><div class="line">        embedded_explicit_runge_kutta.evolve_one_time_step(</div><div class="line">          [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y) {</div><div class="line">            <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">          },</div><div class="line">          time.get_current_time(),</div><div class="line">          time.get_next_step_size(),</div><div class="line">          solution);</div><div class="line">      time.set_next_step_size(new_time - time.get_current_time());</div><div class="line">      time.advance_time();</div><div class="line"></div><div class="line">      constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">        output_results(time.get_current_time(),</div><div class="line">                       time.get_step_number(),</div><div class="line">                       method);</div><div class="line"></div><div class="line">      time.set_desired_next_step_size(</div><div class="line">        embedded_explicit_runge_kutta.get_status().delta_t_guess);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> time.get_step_number();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionruncode"></a> </p><h4><code>Diffusion::run</code></h4>
<p>The following is the main function of the program. At the top, we create the grid (a [0,5]x[0,5] square) and refine it four times to get a mesh that has 16 by 16 cells, for a total of 256. We then set the boundary indicator to 1 for those parts of the boundary where \(x=0\) and \(x=5\).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Diffusion::run</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 5.);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">      <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> ((face-&gt;center()[0] == 0.) || (face-&gt;center()[0] == 5.))</div><div class="line">            face-&gt;set_boundary_id(1);</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            face-&gt;set_boundary_id(0);</div><div class="line">        }</div></div><!-- fragment --><p>Next, we set up the linear systems and fill them with content so that they can be used throughout the time stepping process:</p>
<div class="fragment"><div class="line">setup_system();</div><div class="line"></div><div class="line">assemble_system();</div></div><!-- fragment --><p>Finally, we solve the diffusion problem using several of the Runge-Kutta methods implemented in namespace <a class="el" href="namespaceTimeStepping.html">TimeStepping</a>, each time outputting the error at the end time. (As explained in the introduction, since the exact solution is zero at the final time, the error equals the numerical solution and can be computed by just taking the \(l_2\) norm of the solution vector.)</p>
<div class="fragment"><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       n_steps      = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps = 200;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time = 0.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time   = 10.;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Explicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a037245063b5afdaf23a96ec566373613">TimeStepping::FORWARD_EULER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Forward Euler:            error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4acd53dff7339f8bd6d11e3e26ee207894">TimeStepping::RK_THIRD_ORDER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Third order Runge-Kutta:  error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a32b4e44cc3d0746c448d48f3fcb6f633">TimeStepping::RK_CLASSIC_FOURTH_ORDER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Fourth order Runge-Kutta: error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Implicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ada1f653aefa77b5cde1c0a644c283a77">TimeStepping::BACKWARD_EULER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Backward Euler:           error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a5cc8559104243d25be4380b76ae5aa62">TimeStepping::IMPLICIT_MIDPOINT</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Implicit Midpoint:        error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ac6a6f8452b01a46c75dc317f0676dafc">TimeStepping::CRANK_NICOLSON</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Crank-Nicolson:           error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a2102ce2c5306320faa2eb291b505d495">TimeStepping::SDIRK_TWO_STAGES</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   SDIRK:                    error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Embedded explicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a48a2da10d70ded640369a80770aa8279">TimeStepping::HEUN_EULER</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Heun-Euler:               error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a13ecb8a07303020901221676521de483">TimeStepping::BOGACKI_SHAMPINE</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Bogacki-Shampine:         error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ad502a4be71ee90ce567e0e65d083c595">TimeStepping::DOPRI</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Dopri:                    error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a617cb06295ff4fd24ebc9d2c3228da6e">TimeStepping::FEHLBERG</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Fehlberg:                 error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ab1d63829a0bd48bc67f35dae07d35a22">TimeStepping::CASH_KARP</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Cash-Karp:                error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step52</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main()</code> function</h3>
<p>The following <code>main</code> function is similar to previous examples and need not be commented on.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step52::Diffusion diffusion;</div><div class="line">      diffusion.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The point of this program is less to show particular results, but instead to show how it is done. This we have already demonstrated simply by discussing the code above. Consequently, the output the program yields is relatively sparse and consists only of the console output and the solutions given in VTU format for visualization.</p>
<p>The console output contains both errors and, for some of the methods, the number of steps they performed: </p><div class="fragment"><div class="line">Explicit methods:</div><div class="line">   Forward Euler:            error=1.00883</div><div class="line">   Third order Runge-Kutta:  error=0.000227982</div><div class="line">   Fourth order Runge-Kutta: error=1.90541e-06</div><div class="line"></div><div class="line">Implicit methods:</div><div class="line">   Backward Euler:           error=1.03428</div><div class="line">   Implicit Midpoint:        error=0.00862702</div><div class="line">   Crank-Nicolson:           error=0.00862675</div><div class="line">   SDIRK:                    error=0.0042349</div><div class="line"></div><div class="line">Embedded <span class="keyword">explicit</span> methods:</div><div class="line">   Heun-Euler:               error=0.0073012</div><div class="line">                   steps performed=284</div><div class="line">   Bogacki-Shampine:         error=0.000408407</div><div class="line">                   steps performed=181</div><div class="line">   Dopri:                    error=0.000836695</div><div class="line">                   steps performed=120</div><div class="line">   Fehlberg:                 error=0.00248922</div><div class="line">                   steps performed=106</div><div class="line">   Cash-Karp:                error=0.0787735</div><div class="line">                   steps performed=106</div></div><!-- fragment --><p>As expected the higher order methods give (much) more accurate solutions. We also see that the (rather inaccurate) Heun-Euler method increased the number of time steps in order to satisfy the tolerance. On the other hand, the other embedded methods used a lot less time steps than what was prescribed.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2014 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Damien Lebrun-Grandie, Bruno Turcksin, 2014</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="time__stepping_8h.html">deal.II/base/time_stepping.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step52</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>Diffusion</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Diffusion();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> get_source(<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;point) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; evaluate_diffusion(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                      <span class="keyword">const</span> Vector&lt;double&gt; &amp;y) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; id_minus_tau_J_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">double</span>          tau,</div><div class="line">                                          <span class="keyword">const</span> Vector&lt;double&gt; &amp;y);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">double</span>                     time,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               time_step,</div><div class="line">                        <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> implicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">    embedded_explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> diffusion_coefficient;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> absorption_cross_section;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> fe;</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraint_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line"></div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> mass_minus_tau_Jacobian;</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> inverse_mass_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  Diffusion::Diffusion()</div><div class="line">    : fe_degree(2)</div><div class="line">    , diffusion_coefficient(1. / 30.)</div><div class="line">    , absorption_cross_section(1.)</div><div class="line">    , fe(fe_degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             1,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;2&gt;</a>(),</div><div class="line">                                             constraint_matrix);</div><div class="line">    constraint_matrix.close();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraint_matrix);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a>(sparsity_pattern);</div><div class="line">    mass_minus_tau_Jacobian.reinit(sparsity_pattern);</div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::assemble_system()</div><div class="line">  {</div><div class="line">    system_matrix = 0.;</div><div class="line">    mass_matrix   = 0.;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix      = 0.;</div><div class="line">        cell_mass_matrix = 0.;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                  ((-diffusion_coefficient *                <span class="comment">// (-D</span></div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *    <span class="comment">//  * grad phi_i</span></div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)      <span class="comment">//  * grad phi_j</span></div><div class="line">                    - absorption_cross_section *            <span class="comment">//  -Sigma</span></div><div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * <span class="comment">//  * phi_i</span></div><div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point))  <span class="comment">//  * phi_j)</span></div><div class="line">                   * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));               <span class="comment">// * dx</span></div><div class="line">                cell_mass_matrix(i, j) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                                          fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point) *</div><div class="line">                                          fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">              }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        constraint_matrix.distribute_local_to_global(cell_matrix,</div><div class="line">                                                     local_dof_indices,</div><div class="line">                                                     system_matrix);</div><div class="line">        constraint_matrix.distribute_local_to_global(cell_mass_matrix,</div><div class="line">                                                     local_dof_indices,</div><div class="line">                                                     mass_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    inverse_mass_matrix.<a class="code" href="classDoFHandler.html#aeca4a4af5c4d7f7c68a4def9ae87bc7b">initialize</a>(mass_matrix);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> Diffusion::get_source(<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;point)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> intensity = 10.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> frequency = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> / 10.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> b         = 5.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> x         = <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> intensity *</div><div class="line">           (frequency * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(frequency * time) * (b * x - x * x) +</div><div class="line">            std::sin(frequency * time) *</div><div class="line">              (absorption_cross_section * (b * x - x * x) +</div><div class="line">               2. * diffusion_coefficient));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  Vector&lt;double&gt; Diffusion::evaluate_diffusion(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                               <span class="keyword">const</span> Vector&lt;double&gt; &amp;y)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    tmp = 0.;</div><div class="line">    system_matrix.vmult(tmp, y);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt; cell_source(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_source = 0.;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> source =</div><div class="line">              get_source(time, fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point));</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              cell_source(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * <span class="comment">// phi_i(x)</span></div><div class="line">                                source *                            <span class="comment">// * S(x)</span></div><div class="line">                                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);             <span class="comment">// * dx</span></div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        constraint_matrix.distribute_local_to_global(cell_source,</div><div class="line">                                                     local_dof_indices,</div><div class="line">                                                     tmp);</div><div class="line">      }</div><div class="line"></div><div class="line">    Vector&lt;double&gt; value(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    inverse_mass_matrix.vmult(value, tmp);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> value;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  Vector&lt;double&gt; Diffusion::id_minus_tau_J_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span> <span class="comment">/*time*/</span>,</div><div class="line">                                                   <span class="keyword">const</span> <span class="keywordtype">double</span>          tau,</div><div class="line">                                                   <span class="keyword">const</span> Vector&lt;double&gt; &amp;y)</div><div class="line">  {</div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> inverse_mass_minus_tau_Jacobian;</div><div class="line"></div><div class="line">    mass_minus_tau_Jacobian.copy_from(mass_matrix);</div><div class="line">    mass_minus_tau_Jacobian.add(-tau, system_matrix);</div><div class="line"></div><div class="line">    inverse_mass_minus_tau_Jacobian.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(mass_minus_tau_Jacobian);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a4aedd84e99cda48dce634a2bbf8763fd">vmult</a>(tmp, y);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; result(y);</div><div class="line">    inverse_mass_minus_tau_Jacobian.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(result, tmp);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> result;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::output_results(<span class="keyword">const</span> <span class="keywordtype">double</span>                     time,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               time_step,</div><div class="line">                                 <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::string method_name;</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (method)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a037245063b5afdaf23a96ec566373613">TimeStepping::FORWARD_EULER</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;forward_euler&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4acd53dff7339f8bd6d11e3e26ee207894">TimeStepping::RK_THIRD_ORDER</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;rk3&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a32b4e44cc3d0746c448d48f3fcb6f633">TimeStepping::RK_CLASSIC_FOURTH_ORDER</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;rk4&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ada1f653aefa77b5cde1c0a644c283a77">TimeStepping::BACKWARD_EULER</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;backward_euler&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a5cc8559104243d25be4380b76ae5aa62">TimeStepping::IMPLICIT_MIDPOINT</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;implicit_midpoint&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a2102ce2c5306320faa2eb291b505d495">TimeStepping::SDIRK_TWO_STAGES</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;sdirk&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a48a2da10d70ded640369a80770aa8279">TimeStepping::HEUN_EULER</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;heun_euler&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a13ecb8a07303020901221676521de483">TimeStepping::BOGACKI_SHAMPINE</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;bocacki_shampine&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ad502a4be71ee90ce567e0e65d083c595">TimeStepping::DOPRI</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;dopri&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a617cb06295ff4fd24ebc9d2c3228da6e">TimeStepping::FEHLBERG</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;fehlberg&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ab1d63829a0bd48bc67f35dae07d35a22">TimeStepping::CASH_KARP</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;cash_karp&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(<a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>(time, time_step));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution_&quot;</span> + method_name + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                                 <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(time_step, 3) +</div><div class="line">                                 <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::vector&lt;std::pair&lt;double, std::string&gt;&gt; times_and_names;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::string method_name_prev = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">    <span class="keyword">static</span> std::string pvd_filename;</div><div class="line">    <span class="keywordflow">if</span> (method_name_prev != method_name)</div><div class="line">      {</div><div class="line">        times_and_names.clear();</div><div class="line">        method_name_prev = method_name;</div><div class="line">        pvd_filename     = <span class="stringliteral">&quot;solution_&quot;</span> + method_name + <span class="stringliteral">&quot;.pvd&quot;</span>;</div><div class="line">      }</div><div class="line">    times_and_names.emplace_back(time, filename);</div><div class="line">    std::ofstream pvd_output(pvd_filename);</div><div class="line">    <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(pvd_output, times_and_names);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">      (final_time - initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line"></div><div class="line">    solution = 0.;</div><div class="line">    constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">    <a class="code" href="classTimeStepping_1_1ExplicitRungeKutta.html">TimeStepping::ExplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt; explicit_runge_kutta(</div><div class="line">      method);</div><div class="line">    output_results(initial_time, 0, method);</div><div class="line">    <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">    <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        explicit_runge_kutta.evolve_one_time_step(</div><div class="line">          [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> Vector&lt;double&gt; &amp;y) {</div><div class="line">            <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">          },</div><div class="line">          time.get_current_time(),</div><div class="line">          time.get_next_step_size(),</div><div class="line">          solution);</div><div class="line">        time.advance_time();</div><div class="line"></div><div class="line">        constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">          output_results(time.get_current_time(),</div><div class="line">                         time.get_step_number(),</div><div class="line">                         method);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::implicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">      (final_time - initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line"></div><div class="line">    solution = 0.;</div><div class="line">    constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">    <a class="code" href="classTimeStepping_1_1ImplicitRungeKutta.html">TimeStepping::ImplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt; implicit_runge_kutta(</div><div class="line">      method);</div><div class="line">    output_results(initial_time, 0, method);</div><div class="line">    <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">    <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        implicit_runge_kutta.evolve_one_time_step(</div><div class="line">          [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> Vector&lt;double&gt; &amp;y) {</div><div class="line">            <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">          },</div><div class="line">          [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <span class="keywordtype">double</span> tau, <span class="keyword">const</span> Vector&lt;double&gt; &amp;y) {</div><div class="line">            <span class="keywordflow">return</span> this-&gt;id_minus_tau_J_inverse(time, tau, y);</div><div class="line">          },</div><div class="line">          time.get_current_time(),</div><div class="line">          time.get_next_step_size(),</div><div class="line">          solution);</div><div class="line">        time.advance_time();</div><div class="line"></div><div class="line">        constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">          output_results(time.get_current_time(),</div><div class="line">                         time.get_step_number(),</div><div class="line">                         method);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Diffusion::embedded_explicit_method(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">      (final_time - initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> coarsen_param = 1.2;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> refine_param  = 0.8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> min_delta     = 1e-8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> max_delta     = 10 * time_step;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> refine_tol    = 1e-1;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> coarsen_tol   = 1e-5;</div><div class="line"></div><div class="line">    solution = 0.;</div><div class="line">    constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">    <a class="code" href="classTimeStepping_1_1EmbeddedExplicitRungeKutta.html">TimeStepping::EmbeddedExplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt;</div><div class="line">      embedded_explicit_runge_kutta(method,</div><div class="line">                                    coarsen_param,</div><div class="line">                                    refine_param,</div><div class="line">                                    min_delta,</div><div class="line">                                    max_delta,</div><div class="line">                                    refine_tol,</div><div class="line">                                    coarsen_tol);</div><div class="line">    output_results(initial_time, 0, method);</div><div class="line">    <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">    <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> new_time =</div><div class="line">          embedded_explicit_runge_kutta.evolve_one_time_step(</div><div class="line">            [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> Vector&lt;double&gt; &amp;y) {</div><div class="line">              <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">            },</div><div class="line">            time.get_current_time(),</div><div class="line">            time.get_next_step_size(),</div><div class="line">            solution);</div><div class="line">        time.set_next_step_size(new_time - time.get_current_time());</div><div class="line">        time.advance_time();</div><div class="line"></div><div class="line">        constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">          output_results(time.get_current_time(),</div><div class="line">                         time.get_step_number(),</div><div class="line">                         method);</div><div class="line"></div><div class="line">        time.set_desired_next_step_size(</div><div class="line">          embedded_explicit_runge_kutta.get_status().delta_t_guess);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> time.get_step_number();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Diffusion::run</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 5.);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> ((face-&gt;center()[0] == 0.) || (face-&gt;center()[0] == 5.))</div><div class="line">              face-&gt;set_boundary_id(1);</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              face-&gt;set_boundary_id(0);</div><div class="line">          }</div><div class="line"></div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    assemble_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       n_steps      = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps = 200;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time = 0.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time   = 10.;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Explicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a037245063b5afdaf23a96ec566373613">TimeStepping::FORWARD_EULER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Forward Euler:            error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4acd53dff7339f8bd6d11e3e26ee207894">TimeStepping::RK_THIRD_ORDER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Third order Runge-Kutta:  error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a32b4e44cc3d0746c448d48f3fcb6f633">TimeStepping::RK_CLASSIC_FOURTH_ORDER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Fourth order Runge-Kutta: error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Implicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ada1f653aefa77b5cde1c0a644c283a77">TimeStepping::BACKWARD_EULER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Backward Euler:           error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a5cc8559104243d25be4380b76ae5aa62">TimeStepping::IMPLICIT_MIDPOINT</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Implicit Midpoint:        error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ac6a6f8452b01a46c75dc317f0676dafc">TimeStepping::CRANK_NICOLSON</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Crank-Nicolson:           error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a2102ce2c5306320faa2eb291b505d495">TimeStepping::SDIRK_TWO_STAGES</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   SDIRK:                    error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Embedded explicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a48a2da10d70ded640369a80770aa8279">TimeStepping::HEUN_EULER</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Heun-Euler:               error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a13ecb8a07303020901221676521de483">TimeStepping::BOGACKI_SHAMPINE</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Bogacki-Shampine:         error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ad502a4be71ee90ce567e0e65d083c595">TimeStepping::DOPRI</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Dopri:                    error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a617cb06295ff4fd24ebc9d2c3228da6e">TimeStepping::FEHLBERG</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Fehlberg:                 error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ab1d63829a0bd48bc67f35dae07d35a22">TimeStepping::CASH_KARP</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Cash-Karp:                error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step52</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step52::Diffusion diffusion;</div><div class="line">      diffusion.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_26.html">step-26</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Problemstatement">Problem statement</a><a href="#Problemstatement">Problem statement</a>
        <li><a href="#RungeKuttamethods">Runge-Kutta methods</a><a href="#RungeKuttamethods">Runge-Kutta methods</a>
      <ul>
        <li><a href="#ExplicitRungeKuttamethods">Explicit Runge-Kutta methods</a><a href="#ExplicitRungeKuttamethods">Explicit Runge-Kutta methods</a>
        <li><a href="#EmbeddedRungeKuttamethods">Embedded Runge-Kutta methods</a><a href="#EmbeddedRungeKuttamethods">Embedded Runge-Kutta methods</a>
        <li><a href="#ImplicitRungeKuttamethods">Implicit Runge-Kutta methods</a><a href="#ImplicitRungeKuttamethods">Implicit Runge-Kutta methods</a>
      </ul>
        <li><a href="#Spatiallydiscreteformulation">Spatially discrete formulation</a><a href="#Spatiallydiscreteformulation">Spatially discrete formulation</a>
        <li><a href="#Notesonthetestcase">Notes on the testcase</a><a href="#Notesonthetestcase">Notes on the testcase</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeDiffusioncodeclass">The <code>Diffusion</code> class</a><a href="#ThecodeDiffusioncodeclass">The <code>Diffusion</code> class</a>
      <ul>
        <li><a href="#codeDiffusionsetup_systemcode"><code>Diffusion::setup_system</code></a><a href="#codeDiffusionsetup_systemcode"><code>Diffusion::setup_system</code></a>
        <li><a href="#codeDiffusionassemble_systemcode"><code>Diffusion::assemble_system</code></a><a href="#codeDiffusionassemble_systemcode"><code>Diffusion::assemble_system</code></a>
        <li><a href="#codeDiffusionget_sourcecode"><code>Diffusion::get_source</code></a><a href="#codeDiffusionget_sourcecode"><code>Diffusion::get_source</code></a>
        <li><a href="#codeDiffusionevaluate_diffusioncode"><code>Diffusion::evaluate_diffusion</code></a><a href="#codeDiffusionevaluate_diffusioncode"><code>Diffusion::evaluate_diffusion</code></a>
        <li><a href="#codeDiffusionid_minus_tau_J_inversecode"><code>Diffusion::id_minus_tau_J_inverse</code></a><a href="#codeDiffusionid_minus_tau_J_inversecode"><code>Diffusion::id_minus_tau_J_inverse</code></a>
        <li><a href="#codeDiffusionoutput_resultscode"><code>Diffusion::output_results</code></a><a href="#codeDiffusionoutput_resultscode"><code>Diffusion::output_results</code></a>
        <li><a href="#codeDiffusionexplicit_methodcode"><code>Diffusion::explicit_method</code></a><a href="#codeDiffusionexplicit_methodcode"><code>Diffusion::explicit_method</code></a>
        <li><a href="#codeDiffusionimplicit_methodcode"><code>Diffusion::implicit_method</code></a><a href="#codeDiffusionimplicit_methodcode"><code>Diffusion::implicit_method</code></a>
        <li><a href="#codeDiffusionembedded_explicit_methodcode"><code>Diffusion::embedded_explicit_method</code></a><a href="#codeDiffusionembedded_explicit_methodcode"><code>Diffusion::embedded_explicit_method</code></a>
        <li><a href="#codeDiffusionruncode"><code>Diffusion::run</code></a><a href="#codeDiffusionruncode"><code>Diffusion::run</code></a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main()</code> function</a><a href="#Thecodemaincodefunction">The <code>main()</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
 <em>This program was contributed by Bruno Turcksin and Damien Lebrun-Grandie.</em> </p><dl class="section note"><dt>Note</dt><dd>In order to run this program, deal.II must be configured to usethe UMFPACK sparse direct solver. Refer to the <a href="../../readme.html#umfpack">ReadMe</a> for instructions how to do this. <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a><h1>Introduction</h1>
</dd></dl>
<p>This program shows how to use Runge-Kutta methods to solve a time-dependentproblem. It solves a small variation of the heat equation discussed first in <a class="el" href="step_26.html">step-26</a> but, since the purpose of this program is only to demonstrate usingmore advanced ways to interface with deal.II's time stepping algorithms, onlysolves a simple problem on a uniformly refined mesh.</p>
<p><a class="anchor" id="Problemstatement"></a></p><h3>Problem statement</h3>
<p>In this example, we solve the one-group time-dependent diffusionapproximation of the neutron transport equation (see <a class="el" href="step_28.html">step-28</a> for thetime-independent multigroup diffusion). This is a model for how neutrons movearound highly scattering media, and consequently it is a variant of thetime-dependent diffusion equation</p>
<ul>
<li>which is just a different name for theheat equation discussed in <a class="el" href="step_26.html">step-26</a> , plus some extra terms.We assume that the medium is notfissible and therefore, the neutron flux satisfies the following equation: <p class="formulaDsp">
\begin{eqnarray*} \frac{1}{v}\frac{\partial \phi(x,t)}{\partial t} = \nabla \cdot D(x) \nabla \phi(x,t) - \Sigma_a(x) \phi(x,t) + S(x,t) \end{eqnarray*}
</p>
 augmented by appropriate boundary conditions. Here, \(v\) is the velocity ofneutrons (for simplicity we assume it is equal to 1 which can be achieved bysimply scaling the time variable), \(D\) is the diffusion coefficient, \(\Sigma_a\) is the absorption cross section, and \(S\) is a source. Because we areonly interested in the time dependence, we assume that \(D\) and \(\Sigma_a\) areconstant. Since this program only intends to demonstrate how to use advanced timestepping algorithms, we will only look for the solutions of relatively simpleproblems. Specifically, we are looking for a solution on a square domain \([0,b]\times[0,b]\) of the form <p class="formulaDsp">
\begin{eqnarray*} \phi(x,t) = A\sin(\omega t)(bx-x^2). \end{eqnarray*}
</p>
 By using quadratic finite elements, we can represent this function exactly atany particular time, and all the error will be due to the timediscretization. We do this because it is then easy to observe the order ofconvergence of the various time stepping schemes we will consider, withouthaving to separate spatial and temporal errors. We impose the following boundary conditions: homogeneous Dirichlet for \(x=0\) and \(x=b\) and homogeneous Neumann conditions for \(y=0\) and \(y=b\) . We choose thesource term so that the corresponding solution isin fact of the form stated above: <p class="formulaDsp">
\begin{eqnarray*} S=A\left(\frac{1}{v}\omega \cos(\omega t)(bx -x^2) + \sin(\omega t) \left(\Sigma_a (bx-x^2)+2D\right) \right). \end{eqnarray*}
</p>
 Because the solution is a sine in time, we know that the exact solutionsatisfies \(\phi\left(x,\frac{\pi}{\omega}\right) = 0\) .Therefore, the error at time \(t=\frac{\pi}{\omega}\) is simply the norm of the numericalsolution, i.e., \(\|e(\cdot,t=\frac{\pi}{\omega})\|_{L_2} = \|\phi_h(\cdot,t=\frac{\pi}{\omega})\|_{L_2}\) ,and is particularly easily evaluated. In the code, we evaluate the \(l_2\) normof the vector of nodal values of \(\phi_h\) instead of the \(L_2\) norm of theassociated spatial function, since the former is simpler to compute; however,on uniform meshes, the two are just related by a constant and we canconsequently observe the temporal convergence order with either.</li>
</ul>
<p><a class="anchor" id="RungeKuttamethods"></a></p><h3>Runge-Kutta methods</h3>
<p>The Runge-Kutta methods implemented in deal.II assume that the equation to besolved can be written as: </p><p class="formulaDsp">
\begin{eqnarray*} \frac{dy}{dt} = g(t,y). \end{eqnarray*}
</p>
<p> On the other hand, when using finite elements, discretized time derivatives always result in thepresence of a mass matrix on the left hand side. This can easily be seen byconsidering that if the solution vector \(y(t)\) in the equation above is in fact the vectorof nodal coefficients \(U(t)\) for a variable of the form </p><p class="formulaDsp">
\begin{eqnarray*} u_h(x,t) = \sum_j U_j(t) \varphi_j(x) \end{eqnarray*}
</p>
<p> with spatial shape functions \(\varphi_j(x)\) , then multiplying an equation ofthe form </p><p class="formulaDsp">
\begin{eqnarray*} \frac{\partial u(x,t)}{\partial t} = q(t,u(x,t)) \end{eqnarray*}
</p>
<p> by test functions, integrating over \(\Omega\) , substituting \(u\rightarrow u_h\) and restricting the test functions to the \(\varphi_i(x)\) from above, then thisspatially discretized equation has the form </p><p class="formulaDsp">
\begin{eqnarray*} M\frac{dU}{dt} = f(t,U), \end{eqnarray*}
</p>
<p> where \(M\) is the mass matrix and \(f(t,U)\) is the spatially discretized versionof \(q(t,u(x,t))\) (where \(q\) is typically the place where spatialderivatives appear, but this is not of much concern for the moment given thatwe only consider time derivatives). In other words, this form fits the generalscheme above if we write </p><p class="formulaDsp">
\begin{eqnarray*} \frac{dy}{dt} = g(t,y) = M^{-1}f(t,y). \end{eqnarray*}
</p>
<p>Runke-Kutta methods are time stepping schemes that approximate \(y(t_n)\approx y_{n}\) through a particular one-step approach. They are typically written in the form </p><p class="formulaDsp">
\begin{eqnarray*} y_{n+1} = y_n + \sum_{i=1}^s b_i k_i \end{eqnarray*}
</p>
<p> where for the form of the right hand side above </p><p class="formulaDsp">
\begin{eqnarray*} k_i = h M^{-1} f\left(t_n+c_ih,y_n+\sum_{j=1}^sa_{ij}k_j\right). \end{eqnarray*}
</p>
<p> Here \(a_{ij}\) , \(b_i\) , and \(c_i\) are known coefficients that identify whichparticular Runge-Kutta scheme you want to use, and \(h=t_{n+1}-t_n\) is the time stepused. Different time stepping methods of the Runge-Kutta class differ in thenumber of stages \(s\) and the values they use for the coefficients \(a_{ij}\) , \(b_i\) , and \(c_i\) but are otherwise easy to implement since one can look uptabulated values for these coefficients. (These tables are often calledButcher tableaus.) At the time of the writing of this tutorial, the methods implemented indeal.II can be divided in three categories: </p><ol>
<li>
Explicit Runge-Kutta; in order for a method to be explicit, it isnecessary that in the formula above defining \(k_i\) , \(k_i\) does not appearon the right hand side. In other words, these methods have to satisfy \(a_{ii}=0, i=1,\ldots,s\) . </li>
<li>
Embedded (or adaptive) Runge-Kutta; we will discuss their properties below. </li>
<li>
Implicit Runge-Kutta; this class of methods require the solution of apossibly nonlinear system the stages \(k_i\) above, i.e., they have \(a_{ii}\neq 0\) for at least one of the stages \(i=1,\ldots,s\) . </li>
</ol>
<p>Many well known time stepping schemes that one does not typically associatewith the names Runge or Kutta can in fact be written in a way so that they,too, can be expressed in these categories. They oftentimes represent thelowest-order members of these families.</p>
<p><a class="anchor" id="ExplicitRungeKuttamethods"></a></p><h4>Explicit Runge-Kutta methods</h4>
<p>These methods, only require a function to evaluate \(M^{-1}f(t,y)\) but not(as implicit methods) to solve an equation that involves \(f(t,y)\) for \(y\) . As all explicit time stepping methods, they become unstablewhen the time step chosen is too large. Well known methods in this class include forward Euler, third orderRunge-Kutta, and fourth order Runge-Kutta (often abbreviated as RK4).</p>
<p><a class="anchor" id="EmbeddedRungeKuttamethods"></a></p><h4>Embedded Runge-Kutta methods</h4>
<p>These methods use both a lower and a higher order method toestimate the error and decide if the time step needs to be shortened or can beincreased. The term "embedded" refers to the fact that the lower-order methoddoes not require additional evaluates of the function \(M^{-1}f(\cdot,\cdot)\) but reuses data that has to be computed for the high order method anyway. Itis, in other words, essentially free, and we get the error estimate as a sideproduct of using the higher order method. This class of methods include Heun-Euler, Bogacki-Shampine, Dormand-Prince (ode45 inMatlab and often abbreviated as RK45 to indicate that the lower and higher order methodsused here are 4th and 5th order Runge-Kutta methods, respectively), Fehlberg,and Cash-Karp. At the time of the writing, only embedded explicit methods have been implemented.</p>
<p><a class="anchor" id="ImplicitRungeKuttamethods"></a></p><h4>Implicit Runge-Kutta methods</h4>
<p>Implicit methods require the solution of (possibly nonlinear) systems of theform \(\alpha y = f(t,y)\) for \(y\) in each (sub-)timestep. Internally, this isdone using a Newton-type method and, consequently, they require that the userprovide functions that can evaluate \(M^{-1}f(t,y)\) and \(\left(I-\tau M^{-1} \frac{\partial f}{\partial y}\right)^{-1}\) or equivalently \(\left(M - \tau \frac{\partial f}{\partial y}\right)^{-1} M\) . The particular form of this operator results from the fact that each Newtonstep requires the solution of an equation of the form </p><p class="formulaDsp">
\begin{align*} \left(M - \tau \frac{\partial f}{\partial y}\right) \Delta y = -M h(t,y) \end{align*}
</p>
<p> for some (given) \(h(t,y)\) . Implicit methods arealways stable, regardless of the time step size, but too large time steps ofcourse affect the <em>accuracy</em> of the solution, even if the numericalsolution remains stable and bounded. Methods in this class include backward Euler, implicit midpoint,Crank-Nicolson, and the two stage SDIRK method (short for "singly diagonallyimplicit Runge-Kutta", a term coined to indicate that the diagonal elements \(a_{ii}\) defining the time stepping method are all equal; this propertyallows for the Newton matrix \(I-\tau M^{-1}\frac{\partial f}{\partial y}\) tobe re-used between stages because \(\tau\) is the same every time).</p>
<p><a class="anchor" id="Spatiallydiscreteformulation"></a></p><h3>Spatially discrete formulation</h3>
<p>By expanding the solution of our model problemas always using shape functions \(\psi_j\) and writing </p><p class="formulaDsp">
\begin{eqnarray*} \phi_h(x,t) = \sum_j U_j(t) \psi_j(x), \end{eqnarray*}
</p>
<p> we immediately get the spatially discretized version of the diffusion equation as </p><p class="formulaDsp">
\begin{eqnarray*} M \frac{dU(t)}{dt} = -{\cal D} U(t) - {\cal A} U(t) + {\cal S}(t) \end{eqnarray*}
</p>
<p> where </p><p class="formulaDsp">
\begin{eqnarray*} M_{ij} &amp;=&amp; (\psi_i,\psi_j), \\ {\cal D}_{ij} &amp;=&amp; (D\nabla\psi_i,\nabla\psi_j)_\Omega, \\ {\cal A}_{ij} &amp;=&amp; (\Sigma_a\psi_i,\psi_j)_\Omega, \\ {\cal S}_{i}(t) &amp;=&amp; (\psi_i,S(x,t))_\Omega. \end{eqnarray*}
</p>
<p> See also <a class="el" href="step_24.html">step-24</a> and <a class="el" href="step_26.html">step-26</a> to understand how we arrive here.Boundary terms are not necessary due to the chosen boundary conditions forthe current problem. To use the Runge-Kutta methods, we recast thisas follows: </p><p class="formulaDsp">
\begin{eqnarray*} f(y) = -{\cal D}y - {\cal A}y + {\cal S}. \end{eqnarray*}
</p>
<p> In the code, we will need to be able to evaluate this function \(f(U)\) alongwith its derivative, </p><p class="formulaDsp">
\begin{eqnarray*} \frac{\partial f}{\partial y} = -{\cal D} - {\cal A}. \end{eqnarray*}
</p>
<p><a class="anchor" id="Notesonthetestcase"></a></p><h3>Notes on the testcase</h3>
<p>To simplify the problem, the domain is two dimensional and the mesh isuniformly refined (there is no need to adapt the mesh since we use quadraticfinite elements and the exact solution is quadratic). Going from a twodimensional domain to a three dimensional domain is not verychallenging. However if you intend to solve more complex problems where themesh must be adapted (as is done, for example, in <a class="el" href="step_26.html">step-26</a> ), then it isimportant to remember the following issues: </p><ol>
<li>
You will need to project the solution to the new mesh when the mesh is changed. Of course, the mesh used should be the same from the beginning to the end of each time step, a question that arises because Runge-Kutta methods use multiple evaluations of the equations within each time step. </li>
<li>
You will need to update the mass matrix and its inverse every time the mesh is changed. </li>
</ol>
<p>The techniques for these steps are readily available by looking at <a class="el" href="step_26.html">step-26</a> .</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first task as usual is to include the functionality of these well-known deal.II library files and some C++ header files.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div></div><!-- fragment --><p>This is the only include file that is new: It includes all the Runge-Kutta methods.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="time__stepping_8h.html">deal.II/base/time_stepping.h</a>&gt;</span></div></div><!-- fragment --><p>The next step is like in all previous tutorial programs: We put everything into a namespace of its own and then import the deal.II classes and functions into it.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step52</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeDiffusioncodeclass"></a> </p><h3>The <code>Diffusion</code> class</h3>
<p>The next piece is the declaration of the main class. Most of the functions in this class are not new and have been explained in previous tutorials. The only interesting functions are <code>evaluate_diffusion()</code> and <code>id_minus_tau_J_inverse()</code>. <code>evaluate_diffusion()</code> evaluates the diffusion equation, \(M^{-1}(f(t,y))\) , at a given time and a given \(y\) . <code>id_minus_tau_J_inverse()</code> evaluates \(\left(I-\tau M^{-1} \frac{\partial f(t,y)}{\partial y}\right)^{-1}\) or equivalently \(\left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} M\) at a given time, for a given \(\tau\) and \(y\) . This function is needed when an implicit method is used.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Diffusion</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Diffusion();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_source(<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;point) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> evaluate_diffusion(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> id_minus_tau_J_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                        <span class="keyword">const</span> <span class="keywordtype">double</span>          tau,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">double</span>                     time,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               time_step,</div><div class="line">                      <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method) <span class="keyword">const</span>;</div></div><!-- fragment --><p>The next three functions are the drivers for the explicit methods, the implicit methods, and the embedded explicit methods respectively. The driver function for embedded explicit methods returns the number of steps executed given that it only takes the number of time steps passed as an argument as a hint, but internally computed the optimal time step itself.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> implicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time);</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">  embedded_explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> diffusion_coefficient;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> absorption_cross_section;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> fe;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraint_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line"></div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> mass_minus_tau_Jacobian;</div><div class="line"></div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> inverse_mass_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">};</div></div><!-- fragment --><p>We choose quadratic finite elements and we initialize the parameters.</p>
<div class="fragment"><div class="line">Diffusion::Diffusion()</div><div class="line">  : fe_degree(2)</div><div class="line">  , diffusion_coefficient(1. / 30.)</div><div class="line">  , absorption_cross_section(1.)</div><div class="line">  , fe(fe_degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionsetup_systemcode"></a> </p><h4><code>Diffusion::setup_system</code></h4>
<p>Now, we create the constraint matrix and the sparsity pattern. Then, we initialize the matrices and the solution vector.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           1,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;2&gt;</a>(),</div><div class="line">                                           constraint_matrix);</div><div class="line">  constraint_matrix.close();</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraint_matrix);</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a>(sparsity_pattern);</div><div class="line">  mass_minus_tau_Jacobian.reinit(sparsity_pattern);</div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionassemble_systemcode"></a> </p><h4><code>Diffusion::assemble_system</code></h4>
<p>In this function, we compute \(-\int D \nabla b_i \cdot \nabla b_j d\boldsymbol{r} - \int \Sigma_a b_i b_j d\boldsymbol{r}\) and the mass matrix \(\int b_i b_j d\boldsymbol{r}\) . The mass matrix is then inverted using a direct solver; the <code>inverse_mass_matrix</code> variable will then store the inverse of the mass matrix so that \(M^{-1}\) can be applied to a vector using the <code>vmult()</code> function of that object. (Internally, UMFPACK does not really store the inverse of the matrix, but its LU factors; applying the inverse matrix is then equivalent to doing one forward and one backward solves with these two factors, which has the same complexity as applying an explicit inverse of the matrix).</p>
<div class="fragment"><div class="line">   <span class="keywordtype">void</span> Diffusion::assemble_system()</div><div class="line">   {</div><div class="line">     system_matrix = 0.;</div><div class="line">     mass_matrix   = 0.;</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe_degree + 1);</div><div class="line">  </div><div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                           quadrature_formula,</div><div class="line">                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line"> </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  </div><div class="line">     <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">     <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  </div><div class="line">     std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  </div><div class="line">     <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">       {</div><div class="line">         cell_matrix      = 0.;</div><div class="line">         cell_mass_matrix = 0.;</div><div class="line">  </div><div class="line">         fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">  </div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">               {</div><div class="line">                 <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                   ((-diffusion_coefficient                <span class="comment">// (-D</span></div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point)    <span class="comment">//  grad phi_i</span></div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)      <span class="comment">//  grad phi_j</span></div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">- absorption_cross_section            <span class="comment">//</span></div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-Sigma</div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) <span class="comment">//  phi_i</span></div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point))  <span class="comment">//  phi_j)</span></div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));               <span class="comment">// dx</span></div><div class="line">                 cell_mass_matrix(i, j) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point)</div><div class="line">                                           fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)</div><div class="line">                                           fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">               }</div><div class="line">  </div><div class="line">         cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">  </div><div class="line">         constraint_matrix.distribute_local_to_global(cell_matrix,</div><div class="line">                                                      local_dof_indices,</div><div class="line">                                                      system_matrix);</div><div class="line">         constraint_matrix.distribute_local_to_global(cell_mass_matrix,</div><div class="line">                                                      local_dof_indices,</div><div class="line">                                                      mass_matrix);</div><div class="line">       }</div><div class="line">  </div><div class="line">     inverse_mass_matrix.<a class="code" href="classDoFHandler.html#aeca4a4af5c4d7f7c68a4def9ae87bc7b">initialize</a>(mass_matrix);</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionget_sourcecode"></a> </p><h4><code>Diffusion::get_source</code></h4>
<p>In this function, the source term of the equation for a given time and a given point is computed.</p>
<div class="fragment"><div class="line">   <span class="keywordtype">double</span> Diffusion::get_source(<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;point)<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> intensity = 10.;</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> frequency = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> / 10.;</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> b         = 5.;</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> x         = <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>(0);</div><div class="line">  </div><div class="line">     <span class="keywordflow">return</span> intensity</div><div class="line">            (frequency std::cos(frequency time) (b x</div><div class="line">  </div><div class="line">- x x) +</div><div class="line">             std::sin(frequency time)</div><div class="line">               (absorption_cross_section (b x</div><div class="line">  </div><div class="line">- x x) +</div><div class="line">                2. diffusion_coefficient));</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionevaluate_diffusioncode"></a> </p><h4><code>Diffusion::evaluate_diffusion</code></h4>
<p>Next, we evaluate the weak form of the diffusion equation at a given time \(t\) and for a given vector \(y\) . In other words, as outlined in the introduction, we evaluate \(M^{-1}(-{\cal D}y - {\cal A}y + {\cal S})\) . For this, we have to apply the matrix \(-{\cal D} - {\cal A}\) (previously computed and stored in the variable <code>system_matrix</code> ) to \(y\) and then add the source term which we integrate as we usually do. (Integrating up the solution could be done using <a class="el" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side()</a> if you wanted to save a few lines of code, or wanted to take advantage of doing the integration in parallel.) The result is then multiplied by \(M^{-1}\) .</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> Diffusion::evaluate_diffusion(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                             <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  tmp = 0.;</div><div class="line">  system_matrix.vmult(tmp, y);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                        quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_source(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_source = 0.;</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> source =</div><div class="line">            get_source(time, fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point));</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            cell_source(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) <span class="comment">// phi_i(x)</span></div><div class="line">                              source                            <span class="comment">// S(x)</span></div><div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);             <span class="comment">// dx</span></div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      constraint_matrix.distribute_local_to_global(cell_source,</div><div class="line">                                                   local_dof_indices,</div><div class="line">                                                   tmp);</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> value(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  inverse_mass_matrix.vmult(value, tmp);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> value;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionid_minus_tau_J_inversecode"></a> </p><h4><code>Diffusion::id_minus_tau_J_inverse</code></h4>
<p>We compute \(\left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} M\) . This is done in several steps:</p>
<ul>
<li>compute \(M-\tau \frac{\partial f}{\partial y}\)</li>
<li>invert the matrix to get \(\left(M-\tau \frac{\partial f} {\partial y}\right)^{-1}\)</li>
<li>compute \(tmp=My\)</li>
<li>compute \(z=\left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} tmp = \left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} My\)</li>
<li>return z.</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> Diffusion::id_minus_tau_J_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span>  <span class="comment">/*time*/</span> ,</div><div class="line">                                                 <span class="keyword">const</span> <span class="keywordtype">double</span>          tau,</div><div class="line">                                                 <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y)</div><div class="line">{</div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> inverse_mass_minus_tau_Jacobian;</div><div class="line"></div><div class="line">  mass_minus_tau_Jacobian.copy_from(mass_matrix);</div><div class="line">  mass_minus_tau_Jacobian.add(-tau, system_matrix);</div><div class="line"></div><div class="line">  inverse_mass_minus_tau_Jacobian.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(mass_minus_tau_Jacobian);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a4aedd84e99cda48dce634a2bbf8763fd">vmult</a>(tmp, y);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> result(y);</div><div class="line">  inverse_mass_minus_tau_Jacobian.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(result, tmp);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionoutput_resultscode"></a> </p><h4><code>Diffusion::output_results</code></h4>
<p>The following function then outputs the solution in vtu files indexed by the number of the time step and the name of the time stepping method. Of course, the (exact) result should really be the same for all time stepping method, but the output here at least allows us to compare them.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::output_results(<span class="keyword">const</span> <span class="keywordtype">double</span>                     time,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               time_step,</div><div class="line">                               <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::string method_name;</div><div class="line"></div><div class="line">  <span class="keywordflow">switch</span> (method)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a037245063b5afdaf23a96ec566373613">TimeStepping::FORWARD_EULER</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;forward_euler&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4acd53dff7339f8bd6d11e3e26ee207894">TimeStepping::RK_THIRD_ORDER</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;rk3&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a32b4e44cc3d0746c448d48f3fcb6f633">TimeStepping::RK_CLASSIC_FOURTH_ORDER</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;rk4&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ada1f653aefa77b5cde1c0a644c283a77">TimeStepping::BACKWARD_EULER</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;backward_euler&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a5cc8559104243d25be4380b76ae5aa62">TimeStepping::IMPLICIT_MIDPOINT</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;implicit_midpoint&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a2102ce2c5306320faa2eb291b505d495">TimeStepping::SDIRK_TWO_STAGES</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;sdirk&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a48a2da10d70ded640369a80770aa8279">TimeStepping::HEUN_EULER</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;heun_euler&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a13ecb8a07303020901221676521de483">TimeStepping::BOGACKI_SHAMPINE</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;bocacki_shampine&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ad502a4be71ee90ce567e0e65d083c595">TimeStepping::DOPRI</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;dopri&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a617cb06295ff4fd24ebc9d2c3228da6e">TimeStepping::FEHLBERG</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;fehlberg&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ab1d63829a0bd48bc67f35dae07d35a22">TimeStepping::CASH_KARP</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;cash_karp&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        {</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(<a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>(time, time_step));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution_&quot;</span> + method_name + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(time_step, 3) +</div><div class="line">                               <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line"></div><div class="line">  <span class="keyword">static</span> std::vector&lt;std::pair&lt;double, std::string&gt;&gt; times_and_names;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> std::string method_name_prev = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">  <span class="keyword">static</span> std::string pvd_filename;</div><div class="line">  <span class="keywordflow">if</span> (method_name_prev != method_name)</div><div class="line">    {</div><div class="line">      times_and_names.clear();</div><div class="line">      method_name_prev = method_name;</div><div class="line">      pvd_filename     = <span class="stringliteral">&quot;solution_&quot;</span> + method_name + <span class="stringliteral">&quot;.pvd&quot;</span>;</div><div class="line">    }</div><div class="line">  times_and_names.emplace_back(time, filename);</div><div class="line">  std::ofstream pvd_output(pvd_filename);</div><div class="line">  <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(pvd_output, times_and_names);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionexplicit_methodcode"></a> </p><h4><code>Diffusion::explicit_method</code></h4>
<p>This function is the driver for all the explicit methods. At the top it initializes the time stepping and the solution (by setting it to zero and then ensuring that boundary value and hanging node constraints are respected; of course, with the mesh we use here, hanging node constraints are not in fact an issue). It then calls <code>evolve_one_time_step</code> which performs one time step. Time is stored and incremented through a <a class="el" href="classDiscreteTime.html">DiscreteTime</a> object. For explicit methods, <code>evolve_one_time_step</code> needs to evaluate \(M^{-1}(f(t,y))\) , i.e, it needs <code>evaluate_diffusion</code> . Because <code>evaluate_diffusion</code> is a member function, it needs to be bound to <code>this</code> . After each evolution step, we again apply the correct boundary values and hanging node constraints. Finally, the solution is output every 10 time steps.</p>
<div class="fragment"><div class="line">   <span class="keywordtype">void</span> Diffusion::explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time)</div><div class="line">   {</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">       (final_time</div><div class="line">  </div><div class="line">- initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line">  </div><div class="line">     solution = 0.;</div><div class="line">     constraint_matrix.distribute(solution);</div><div class="line">  </div><div class="line">     <a class="code" href="classTimeStepping_1_1ExplicitRungeKutta.html">TimeStepping::ExplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt; explicit_runge_kutta(</div><div class="line">       method);</div><div class="line">     output_results(initial_time, 0, method);</div><div class="line">     <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">     <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">       {</div><div class="line">         explicit_runge_kutta.evolve_one_time_step(</div><div class="line">           [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y) {</div><div class="line">             <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">           },</div><div class="line">           time.get_current_time(),</div><div class="line">           time.get_next_step_size(),</div><div class="line">           solution);</div><div class="line">         time.advance_time();</div><div class="line">  </div><div class="line">         constraint_matrix.distribute(solution);</div><div class="line">  </div><div class="line">         <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">           output_results(time.get_current_time(),</div><div class="line">                          time.get_step_number(),</div><div class="line">                          method);</div><div class="line">       }</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionimplicit_methodcode"></a> </p><h4><code>Diffusion::implicit_method</code></h4>
<p>This function is equivalent to <code>explicit_method</code> but for implicit methods. When using implicit methods, we need to evaluate \(M^{-1}(f(t,y))\) and \(\left(I-\tau M^{-1} \frac{\partial f(t,y)}{\partial y}\right)^{-1}\) for which we use the two member functions previously introduced.</p>
<div class="fragment"><div class="line">   <span class="keywordtype">void</span> Diffusion::implicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time)</div><div class="line">   {</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">       (final_time</div><div class="line">  </div><div class="line">- initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line">  </div><div class="line">     solution = 0.;</div><div class="line">     constraint_matrix.distribute(solution);</div><div class="line">  </div><div class="line">     <a class="code" href="classTimeStepping_1_1ImplicitRungeKutta.html">TimeStepping::ImplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt; implicit_runge_kutta(</div><div class="line">       method);</div><div class="line">     output_results(initial_time, 0, method);</div><div class="line">     <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">     <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">       {</div><div class="line">         implicit_runge_kutta.evolve_one_time_step(</div><div class="line">           [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y) {</div><div class="line">             <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">           },</div><div class="line">           [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <span class="keywordtype">double</span> tau, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y) {</div><div class="line">             <span class="keywordflow">return</span> this-&gt;id_minus_tau_J_inverse(time, tau, y);</div><div class="line">           },</div><div class="line">           time.get_current_time(),</div><div class="line">           time.get_next_step_size(),</div><div class="line">           solution);</div><div class="line">         time.advance_time();</div><div class="line">  </div><div class="line">         constraint_matrix.distribute(solution);</div><div class="line">  </div><div class="line">         <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">           output_results(time.get_current_time(),</div><div class="line">                          time.get_step_number(),</div><div class="line">                          method);</div><div class="line">       }</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionembedded_explicit_methodcode"></a> </p><h4><code>Diffusion::embedded_explicit_method</code></h4>
<p>This function is the driver for the embedded explicit methods. It requires more parameters:</p>
<ul>
<li>coarsen_param: factor multiplying the current time step when the error is below the threshold.</li>
<li>refine_param: factor multiplying the current time step when the error is above the threshold.</li>
<li>min_delta: smallest time step acceptable.</li>
<li>max_delta: largest time step acceptable.</li>
<li>refine_tol: threshold above which the time step is refined.</li>
<li>coarsen_tol: threshold below which the time step is coarsen. Embedded methods use a guessed time step. If the error using this time step is too large, the time step will be reduced. If the error is below the threshold, a larger time step will be tried for the next time step. <code>delta_t_guess</code> is the guessed time step produced by the embedded method. In summary, time step size is potentially modified in three ways:</li>
<li>Reducing or increasing time step size within <a class="el" href="classTimeStepping_1_1EmbeddedExplicitRungeKutta.html#accb05cdd9b6519c4d4ffe9ea996cee87">TimeStepping::EmbeddedExplicitRungeKutta::evolve_one_time_step()</a>.</li>
<li>Using the calculated <code>delta_t_guess</code> .</li>
<li>Automatically adjusting the step size of the last time step to ensure simulation ends precisely at <code>final_time</code> . This adjustment is handled inside the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> instance.</li>
</ul>
<div class="fragment"><div class="line">   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Diffusion::embedded_explicit_method(</div><div class="line">     <span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time)</div><div class="line">   {</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">       (final_time</div><div class="line">  </div><div class="line">- initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> coarsen_param = 1.2;</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> refine_param  = 0.8;</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> min_delta     = 1e-8;</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> max_delta     = 10 time_step;</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> refine_tol    = 1e-1;</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> coarsen_tol   = 1e-5;</div><div class="line">  </div><div class="line">     solution = 0.;</div><div class="line">     constraint_matrix.distribute(solution);</div><div class="line">  </div><div class="line">     <a class="code" href="classTimeStepping_1_1EmbeddedExplicitRungeKutta.html">TimeStepping::EmbeddedExplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt;</div><div class="line">       embedded_explicit_runge_kutta(method,</div><div class="line">                                     coarsen_param,</div><div class="line">                                     refine_param,</div><div class="line">                                     min_delta,</div><div class="line">                                     max_delta,</div><div class="line">                                     refine_tol,</div><div class="line">                                     coarsen_tol);</div><div class="line">     output_results(initial_time, 0, method);</div><div class="line">     <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">     <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">       {</div><div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span> new_time =</div><div class="line">           embedded_explicit_runge_kutta.evolve_one_time_step(</div><div class="line">             [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y) {</div><div class="line">               <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">             },</div><div class="line">             time.get_current_time(),</div><div class="line">             time.get_next_step_size(),</div><div class="line">             solution);</div><div class="line">         time.set_next_step_size(new_time</div><div class="line">  </div><div class="line">- time.get_current_time());</div><div class="line">         time.advance_time();</div><div class="line">  </div><div class="line">         constraint_matrix.distribute(solution);</div><div class="line">  </div><div class="line">         <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">           output_results(time.get_current_time(),</div><div class="line">                          time.get_step_number(),</div><div class="line">                          method);</div><div class="line">  </div><div class="line">         time.set_desired_next_step_size(</div><div class="line">           embedded_explicit_runge_kutta.get_status().delta_t_guess);</div><div class="line">       }</div><div class="line">  </div><div class="line">     <span class="keywordflow">return</span> time.get_step_number();</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionruncode"></a> </p><h4><code>Diffusion::run</code></h4>
<p>The following is the main function of the program. At the top, we create the grid (a [0,5]x[0,5] square) and refine it four times to get a mesh that has 16 by 16 cells, for a total of 256. We then set the boundary indicator to 1 for those parts of the boundary where \(x=0\) and \(x=5\) .</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Diffusion::run</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 5.);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">      <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> ((face-&gt;center()[0] == 0.) || (face-&gt;center()[0] == 5.))</div><div class="line">            face-&gt;set_boundary_id(1);</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            face-&gt;set_boundary_id(0);</div><div class="line">        }</div></div><!-- fragment --><p>Next, we set up the linear systems and fill them with content so that they can be used throughout the time stepping process:</p>
<div class="fragment"><div class="line">setup_system();</div><div class="line"></div><div class="line">assemble_system();</div></div><!-- fragment --><p>Finally, we solve the diffusion problem using several of the Runge-Kutta methods implemented in namespace <a class="el" href="namespaceTimeStepping.html">TimeStepping</a>, each time outputting the error at the end time. (As explained in the introduction, since the exact solution is zero at the final time, the error equals the numerical solution and can be computed by just taking the \(l_2\) norm of the solution vector.)</p>
<div class="fragment"><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       n_steps      = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps = 200;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time = 0.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time   = 10.;</div><div class="line"> </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Explicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a037245063b5afdaf23a96ec566373613">TimeStepping::FORWARD_EULER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Forward Euler:            error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4acd53dff7339f8bd6d11e3e26ee207894">TimeStepping::RK_THIRD_ORDER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Third order Runge-Kutta:  error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a32b4e44cc3d0746c448d48f3fcb6f633">TimeStepping::RK_CLASSIC_FOURTH_ORDER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Fourth order Runge-Kutta: error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"> </div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Implicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ada1f653aefa77b5cde1c0a644c283a77">TimeStepping::BACKWARD_EULER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Backward Euler:           error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a5cc8559104243d25be4380b76ae5aa62">TimeStepping::IMPLICIT_MIDPOINT</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Implicit Midpoint:        error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ac6a6f8452b01a46c75dc317f0676dafc">TimeStepping::CRANK_NICOLSON</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Crank-Nicolson:           error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a2102ce2c5306320faa2eb291b505d495">TimeStepping::SDIRK_TWO_STAGES</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   SDIRK:                    error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"> </div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Embedded explicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a48a2da10d70ded640369a80770aa8279">TimeStepping::HEUN_EULER</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Heun-Euler:               error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a13ecb8a07303020901221676521de483">TimeStepping::BOGACKI_SHAMPINE</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Bogacki-Shampine:         error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ad502a4be71ee90ce567e0e65d083c595">TimeStepping::DOPRI</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Dopri:                    error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a617cb06295ff4fd24ebc9d2c3228da6e">TimeStepping::FEHLBERG</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Fehlberg:                 error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ab1d63829a0bd48bc67f35dae07d35a22">TimeStepping::CASH_KARP</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Cash-Karp:                error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step52</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main()</code> function</h3>
<p>The following <code>main</code> function is similar to previous examples and need not be commented on.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step52::Diffusion diffusion;</div><div class="line">      diffusion.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"> </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The point of this program is less to show particular results, but instead toshow how it is done. This we have already demonstrated simply by discussingthe code above. Consequently, the output the program yields is relativelysparse and consists only of the console output and the solutions given in VTUformat for visualization. The console output contains both errors and, for some of the methods, thenumber of steps they performed: </p><div class="fragment"><div class="line">Explicit methods:</div><div class="line">   Forward Euler:            error=1.00883</div><div class="line">   Third order Runge-Kutta:  error=0.000227982</div><div class="line">   Fourth order Runge-Kutta: error=1.90541e-06</div><div class="line">  </div><div class="line">Implicit methods:</div><div class="line">   Backward Euler:           error=1.03428</div><div class="line">   Implicit Midpoint:        error=0.00862702</div><div class="line">   Crank-Nicolson:           error=0.00862675</div><div class="line">   SDIRK:                    error=0.0042349</div><div class="line">  </div><div class="line">Embedded <span class="keyword">explicit</span> methods:</div><div class="line">   Heun-Euler:               error=0.0073012</div><div class="line">                   steps performed=284</div><div class="line">   Bogacki-Shampine:         error=0.000408407</div><div class="line">                   steps performed=181</div><div class="line">   Dopri:                    error=0.000836695</div><div class="line">                   steps performed=120</div><div class="line">   Fehlberg:                 error=0.00248922</div><div class="line">                   steps performed=106</div><div class="line">   Cash-Karp:                error=0.0787735</div><div class="line">                   steps performed=106</div></div><!-- fragment --><p>As expected the higher order methods give (much) more accurate solutions. Wealso see that the (rather inaccurate) Heun-Euler method increased the number oftime steps in order to satisfy the tolerance. On the other hand, the otherembedded methods used a lot less time steps than what was prescribed.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2014 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Damien Lebrun-Grandie, Bruno Turcksin, 2014</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="time__stepping_8h.html">deal.II/base/time_stepping.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step52</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>Diffusion</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Diffusion();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> get_source(<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;point) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; evaluate_diffusion(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                      <span class="keyword">const</span> Vector&lt;double&gt; &amp;y) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; id_minus_tau_J_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">double</span>          tau,</div><div class="line">                                          <span class="keyword">const</span> Vector&lt;double&gt; &amp;y);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">double</span>                     time,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               time_step,</div><div class="line">                        <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> implicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">    embedded_explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> diffusion_coefficient;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> absorption_cross_section;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> fe;</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraint_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line"></div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> mass_minus_tau_Jacobian;</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> inverse_mass_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  Diffusion::Diffusion()</div><div class="line">    : fe_degree(2)</div><div class="line">    , diffusion_coefficient(1. / 30.)</div><div class="line">    , absorption_cross_section(1.)</div><div class="line">    , fe(fe_degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             1,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;2&gt;</a>(),</div><div class="line">                                             constraint_matrix);</div><div class="line">    constraint_matrix.close();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraint_matrix);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a>(sparsity_pattern);</div><div class="line">    mass_minus_tau_Jacobian.reinit(sparsity_pattern);</div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::assemble_system()</div><div class="line">  {</div><div class="line">    system_matrix = 0.;</div><div class="line">    mass_matrix   = 0.;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix      = 0.;</div><div class="line">        cell_mass_matrix = 0.;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                  ((-diffusion_coefficient *                <span class="comment">// (-D</span></div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *    <span class="comment">//  * grad phi_i</span></div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)      <span class="comment">//  * grad phi_j</span></div><div class="line">                    - absorption_cross_section *            <span class="comment">//  -Sigma</span></div><div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * <span class="comment">//  * phi_i</span></div><div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point))  <span class="comment">//  * phi_j)</span></div><div class="line">                   * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));               <span class="comment">// * dx</span></div><div class="line">                cell_mass_matrix(i, j) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                                          fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point) *</div><div class="line">                                          fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">              }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        constraint_matrix.distribute_local_to_global(cell_matrix,</div><div class="line">                                                     local_dof_indices,</div><div class="line">                                                     system_matrix);</div><div class="line">        constraint_matrix.distribute_local_to_global(cell_mass_matrix,</div><div class="line">                                                     local_dof_indices,</div><div class="line">                                                     mass_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    inverse_mass_matrix.<a class="code" href="classDoFHandler.html#aeca4a4af5c4d7f7c68a4def9ae87bc7b">initialize</a>(mass_matrix);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> Diffusion::get_source(<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;point)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> intensity = 10.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> frequency = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> / 10.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> b         = 5.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> x         = <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> intensity *</div><div class="line">           (frequency * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(frequency * time) * (b * x - x * x) +</div><div class="line">            std::sin(frequency * time) *</div><div class="line">              (absorption_cross_section * (b * x - x * x) +</div><div class="line">               2. * diffusion_coefficient));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  Vector&lt;double&gt; Diffusion::evaluate_diffusion(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                               <span class="keyword">const</span> Vector&lt;double&gt; &amp;y)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    tmp = 0.;</div><div class="line">    system_matrix.vmult(tmp, y);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt; cell_source(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_source = 0.;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> source =</div><div class="line">              get_source(time, fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point));</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              cell_source(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * <span class="comment">// phi_i(x)</span></div><div class="line">                                source *                            <span class="comment">// * S(x)</span></div><div class="line">                                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);             <span class="comment">// * dx</span></div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        constraint_matrix.distribute_local_to_global(cell_source,</div><div class="line">                                                     local_dof_indices,</div><div class="line">                                                     tmp);</div><div class="line">      }</div><div class="line"></div><div class="line">    Vector&lt;double&gt; value(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    inverse_mass_matrix.vmult(value, tmp);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> value;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  Vector&lt;double&gt; Diffusion::id_minus_tau_J_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span> <span class="comment">/*time*/</span>,</div><div class="line">                                                   <span class="keyword">const</span> <span class="keywordtype">double</span>          tau,</div><div class="line">                                                   <span class="keyword">const</span> Vector&lt;double&gt; &amp;y)</div><div class="line">  {</div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> inverse_mass_minus_tau_Jacobian;</div><div class="line"></div><div class="line">    mass_minus_tau_Jacobian.copy_from(mass_matrix);</div><div class="line">    mass_minus_tau_Jacobian.add(-tau, system_matrix);</div><div class="line"></div><div class="line">    inverse_mass_minus_tau_Jacobian.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(mass_minus_tau_Jacobian);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a4aedd84e99cda48dce634a2bbf8763fd">vmult</a>(tmp, y);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; result(y);</div><div class="line">    inverse_mass_minus_tau_Jacobian.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(result, tmp);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> result;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::output_results(<span class="keyword">const</span> <span class="keywordtype">double</span>                     time,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               time_step,</div><div class="line">                                 <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::string method_name;</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (method)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a037245063b5afdaf23a96ec566373613">TimeStepping::FORWARD_EULER</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;forward_euler&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4acd53dff7339f8bd6d11e3e26ee207894">TimeStepping::RK_THIRD_ORDER</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;rk3&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a32b4e44cc3d0746c448d48f3fcb6f633">TimeStepping::RK_CLASSIC_FOURTH_ORDER</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;rk4&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ada1f653aefa77b5cde1c0a644c283a77">TimeStepping::BACKWARD_EULER</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;backward_euler&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a5cc8559104243d25be4380b76ae5aa62">TimeStepping::IMPLICIT_MIDPOINT</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;implicit_midpoint&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a2102ce2c5306320faa2eb291b505d495">TimeStepping::SDIRK_TWO_STAGES</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;sdirk&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a48a2da10d70ded640369a80770aa8279">TimeStepping::HEUN_EULER</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;heun_euler&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a13ecb8a07303020901221676521de483">TimeStepping::BOGACKI_SHAMPINE</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;bocacki_shampine&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ad502a4be71ee90ce567e0e65d083c595">TimeStepping::DOPRI</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;dopri&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a617cb06295ff4fd24ebc9d2c3228da6e">TimeStepping::FEHLBERG</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;fehlberg&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ab1d63829a0bd48bc67f35dae07d35a22">TimeStepping::CASH_KARP</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;cash_karp&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(<a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>(time, time_step));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution_&quot;</span> + method_name + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                                 <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(time_step, 3) +</div><div class="line">                                 <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::vector&lt;std::pair&lt;double, std::string&gt;&gt; times_and_names;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::string method_name_prev = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">    <span class="keyword">static</span> std::string pvd_filename;</div><div class="line">    <span class="keywordflow">if</span> (method_name_prev != method_name)</div><div class="line">      {</div><div class="line">        times_and_names.clear();</div><div class="line">        method_name_prev = method_name;</div><div class="line">        pvd_filename     = <span class="stringliteral">&quot;solution_&quot;</span> + method_name + <span class="stringliteral">&quot;.pvd&quot;</span>;</div><div class="line">      }</div><div class="line">    times_and_names.emplace_back(time, filename);</div><div class="line">    std::ofstream pvd_output(pvd_filename);</div><div class="line">    <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(pvd_output, times_and_names);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">      (final_time - initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line"></div><div class="line">    solution = 0.;</div><div class="line">    constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">    <a class="code" href="classTimeStepping_1_1ExplicitRungeKutta.html">TimeStepping::ExplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt; explicit_runge_kutta(</div><div class="line">      method);</div><div class="line">    output_results(initial_time, 0, method);</div><div class="line">    <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">    <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        explicit_runge_kutta.evolve_one_time_step(</div><div class="line">          [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> Vector&lt;double&gt; &amp;y) {</div><div class="line">            <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">          },</div><div class="line">          time.get_current_time(),</div><div class="line">          time.get_next_step_size(),</div><div class="line">          solution);</div><div class="line">        time.advance_time();</div><div class="line"></div><div class="line">        constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">          output_results(time.get_current_time(),</div><div class="line">                         time.get_step_number(),</div><div class="line">                         method);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::implicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">      (final_time - initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line"></div><div class="line">    solution = 0.;</div><div class="line">    constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">    <a class="code" href="classTimeStepping_1_1ImplicitRungeKutta.html">TimeStepping::ImplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt; implicit_runge_kutta(</div><div class="line">      method);</div><div class="line">    output_results(initial_time, 0, method);</div><div class="line">    <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">    <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        implicit_runge_kutta.evolve_one_time_step(</div><div class="line">          [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> Vector&lt;double&gt; &amp;y) {</div><div class="line">            <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">          },</div><div class="line">          [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <span class="keywordtype">double</span> tau, <span class="keyword">const</span> Vector&lt;double&gt; &amp;y) {</div><div class="line">            <span class="keywordflow">return</span> this-&gt;id_minus_tau_J_inverse(time, tau, y);</div><div class="line">          },</div><div class="line">          time.get_current_time(),</div><div class="line">          time.get_next_step_size(),</div><div class="line">          solution);</div><div class="line">        time.advance_time();</div><div class="line"></div><div class="line">        constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">          output_results(time.get_current_time(),</div><div class="line">                         time.get_step_number(),</div><div class="line">                         method);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Diffusion::embedded_explicit_method(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">      (final_time - initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> coarsen_param = 1.2;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> refine_param  = 0.8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> min_delta     = 1e-8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> max_delta     = 10 * time_step;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> refine_tol    = 1e-1;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> coarsen_tol   = 1e-5;</div><div class="line"></div><div class="line">    solution = 0.;</div><div class="line">    constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">    <a class="code" href="classTimeStepping_1_1EmbeddedExplicitRungeKutta.html">TimeStepping::EmbeddedExplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt;</div><div class="line">      embedded_explicit_runge_kutta(method,</div><div class="line">                                    coarsen_param,</div><div class="line">                                    refine_param,</div><div class="line">                                    min_delta,</div><div class="line">                                    max_delta,</div><div class="line">                                    refine_tol,</div><div class="line">                                    coarsen_tol);</div><div class="line">    output_results(initial_time, 0, method);</div><div class="line">    <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">    <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> new_time =</div><div class="line">          embedded_explicit_runge_kutta.evolve_one_time_step(</div><div class="line">            [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> Vector&lt;double&gt; &amp;y) {</div><div class="line">              <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">            },</div><div class="line">            time.get_current_time(),</div><div class="line">            time.get_next_step_size(),</div><div class="line">            solution);</div><div class="line">        time.set_next_step_size(new_time - time.get_current_time());</div><div class="line">        time.advance_time();</div><div class="line"></div><div class="line">        constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">          output_results(time.get_current_time(),</div><div class="line">                         time.get_step_number(),</div><div class="line">                         method);</div><div class="line"></div><div class="line">        time.set_desired_next_step_size(</div><div class="line">          embedded_explicit_runge_kutta.get_status().delta_t_guess);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> time.get_step_number();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Diffusion::run</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 5.);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> ((face-&gt;center()[0] == 0.) || (face-&gt;center()[0] == 5.))</div><div class="line">              face-&gt;set_boundary_id(1);</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              face-&gt;set_boundary_id(0);</div><div class="line">          }</div><div class="line"></div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    assemble_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       n_steps      = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps = 200;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time = 0.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time   = 10.;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Explicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a037245063b5afdaf23a96ec566373613">TimeStepping::FORWARD_EULER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Forward Euler:            error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4acd53dff7339f8bd6d11e3e26ee207894">TimeStepping::RK_THIRD_ORDER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Third order Runge-Kutta:  error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a32b4e44cc3d0746c448d48f3fcb6f633">TimeStepping::RK_CLASSIC_FOURTH_ORDER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Fourth order Runge-Kutta: error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Implicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ada1f653aefa77b5cde1c0a644c283a77">TimeStepping::BACKWARD_EULER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Backward Euler:           error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a5cc8559104243d25be4380b76ae5aa62">TimeStepping::IMPLICIT_MIDPOINT</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Implicit Midpoint:        error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ac6a6f8452b01a46c75dc317f0676dafc">TimeStepping::CRANK_NICOLSON</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Crank-Nicolson:           error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a2102ce2c5306320faa2eb291b505d495">TimeStepping::SDIRK_TWO_STAGES</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   SDIRK:                    error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Embedded explicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a48a2da10d70ded640369a80770aa8279">TimeStepping::HEUN_EULER</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Heun-Euler:               error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a13ecb8a07303020901221676521de483">TimeStepping::BOGACKI_SHAMPINE</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Bogacki-Shampine:         error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ad502a4be71ee90ce567e0e65d083c595">TimeStepping::DOPRI</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Dopri:                    error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a617cb06295ff4fd24ebc9d2c3228da6e">TimeStepping::FEHLBERG</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Fehlberg:                 error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ab1d63829a0bd48bc67f35dae07d35a22">TimeStepping::CASH_KARP</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Cash-Karp:                error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step52</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step52::Diffusion diffusion;</div><div class="line">      diffusion.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_26.html">step-26</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Problemstatement">Problem statement</a>
        <li><a href="#RungeKuttamethods">Runge-Kutta methods</a>
      <ul>
        <li><a href="#ExplicitRungeKuttamethods">Explicit Runge-Kutta methods</a>
        <li><a href="#EmbeddedRungeKuttamethods">Embedded Runge-Kutta methods</a>
        <li><a href="#ImplicitRungeKuttamethods">Implicit Runge-Kutta methods</a>
      </ul>
        <li><a href="#Spatiallydiscreteformulation">Spatially discrete formulation</a>
        <li><a href="#Notesonthetestcase">Notes on the testcase</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeDiffusioncodeclass">The <code>Diffusion</code> class</a>
      <ul>
        <li><a href="#codeDiffusionsetup_systemcode"><code>Diffusion::setup_system</code></a>
        <li><a href="#codeDiffusionassemble_systemcode"><code>Diffusion::assemble_system</code></a>
        <li><a href="#codeDiffusionget_sourcecode"><code>Diffusion::get_source</code></a>
        <li><a href="#codeDiffusionevaluate_diffusioncode"><code>Diffusion::evaluate_diffusion</code></a>
        <li><a href="#codeDiffusionid_minus_tau_J_inversecode"><code>Diffusion::id_minus_tau_J_inverse</code></a>
        <li><a href="#codeDiffusionoutput_resultscode"><code>Diffusion::output_results</code></a>
        <li><a href="#codeDiffusionexplicit_methodcode"><code>Diffusion::explicit_method</code></a>
        <li><a href="#codeDiffusionimplicit_methodcode"><code>Diffusion::implicit_method</code></a>
        <li><a href="#codeDiffusionembedded_explicit_methodcode"><code>Diffusion::embedded_explicit_method</code></a>
        <li><a href="#codeDiffusionruncode"><code>Diffusion::run</code></a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main()</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-52/doc/intro.dox</p>
<p><br />
</p>
<p><em>This program was contributed by Bruno Turcksin and Damien Lebrun-Grandie.</em></p>
<dl class="section note"><dt>Note</dt><dd>为了运行这个程序，deal.II必须被配置为使用UMFPACK稀疏直接解算器。请参考<a href="../../readme.html#umfpack">ReadMe</a>中的说明如何做到这一点。</dd></dl>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>这个程序展示了如何使用Runge-Kutta方法来解决一个随时间变化的问题。它解决了首先在步骤26中讨论的热方程的一个小变化，但是由于这个程序的目的只是演示使用更高级的方法与deal.II的时间步进算法对接，所以只解决了一个均匀细化网格上的简单问题。</p>
<p><a class="anchor" id="Problemstatement"></a></p><h3>Problem statement</h3>
<p>在这个例子中，我们求解中子输运方程的单组时间依赖性扩散近似（关于时间依赖性多组扩散，见步骤28）。这是一个关于中子如何在高散射介质中移动的模型，因此它是时间依赖性扩散方程的一个变体&ndash;它只是步骤26中讨论的热方程的一个不同名称，加上一些额外的条款。我们假设介质是不可逆的，因此，中子通量满足以下方程。</p>
<p class="formulaDsp">
\begin{eqnarray*} \frac{1}{v}\frac{\partial \phi(x,t)}{\partial t} = \nabla \cdot D(x) \nabla \phi(x,t) - \Sigma_a(x) \phi(x,t) + S(x,t) \end{eqnarray*}
</p>
<p>通过适当的边界条件增强。这里， \(v\) 是中子的速度（为简单起见，我们假设它等于1，这可以通过简单地缩放时间变量来实现）， \(D\) 是扩散系数， \(\Sigma_a\) 是吸收截面， \(S\) 是一个源。因为我们只对时间依赖性感兴趣，我们假设 \(D\) 和 \(\Sigma_a\) 是常数。</p>
<p>由于这个程序只打算演示如何使用先进的时间步进算法，我们将只寻找相对简单问题的解。具体来说，我们要在一个正方形域 \([0,b]\times[0,b]\) 上寻找一个解，其形式为</p>
<p class="formulaDsp">
\begin{eqnarray*} \phi(x,t) = A\sin(\omega t)(bx-x^2). \end{eqnarray*}
</p>
<p>通过使用二次有限元，我们可以在任何特定时间精确地表示这个函数，所有的误差都是由于时间离散化造成的。我们这样做是因为这样就很容易观察到我们将要考虑的各种时间步进方案的收敛顺序，而不需要将空间和时间误差分开。</p>
<p>我们施加以下边界条件：对 \(x=0\) 和 \(x=b\) 施加同质的迪里希特条件，对 \(y=0\) 和 \(y=b\) 施加同质的纽曼条件。我们选择源项，以便相应的解决方案实际上是上述的形式。</p>
<p class="formulaDsp">
\begin{eqnarray*} S=A\left(\frac{1}{v}\omega \cos(\omega t)(bx -x^2) + \sin(\omega t) \left(\Sigma_a (bx-x^2)+2D\right) \right). \end{eqnarray*}
</p>
<p>因为解是时间上的正弦，我们知道精确解满足 \(\phi\left(x,\frac{\pi}{\omega}\right) = 0\) 。因此，时间 \(t=\frac{\pi}{\omega}\) 的误差只是数值解的规范，即 \(\|e(\cdot,t=\frac{\pi}{\omega})\|_{L_2} = \|\phi_h(\cdot,t=\frac{\pi}{\omega})\|_{L_2}\) ，而且特别容易评估。在代码中，我们评估 \(l_2\) 的节点值的规范，而不是相关空间函数的 \(L_2\) 规范，因为前者的计算更简单；然而，在均匀网格上，这两者只是由一个常数相关，因此我们可以用其中一个观察时间收敛顺序。</p>
<p><a class="anchor" id="RungeKuttamethods"></a></p><h3>Runge-Kutta methods</h3>
<p>在deal.II中实现的Runge-Kutta方法假定要解决的方程可以写成。</p>
<p class="formulaDsp">
\begin{eqnarray*} \frac{dy}{dt} = g(t,y). \end{eqnarray*}
</p>
<p>另一方面，当使用有限元时，离散化的时间导数总是导致左手边存在一个质量矩阵。这可以很容易地看出，如果上述方程中的解向量 \(y(t)\) 实际上是节点系数的向量 \(U(t)\) ，其形式为变量</p>
<p class="formulaDsp">
\begin{eqnarray*} u_h(x,t) = \sum_j U_j(t) \varphi_j(x) \end{eqnarray*}
</p>
<p>用空间形状函数 \(\varphi_j(x)\) ，然后乘以一个形式的方程</p>
<p class="formulaDsp">
\begin{eqnarray*} \frac{\partial u(x,t)}{\partial t} = q(t,u(x,t)) \end{eqnarray*}
</p>
<p>通过测试函数，对 \(\Omega\) 进行积分，代入 \(u\rightarrow u_h\) 并将测试函数限制在上面的 \(\varphi_i(x)\) ，那么这个空间离散方程的形式为</p>
<p class="formulaDsp">
\begin{eqnarray*} M\frac{dU}{dt} = f(t,U), \end{eqnarray*}
</p>
<p>其中 \(M\) 是质量矩阵， \(f(t,U)\) 是 \(q(t,u(x,t))\) 的空间离散版本（其中 \(q\) 通常是出现空间导数的地方，但鉴于我们只考虑时间导数，这一点目前并不太关心）。换句话说，这种形式符合上面的一般方案，如果我们写成</p>
<p class="formulaDsp">
\begin{eqnarray*} \frac{dy}{dt} = g(t,y) = M^{-1}f(t,y). \end{eqnarray*}
</p>
<p>Runk-Kutta方法是一种时间步进方案，通过特定的一步法对 \(y(t_n)\approx y_{n}\) 进行近似。它们通常被写成以下形式</p>
<p class="formulaDsp">
\begin{eqnarray*} y_{n+1} = y_n + \sum_{i=1}^s b_i k_i \end{eqnarray*}
</p>
<p>其中对于上面的右手边的形式</p>
<p class="formulaDsp">
\begin{eqnarray*} k_i = h M^{-1} f\left(t_n+c_ih,y_n+\sum_{j=1}^sa_{ij}k_j\right). \end{eqnarray*}
</p>
<p>这里 \(a_{ij}\) , \(b_i\) , 和 \(c_i\) 是已知的系数，确定你要使用的特定Runge-Kutta方案， \(h=t_{n+1}-t_n\) 是使用的时间步长。Runge-Kutta类的不同时间步长方法在级数 \(s\) 和系数 \(a_{ij}\) 、 \(b_i\) 和 \(c_i\) 上有所不同，但由于可以查找这些系数的表格值，所以很容易实施。这些表格通常被称为Butcher tableaus）。</p>
<p>在编写本教程时，deal.II中实现的方法可分为三类。&lt;ol&gt;  显式Runge-Kutta；为了使一个方法成为显式，必须在上述定义 \(k_i\) 的公式中， \(k_i\) 不出现在右侧。换句话说，这些方法必须满足 \(a_{ii}=0, i=1,\ldots,s\) 。  嵌入式（或自适应）Runge-Kutta；我们将在下面讨论其特性。  隐式Runge-Kutta；这类方法需要解决可能是非线性系统的上述阶段 \(k_i\) ，即它们至少有 \(a_{ii}\neq 0\) 个阶段 \(i=1,\ldots,s\) 。  许多众所周知的时间步进方案，人们通常不会将其与Runge或Kutta的名字联系起来，事实上，它们也可以用这些类别来表达。它们往往代表这些系列的最低阶成员。</p>
<p><a class="anchor" id="ExplicitRungeKuttamethods"></a></p><h4>Explicit Runge-Kutta methods</h4>
<p>这些方法，只需要一个函数来评估 \(M^{-1}f(t,y)\) ，但不需要（作为隐式方法）来解决涉及 \(f(t,y)\) 的 \(y\) 的方程。与所有显式时间步长方法一样，当选择的时间步长过大时，它们会变得不稳定。</p>
<p>这一类众所周知的方法包括正向欧拉、三阶Runge-Kutta和四阶Runge-Kutta（通常缩写为RK4）。</p>
<p><a class="anchor" id="EmbeddedRungeKuttamethods"></a></p><h4>Embedded Runge-Kutta methods</h4>
<p>这些方法同时使用低阶和高阶方法来估计误差，并决定是否需要缩短时间步长或可以增加。术语 "嵌入 "是指低阶方法不需要对函数 \(M^{-1}f(\cdot,\cdot)\) 进行额外的评估，而是重复使用那些必须为高阶方法计算的数据。换句话说，它基本上是免费的，而我们得到的误差估计是使用高阶方法的副产品。</p>
<p>这类方法包括Heun-Euler、Bogacki-Shampine、Dormand-Prince（在Matlab中为ode45，通常缩写为RK45，表示这里使用的低阶和高阶方法分别为4阶和5阶Runge-Kutta方法），Fehlberg和Cash-Karp。</p>
<p>在撰写本文时，只有嵌入式的显式方法得到了实现。</p>
<p><a class="anchor" id="ImplicitRungeKuttamethods"></a></p><h4>Implicit Runge-Kutta methods</h4>
<p>隐式方法要求在每个（子）时间步中解决 \(\alpha y = f(t,y)\) 形式的 \(y\) 的（可能是非线性）系统。在内部，这是用牛顿式方法完成的，因此，它们要求用户提供能够评估 \(M^{-1}f(t,y)\) 和 \(\left(I-\tau M^{-1} \frac{\partial f}{\partial y}\right)^{-1}\) 或等价的 \(\left(M - \tau \frac{\partial f}{\partial y}\right)^{-1} M\) 的函数。</p>
<p>这个算子的特殊形式来自于这样一个事实，即每一个牛顿步骤都需要解一个形式的方程</p>
<p class="formulaDsp">
\begin{align*} \left(M - \tau \frac{\partial f}{\partial y}\right) \Delta y = -M h(t,y) \end{align*}
</p>
<p>对于一些（给定的） \(h(t,y)\) 。无论时间步长如何，隐式方法总是稳定的，但过大的时间步长当然会影响到解的<em>accuracy</em>，即使数值解仍然稳定且有界。</p>
<p>这类方法包括后退欧拉法、隐式中点法、Crank-Nicolson法和两阶段SDIRK法（"单对角隐式Runge-Kutta "的简称，这个术语是用来表示定义时间步进方法的对角线元素 \(a_{ii}\) 都是相等的；这个特性使得牛顿矩阵 \(I-\tau M^{-1}\frac{\partial f}{\partial y}\) 可以在各阶段之间重复使用，因为 \(\tau\) 每次都是相同的）。</p>
<p><a class="anchor" id="Spatiallydiscreteformulation"></a></p><h3>Spatially discrete formulation</h3>
<p>通过扩大我们的模型问题的解决方案，一如既往地使用形状函数 \(\psi_j\) 并写出</p>
<p class="formulaDsp">
\begin{eqnarray*} \phi_h(x,t) = \sum_j U_j(t) \psi_j(x), \end{eqnarray*}
</p>
<p>我们立即得到扩散方程的空间离散化版本为</p>
<p class="formulaDsp">
\begin{eqnarray*} M \frac{dU(t)}{dt} = -{\cal D} U(t) - {\cal A} U(t) + {\cal S}(t) \end{eqnarray*}
</p>
<p>其中</p>
<p class="formulaDsp">
\begin{eqnarray*} M_{ij} &amp;=&amp; (\psi_i,\psi_j), \\ {\cal D}_{ij} &amp;=&amp; (D\nabla\psi_i,\nabla\psi_j)_\Omega, \\ {\cal A}_{ij} &amp;=&amp; (\Sigma_a\psi_i,\psi_j)_\Omega, \\ {\cal S}_{i}(t) &amp;=&amp; (\psi_i,S(x,t))_\Omega. \end{eqnarray*}
</p>
<p>参见第24步和第26步以了解我们如何到达这里。由于当前问题所选择的边界条件，边界项是没有必要的。为了使用Runge-Kutta方法，我们将其改写如下。</p>
<p class="formulaDsp">
\begin{eqnarray*} f(y) = -{\cal D}y - {\cal A}y + {\cal S}. \end{eqnarray*}
</p>
<p>在代码中，我们将需要能够评估这个函数 \(f(U)\) 以及它的导数。</p>
<p class="formulaDsp">
\begin{eqnarray*} \frac{\partial f}{\partial y} = -{\cal D} - {\cal A}. \end{eqnarray*}
</p>
<p><a class="anchor" id="Notesonthetestcase"></a></p><h3>Notes on the testcase</h3>
<p>为了简化问题，域是二维的，网格是均匀细化的（不需要调整网格，因为我们使用的是二次有限元，而且精确解是二次的）。从二维域到三维域并不是很有挑战性。然而，如果你打算解决更复杂的问题，必须对网格进行调整（例如在步骤26中），那么就必须记住以下问题。</p>
<ol>
<li>
在改变网格时，你需要将解投影到新的网格上。当然，从每个时间步长的开始到结束，所使用的网格应该是相同的，这个问题的出现是因为Runge-Kutta方法在每个时间步长内使用了多次方程求值。 </li>
<li>
每次改变网格时，你都需要更新质量矩阵和它的逆值。 </li>
</ol>
<p>这些步骤的技术可以通过查看步骤26轻易获得。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first task as usual is to include the functionality of these well-known deal.II library files and some C++ header files.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div></div><!-- fragment --><p>This is the only include file that is new: It includes all the Runge-Kutta methods.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="time__stepping_8h.html">deal.II/base/time_stepping.h</a>&gt;</span></div></div><!-- fragment --><p>The next step is like in all previous tutorial programs: We put everything into a namespace of its own and then import the deal.II classes and functions into it.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step52</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeDiffusioncodeclass"></a> </p><h3>The <code>Diffusion</code> class</h3>
<p>The next piece is the declaration of the main class. Most of the functions in this class are not new and have been explained in previous tutorials. The only interesting functions are <code>evaluate_diffusion()</code> and <code>id_minus_tau_J_inverse()</code>. <code>evaluate_diffusion()</code> evaluates the diffusion equation, \(M^{-1}(f(t,y))\), at a given time and a given \(y\). <code>id_minus_tau_J_inverse()</code> evaluates \(\left(I-\tau M^{-1} \frac{\partial f(t,y)}{\partial y}\right)^{-1}\) or equivalently \(\left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} M\) at a given time, for a given \(\tau\) and \(y\). This function is needed when an implicit method is used.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Diffusion</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Diffusion();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> get_source(<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;point) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> evaluate_diffusion(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                    <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> id_minus_tau_J_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                        <span class="keyword">const</span> <span class="keywordtype">double</span>          tau,</div><div class="line">                                        <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">double</span>                     time,</div><div class="line">                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               time_step,</div><div class="line">                      <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method) <span class="keyword">const</span>;</div></div><!-- fragment --><p>The next three functions are the drivers for the explicit methods, the implicit methods, and the embedded explicit methods respectively. The driver function for embedded explicit methods returns the number of steps executed given that it only takes the number of time steps passed as an argument as a hint, but internally computed the optimal time step itself.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">void</span> explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> implicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time);</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">  embedded_explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> diffusion_coefficient;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> absorption_cross_section;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> fe;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraint_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line"></div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> mass_minus_tau_Jacobian;</div><div class="line"></div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> inverse_mass_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">};</div></div><!-- fragment --><p>We choose quadratic finite elements and we initialize the parameters.</p>
<div class="fragment"><div class="line">Diffusion::Diffusion()</div><div class="line">  : fe_degree(2)</div><div class="line">  , diffusion_coefficient(1. / 30.)</div><div class="line">  , absorption_cross_section(1.)</div><div class="line">  , fe(fe_degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionsetup_systemcode"></a> </p><h4><code>Diffusion::setup_system</code></h4>
<p>Now, we create the constraint matrix and the sparsity pattern. Then, we initialize the matrices and the solution vector.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           1,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;2&gt;</a>(),</div><div class="line">                                           constraint_matrix);</div><div class="line">  constraint_matrix.close();</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraint_matrix);</div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a>(sparsity_pattern);</div><div class="line">  mass_minus_tau_Jacobian.reinit(sparsity_pattern);</div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionassemble_systemcode"></a> </p><h4><code>Diffusion::assemble_system</code></h4>
<p>In this function, we compute \(-\int D \nabla b_i \cdot \nabla b_j d\boldsymbol{r} - \int \Sigma_a b_i b_j d\boldsymbol{r}\) and the mass matrix \(\int b_i b_j d\boldsymbol{r}\). The mass matrix is then inverted using a direct solver; the <code>inverse_mass_matrix</code> variable will then store the inverse of the mass matrix so that \(M^{-1}\) can be applied to a vector using the <code>vmult()</code> function of that object. (Internally, UMFPACK does not really store the inverse of the matrix, but its LU factors; applying the inverse matrix is then equivalent to doing one forward and one backward solves with these two factors, which has the same complexity as applying an explicit inverse of the matrix).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::assemble_system()</div><div class="line">{</div><div class="line">  system_matrix = 0.;</div><div class="line">  mass_matrix   = 0.;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                        quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_matrix      = 0.;</div><div class="line">      cell_mass_matrix = 0.;</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                ((-diffusion_coefficient *                <span class="comment">// (-D</span></div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *    <span class="comment">//  * grad phi_i</span></div><div class="line">                    fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)      <span class="comment">//  * grad phi_j</span></div><div class="line">                  - absorption_cross_section *            <span class="comment">//  -Sigma</span></div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * <span class="comment">//  * phi_i</span></div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point))  <span class="comment">//  * phi_j)</span></div><div class="line">                 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));               <span class="comment">// * dx</span></div><div class="line">              cell_mass_matrix(i, j) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                                        fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point) *</div><div class="line">                                        fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">            }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      constraint_matrix.distribute_local_to_global(cell_matrix,</div><div class="line">                                                   local_dof_indices,</div><div class="line">                                                   system_matrix);</div><div class="line">      constraint_matrix.distribute_local_to_global(cell_mass_matrix,</div><div class="line">                                                   local_dof_indices,</div><div class="line">                                                   mass_matrix);</div><div class="line">    }</div><div class="line"></div><div class="line">  inverse_mass_matrix.<a class="code" href="classDoFHandler.html#aeca4a4af5c4d7f7c68a4def9ae87bc7b">initialize</a>(mass_matrix);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionget_sourcecode"></a> </p><h4><code>Diffusion::get_source</code></h4>
<p>In this function, the source term of the equation for a given time and a given point is computed.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> Diffusion::get_source(<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;point)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> intensity = 10.;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> frequency = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> / 10.;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> b         = 5.;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> x         = <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> intensity *</div><div class="line">         (frequency * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(frequency * time) * (b * x - x * x) +</div><div class="line">          std::sin(frequency * time) *</div><div class="line">            (absorption_cross_section * (b * x - x * x) +</div><div class="line">             2. * diffusion_coefficient));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionevaluate_diffusioncode"></a> </p><h4><code>Diffusion::evaluate_diffusion</code></h4>
<p>Next, we evaluate the weak form of the diffusion equation at a given time \(t\) and for a given vector \(y\). In other words, as outlined in the introduction, we evaluate \(M^{-1}(-{\cal D}y - {\cal A}y + {\cal S})\). For this, we have to apply the matrix \(-{\cal D} - {\cal A}\) (previously computed and stored in the variable <code>system_matrix</code>) to \(y\) and then add the source term which we integrate as we usually do. (Integrating up the solution could be done using <a class="el" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side()</a> if you wanted to save a few lines of code, or wanted to take advantage of doing the integration in parallel.) The result is then multiplied by \(M^{-1}\).</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> Diffusion::evaluate_diffusion(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                             <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  tmp = 0.;</div><div class="line">  system_matrix.vmult(tmp, y);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                        quadrature_formula,</div><div class="line">                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> cell_source(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      cell_source = 0.;</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> source =</div><div class="line">            get_source(time, fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point));</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            cell_source(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * <span class="comment">// phi_i(x)</span></div><div class="line">                              source *                            <span class="comment">// * S(x)</span></div><div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);             <span class="comment">// * dx</span></div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      constraint_matrix.distribute_local_to_global(cell_source,</div><div class="line">                                                   local_dof_indices,</div><div class="line">                                                   tmp);</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> value(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  inverse_mass_matrix.vmult(value, tmp);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> value;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionid_minus_tau_J_inversecode"></a> </p><h4><code>Diffusion::id_minus_tau_J_inverse</code></h4>
<p>We compute \(\left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} M\). This is done in several steps:</p><ul>
<li>compute \(M-\tau \frac{\partial f}{\partial y}\)</li>
<li>invert the matrix to get \(\left(M-\tau \frac{\partial f} {\partial y}\right)^{-1}\)</li>
<li>compute \(tmp=My\)</li>
<li>compute \(z=\left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} tmp = \left(M-\tau \frac{\partial f}{\partial y}\right)^{-1} My\)</li>
<li>return z.</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> Diffusion::id_minus_tau_J_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span> <span class="comment">/*time*/</span>,</div><div class="line">                                                 <span class="keyword">const</span> <span class="keywordtype">double</span>          tau,</div><div class="line">                                                 <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y)</div><div class="line">{</div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> inverse_mass_minus_tau_Jacobian;</div><div class="line"></div><div class="line">  mass_minus_tau_Jacobian.copy_from(mass_matrix);</div><div class="line">  mass_minus_tau_Jacobian.add(-tau, system_matrix);</div><div class="line"></div><div class="line">  inverse_mass_minus_tau_Jacobian.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(mass_minus_tau_Jacobian);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a4aedd84e99cda48dce634a2bbf8763fd">vmult</a>(tmp, y);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> result(y);</div><div class="line">  inverse_mass_minus_tau_Jacobian.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(result, tmp);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> result;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionoutput_resultscode"></a> </p><h4><code>Diffusion::output_results</code></h4>
<p>The following function then outputs the solution in vtu files indexed by the number of the time step and the name of the time stepping method. Of course, the (exact) result should really be the same for all time stepping method, but the output here at least allows us to compare them.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::output_results(<span class="keyword">const</span> <span class="keywordtype">double</span>                     time,</div><div class="line">                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               time_step,</div><div class="line">                               <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  std::string method_name;</div><div class="line"></div><div class="line">  <span class="keywordflow">switch</span> (method)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a037245063b5afdaf23a96ec566373613">TimeStepping::FORWARD_EULER</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;forward_euler&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4acd53dff7339f8bd6d11e3e26ee207894">TimeStepping::RK_THIRD_ORDER</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;rk3&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a32b4e44cc3d0746c448d48f3fcb6f633">TimeStepping::RK_CLASSIC_FOURTH_ORDER</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;rk4&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ada1f653aefa77b5cde1c0a644c283a77">TimeStepping::BACKWARD_EULER</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;backward_euler&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a5cc8559104243d25be4380b76ae5aa62">TimeStepping::IMPLICIT_MIDPOINT</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;implicit_midpoint&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a2102ce2c5306320faa2eb291b505d495">TimeStepping::SDIRK_TWO_STAGES</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;sdirk&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a48a2da10d70ded640369a80770aa8279">TimeStepping::HEUN_EULER</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;heun_euler&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a13ecb8a07303020901221676521de483">TimeStepping::BOGACKI_SHAMPINE</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;bocacki_shampine&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ad502a4be71ee90ce567e0e65d083c595">TimeStepping::DOPRI</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;dopri&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a617cb06295ff4fd24ebc9d2c3228da6e">TimeStepping::FEHLBERG</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;fehlberg&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ab1d63829a0bd48bc67f35dae07d35a22">TimeStepping::CASH_KARP</a>:</div><div class="line">        {</div><div class="line">          method_name = <span class="stringliteral">&quot;cash_karp&quot;</span>;</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">      <span class="keywordflow">default</span>:</div><div class="line">        {</div><div class="line">          <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(<a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>(time, time_step));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution_&quot;</span> + method_name + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(time_step, 3) +</div><div class="line">                               <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line"></div><div class="line">  <span class="keyword">static</span> std::vector&lt;std::pair&lt;double, std::string&gt;&gt; times_and_names;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> std::string method_name_prev = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">  <span class="keyword">static</span> std::string pvd_filename;</div><div class="line">  <span class="keywordflow">if</span> (method_name_prev != method_name)</div><div class="line">    {</div><div class="line">      times_and_names.clear();</div><div class="line">      method_name_prev = method_name;</div><div class="line">      pvd_filename     = <span class="stringliteral">&quot;solution_&quot;</span> + method_name + <span class="stringliteral">&quot;.pvd&quot;</span>;</div><div class="line">    }</div><div class="line">  times_and_names.emplace_back(time, filename);</div><div class="line">  std::ofstream pvd_output(pvd_filename);</div><div class="line">  <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(pvd_output, times_and_names);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionexplicit_methodcode"></a> </p><h4><code>Diffusion::explicit_method</code></h4>
<p>This function is the driver for all the explicit methods. At the top it initializes the time stepping and the solution (by setting it to zero and then ensuring that boundary value and hanging node constraints are respected; of course, with the mesh we use here, hanging node constraints are not in fact an issue). It then calls <code>evolve_one_time_step</code> which performs one time step. Time is stored and incremented through a <a class="el" href="classDiscreteTime.html">DiscreteTime</a> object.</p>
<p>For explicit methods, <code>evolve_one_time_step</code> needs to evaluate \(M^{-1}(f(t,y))\), i.e, it needs <code>evaluate_diffusion</code>. Because <code>evaluate_diffusion</code> is a member function, it needs to be bound to <code>this</code>. After each evolution step, we again apply the correct boundary values and hanging node constraints.</p>
<p>Finally, the solution is output every 10 time steps.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">    (final_time - initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line"></div><div class="line">  solution = 0.;</div><div class="line">  constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">  <a class="code" href="classTimeStepping_1_1ExplicitRungeKutta.html">TimeStepping::ExplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt; explicit_runge_kutta(</div><div class="line">    method);</div><div class="line">  output_results(initial_time, 0, method);</div><div class="line">  <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">  <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      explicit_runge_kutta.evolve_one_time_step(</div><div class="line">        [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y) {</div><div class="line">          <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">        },</div><div class="line">        time.get_current_time(),</div><div class="line">        time.get_next_step_size(),</div><div class="line">        solution);</div><div class="line">      time.advance_time();</div><div class="line"></div><div class="line">      constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">        output_results(time.get_current_time(),</div><div class="line">                       time.get_step_number(),</div><div class="line">                       method);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionimplicit_methodcode"></a> </p><h4><code>Diffusion::implicit_method</code></h4>
<p>This function is equivalent to <code>explicit_method</code> but for implicit methods. When using implicit methods, we need to evaluate \(M^{-1}(f(t,y))\) and \(\left(I-\tau M^{-1} \frac{\partial f(t,y)}{\partial y}\right)^{-1}\) for which we use the two member functions previously introduced.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Diffusion::implicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                                <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">    (final_time - initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line"></div><div class="line">  solution = 0.;</div><div class="line">  constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">  <a class="code" href="classTimeStepping_1_1ImplicitRungeKutta.html">TimeStepping::ImplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt; implicit_runge_kutta(</div><div class="line">    method);</div><div class="line">  output_results(initial_time, 0, method);</div><div class="line">  <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">  <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      implicit_runge_kutta.evolve_one_time_step(</div><div class="line">        [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y) {</div><div class="line">          <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">        },</div><div class="line">        [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <span class="keywordtype">double</span> tau, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y) {</div><div class="line">          <span class="keywordflow">return</span> this-&gt;id_minus_tau_J_inverse(time, tau, y);</div><div class="line">        },</div><div class="line">        time.get_current_time(),</div><div class="line">        time.get_next_step_size(),</div><div class="line">        solution);</div><div class="line">      time.advance_time();</div><div class="line"></div><div class="line">      constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">        output_results(time.get_current_time(),</div><div class="line">                       time.get_step_number(),</div><div class="line">                       method);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionembedded_explicit_methodcode"></a> </p><h4><code>Diffusion::embedded_explicit_method</code></h4>
<p>This function is the driver for the embedded explicit methods. It requires more parameters:</p><ul>
<li>coarsen_param: factor multiplying the current time step when the error is below the threshold.</li>
<li>refine_param: factor multiplying the current time step when the error is above the threshold.</li>
<li>min_delta: smallest time step acceptable.</li>
<li>max_delta: largest time step acceptable.</li>
<li>refine_tol: threshold above which the time step is refined.</li>
<li>coarsen_tol: threshold below which the time step is coarsen.</li>
</ul>
<p>Embedded methods use a guessed time step. If the error using this time step is too large, the time step will be reduced. If the error is below the threshold, a larger time step will be tried for the next time step. <code>delta_t_guess</code> is the guessed time step produced by the embedded method. In summary, time step size is potentially modified in three ways:</p><ul>
<li>Reducing or increasing time step size within <a class="el" href="classTimeStepping_1_1EmbeddedExplicitRungeKutta.html#accb05cdd9b6519c4d4ffe9ea996cee87">TimeStepping::EmbeddedExplicitRungeKutta::evolve_one_time_step()</a>.</li>
<li>Using the calculated <code>delta_t_guess</code>.</li>
<li>Automatically adjusting the step size of the last time step to ensure simulation ends precisely at <code>final_time</code>. This adjustment is handled inside the <a class="el" href="classDiscreteTime.html">DiscreteTime</a> instance.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Diffusion::embedded_explicit_method(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">    (final_time - initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> coarsen_param = 1.2;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> refine_param  = 0.8;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> min_delta     = 1e-8;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_delta     = 10 * time_step;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> refine_tol    = 1e-1;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> coarsen_tol   = 1e-5;</div><div class="line"></div><div class="line">  solution = 0.;</div><div class="line">  constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">  <a class="code" href="classTimeStepping_1_1EmbeddedExplicitRungeKutta.html">TimeStepping::EmbeddedExplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt;</div><div class="line">    embedded_explicit_runge_kutta(method,</div><div class="line">                                  coarsen_param,</div><div class="line">                                  refine_param,</div><div class="line">                                  min_delta,</div><div class="line">                                  max_delta,</div><div class="line">                                  refine_tol,</div><div class="line">                                  coarsen_tol);</div><div class="line">  output_results(initial_time, 0, method);</div><div class="line">  <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">  <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> new_time =</div><div class="line">        embedded_explicit_runge_kutta.evolve_one_time_step(</div><div class="line">          [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;y) {</div><div class="line">            <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">          },</div><div class="line">          time.get_current_time(),</div><div class="line">          time.get_next_step_size(),</div><div class="line">          solution);</div><div class="line">      time.set_next_step_size(new_time - time.get_current_time());</div><div class="line">      time.advance_time();</div><div class="line"></div><div class="line">      constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">        output_results(time.get_current_time(),</div><div class="line">                       time.get_step_number(),</div><div class="line">                       method);</div><div class="line"></div><div class="line">      time.set_desired_next_step_size(</div><div class="line">        embedded_explicit_runge_kutta.get_status().delta_t_guess);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> time.get_step_number();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="codeDiffusionruncode"></a> </p><h4><code>Diffusion::run</code></h4>
<p>The following is the main function of the program. At the top, we create the grid (a [0,5]x[0,5] square) and refine it four times to get a mesh that has 16 by 16 cells, for a total of 256. We then set the boundary indicator to 1 for those parts of the boundary where \(x=0\) and \(x=5\).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Diffusion::run</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 5.);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">      <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">        {</div><div class="line">          <span class="keywordflow">if</span> ((face-&gt;center()[0] == 0.) || (face-&gt;center()[0] == 5.))</div><div class="line">            face-&gt;set_boundary_id(1);</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            face-&gt;set_boundary_id(0);</div><div class="line">        }</div></div><!-- fragment --><p>Next, we set up the linear systems and fill them with content so that they can be used throughout the time stepping process:</p>
<div class="fragment"><div class="line">setup_system();</div><div class="line"></div><div class="line">assemble_system();</div></div><!-- fragment --><p>Finally, we solve the diffusion problem using several of the Runge-Kutta methods implemented in namespace <a class="el" href="namespaceTimeStepping.html">TimeStepping</a>, each time outputting the error at the end time. (As explained in the introduction, since the exact solution is zero at the final time, the error equals the numerical solution and can be computed by just taking the \(l_2\) norm of the solution vector.)</p>
<div class="fragment"><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       n_steps      = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps = 200;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time = 0.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time   = 10.;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Explicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a037245063b5afdaf23a96ec566373613">TimeStepping::FORWARD_EULER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Forward Euler:            error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4acd53dff7339f8bd6d11e3e26ee207894">TimeStepping::RK_THIRD_ORDER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Third order Runge-Kutta:  error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a32b4e44cc3d0746c448d48f3fcb6f633">TimeStepping::RK_CLASSIC_FOURTH_ORDER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Fourth order Runge-Kutta: error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Implicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ada1f653aefa77b5cde1c0a644c283a77">TimeStepping::BACKWARD_EULER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Backward Euler:           error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a5cc8559104243d25be4380b76ae5aa62">TimeStepping::IMPLICIT_MIDPOINT</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Implicit Midpoint:        error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ac6a6f8452b01a46c75dc317f0676dafc">TimeStepping::CRANK_NICOLSON</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Crank-Nicolson:           error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a2102ce2c5306320faa2eb291b505d495">TimeStepping::SDIRK_TWO_STAGES</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   SDIRK:                    error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Embedded explicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a48a2da10d70ded640369a80770aa8279">TimeStepping::HEUN_EULER</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Heun-Euler:               error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a13ecb8a07303020901221676521de483">TimeStepping::BOGACKI_SHAMPINE</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Bogacki-Shampine:         error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ad502a4be71ee90ce567e0e65d083c595">TimeStepping::DOPRI</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Dopri:                    error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a617cb06295ff4fd24ebc9d2c3228da6e">TimeStepping::FEHLBERG</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Fehlberg:                 error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ab1d63829a0bd48bc67f35dae07d35a22">TimeStepping::CASH_KARP</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Cash-Karp:                error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step52</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main()</code> function</h3>
<p>The following <code>main</code> function is similar to previous examples and need not be commented on.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step52::Diffusion diffusion;</div><div class="line">      diffusion.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-52/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>这个程序的重点不在于显示特定的结果，而在于显示它是如何做到的。这一点我们已经通过讨论上面的代码证明过了。因此，该程序的输出相对较少，只包括控制台输出和用于可视化的VTU格式的解决方案。</p>
<p>控制台输出既包含错误，也包含对某些方法所执行的步骤数量。</p>
<div class="fragment"><div class="line">Explicit methods:</div><div class="line">   Forward Euler:            error=1.00883</div><div class="line">   Third order Runge-Kutta:  error=0.000227982</div><div class="line">   Fourth order Runge-Kutta: error=1.90541e-06</div><div class="line"></div><div class="line"></div><div class="line">Implicit methods:</div><div class="line">   Backward Euler:           error=1.03428</div><div class="line">   Implicit Midpoint:        error=0.00862702</div><div class="line">   Crank-Nicolson:           error=0.00862675</div><div class="line">   SDIRK:                    error=0.0042349</div><div class="line"></div><div class="line"></div><div class="line">Embedded <span class="keyword">explicit</span> methods:</div><div class="line">   Heun-Euler:               error=0.0073012</div><div class="line">                   steps performed=284</div><div class="line">   Bogacki-Shampine:         error=0.000408407</div><div class="line">                   steps performed=181</div><div class="line">   Dopri:                    error=0.000836695</div><div class="line">                   steps performed=120</div><div class="line">   Fehlberg:                 error=0.00248922</div><div class="line">                   steps performed=106</div><div class="line">   Cash-Karp:                error=0.0787735</div><div class="line">                   steps performed=106</div></div><!-- fragment --><p>正如预期的那样，高阶方法给出了（更）准确的解决方案。我们还看到，（相当不准确的）Heun-Euler方法增加了时间步数，以满足公差要求。另一方面，其他嵌入式方法使用的时间步数比规定的要少得多。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2014 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Damien Lebrun-Grandie, Bruno Turcksin, 2014</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="discrete__time_8h.html">deal.II/base/discrete_time.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="time__stepping_8h.html">deal.II/base/time_stepping.h</a>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step52</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>Diffusion</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Diffusion();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> get_source(<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;point) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; evaluate_diffusion(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                      <span class="keyword">const</span> Vector&lt;double&gt; &amp;y) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; id_minus_tau_J_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">double</span>          tau,</div><div class="line">                                          <span class="keyword">const</span> Vector&lt;double&gt; &amp;y);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">double</span>                     time,</div><div class="line">                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               time_step,</div><div class="line">                        <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> implicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span></div><div class="line">    embedded_explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fe_degree;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> diffusion_coefficient;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> absorption_cross_section;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> fe;</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraint_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line"></div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> mass_minus_tau_Jacobian;</div><div class="line"></div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> inverse_mass_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  Diffusion::Diffusion()</div><div class="line">    : fe_degree(2)</div><div class="line">    , diffusion_coefficient(1. / 30.)</div><div class="line">    , absorption_cross_section(1.)</div><div class="line">    , fe(fe_degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             1,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;2&gt;</a>(),</div><div class="line">                                             constraint_matrix);</div><div class="line">    constraint_matrix.close();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraint_matrix);</div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a614ca8e186fe3c61e03a52369437157e">reinit</a>(sparsity_pattern);</div><div class="line">    mass_minus_tau_Jacobian.reinit(sparsity_pattern);</div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::assemble_system()</div><div class="line">  {</div><div class="line">    system_matrix = 0.;</div><div class="line">    mass_matrix   = 0.;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix      = 0.;</div><div class="line">        cell_mass_matrix = 0.;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                  ((-diffusion_coefficient *                <span class="comment">// (-D</span></div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *    <span class="comment">//  * grad phi_i</span></div><div class="line">                      fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)      <span class="comment">//  * grad phi_j</span></div><div class="line">                    - absorption_cross_section *            <span class="comment">//  -Sigma</span></div><div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * <span class="comment">//  * phi_i</span></div><div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point))  <span class="comment">//  * phi_j)</span></div><div class="line">                   * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point));               <span class="comment">// * dx</span></div><div class="line">                cell_mass_matrix(i, j) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) *</div><div class="line">                                          fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point) *</div><div class="line">                                          fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">              }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        constraint_matrix.distribute_local_to_global(cell_matrix,</div><div class="line">                                                     local_dof_indices,</div><div class="line">                                                     system_matrix);</div><div class="line">        constraint_matrix.distribute_local_to_global(cell_mass_matrix,</div><div class="line">                                                     local_dof_indices,</div><div class="line">                                                     mass_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    inverse_mass_matrix.<a class="code" href="classDoFHandler.html#aeca4a4af5c4d7f7c68a4def9ae87bc7b">initialize</a>(mass_matrix);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> Diffusion::get_source(<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> &amp;point)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> intensity = 10.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> frequency = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> / 10.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> b         = 5.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> x         = <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> intensity *</div><div class="line">           (frequency * <a class="code" href="vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a>(frequency * time) * (b * x - x * x) +</div><div class="line">            std::sin(frequency * time) *</div><div class="line">              (absorption_cross_section * (b * x - x * x) +</div><div class="line">               2. * diffusion_coefficient));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  Vector&lt;double&gt; Diffusion::evaluate_diffusion(<span class="keyword">const</span> <span class="keywordtype">double</span>          time,</div><div class="line">                                               <span class="keyword">const</span> Vector&lt;double&gt; &amp;y)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    tmp = 0.;</div><div class="line">    system_matrix.vmult(tmp, y);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;2&gt;</a> quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;2&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt; cell_source(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_source = 0.;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> source =</div><div class="line">              get_source(time, fe_values.<a class="code" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>(q_point));</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              cell_source(i) += fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * <span class="comment">// phi_i(x)</span></div><div class="line">                                source *                            <span class="comment">// * S(x)</span></div><div class="line">                                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);             <span class="comment">// * dx</span></div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        constraint_matrix.distribute_local_to_global(cell_source,</div><div class="line">                                                     local_dof_indices,</div><div class="line">                                                     tmp);</div><div class="line">      }</div><div class="line"></div><div class="line">    Vector&lt;double&gt; value(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    inverse_mass_matrix.vmult(value, tmp);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> value;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  Vector&lt;double&gt; Diffusion::id_minus_tau_J_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span> <span class="comment">/*time*/</span>,</div><div class="line">                                                   <span class="keyword">const</span> <span class="keywordtype">double</span>          tau,</div><div class="line">                                                   <span class="keyword">const</span> Vector&lt;double&gt; &amp;y)</div><div class="line">  {</div><div class="line">    <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> inverse_mass_minus_tau_Jacobian;</div><div class="line"></div><div class="line">    mass_minus_tau_Jacobian.copy_from(mass_matrix);</div><div class="line">    mass_minus_tau_Jacobian.add(-tau, system_matrix);</div><div class="line"></div><div class="line">    inverse_mass_minus_tau_Jacobian.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a>(mass_minus_tau_Jacobian);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    mass_matrix.<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html#a4aedd84e99cda48dce634a2bbf8763fd">vmult</a>(tmp, y);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; result(y);</div><div class="line">    inverse_mass_minus_tau_Jacobian.<a class="code" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a>(result, tmp);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> result;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::output_results(<span class="keyword">const</span> <span class="keywordtype">double</span>                     time,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>               time_step,</div><div class="line">                                 <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    std::string method_name;</div><div class="line"></div><div class="line">    <span class="keywordflow">switch</span> (method)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a037245063b5afdaf23a96ec566373613">TimeStepping::FORWARD_EULER</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;forward_euler&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4acd53dff7339f8bd6d11e3e26ee207894">TimeStepping::RK_THIRD_ORDER</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;rk3&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a32b4e44cc3d0746c448d48f3fcb6f633">TimeStepping::RK_CLASSIC_FOURTH_ORDER</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;rk4&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ada1f653aefa77b5cde1c0a644c283a77">TimeStepping::BACKWARD_EULER</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;backward_euler&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a5cc8559104243d25be4380b76ae5aa62">TimeStepping::IMPLICIT_MIDPOINT</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;implicit_midpoint&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a2102ce2c5306320faa2eb291b505d495">TimeStepping::SDIRK_TWO_STAGES</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;sdirk&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a48a2da10d70ded640369a80770aa8279">TimeStepping::HEUN_EULER</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;heun_euler&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a13ecb8a07303020901221676521de483">TimeStepping::BOGACKI_SHAMPINE</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;bocacki_shampine&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ad502a4be71ee90ce567e0e65d083c595">TimeStepping::DOPRI</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;dopri&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a617cb06295ff4fd24ebc9d2c3228da6e">TimeStepping::FEHLBERG</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;fehlberg&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ab1d63829a0bd48bc67f35dae07d35a22">TimeStepping::CASH_KARP</a>:</div><div class="line">          {</div><div class="line">            method_name = <span class="stringliteral">&quot;cash_karp&quot;</span>;</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">default</span>:</div><div class="line">          {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;2&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(<a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a>(time, time_step));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution_&quot;</span> + method_name + <span class="stringliteral">&quot;-&quot;</span> +</div><div class="line">                                 <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(time_step, 3) +</div><div class="line">                                 <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::vector&lt;std::pair&lt;double, std::string&gt;&gt; times_and_names;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> std::string method_name_prev = <span class="stringliteral">&quot;&quot;</span>;</div><div class="line">    <span class="keyword">static</span> std::string pvd_filename;</div><div class="line">    <span class="keywordflow">if</span> (method_name_prev != method_name)</div><div class="line">      {</div><div class="line">        times_and_names.clear();</div><div class="line">        method_name_prev = method_name;</div><div class="line">        pvd_filename     = <span class="stringliteral">&quot;solution_&quot;</span> + method_name + <span class="stringliteral">&quot;.pvd&quot;</span>;</div><div class="line">      }</div><div class="line">    times_and_names.emplace_back(time, filename);</div><div class="line">    std::ofstream pvd_output(pvd_filename);</div><div class="line">    <a class="code" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record</a>(pvd_output, times_and_names);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::explicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">      (final_time - initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line"></div><div class="line">    solution = 0.;</div><div class="line">    constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">    <a class="code" href="classTimeStepping_1_1ExplicitRungeKutta.html">TimeStepping::ExplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt; explicit_runge_kutta(</div><div class="line">      method);</div><div class="line">    output_results(initial_time, 0, method);</div><div class="line">    <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">    <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        explicit_runge_kutta.evolve_one_time_step(</div><div class="line">          [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> Vector&lt;double&gt; &amp;y) {</div><div class="line">            <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">          },</div><div class="line">          time.get_current_time(),</div><div class="line">          time.get_next_step_size(),</div><div class="line">          solution);</div><div class="line">        time.advance_time();</div><div class="line"></div><div class="line">        constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">          output_results(time.get_current_time(),</div><div class="line">                         time.get_step_number(),</div><div class="line">                         method);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> Diffusion::implicit_method(<span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">      (final_time - initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line"></div><div class="line">    solution = 0.;</div><div class="line">    constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">    <a class="code" href="classTimeStepping_1_1ImplicitRungeKutta.html">TimeStepping::ImplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt; implicit_runge_kutta(</div><div class="line">      method);</div><div class="line">    output_results(initial_time, 0, method);</div><div class="line">    <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">    <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        implicit_runge_kutta.evolve_one_time_step(</div><div class="line">          [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> Vector&lt;double&gt; &amp;y) {</div><div class="line">            <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">          },</div><div class="line">          [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> <span class="keywordtype">double</span> tau, <span class="keyword">const</span> Vector&lt;double&gt; &amp;y) {</div><div class="line">            <span class="keywordflow">return</span> this-&gt;id_minus_tau_J_inverse(time, tau, y);</div><div class="line">          },</div><div class="line">          time.get_current_time(),</div><div class="line">          time.get_next_step_size(),</div><div class="line">          solution);</div><div class="line">        time.advance_time();</div><div class="line"></div><div class="line">        constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">          output_results(time.get_current_time(),</div><div class="line">                         time.get_step_number(),</div><div class="line">                         method);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Diffusion::embedded_explicit_method(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4">TimeStepping::runge_kutta_method</a> method,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                     n_time_steps,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                           initial_time,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                           final_time)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> time_step =</div><div class="line">      (final_time - initial_time) / static_cast&lt;double&gt;(n_time_steps);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> coarsen_param = 1.2;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> refine_param  = 0.8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> min_delta     = 1e-8;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> max_delta     = 10 * time_step;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> refine_tol    = 1e-1;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> coarsen_tol   = 1e-5;</div><div class="line"></div><div class="line">    solution = 0.;</div><div class="line">    constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">    <a class="code" href="classTimeStepping_1_1EmbeddedExplicitRungeKutta.html">TimeStepping::EmbeddedExplicitRungeKutta&lt;Vector&lt;double&gt;</a>&gt;</div><div class="line">      embedded_explicit_runge_kutta(method,</div><div class="line">                                    coarsen_param,</div><div class="line">                                    refine_param,</div><div class="line">                                    min_delta,</div><div class="line">                                    max_delta,</div><div class="line">                                    refine_tol,</div><div class="line">                                    coarsen_tol);</div><div class="line">    output_results(initial_time, 0, method);</div><div class="line">    <a class="code" href="classDiscreteTime.html">DiscreteTime</a> time(initial_time, final_time, time_step);</div><div class="line">    <span class="keywordflow">while</span> (time.is_at_end() == <span class="keyword">false</span>)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> new_time =</div><div class="line">          embedded_explicit_runge_kutta.evolve_one_time_step(</div><div class="line">            [<span class="keyword">this</span>](<span class="keyword">const</span> <span class="keywordtype">double</span> time, <span class="keyword">const</span> Vector&lt;double&gt; &amp;y) {</div><div class="line">              <span class="keywordflow">return</span> this-&gt;evaluate_diffusion(time, y);</div><div class="line">            },</div><div class="line">            time.get_current_time(),</div><div class="line">            time.get_next_step_size(),</div><div class="line">            solution);</div><div class="line">        time.set_next_step_size(new_time - time.get_current_time());</div><div class="line">        time.advance_time();</div><div class="line"></div><div class="line">        constraint_matrix.distribute(solution);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (time.get_step_number() % 10 == 0)</div><div class="line">          output_results(time.get_current_time(),</div><div class="line">                         time.get_step_number(),</div><div class="line">                         method);</div><div class="line"></div><div class="line">        time.set_desired_next_step_size(</div><div class="line">          embedded_explicit_runge_kutta.get_status().delta_t_guess);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> time.get_step_number();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">Diffusion::run</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 5.);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(4);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">          {</div><div class="line">            <span class="keywordflow">if</span> ((face-&gt;center()[0] == 0.) || (face-&gt;center()[0] == 5.))</div><div class="line">              face-&gt;set_boundary_id(1);</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              face-&gt;set_boundary_id(0);</div><div class="line">          }</div><div class="line"></div><div class="line">    setup_system();</div><div class="line"></div><div class="line">    assemble_system();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       n_steps      = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_time_steps = 200;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       initial_time = 0.;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       final_time   = 10.;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Explicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a037245063b5afdaf23a96ec566373613">TimeStepping::FORWARD_EULER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Forward Euler:            error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4acd53dff7339f8bd6d11e3e26ee207894">TimeStepping::RK_THIRD_ORDER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Third order Runge-Kutta:  error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a32b4e44cc3d0746c448d48f3fcb6f633">TimeStepping::RK_CLASSIC_FOURTH_ORDER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Fourth order Runge-Kutta: error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Implicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ada1f653aefa77b5cde1c0a644c283a77">TimeStepping::BACKWARD_EULER</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Backward Euler:           error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a5cc8559104243d25be4380b76ae5aa62">TimeStepping::IMPLICIT_MIDPOINT</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Implicit Midpoint:        error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ac6a6f8452b01a46c75dc317f0676dafc">TimeStepping::CRANK_NICOLSON</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Crank-Nicolson:           error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    implicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a2102ce2c5306320faa2eb291b505d495">TimeStepping::SDIRK_TWO_STAGES</a>,</div><div class="line">                    n_time_steps,</div><div class="line">                    initial_time,</div><div class="line">                    final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   SDIRK:                    error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Embedded explicit methods:&quot;</span> &lt;&lt; std::endl;</div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a48a2da10d70ded640369a80770aa8279">TimeStepping::HEUN_EULER</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Heun-Euler:               error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a13ecb8a07303020901221676521de483">TimeStepping::BOGACKI_SHAMPINE</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Bogacki-Shampine:         error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ad502a4be71ee90ce567e0e65d083c595">TimeStepping::DOPRI</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Dopri:                    error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4a617cb06295ff4fd24ebc9d2c3228da6e">TimeStepping::FEHLBERG</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Fehlberg:                 error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    n_steps = embedded_explicit_method(<a class="code" href="namespaceTimeStepping.html#abff97b5326e452552f108a379dd6cff4ab1d63829a0bd48bc67f35dae07d35a22">TimeStepping::CASH_KARP</a>,</div><div class="line">                                       n_time_steps,</div><div class="line">                                       initial_time,</div><div class="line">                                       final_time);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Cash-Karp:                error=&quot;</span> &lt;&lt; solution.l2_norm()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;                   steps performed=&quot;</span> &lt;&lt; n_steps &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step52</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step52::Diffusion diffusion;</div><div class="line">      diffusion.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    };</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
