<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_43.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-43 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-43 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_31.html">step-31</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Advectiondominatedtwophaseflowmathematicalmodel">Advection-dominated two-phase flow mathematical model.</a>
        <li><a href="#Adaptiveoperatorsplittingandtimestepping">Adaptive operator splitting and time stepping.</a>
        <li><a href="#Timediscretization">Time discretization.</a>
        <li><a href="#Weakformspacediscretizationforthepressurevelocitypart">Weak form, space discretization for the pressure-velocity part.</a>
        <li><a href="#Stabilizationweakformandspacediscretizationforthesaturationtransportequation">Stabilization, weak form and space discretization for the saturation transport equation.</a>
        <li><a href="#Adaptivemeshrefinement">Adaptive mesh refinement.</a>
        <li><a href="#Linearsystemanditspreconditioning">Linear system and its preconditioning.</a>
        <li><a href="#Thetestcases">The test cases.</a>
        <li><a href="#Listofreferences">List of references</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Boundaryandinitialvalueclasses">Boundary and initial value classes</a>
        <li><a href="#Permeabilitymodels">Permeability models</a>
        <li><a href="#Physicalquantities">Physical quantities</a>
        <li><a href="#Helperclassesforsolversandpreconditioners">Helper classes for solvers and preconditioners</a>
        <li><a href="#TheTwoPhaseFlowProblemclass">The TwoPhaseFlowProblem class</a>
        <li><a href="#TwoPhaseFlowProblemdimTwoPhaseFlowProblem">TwoPhaseFlowProblem<dim>::TwoPhaseFlowProblem</a>
        <li><a href="#TwoPhaseFlowProblemdimsetup_dofs">TwoPhaseFlowProblem<dim>::setup_dofs</a>
        <li><a href="#Assemblingmatricesandpreconditioners">Assembling matrices and preconditioners</a>
      <ul>
        <li><a href="#TwoPhaseFlowProblemdimassemble_darcy_preconditioner">TwoPhaseFlowProblem<dim>::assemble_darcy_preconditioner</a>
        <li><a href="#TwoPhaseFlowProblemdimbuild_darcy_preconditioner">TwoPhaseFlowProblem<dim>::build_darcy_preconditioner</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_darcy_system">TwoPhaseFlowProblem<dim>::assemble_darcy_system</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_saturation_system">TwoPhaseFlowProblem<dim>::assemble_saturation_system</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_saturation_matrix">TwoPhaseFlowProblem<dim>::assemble_saturation_matrix</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_saturation_rhs">TwoPhaseFlowProblem<dim>::assemble_saturation_rhs</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_saturation_rhs_cell_term">TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_cell_term</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_saturation_rhs_boundary_term">TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_boundary_term</a>
      </ul>
        <li><a href="#TwoPhaseFlowProblemdimsolve">TwoPhaseFlowProblem<dim>::solve</a>
        <li><a href="#TwoPhaseFlowProblemdimrefine_mesh">TwoPhaseFlowProblem<dim>::refine_mesh</a>
        <li><a href="#TwoPhaseFlowProblemdimoutput_results">TwoPhaseFlowProblem<dim>::output_results</a>
        <li><a href="#Toolfunctions">Tool functions</a>
      <ul>
        <li><a href="#TwoPhaseFlowProblemdimdetermine_whether_to_solve_for_pressure_and_velocity">TwoPhaseFlowProblem<dim>::determine_whether_to_solve_for_pressure_and_velocity</a>
        <li><a href="#TwoPhaseFlowProblemdimproject_back_saturation">TwoPhaseFlowProblem<dim>::project_back_saturation</a>
        <li><a href="#TwoPhaseFlowProblemdimget_max_u_F_prime">TwoPhaseFlowProblem<dim>::get_max_u_F_prime</a>
        <li><a href="#TwoPhaseFlowProblemdimget_extrapolated_saturation_range">TwoPhaseFlowProblem<dim>::get_extrapolated_saturation_range</a>
        <li><a href="#TwoPhaseFlowProblemdimcompute_viscosity">TwoPhaseFlowProblem<dim>::compute_viscosity</a>
      </ul>
        <li><a href="#TwoPhaseFlowProblemdimrun">TwoPhaseFlowProblem<dim>::run</a>
        <li><a href="#Thecodemaincodefunction">The <code>main()</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em> This program was contributed by Chih-Che Chueh (University of Victoria) and Wolfgang Bangerth. Results from this program are used and discussed in the following publications (in particular in the second one):</p><ul>
<li>Chih-Che Chueh, Marc Secanell, Wolfgang Bangerth, Ned Djilali. Multi-level adaptive simulation of transient two-phase flow in heterogeneous porous media. Computers &amp; Fluids, 39:1585-1596, 2010</li>
<li>Chih-Che Chueh, Ned Djilali, Wolfgang Bangerth. An h-adaptive operator splitting method for two-phase flow in 3D heterogeneous porous media. SIAM Journal on Scientific Computing, 35:B149-B175, 2013.</li>
</ul>
<p></em></p>
<p><em>The implementation discussed here uses and extends parts of the <a class="el" href="step_21.html">step-21</a> and <a class="el" href="step_31.html">step-31</a> tutorial programs.</em></p>
<p><em>The work of the Chih-Che Chueh was funded through the Canada Research Chairs Program and the MITACS Network of Centres of Excellence. Parts of the work by Wolfgang Bangerth were funded through Award No. KUS-C1-016-04, made by the King Abdullah University of Science and Technology, and through an Alfred P. Sloan Research Fellowship. This material is also in parts based upon work supported by the National Science Foundation under Award No. EAR-0426271 and The California Institute of Technology; and in a continuation by the National Science Foundation under Award No. EAR-0949446 and The University of California &ndash; Davis. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation, The California Institute of Technology, or of The University of California &ndash; Davis. </em></p>
<p><a class="anchor" id="Introduction"></a><a class="anchor" id="Intro"></a> </p><h1>Introduction</h1>
<p>The simulation of multiphase flow in porous media is a ubiquitous problem, and we have previously addressed it already in some form in <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a>. However, as was easy to see there, it faces two major difficulties: numerical accuracy and efficiency. The first is easy to see in the stationary solver <a class="el" href="step_20.html">step-20</a>: using lowest order Raviart-Thomas elements can not be expected to yield highly accurate solutions. We need more accurate methods. The second reason is apparent from the time dependent <a class="el" href="step_21.html">step-21</a>: that program is excruciatingly slow, and there is no hope to get highly accurate solutions in 3d within reasonable time frames.</p>
<p>In this program, in order to overcome these two problems, there are five areas which we are trying to improve for a high performance simulator:</p>
<ul>
<li>
Higher order spatial discretizations </li>
<li>
Adaptive mesh refinement </li>
<li>
Adaptive time stepping </li>
<li>
Operator splitting </li>
<li>
Efficient solver and preconditioning </li>
</ul>
<p>Much inspiration for this program comes from <a class="el" href="step_31.html">step-31</a> but several of the techniques discussed here are original.</p>
<p><a class="anchor" id="Advectiondominatedtwophaseflowmathematicalmodel"></a></p><h3>Advection-dominated two-phase flow mathematical model.</h3>
<p>We consider the flow of a two-phase immiscible, incompressible fluid. Capillary and gravity effects are neglected, and viscous effects are assumed dominant. The governing equations for such a flow that are identical to those used in <a class="el" href="step_21.html">step-21</a> and are </p><p class="formulaDsp">
\begin{align*} \mathbf{u}_t &amp;= - \mathbf{K} \lambda_t \left(S\right) \nabla p, \\ \nabla \cdot \mathbf{u}_t &amp;= q, \\ \epsilon \frac{\partial S}{\partial t} + \nabla \cdot \left( \mathbf{u}_t F\left( S \right) \right)&amp;=0, \end{align*}
</p>
<p> where \(S\) is the saturation (volume fraction between zero and one) of the second (wetting) phase, \(p\) is the pressure, \(\mathbf{K}\) is the permeability tensor, \(\lambda_t\) is the total mobility, \(\epsilon\) is the porosity, \(F\) is the fractional flow of the wetting phase, \(q\) is the source term and \(\mathbf{u}_t\) is the total velocity. The total mobility, fractional flow of the wetting phase and total velocity are respectively given by </p><p class="formulaDsp">
\begin{align*} \lambda_t(S)&amp;= \lambda_w + \lambda_{nw} = \frac{k_{rw}(S)}{\mu_w} + \frac{k_{rnw}(S)}{\mu_{nw}}, \\ F(S) &amp;= \frac{\lambda_w}{\lambda_t} = \frac{\lambda_w}{\lambda_w + \lambda_{nw}} = \frac{k_{rw}(S)/\mu_w}{k_{rw}(S)/\mu_w + k_{rnw}(S)/\mu_{nw}}, \\ \mathbf{u}_t &amp;= \mathbf{u}_w + \mathbf{u}_{nw} = -\lambda_t(S)\mathbf{K} \cdot \nabla p, \end{align*}
</p>
<p> where subscripts \(w, nw\) represent the wetting and non-wetting phases, respectively.</p>
<p>For convenience, the porosity \(\epsilon\) in the saturation equation, which can be considered a scaling factor for the time variable, is set to one. Following a commonly used prescription for the dependence of the relative permeabilities \(k_{rw}\) and \(k_{rnw}\) on saturation, we use </p><p class="formulaDsp">
\begin{align*} k_{rw} &amp;= S^2, \qquad&amp;\qquad k_{rnw} &amp;= \left( 1-S \right)^2. \end{align*}
</p>
<p>The porous media equations above are augmented by initial conditions for the saturation and boundary conditions for the pressure. Since saturation and the gradient of the pressure uniquely determine the velocity, no boundary conditions are necessary for the velocity. Since the flow equations do not contain time derivatives, initial conditions for the velocity and pressure variables are not required. The flow field separates the boundary into inflow or outflow parts. Specifically, </p><p class="formulaDsp">
\[ \mathbf{\Gamma}_{in}(t) = \left\{\mathbf{x} \in \partial \Omega:\mathbf{n} \cdot \mathbf{u}_t&lt;0\right\}, \]
</p>
<p> and we arrive at a complete model by also imposing boundary values for the saturation variable on the inflow boundary \(\mathbf{\Gamma}_{in}\).</p>
<p><a class="anchor" id="Adaptiveoperatorsplittingandtimestepping"></a></p><h3>Adaptive operator splitting and time stepping.</h3>
<p>As seen in <a class="el" href="step_21.html">step-21</a>, solving the flow equations for velocity and pressure are the parts of the program that take far longer than the (explicit) updating step for the saturation variable once we know the flow variables. On the other hand, the pressure and velocity depend only weakly on saturation, so one may think about only solving for pressure and velocity every few time steps while updating the saturation in every step. If we can find a criterion for when the flow variables need to be updated, we call this splitting an "adaptive
operator splitting" scheme.</p>
<p>Here, we use the following a posteriori criterion to decide when to re-compute pressure and velocity variables (detailed derivations and descriptions can be found in [Chueh, Djilali and Bangerth 2011]): </p><p class="formulaDsp">
\begin{align*} \theta(n,n_p) = \max_{\kappa\in{\mathbb T}} \left( \left\| \frac 1{\lambda_t\left(S^{(n-1)}\right)} - \frac 1{\lambda_t\left(S^{(n_p)}\right)} \right\|_{L^\infty(\kappa)} \left\|\|\mathbf{K}^{-1}\|_1\right\|_{L^\infty(\kappa)} \right). \end{align*}
</p>
<p> where superscripts in parentheses denote the number of the saturation time step at which any quantity is defined and \(n_p&lt;n\) represents the last step where we actually computed the pressure and velocity. If \(\theta(n,n_p)\) exceeds a certain threshold we re-compute the flow variables; otherwise, we skip this computation in time step \(n\) and only move the saturation variable one time step forward.</p>
<p>In short, the algorithm allows us to perform a number of saturation time steps of length \(\Delta t_c^{(n)}=t^{(n)}_c-t^{(n-1)}_c\) until the criterion above tells us to re-compute velocity and pressure variables, leading to a macro time step of length </p><p class="formulaDsp">
\[ \Delta t_p^{(n)} = \sum_{i=n_p+1}^{n} \Delta t_c^{(i)}. \]
</p>
<p> We choose the length of (micro) steps subject to the Courant-Friedrichs-Lewy (CFL) restriction according to the criterion </p><p class="formulaDsp">
\[ \Delta t_c = \frac{\textrm{min}_{K}h_{K}}{7 \|\mathbf{u}_t\|_{L^{\infty}\left(\Omega\right)}}, \]
</p>
<p> which we have confirmed to be stable for the choice of finite element and time stepping scheme for the saturation equation discussed below ( \(h_K\) denotes the diameter of cell \(K\)). The result is a scheme where neither micro nor macro time steps are of uniform length, and both are chosen adaptively.</p>
<p><a class="anchor" id="Timediscretization"></a></p><h3>Time discretization.</h3>
<p>Using this time discretization, we obtain the following set of equations for each time step from the IMPES approach (see <a class="el" href="step_21.html">step-21</a>): </p><p class="formulaDsp">
\begin{align*} \mathbf{u}^{(n)}_t + \lambda_t\left(S^{(n-1)}\right) \mathbf{K} \nabla p^{(n)} =0, \\ \nabla \cdot \mathbf{u}^{(n)}_t = q, \\ \epsilon \left( \frac{S^{(n-1)}-S^{(n)}}{\Delta t^{(n)}_c} \right) + \mathbf{u}^{(n)}_t \cdot \nabla F\left(S^{(n-1)}\right) + F\left(S^{(n-1)}\right) \nabla \cdot \mathbf{u}^{(n)}_t =0. \end{align*}
</p>
<p>Using the fact that \(\nabla \cdot \mathbf{u}_t = q\), the time discrete saturation equation becomes </p><p class="formulaDsp">
\begin{align*} &amp;\epsilon \left( \frac{S^{(n)}-S^{(n-1)}}{\Delta t^{(n)}_c} \right) + \mathbf{u}^{(n)}_t \cdot \nabla F\left(S^{(n-1)}\right) + F\left(S^{(n-1)}\right)q=0. \end{align*}
</p>
<p><a class="anchor" id="Weakformspacediscretizationforthepressurevelocitypart"></a></p><h3>Weak form, space discretization for the pressure-velocity part.</h3>
<p>By multiplying the equations defining the total velocity \(\mathbf u_t^{(n)}\) and the equation that expresses its divergence in terms of source terms, with test functions \(\mathbf{v}\) and \(w\) respectively and then integrating terms by parts as necessary, the weak form of the problem reads: Find \(\mathbf u, p\) so that for all test functions \(\mathbf{v}, w\) there holds </p><p class="formulaDsp">
\begin{gather*} \left( \left( \mathbf{K} \lambda_t\left(S^{(n-1)}\right) \right)^{-1} \mathbf{u}^{(n)}_t, \mathbf{v}\right)_{\Omega} - \left(p^{(n)}, \nabla \cdot \mathbf{v}\right)_{\Omega} = -\left(p^{(n)}, \mathbf{n} \cdot \mathbf{v} \right)_{\partial \Omega}, \\ - \left( \nabla \cdot \mathbf{u}^{(n)}_t,w\right)_{\Omega} = - \big(q,w\big)_{\Omega}. \end{gather*}
</p>
<p> Here, \(\mathbf{n}\) represents the unit outward normal vector to \(\partial \Omega\) and the pressure \(p^{(n)}\) can be prescribed weakly on the open part of the boundary \(\partial \Omega\) whereas on those parts where a velocity is prescribed (for example impermeable boundaries with \(\mathbf n \cdot \mathbf u=0\) the term disappears altogether because \(\mathbf n \cdot \mathbf v=0\).</p>
<p>We use continuous finite elements to discretize the velocity and pressure equations. Specifically, we use mixed finite elements to ensure high order approximation for both vector (e.g. a fluid velocity) and scalar variables (e.g. pressure) simultaneously. For saddle point problems, it is well established that the so-called Babuska-Brezzi or Ladyzhenskaya-Babuska-Brezzi (LBB) conditions [Brezzi 1991, Chen 2005] need to be satisfied to ensure stability of the pressure-velocity system. These stability conditions are satisfied in the present work by using elements for velocity that are one order higher than for the pressure, i.e. \(u_h \in Q^d_{p+1}\) and \(p_h \in Q_p\), where \(p=1\), \(d\) is the space dimension, and \(Q_s\) denotes the space of tensor product Lagrange polynomials of degree \(s\) in each variable.</p>
<p><a class="anchor" id="Stabilizationweakformandspacediscretizationforthesaturationtransportequation"></a></p><h3>Stabilization, weak form and space discretization for the saturation transport equation.</h3>
<p>The chosen \(Q_1\) elements for the saturation equation do not lead to a stable discretization without upwinding or other kinds of stabilization, and spurious oscillations will appear in the numerical solution. Adding an artificial diffusion term is one approach to eliminating these oscillations [Chen 2005]. On the other hand, adding too much diffusion smears sharp fronts in the solution and suffers from grid-orientation difficulties [Chen 2005]. To avoid these effects, we use the artificial diffusion term proposed by [Guermond and Pasquetti 2008] and validated in [Chueh, Djilali, Bangerth 2011] and [Kronbichler, Heister and Bangerth, 2011], as well as in <a class="el" href="step_31.html">step-31</a>.</p>
<p>This method modifies the (discrete) weak form of the saturation equation to read </p><p class="formulaDsp">
\begin{align*} \left(\epsilon \frac{\partial S_h}{\partial t},\sigma_h\right) - \left(\mathbf{u}_t F\left( S_h \right), \nabla \sigma_h\right) + \left(\mathbf n \cdot \mathbf{u}_t \hat F\left( S_h \right), \sigma_h\right)_{\partial\Omega} + (\nu(S_h) \nabla S_h, \nabla \sigma_h) &amp;=0 \qquad \forall \sigma_h, \end{align*}
</p>
<p> where \(\nu\) is the artificial diffusion parameter and \(\hat F\) is an appropriately chosen numerical flux on the boundary of the domain (we choose the obvious full upwind flux for this).</p>
<p>Following [Guermond and Pasquetti 2008] (and as detailed in [Chueh, Djilali and Bangerth 2011]), we use the parameter as a piecewise constant function set on each cell \(K\) with the diameter \(h_{K}\) as </p><p class="formulaDsp">
\[ \nu(S_h)|_{K} = \beta \| \mathbf{u}_t \max\{F&#39;(S_h),1\} \|_{L^{\infty}(K)} \textrm{min} \left\{ h_{K},h^{\alpha}_{K} \frac{\|\textrm{Res}(S_h)\|_{L^{\infty}(K)}}{c(\mathbf{u}_t,S)} \right\} \]
</p>
<p> where \(\alpha\) is a stabilization exponent and \(\beta\) is a dimensionless user-defined stabilization constant. Following [Guermond and Pasquetti 2008] as well as the implementation in <a class="el" href="step_31.html">step-31</a>, the velocity and saturation global normalization constant, \(c(\mathbf{u}_t,S)\), and the residual \(\textrm{Res}(S)\) are respectively given by </p><p class="formulaDsp">
\[ c(\mathbf{u}_t,S) = c_R \|\mathbf{u}_t \max\{F&#39;(S),1\}\|_{L^{\infty}(\Omega)} \textrm{var}(S)^\alpha | \textrm{diam} (\Omega) |^{\alpha - 2} \]
</p>
<p> and </p><p class="formulaDsp">
\[ \textrm{Res}(S) = \left( \epsilon \frac{\partial S}{\partial t} + \mathbf{u}_t \cdot \nabla F(S) + F(S)q \right) \cdot S^{\alpha - 1} \]
</p>
<p> where \(c_R\) is a second dimensionless user-defined constant, \(\textrm{diam}(\Omega)\) is the diameter of the domain and \(\textrm{var}(S) = \textrm{max}_{\Omega} S - \textrm{min}_{\Omega} S\) is the range of the present saturation values in the entire computational domain \(\Omega\).</p>
<p>This stabilization scheme has a number of advantages over simpler schemes such as finite volume (or discontinuous Galerkin) methods or streamline upwind Petrov Galerkin (SUPG) discretizations. In particular, the artificial diffusion term acts primarily in the vicinity of discontinuities since the residual is small in areas where the saturation is smooth. It therefore provides for a higher degree of accuracy. On the other hand, it is nonlinear since \(\nu\) depends on the saturation \(S\). We avoid this difficulty by treating all nonlinear terms explicitly, which leads to the following fully discrete problem at time step \(n\): </p><p class="formulaDsp">
\begin{align*} &amp;\left( \epsilon S_h^{(n)},\sigma_h\right)_{\Omega} - \Delta t^{(n)}_c \Big(F\left(S_h^{(n-1)}\right)\mathbf{u}^{*}_t,\nabla\sigma_h\Big)_{\Omega} + \Delta t^{(n)}_c \Big(F\left(S_h^{(n-1)}\right)\left(\mathbf{n}\cdot\mathbf{u}^{*}_t\right),\sigma_h\Big)_{\partial\Omega} \nonumber \\ &amp; \quad = \left( \epsilon S_h^{(n-1)},\sigma_h\right)_{\Omega} - \Delta t^{(n)}_c \bigg(\nu\left(S_h^{(n-1)}\right)\nabla S_h^{(n-1)},\nabla\sigma_h\bigg)_{\Omega} \nonumber \\ &amp; \qquad + \Delta t^{(n)}_c \bigg(\mathbf{n}\cdot\nu\left(S_h^{(n-1)}\right)\nabla S^{(n-1)},\sigma_h\bigg)_{\partial\Omega} \end{align*}
</p>
<p> where \(\mathbf{u}_t^{*}\) is the velocity linearly extrapolated from \(\mathbf{u}^{(n_p)}_t\) and \(\mathbf{u}^{(n_{pp})}_t\) to the current time \(t^{(n)}\) if \(\theta&lt;\theta^*\) while \(\mathbf{u}_t^{*}\) is \(\mathbf{u}^{(n_p)}_t\) if \(\theta&gt;\theta^*\). Consequently, the equation is linear in \(S_h^{(n)}\) and all that is required is to solve with a mass matrix on the saturation space.</p>
<p>Since the Dirichlet boundary conditions for saturation are only imposed on the inflow boundaries, the third term on the left hand side of the equation above needs to be split further into two parts: </p><p class="formulaDsp">
\begin{align*} &amp;\Delta t^{(n)}_c \Big(F\left(S_h^{(n-1)}\right)\left(\mathbf{n}\cdot\mathbf{u}^{(n)}_t\right),\sigma_h\Big)_{\partial\Omega} \nonumber \\ &amp;\qquad= \Delta t^{(n)}_c \Big(F\left(S^{(n-1)}_{(+)}\right)\left(\mathbf{n}\cdot\mathbf{u}^{(n)}_{t(+)}\right),\sigma_h\Big)_{\partial\Omega_{(+)}} + \Delta t^{(n)}_c \Big(F\left(S^{(n-1)}_{(-)}\right)\left(\mathbf{n}\cdot\mathbf{u}^{(n)}_{t(-)}\right),\sigma_h\Big)_{\partial\Omega_{(-)}} \end{align*}
</p>
<p> where \(\partial\Omega_{(-)} = \left\{\mathbf{x} \in \partial\Omega : \mathbf{n} \cdot \mathbf{u}_t&lt;0\right\}\) and \(\partial\Omega_{(+)} = \left\{\mathbf{x} \in \partial\Omega : \mathbf{n} \cdot \mathbf{u}_t&gt;0\right\}\) represent inflow and outflow boundaries, respectively. We choose values using an upwind formulation, i.e. \(S^{(n-1)}_{(+)}\) and \(\mathbf{u}^{(n)}_{t(+)}\) correspond to the values taken from the present cell, while the values of \(S^{(n-1)}_{(-)}\) and \(\mathbf{u}^{(n)}_{t(-)}\) are those taken from the neighboring boundary \(\partial\Omega_{(-)}\).</p>
<p><a class="anchor" id="Adaptivemeshrefinement"></a></p><h3>Adaptive mesh refinement.</h3>
<p>Choosing meshes adaptively to resolve sharp saturation fronts is an essential ingredient to achieve efficiency in our algorithm. Here, we use the same shock-type refinement approach used in [Chueh, Djilali and Bangerth 2011] to select those cells that should be refined or coarsened. The refinement indicator for each cell \(K\) of the triangulation is computed by </p><p class="formulaDsp">
\[ \eta_{K} = |\nabla S_h(\mathbf x_K)| \]
</p>
<p> where \(\nabla S_h(\mathbf x_K)\) is the gradient of the discrete saturation variable evaluated at the center \(\mathbf x_K\) of cell \(K\). This approach is analogous to ones frequently used in compressible flow problems, where density gradients are used to indicate refinement. That said, as we will discuss at the end of the <a href="#Results">results section</a>, this turns out to not be a very useful criterion since it leads to refinement basically everywhere. We only show it here for illustrative purposes.</p>
<p><a class="anchor" id="Linearsystemanditspreconditioning"></a></p><h3>Linear system and its preconditioning.</h3>
<p>Following the discretization of the governing equations discussed above, we obtain a linear system of equations in time step \((n)\) of the following form: </p><p class="formulaDsp">
\[ \left( \begin{array}{ccc} \mathbf{M}^{\mathbf{u}} &amp; \mathbf{B}^{T} &amp; \mathbf{0} \\ \mathbf{B} &amp; \mathbf{0} &amp; \mathbf{0} \\ \mathbf{H} &amp; \mathbf{0} &amp; \mathbf{M}^{S} \end{array} \right) \left( \begin{array}{c} \mathbf{U}^{(n)} \\ \mathbf{P}^{(n)} \\ \mathbf{S}^{(n)} \end{array} \right) = \left( \begin{array}{c} 0 \\ \mathbf{F}_{2} \\ \mathbf{F}_{3} \end{array} \right) \]
</p>
<p> where the individual matrices and vectors are defined as follows using shape functions \(\mathbf{v}_i\) for velocity, and \(\phi_i\) for both pressure and saturation: </p><p class="formulaDsp">
\begin{align*} \mathbf{M}^{\mathbf{u}}_{ij} &amp;= \left( \left( \mathbf{K} \lambda_t\left(S^{(n-1)}\right) \right)^{-1} \mathbf{v}_{i},\mathbf{v}_{j}\right)_{\Omega}, &amp; \mathbf{M}^{S}_{ij} &amp;= \left(\epsilon \phi_i,\phi_j\right)_{\Omega} \\ \mathbf{B}_{ij} &amp;= - \left( \nabla \cdot \mathbf{v}_{j},\phi_{i}\right)_{\Omega}, &amp; \mathbf{H}_{ij} &amp;= - \Delta t^{(n)}_c \Big( F\left(S^{(n-1)}\right) \mathbf{v}_i,\nabla\phi_j\Big)_{\Omega} \\ \left(\mathbf{F}_{2}\right)_i &amp;= - \big(F\left(S^{(n-1)}\right)q,\phi_i\big)_{\Omega}, \end{align*}
</p>
<p> and \(\mathbf{F}_{3}\) as given in the definition of the stabilized transport equation.</p>
<p>The linear system above is of block triangular form if we consider the top left \(2\times 2\) panel of matrices as one block. We can therefore first solve for the velocity and pressure (unless we decide to use \(\mathbf U^{(n_p)}\) in place of the velocity) followed by a solve for the saturation variable. The first of these steps requires us to solve </p><p class="formulaDsp">
\[ \left( \begin{array}{cc} \mathbf{M}^{\mathbf{u}} &amp; \mathbf{B}^{T} \\ \mathbf{B} &amp; \mathbf{0} \end{array} \right) \left( \begin{array}{c} \mathbf{U}^{(n)} \\ \mathbf{P}^{(n)} \end{array} \right) = \left( \begin{array}{c} 0 \\ \mathbf{F}_{2} \end{array} \right) \]
</p>
<p> We apply the Generalized Minimal Residual (GMRES) method [Saad and Schultz 1986] to this linear system. The ideal preconditioner for the velocity-pressure system is </p><p class="formulaDsp">
\begin{align*} \mathbf{P} = \left( \begin{array}{cc} \mathbf{M}^{\mathbf{u}} &amp; \mathbf{0} \\ \mathbf{B} &amp; -\mathbf{S} \end{array} \right), &amp; \qquad \mathbf{P}^{-1} = \left( \begin{array}{cc} \left(\mathbf{M}^{\mathbf{u}}\right)^{-1} &amp; \mathbf{0} \\ \mathbf{S}^{-1} \mathbf{B} \left(\mathbf{M}^{\mathbf{u}}\right)^{-1} &amp; -\mathbf{S}^{-1} \end{array} \right) \end{align*}
</p>
<p> where \(\mathbf{S}=\mathbf{B}\left(\mathbf{M}^{\mathbf{u}}\right)^{-1}\mathbf{B}^T\) is the Schur complement [Zhang 2005] of the system. This preconditioner is optimal since </p><p class="formulaDsp">
\begin{align*} \mathbf{P}^{-1} \left( \begin{array}{cc} \mathbf{M}^{\mathbf{u}} &amp; \mathbf{B}^{T} \\ \mathbf{B} &amp; \mathbf{0} \end{array} \right) = \left( \begin{array}{cc} \mathbf{I} &amp; \left(\mathbf{M}^{\mathbf{u}}\right)^{-1} \mathbf{B}^{T} \\ \mathbf{0} &amp; \mathbf{I} \end{array} \right), \end{align*}
</p>
<p> for which it can be shown that GMRES converges in two iterations.</p>
<p>However, we cannot of course expect to use exact inverses of the velocity mass matrix and the Schur complement. We therefore follow the approach by [Silvester and Wathen 1994] originally proposed for the Stokes system. Adapting it to the current set of equations yield the preconditioner </p><p class="formulaDsp">
\begin{align*} \mathbf{\tilde{P}}^{-1} = \left( \begin{array}{cc} \widetilde{\left(\mathbf{{M}}^{\mathbf{u}}\right)^{-1}} &amp; \mathbf{0} \\ \widetilde{\mathbf{{S}}^{-1}} \mathbf{B} \widetilde{\left(\mathbf{{M}}^{\mathbf{u}}\right)^{-1}} &amp; -\widetilde{\mathbf{{S}}^{-1}} \end{array} \right) \end{align*}
</p>
<p> where a tilde indicates an approximation of the exact inverse matrix. In particular, since \(\left(\mathbf{{M}}^{\mathbf{u}}\right)^{-1}=\left( \left( \mathbf{K} \lambda_t \right)^{-1} \mathbf{v}_{i},\mathbf{v}_{j}\right)_{\Omega}\) is a sparse symmetric and positive definite matrix, we choose for \(\widetilde{\left(\mathbf{{M}}^{\mathbf{u}}\right)^{-1}}\) a single application of a sparse incomplete Cholesky decomposition of this matrix [Golub and Van Loan 1996]. We note that the Schur complement that corresponds to the porous media flow operator in non-mixed form, \(-\nabla \cdot [\mathbf K \lambda_t(S)]\nabla\) and \(\mathbf{\tilde {S}} = \left( \left( \mathbf{K} \lambda_t \right) \nabla \phi_{i},\nabla \phi_{j}\right)_{\Omega}\) should be a good approximation of the actual Schur complement matrix \(\mathbf S\). Since both of these matrices are again symmetric and positive definite, we use an incomplete Cholesky decomposition of \(\mathbf{\tilde S}\) for \(\widetilde {\mathbf{{S}}^{-1}}\). It is important to note that \(\mathbf{\tilde S}\) needs to be built with Dirichlet boundary conditions to ensure its invertibility.</p>
<p>Once the velocity \(\mathbf{U}^{(n)} \equiv \mathbf{u}^*_t\) is available, we can assemble \(\mathbf{H}\) and \(\mathbf{F}_{3}\) and solve for the saturations using </p><p class="formulaDsp">
\begin{align*} \mathbf{M}^{S} \mathbf{S}^{(n)} = \mathbf{F}_{3} - \mathbf{H} \mathbf{U}^{(n)}. \end{align*}
</p>
<p> where the mass matrix \(\mathbf{M}^{S}\) is solved by the conjugate gradient method, using an incomplete Cholesky decomposition as preconditioner once more.</p>
<p><a class="anchor" id="Thetestcases"></a></p><h3>The test cases.</h3>
<dl class="section note"><dt>Note</dt><dd>The implementation discussed here uses and extends parts of the <a class="el" href="step_21.html">step-21</a>, <a class="el" href="step_31.html">step-31</a> and <a class="el" href="step_33.html">step-33</a> tutorial programs of this library. In particular, if you want to understand how it works, please consult <a class="el" href="step_21.html">step-21</a> for a discussion of the mathematical problem, and <a class="el" href="step_31.html">step-31</a> from which most of the implementation is derived. We will not discuss aspects of the implementation that have already been discussed in <a class="el" href="step_31.html">step-31</a>.</dd></dl>
<p>We show numerical results for some two-phase flow equations augmented by appropriate initial and boundary conditions in conjunction with two different choices of the permeability model. In the problems considered, there is no internal source term ( \(q=0\)). As mentioned above, quantitative numerical results are presented in [Chueh, Djilali and Bangerth 2011].</p>
<p>For simplicity, we choose \(\Omega=[0,1]^d,d=2,3\), though all methods (as well as our implementation) should work equally well on general unstructured meshes.</p>
<p>Initial conditions are only required for the saturation variable, and we choose \(S(\mathbf{x},0)=0.2\), i.e. the porous medium is initially filled by a mixture of the non-wetting (80%) and wetting (20%) phases. This differs from the initial condition in <a class="el" href="step_21.html">step-21</a> where we had taken \(S(\mathbf{x},0)=0\), but for complicated mathematical reasons that are mentioned there in a longish remark, the current method using an entropy-based artificial diffusion term does not converge to the viscosity solution with this initial condition without additional modifications to the method. We therefore choose this modified version for the current program.</p>
<p>Furthermore, we prescribe a linear pressure on the boundaries: </p><p class="formulaDsp">
\[ p(\mathbf{x},t) = 1 - x \qquad \textrm{on} \quad \partial \Omega \times [0,T]. \]
</p>
<p> Pressure and saturation uniquely determine a velocity, and the velocity determines whether a boundary segment is an inflow or outflow boundary. On the inflow part of the boundary, \(\mathbf{\Gamma}_{in}(t)\), we impose </p><p class="formulaDsp">
\begin{align*} S(\mathbf{x},t) = 1 \qquad &amp; \textrm{on} \quad \mathbf{\Gamma}_{in}(t) \cap \left\{x = 0\right\}, \\ S(\mathbf{x},t) = 0 \qquad &amp; \textrm{on} \quad \mathbf{\Gamma}_{in}(t) \backslash \left\{x = 0\right\}. \end{align*}
</p>
<p> In other words, the domain is flooded by the wetting phase from the left. No boundary conditions for the saturation are required for the outflow parts of the boundary.</p>
<p>All the numerical and physical parameters used for the 2D/3D cases are listed in the following table:</p>
<table align="center" class="tutorial" width="50%">
<tr>
<th>Parameter </th><th>Symbol </th><th>Value </th><th>units </th></tr>
<tr>
<td>Porosity </td><td>\(\epsilon\) </td><td>1.0 </td><td>- </td></tr>
<tr>
<td>Viscosity (wetting) </td><td>\(\mu_w\) </td><td>0.2 </td><td>\(kg \cdot m^{-1} \cdot sec^{-1}\) </td></tr>
<tr>
<td>Viscosity (nonwetting) </td><td>\(\mu_{nw}\) </td><td>1.0 </td><td>\(kg \cdot m^{-1} \cdot sec^{-1}\) </td></tr>
<tr>
<td>Stabilization exponent </td><td>\(\alpha\) </td><td>1.0 </td><td>- </td></tr>
<tr>
<td>Stabilization constant </td><td>\(\beta\) </td><td>2D: 0.3; 3D: 0.27 </td><td>- </td></tr>
<tr>
<td>Normalization constant </td><td>\(c_R\) </td><td>1.0 </td><td>- </td></tr>
<tr>
<td>Number of high-permeability regions </td><td>\(N\) </td><td>50; 200 </td><td>- </td></tr>
<tr>
<td>Operator splitting threshold </td><td>\(\theta^\ast\) </td><td>5.0 </td><td>-  </td></tr>
</table>
<p><a class="anchor" id="Listofreferences"></a></p><h3>List of references</h3>
<ol>
<li>
<p class="startli">CC Chueh, N Djilali and W Bangerth. <br />
 An h-adaptive operator splitting method for two-phase flow in 3D heterogeneous porous media. <br />
 SIAM Journal on Scientific Computing, vol. 35 (2013), pp. B149-B175</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">M. Kronbichler, T. Heister, and W. Bangerth <br />
 High Accuracy Mantle Convection Simulation through Modern Numerical Methods. <br />
 Geophysics Journal International, vol. 191 (2012), pp. 12-29</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">F Brezzi and M Fortin. <br />
 <em>Mixed and Hybrid Finite Element Methods</em>. <br />
 Springer-Verlag, 1991.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Z Chen. <br />
 <em>Finite Element Methods and Their Applications</em>. <br />
 Springer, 2005.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">JL Guermond and R Pasquetti. <br />
 Entropy-based nonlinear viscosity for Fourier approximations of conservation laws. <br />
 <em>Comptes Rendus Mathematique</em>, 346(13-14):801-806, 2008.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">CC Chueh, M Secanell, W Bangerth, and N Djilali. <br />
 Multi-level adaptive simulation of transient two-phase flow in heterogeneous porous media. <br />
 <em>Computers and Fluids</em>, 39:1585-1596, 2010.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Y Saad and MH Schultz. <br />
 Gmres: A generalized minimal residual algorithm for solving nonsymmetric linear systems. <br />
 <em>SIAM Journal on Scientific and Statistical Computing</em>, 7(3):856-869, 1986.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">F Zhang. <br />
 <em>The Schur Complement and its Applications</em>. <br />
 Springer, 2005.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">D Silvester and A Wathen. <br />
 Fast iterative solution of stabilised Stokes systems part ii: Using general block preconditioners. <br />
 <em>SIAM Journal on Numerical Analysis</em>, 31(5):1352-1367, 1994.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">GH Golub and CF van Loan. <br />
 <em>Matrix Computations</em>. <br />
 3rd Edition, Johns Hopkins, 1996.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">SE Buckley and MC Leverett. <br />
 Mechanism of fluid displacements in sands. <br />
 <em>AIME Trans.</em>, 146:107-116, 1942.</p>
<p class="endli"></p>
</li>
</ol>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first step, as always, is to include the functionality of a number of deal.II and C++ header files.</p>
<p>The list includes some header files that provide vector, matrix, and preconditioner classes that implement interfaces to the respective Trilinos classes; some more information on these may be found in <a class="el" href="step_31.html">step-31</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div></div><!-- fragment --><p>At the end of this top-matter, we open a namespace for the current project into which all the following material will go, and then import all deal.II names into this namespace:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step43</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Boundaryandinitialvalueclasses"></a> </p><h3>Boundary and initial value classes</h3>
<p>The following part is taken directly from <a class="el" href="step_21.html">step-21</a> so there is no need to repeat the descriptions found there.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PressureBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PressureBoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">PressureBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 1 - p[0];</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SaturationBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SaturationBoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">SaturationBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (p[0] == 0)</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SaturationInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SaturationInitialValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">SaturationInitialValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 0.2;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SaturationInitialValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                                <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = SaturationInitialValues&lt;dim&gt;::value(p, c);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Permeabilitymodels"></a> </p><h3>Permeability models</h3>
<p>In this tutorial, we still use the two permeability models previously used in <a class="el" href="step_21.html">step-21</a> so we again refrain from commenting in detail about them.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SingleCurvingCrack</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    KInverse()</div><div class="line">      : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">    value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">               std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> KInverse&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                 std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">      {</div><div class="line">        values[p].clear();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> distance_to_flowline =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0]));</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> permeability =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::exp(-(distance_to_flowline * distance_to_flowline) /</div><div class="line">                            (0.1 * 0.1)),</div><div class="line">                   0.01);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          values[p][d][d] = 1. / permeability;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace SingleCurvingCrack</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>RandomMedium</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    KInverse()</div><div class="line">      : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">    value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">               std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; centers;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;Point&lt;dim&gt;&gt; KInverse&lt;dim&gt;::centers = []() {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N =</div><div class="line">      (dim == 2 ? 40 : (dim == 3 ? 100 : <span class="keywordflow">throw</span> <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()));</div><div class="line"></div><div class="line">    std::vector&lt;Point&lt;dim&gt;&gt; centers_list(N);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a>; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        centers_list[i][d] = static_cast&lt;double&gt;(rand()) / RAND_MAX;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> centers_list;</div><div class="line">  }();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> KInverse&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                 std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(points.size(), values.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">      {</div><div class="line">        values[p].clear();</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> permeability = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; centers.size(); ++i)</div><div class="line">          permeability +=</div><div class="line">            std::exp(-(points[p] - centers[i]).norm_square() / (0.05 * 0.05));</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> normalized_permeability =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(permeability, 0.01), 4.);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          values[p][d][d] = 1. / normalized_permeability;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace RandomMedium</span></div></div><!-- fragment --><p><a class="anchor" id="Physicalquantities"></a> </p><h3>Physical quantities</h3>
<p>The implementations of all the physical quantities such as total mobility \(\lambda_t\) and fractional flow of water \(F\) are taken from <a class="el" href="step_21.html">step-21</a> so again we don't have do any comment about them. Compared to <a class="el" href="step_21.html">step-21</a> we have added checks that the saturation passed to these functions is in fact within the physically valid range. Furthermore, given that the wetting phase moves at speed \(\mathbf u F&#39;(S)\) it is clear that \(F&#39;(S)\) must be greater or equal to zero, so we assert that as well to make sure that our calculations to get at the formula for the derivative made sense.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> mobility_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> fractional_flow(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((S &gt;= 0) &amp;&amp; (S &lt;= 1),</div><div class="line">         <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Saturation is outside its physically valid range.&quot;</span>));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> S * S / (S * S + viscosity * (1 - S) * (1 - S));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> fractional_flow_derivative(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((S &gt;= 0) &amp;&amp; (S &lt;= 1),</div><div class="line">         <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Saturation is outside its physically valid range.&quot;</span>));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> temp = (S * S + viscosity * (1 - S) * (1 - S));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> numerator =</div><div class="line">    2.0 * S * temp - S * S * (2.0 * S - 2.0 * viscosity * (1 - S));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> denominator = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(temp, 2.0);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> F_prime = numerator / denominator;</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(F_prime &gt;= 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> F_prime;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Helperclassesforsolversandpreconditioners"></a> </p><h3>Helper classes for solvers and preconditioners</h3>
<p>In this first part we define a number of classes that we need in the construction of linear solvers and preconditioners. This part is essentially the same as that used in <a class="el" href="step_31.html">step-31</a>. The only difference is that the original variable name stokes_matrix is replaced by another name darcy_matrix to match our problem.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>LinearSolvers</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                  <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">    <span class="keywordtype">void</span> vmult(<a class="code" href="classVectorType.html">VectorType</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">    <span class="keyword">const</span> PreconditionerType &amp;           preconditioner;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">    <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">    <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">    : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">    , preconditioner(preconditioner)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">  <span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">    <a class="code" href="classVectorType.html">VectorType</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>        solver_control(src.size(), 1e-7 * src.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;VectorType&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">    dst = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">try</span></div><div class="line">      {</div><div class="line">        cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, preconditioner);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">catch</span> (std::exception &amp;e)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(e.what()));</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">  <span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BlockSchurPreconditioner(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">      <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                          PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">      <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#aff5a880cfa288ecdd2a83a876abacf0d">vmult</a>(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">      darcy_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;<span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                           PreconditionerTypeMp&gt;&gt;</div><div class="line">                               m_inverse;</div><div class="line">    <span class="keyword">const</span> PreconditionerTypeA &amp;a_preconditioner;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">  BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::</div><div class="line">    BlockSchurPreconditioner(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">      <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                          PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">      <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner)</div><div class="line">    : darcy_matrix(&amp;S)</div><div class="line">    , m_inverse(&amp;Mpinv)</div><div class="line">    , a_preconditioner(Apreconditioner)</div><div class="line">    , tmp(<a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(darcy_matrix-&gt;block(1, 1).m()))</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::vmult(</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    a_preconditioner.vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">    darcy_matrix-&gt;block(1, 0).residual(tmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">    tmp *= -1;</div><div class="line">    m_inverse-&gt;vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace LinearSolvers</span></div></div><!-- fragment --><p><a class="anchor" id="TheTwoPhaseFlowProblemclass"></a> </p><h3>The TwoPhaseFlowProblem class</h3>
<p>The definition of the class that defines the top-level logic of solving the time-dependent advection-dominated two-phase flow problem (or Buckley-Leverett problem [Buckley 1942]) is mainly based on tutorial programs <a class="el" href="step_21.html">step-21</a> and <a class="el" href="step_33.html">step-33</a>, and in particular on <a class="el" href="step_31.html">step-31</a> where we have used basically the same general structure as done here. As in <a class="el" href="step_31.html">step-31</a>, the key routines to look for in the implementation below are the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> and <code>solve()</code> functions.</p>
<p>The main difference to <a class="el" href="step_31.html">step-31</a> is that, since adaptive operator splitting is considered, we need a couple more member variables to hold the last two computed Darcy (velocity/pressure) solutions in addition to the current one (which is either computed directly, or extrapolated from the previous two), and we need to remember the last two times we computed the Darcy solution. We also need a helper function that figures out whether we do indeed need to recompute the Darcy solution.</p>
<p>Unlike <a class="el" href="step_31.html">step-31</a>, this step uses one more <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object called darcy_preconditioner_constraints. This constraint object is used only for assembling the matrix for the Darcy preconditioner and includes hanging node constraints as well as Dirichlet boundary value constraints for the pressure variable. We need this because we are building a Laplace matrix for the pressure as an approximation of the Schur complement) which is only positive definite if boundary conditions are applied.</p>
<p>The collection of member functions and variables thus declared in this class is then rather similar to those in <a class="el" href="step_31.html">step-31</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>TwoPhaseFlowProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_dofs();</div><div class="line">  <span class="keywordtype">void</span> assemble_darcy_preconditioner();</div><div class="line">  <span class="keywordtype">void</span> build_darcy_preconditioner();</div><div class="line">  <span class="keywordtype">void</span> assemble_darcy_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_saturation_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_saturation_matrix();</div><div class="line">  <span class="keywordtype">void</span> assemble_saturation_rhs();</div><div class="line">  <span class="keywordtype">void</span> assemble_saturation_rhs_cell_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       saturation_fe_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       darcy_fe_values,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_max_u_F_prime,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_S_variation,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices);</div><div class="line">  <span class="keywordtype">void</span> assemble_saturation_rhs_boundary_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   saturation_fe_face_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   darcy_fe_face_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices);</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_grid_level,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div></div><!-- fragment --><p>We follow with a number of helper functions that are used in a variety of places throughout the program:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span>                    get_max_u_F_prime() <span class="keyword">const</span>;</div><div class="line">std::pair&lt;double, double&gt; get_extrapolated_saturation_range() <span class="keyword">const</span>;</div><div class="line"><span class="keywordtype">bool</span>   determine_whether_to_solve_for_pressure_and_velocity() <span class="keyword">const</span>;</div><div class="line"><span class="keywordtype">void</span>   project_back_saturation();</div><div class="line"><span class="keywordtype">double</span> compute_viscosity(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_saturation,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_saturation,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_saturation_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_saturation_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;present_darcy_values,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_max_u_F_prime,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_S_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter) <span class="keyword">const</span>;</div></div><!-- fragment --><p>This all is followed by the member variables, most of which are similar to the ones in <a class="el" href="step_31.html">step-31</a>, with the exception of the ones that pertain to the macro time stepping for the velocity/pressure system:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="keywordtype">double</span>             global_Omega_diameter;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        darcy_degree;</div><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             darcy_fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           darcy_dof_handler;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> darcy_constraints;</div><div class="line"></div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> darcy_preconditioner_constraints;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> darcy_matrix;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> darcy_preconditioner_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> darcy_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> darcy_rhs;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> last_computed_darcy_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> second_last_computed_darcy_solution;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        saturation_degree;</div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 saturation_fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           saturation_dof_handler;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> saturation_constraints;</div><div class="line"></div><div class="line">TrilinosWrappers::SparseMatrix saturation_matrix;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> saturation_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_saturation_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_saturation_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> saturation_rhs;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a></div><div class="line">  saturation_matching_last_computed_darcy_solution;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> saturation_refinement_threshold;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span>       time;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> end_time;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> current_macro_time_step;</div><div class="line"><span class="keywordtype">double</span> old_macro_time_step;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span>       time_step;</div><div class="line"><span class="keywordtype">double</span>       old_time_step;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> viscosity;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> porosity;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> AOS_threshold;</div><div class="line"></div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt; Amg_preconditioner;</div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt; Mp_preconditioner;</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> rebuild_saturation_matrix;</div></div><!-- fragment --><p>At the very end we declare a variable that denotes the material model. Compared to <a class="el" href="step_21.html">step-21</a>, we do this here as a member variable since we will want to use it in a variety of places and so having a central place where such a variable is declared will make it simpler to replace one class by another (e.g. replace RandomMedium::KInverse by SingleCurvingCrack::KInverse).</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> RandomMedium::KInverse&lt;dim&gt; k_inverse;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimTwoPhaseFlowProblem"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::TwoPhaseFlowProblem</h3>
<p>The constructor of this class is an extension of the constructors in <a class="el" href="step_21.html">step-21</a> and <a class="el" href="step_31.html">step-31</a>. We need to add the various variables that concern the saturation. As discussed in the introduction, we are going to use \(Q_2 \times Q_1\) (Taylor-Hood) elements again for the Darcy system, an element combination that fulfills the Ladyzhenskaya-Babuska-Brezzi (LBB) conditions [Brezzi and Fortin 1991, Chen 2005], and \(Q_1\) elements for the saturation. However, by using variables that store the polynomial degree of the Darcy and temperature finite elements, it is easy to consistently modify the degree of the elements as well as all quadrature formulas used on them downstream. Moreover, we initialize the time stepping variables related to operator splitting as well as the option for matrix assembly and preconditioning:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TwoPhaseFlowProblem&lt;dim&gt;::TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">  , global_Omega_diameter(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">  , degree(degree)</div><div class="line">  , darcy_degree(degree)</div><div class="line">  , darcy_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(darcy_degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(darcy_degree), 1)</div><div class="line">  , darcy_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  saturation_degree(degree + 1)</div><div class="line">  , saturation_fe(saturation_degree)</div><div class="line">  , saturation_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  saturation_refinement_threshold(0.5)</div><div class="line">  ,</div><div class="line"></div><div class="line">  time(0)</div><div class="line">  , end_time(10)</div><div class="line">  ,</div><div class="line"></div><div class="line">  current_macro_time_step(0)</div><div class="line">  , old_macro_time_step(0)</div><div class="line">  ,</div><div class="line"></div><div class="line">  time_step(0)</div><div class="line">  , old_time_step(0)</div><div class="line">  , timestep_number(0)</div><div class="line">  , viscosity(0.2)</div><div class="line">  , porosity(1.0)</div><div class="line">  , AOS_threshold(3.0)</div><div class="line">  ,</div><div class="line"></div><div class="line">  rebuild_saturation_matrix(true)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimsetup_dofs"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::setup_dofs</h3>
<p>This is the function that sets up the <a class="el" href="classDoFHandler.html">DoFHandler</a> objects we have here (one for the Darcy part and one for the saturation part) as well as set to the right sizes the various objects required for the linear algebra in this program. Its basic operations are similar to what <a class="el" href="step_31.html">step-31</a> did.</p>
<p>The body of the function first enumerates all degrees of freedom for the Darcy and saturation systems. For the Darcy part, degrees of freedom are then sorted to ensure that velocities precede pressure DoFs so that we can partition the Darcy matrix into a \(2 \times 2\) matrix.</p>
<p>Then, we need to incorporate hanging node constraints and Dirichlet boundary value constraints into darcy_preconditioner_constraints. The boundary condition constraints are only set on the pressure component since the Schur complement preconditioner that corresponds to the porous media flow operator in non-mixed form, \(-\nabla \cdot [\mathbf K \lambda_t(S)]\nabla\), acts only on the pressure variable. Therefore, we use a component_mask that filters out the velocity component, so that the condensation is performed on pressure degrees of freedom only.</p>
<p>After having done so, we count the number of degrees of freedom in the various blocks. This information is then used to create the sparsity pattern for the Darcy and saturation system matrices as well as the preconditioner matrix from which we build the Darcy preconditioner. As in <a class="el" href="step_31.html">step-31</a>, we choose to create the pattern using the blocked version of <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>. So, for this, we follow the same way as <a class="el" href="step_31.html">step-31</a> did and we don't have to repeat descriptions again for the rest of the member function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; darcy_block_component(dim + 1, 0);</div><div class="line">  darcy_block_component[dim] = 1;</div><div class="line">  {</div><div class="line">    darcy_dof_handler.distribute_dofs(darcy_fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(darcy_dof_handler);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(darcy_dof_handler, darcy_block_component);</div><div class="line"></div><div class="line">    darcy_constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(darcy_dof_handler,</div><div class="line">                                            darcy_constraints);</div><div class="line">    darcy_constraints.close();</div><div class="line">  }</div><div class="line">  {</div><div class="line">    saturation_dof_handler.distribute_dofs(saturation_fe);</div><div class="line"></div><div class="line">    saturation_constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(saturation_dof_handler,</div><div class="line">                                            saturation_constraints);</div><div class="line">    saturation_constraints.close();</div><div class="line">  }</div><div class="line">  {</div><div class="line">    darcy_preconditioner_constraints.clear();</div><div class="line"></div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(darcy_dof_handler,</div><div class="line">                                            darcy_preconditioner_constraints);</div><div class="line">    <a class="code" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a>(darcy_dof_handler,</div><div class="line">                                             darcy_preconditioner_constraints,</div><div class="line">                                             darcy_fe.component_mask(</div><div class="line">                                               pressure));</div><div class="line"></div><div class="line">    darcy_preconditioner_constraints.close();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; darcy_dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(darcy_dof_handler,</div><div class="line">                                      darcy_block_component);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = darcy_dofs_per_block[0],</div><div class="line">                     n_p = darcy_dofs_per_block[1],</div><div class="line">                     n_s = saturation_dof_handler.n_dofs();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_s &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">            &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_s &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    darcy_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">    dsp.block(0, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_u);</div><div class="line">    dsp.block(0, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_p);</div><div class="line">    dsp.block(1, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_u);</div><div class="line">    dsp.block(1, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_p);</div><div class="line"></div><div class="line">    dsp.collect_sizes();</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (d == dim)))</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">      darcy_dof_handler, coupling, dsp, darcy_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    darcy_matrix.reinit(dsp);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    Amg_preconditioner.reset();</div><div class="line">    Mp_preconditioner.reset();</div><div class="line">    darcy_preconditioner_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">    dsp.block(0, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_u);</div><div class="line">    dsp.block(0, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_p);</div><div class="line">    dsp.block(1, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_u);</div><div class="line">    dsp.block(1, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_p);</div><div class="line"></div><div class="line">    dsp.collect_sizes();</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        <span class="keywordflow">if</span> (c == d)</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">      darcy_dof_handler, coupling, dsp, darcy_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    darcy_preconditioner_matrix.reinit(dsp);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  {</div><div class="line">    saturation_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_s, n_s);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(saturation_dof_handler,</div><div class="line">                                    dsp,</div><div class="line">                                    saturation_constraints,</div><div class="line">                                    <span class="keyword">false</span>);</div><div class="line"></div><div class="line"></div><div class="line">    saturation_matrix.reinit(dsp);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::vector&lt;IndexSet&gt; darcy_partitioning(2);</div><div class="line">  darcy_partitioning[0] = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_u);</div><div class="line">  darcy_partitioning[1] = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_p);</div><div class="line">  darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">  darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">  last_computed_darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">  last_computed_darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">  second_last_computed_darcy_solution.reinit(darcy_partitioning,</div><div class="line">                                             MPI_COMM_WORLD);</div><div class="line">  second_last_computed_darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">  darcy_rhs.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">  darcy_rhs.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> saturation_partitioning = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_s);</div><div class="line">  saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  saturation_matching_last_computed_darcy_solution.reinit(</div><div class="line">    saturation_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  saturation_rhs.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblingmatricesandpreconditioners"></a> </p><h3>Assembling matrices and preconditioners</h3>
<p>The next few functions are devoted to setting up the various system and preconditioner matrices and right hand sides that we have to deal with in this program.</p>
<p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_darcy_preconditioner"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_preconditioner</h4>
<p>This function assembles the matrix we use for preconditioning the Darcy system. What we need are a vector mass matrix weighted by \(\left(\mathbf{K} \lambda_t\right)^{-1}\) on the velocity components and a mass matrix weighted by \(\left(\mathbf{K} \lambda_t\right)\) on the pressure component. We start by generating a quadrature object of appropriate order, the <a class="el" href="classFEValues.html">FEValues</a> object that can give values and gradients at the quadrature points (together with quadrature weights). Next we create data structures for the cell matrix and the relation between local and global DoFs. The vectors phi_u and grad_phi_p are going to hold the values of the basis functions in order to faster build up the local matrices, as was already done in <a class="el" href="step_22.html">step-22</a>. Before we start the loop over all active cells, we have to specify which components are pressure and which are velocity.</p>
<p>The creation of the local matrix is rather simple. There are only a term weighted by \(\left(\mathbf{K} \lambda_t\right)^{-1}\) (on the velocity) and a Laplace matrix weighted by \(\left(\mathbf{K} \lambda_t\right)\) to be generated, so the creation of the local matrix is done in essentially two lines. Since the material model functions at the top of this file only provide the inverses of the permeability and mobility, we have to compute \(\mathbf K\) and \(\lambda_t\) by hand from the given values, once per quadrature point.</p>
<p>Once the local matrix is ready (loop over rows and columns in the local matrix on each quadrature point), we get the local DoF indices and write the local information into the global matrix. We do this by directly applying the constraints (i.e. darcy_preconditioner_constraints) that takes care of hanging node and zero Dirichlet boundary condition constraints. By doing so, we don't have to do that afterwards, and we later don't have to use <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense</a> and <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>, both functions that would need to modify matrix and vector entries and so are difficult to write for the Trilinos classes where we don't immediately have access to individual memory locations.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_preconditioner()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding darcy preconditioner...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  darcy_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(darcy_degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     darcy_fe_values(darcy_fe,</div><div class="line">                                quadrature_formula,</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     saturation_fe_values(saturation_fe,</div><div class="line">                                     quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = darcy_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; phi_u(dofs_per_cell);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">  <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">    {</div><div class="line">      darcy_fe_values.reinit(cell);</div><div class="line">      saturation_fe_values.reinit(saturation_cell);</div><div class="line"></div><div class="line">      local_matrix = 0;</div><div class="line"></div><div class="line">      saturation_fe_values.get_function_values(old_saturation_solution,</div><div class="line">                                               old_saturation_values);</div><div class="line"></div><div class="line">      k_inverse.value_list(darcy_fe_values.get_quadrature_points(),</div><div class="line">                           k_inverse_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_saturation_values[q];</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> inverse_mobility = mobility_inverse(old_s, viscosity);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> mobility         = 1.0 / inverse_mobility;</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> permeability = <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(k_inverse_values[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              phi_u[k]      = darcy_fe_values[velocities].value(k, q);</div><div class="line">              grad_phi_p[k] = darcy_fe_values[pressure].gradient(k, q);</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                local_matrix(i, j) +=</div><div class="line">                  (k_inverse_values[q] * inverse_mobility * phi_u[i] *</div><div class="line">                     phi_u[j] +</div><div class="line">                   permeability * mobility * grad_phi_p[i] * grad_phi_p[j]) *</div><div class="line">                  darcy_fe_values.JxW(q);</div><div class="line">              }</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      darcy_preconditioner_constraints.distribute_local_to_global(</div><div class="line">        local_matrix, local_dof_indices, darcy_preconditioner_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimbuild_darcy_preconditioner"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::build_darcy_preconditioner</h4>
<p>After calling the above functions to assemble the preconditioner matrix, this function generates the inner preconditioners that are going to be used for the Schur complement block preconditioner. The preconditioners need to be regenerated at every saturation time step since they depend on the saturation \(S\) that varies with time.</p>
<p>In here, we set up the preconditioner for the velocity-velocity matrix \(\mathbf{M}^{\mathbf{u}}\) and the Schur complement \(\mathbf{S}\). As explained in the introduction, we are going to use an IC preconditioner based on the vector matrix \(\mathbf{M}^{\mathbf{u}}\) and another based on the scalar Laplace matrix \(\tilde{\mathbf{S}}^p\) (which is spectrally close to the Schur complement of the Darcy matrix). Usually, the <a class="el" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a> class can be seen as a good black-box preconditioner which does not need any special knowledge of the matrix structure and/or the operator that's behind it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::build_darcy_preconditioner()</div><div class="line">{</div><div class="line">  assemble_darcy_preconditioner();</div><div class="line"></div><div class="line">  Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">  Amg_preconditioner-&gt;initialize(darcy_preconditioner_matrix.block(0, 0));</div><div class="line"></div><div class="line">  Mp_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">  Mp_preconditioner-&gt;initialize(darcy_preconditioner_matrix.block(1, 1));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_darcy_system"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_system</h4>
<p>This is the function that assembles the linear system for the Darcy system.</p>
<p>Regarding the technical details of implementation, the procedures are similar to those in <a class="el" href="step_22.html">step-22</a> and <a class="el" href="step_31.html">step-31</a>. We reset matrix and vector, create a quadrature formula on the cells, and then create the respective <a class="el" href="classFEValues.html">FEValues</a> object.</p>
<p>There is one thing that needs to be commented: since we have a separate finite element and <a class="el" href="classDoFHandler.html">DoFHandler</a> for the saturation, we need to generate a second <a class="el" href="classFEValues.html">FEValues</a> object for the proper evaluation of the saturation solution. This isn't too complicated to realize here: just use the saturation structures and set an update flag for the basis function values which we need for evaluation of the saturation solution. The only important part to remember here is that the same quadrature formula is used for both <a class="el" href="classFEValues.html">FEValues</a> objects to ensure that we get matching information when we loop over the quadrature points of the two objects.</p>
<p>The declarations proceed with some shortcuts for array sizes, the creation of the local matrix, right hand side as well as the vector for the indices of the local dofs compared to the global system.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_system()</div><div class="line">{</div><div class="line">  darcy_matrix = 0;</div><div class="line">  darcy_rhs    = 0;</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(darcy_degree + 2);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(darcy_degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe,</div><div class="line">                                quadrature_formula,</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                     quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> darcy_fe_face_values(darcy_fe,</div><div class="line">                                         face_quadrature_formula,</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = darcy_fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> pressure_right_hand_side;</div><div class="line">  <span class="keyword">const</span> PressureBoundaryValues&lt;dim&gt;  pressure_boundary_values;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;         pressure_rhs_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;         boundary_values(n_face_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div></div><!-- fragment --><p>Next we need a vector that will contain the values of the saturation solution at the previous time level at the quadrature points to assemble the saturation dependent coefficients in the Darcy equations.</p>
<p>The set of vectors we create next hold the evaluations of the basis functions as well as their gradients that will be used for creating the matrices. Putting these into their own arrays rather than asking the <a class="el" href="classFEValues.html">FEValues</a> object for this information each time it is needed is an optimization to accelerate the assembly process, see <a class="el" href="step_22.html">step-22</a> for details.</p>
<p>The last two declarations are used to extract the individual blocks (velocity, pressure, saturation) from the total FE system.</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line"></div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;         div_phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;         phi_p(dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div></div><!-- fragment --><p>Now start the loop over all cells in the problem. We are working on two different DoFHandlers for this assembly routine, so we must have two different cell iterators for the two objects in use. This might seem a bit peculiar, but since both the Darcy system and the saturation system use the same grid we can assume that the two iterators run in sync over the cells of the two <a class="el" href="classDoFHandler.html">DoFHandler</a> objects.</p>
<p>The first statements within the loop are again all very familiar, doing the update of the finite element data as specified by the update flags, zeroing out the local arrays and getting the values of the old solution at the quadrature points. At this point we also have to get the values of the saturation function of the previous time step at the quadrature points. To this end, we can use the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues::get_function_values</a> (previously already used in <a class="el" href="step_9.html">step-9</a>, <a class="el" href="step_14.html">step-14</a> and <a class="el" href="step_15.html">step-15</a>), a function that takes a solution vector and returns a list of function values at the quadrature points of the present cell. In fact, it returns the complete vector-valued solution at each quadrature point, i.e. not only the saturation but also the velocities and pressure.</p>
<p>Then we are ready to loop over the quadrature points on the cell to do the integration. The formula for this follows in a straightforward way from what has been discussed in the introduction.</p>
<p>Once this is done, we start the loop over the rows and columns of the local matrix and feed the matrix with the relevant products.</p>
<p>The last step in the loop over all cells is to enter the local contributions into the global matrix and vector structures to the positions specified in local_dof_indices. Again, we let the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class do the insertion of the cell matrix elements to the global matrix, which already condenses the hanging node constraints.</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">  <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">    {</div><div class="line">      darcy_fe_values.reinit(cell);</div><div class="line">      saturation_fe_values.reinit(saturation_cell);</div><div class="line"></div><div class="line">      local_matrix = 0;</div><div class="line">      local_rhs    = 0;</div><div class="line"></div><div class="line">      saturation_fe_values.get_function_values(old_saturation_solution,</div><div class="line">                                               old_saturation_values);</div><div class="line"></div><div class="line">      pressure_right_hand_side.<a class="code" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">value_list</a>(</div><div class="line">        darcy_fe_values.get_quadrature_points(), pressure_rhs_values);</div><div class="line">      k_inverse.value_list(darcy_fe_values.get_quadrature_points(),</div><div class="line">                           k_inverse_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              phi_u[k]     = darcy_fe_values[velocities].value(k, q);</div><div class="line">              div_phi_u[k] = darcy_fe_values[velocities].divergence(k, q);</div><div class="line">              phi_p[k]     = darcy_fe_values[pressure].value(k, q);</div><div class="line">            }</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_saturation_values[q];</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j)</div><div class="line">                {</div><div class="line">                  local_matrix(i, j) +=</div><div class="line">                    (phi_u[i] * k_inverse_values[q] *</div><div class="line">                       mobility_inverse(old_s, viscosity) * phi_u[j] -</div><div class="line">                     div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div><div class="line">                    darcy_fe_values.JxW(q);</div><div class="line">                }</div><div class="line"></div><div class="line">              local_rhs(i) +=</div><div class="line">                (-phi_p[i] * pressure_rhs_values[q]) * darcy_fe_values.JxW(q);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">          {</div><div class="line">            darcy_fe_face_values.reinit(cell, face);</div><div class="line"></div><div class="line">            pressure_boundary_values.value_list(</div><div class="line">              darcy_fe_face_values.get_quadrature_points(), boundary_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u =</div><div class="line">                    darcy_fe_face_values[velocities].value(i, q);</div><div class="line"></div><div class="line">                  local_rhs(i) +=</div><div class="line">                    -(phi_i_u * darcy_fe_face_values.normal_vector(q) *</div><div class="line">                      boundary_values[q] * darcy_fe_face_values.JxW(q));</div><div class="line">                }</div><div class="line">          }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div><div class="line">          local_matrix(i, j) = local_matrix(j, i);</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      darcy_constraints.distribute_local_to_global(</div><div class="line">        local_matrix, local_rhs, local_dof_indices, darcy_matrix, darcy_rhs);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_saturation_system"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_system</h4>
<p>This function is to assemble the linear system for the saturation transport equation. It calls, if necessary, two other member functions: assemble_saturation_matrix() and assemble_saturation_rhs(). The former function then assembles the saturation matrix that only needs to be changed occasionally. On the other hand, the latter function that assembles the right hand side must be called at every saturation time step.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_system()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_saturation_matrix == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      saturation_matrix = 0;</div><div class="line">      assemble_saturation_matrix();</div><div class="line">    }</div><div class="line"></div><div class="line">  saturation_rhs = 0;</div><div class="line">  assemble_saturation_rhs();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_saturation_matrix"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_matrix</h4>
<p>This function is easily understood since it only forms a simple mass matrix for the left hand side of the saturation linear system by basis functions phi_i_s and phi_j_s only. Finally, as usual, we enter the local contribution into the global matrix by specifying the position in local_dof_indices. This is done by letting the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class do the insertion of the cell matrix elements to the global matrix, which already condenses the hanging node constraints.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_matrix()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(saturation_degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                     quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      saturation_fe_values.reinit(cell);</div><div class="line">      local_matrix = 0;</div><div class="line">      local_rhs    = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_s = saturation_fe_values.shape_value(i, q);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_s = saturation_fe_values.shape_value(j, q);</div><div class="line">                local_matrix(i, j) +=</div><div class="line">                  porosity * phi_i_s * phi_j_s * saturation_fe_values.JxW(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      saturation_constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                                        local_dof_indices,</div><div class="line">                                                        saturation_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_saturation_rhs"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs</h4>
<p>This function is to assemble the right hand side of the saturation transport equation. Before going about it, we have to create two <a class="el" href="classFEValues.html">FEValues</a> objects for the Darcy and saturation systems respectively and, in addition, two <a class="el" href="classFEFaceValues.html">FEFaceValues</a> objects for the two systems because we have a boundary integral term in the weak form of saturation equation. For the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object of the saturation system, we also require normal vectors, which we request using the update_normal_vectors flag.</p>
<p>Next, before looping over all the cells, we have to compute some parameters (e.g. global_u_infty, global_S_variation, and global_Omega_diameter) that the artificial viscosity \(\nu\) needs. This is largely the same as was done in <a class="el" href="step_31.html">step-31</a>, so you may see there for more information.</p>
<p>The real works starts with the loop over all the saturation and Darcy cells to put the local contributions into the global vector. In this loop, in order to simplify the implementation, we split some of the work into two helper functions: assemble_saturation_rhs_cell_term and assemble_saturation_rhs_boundary_term. We note that we insert cell or boundary contributions into the global vector in the two functions rather than in this present function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(saturation_degree + 2);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(saturation_degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                     quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> saturation_fe_face_values(saturation_fe,</div><div class="line">                                              face_quadrature_formula,</div><div class="line">                                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> darcy_fe_face_values(darcy_fe,</div><div class="line">                                         face_quadrature_formula,</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> saturation_fe_face_values_neighbor(</div><div class="line">    saturation_fe, face_quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">    saturation_dof_handler.get_fe().n_dofs_per_cell();</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_max_u_F_prime = get_max_u_F_prime();</div><div class="line">  <span class="keyword">const</span> std::pair&lt;double, double&gt; global_S_range =</div><div class="line">    get_extrapolated_saturation_range();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> global_S_variation =</div><div class="line">    global_S_range.second - global_S_range.first;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span>       cell       = saturation_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> endc       = saturation_dof_handler.end();</div><div class="line">  <span class="keyword">auto</span>       darcy_cell = darcy_dof_handler.begin_active();</div><div class="line">  <span class="keywordflow">for</span> (; cell != endc; ++cell, ++darcy_cell)</div><div class="line">    {</div><div class="line">      saturation_fe_values.reinit(cell);</div><div class="line">      darcy_fe_values.reinit(darcy_cell);</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      assemble_saturation_rhs_cell_term(saturation_fe_values,</div><div class="line">                                        darcy_fe_values,</div><div class="line">                                        global_max_u_F_prime,</div><div class="line">                                        global_S_variation,</div><div class="line">                                        local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">          {</div><div class="line">            darcy_fe_face_values.reinit(darcy_cell, face);</div><div class="line">            saturation_fe_face_values.reinit(cell, face);</div><div class="line">            assemble_saturation_rhs_boundary_term(saturation_fe_face_values,</div><div class="line">                                                  darcy_fe_face_values,</div><div class="line">                                                  local_dof_indices);</div><div class="line">          }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_saturation_rhs_cell_term"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_cell_term</h4>
<p>This function takes care of integrating the cell terms of the right hand side of the saturation equation, and then assembling it into the global right hand side vector. Given the discussion in the introduction, the form of these contributions is clear. The only tricky part is getting the artificial viscosity and all that is necessary to compute it. The first half of the function is devoted to this task.</p>
<p>The last part of the function is copying the local contributions into the global vector with position specified in local_dof_indices.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_cell_term(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       saturation_fe_values,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       darcy_fe_values,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_max_u_F_prime,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_S_variation,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;         old_saturation_solution_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;         old_old_saturation_solution_values(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_grad_saturation_solution_values(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_grad_saturation_solution_values(</div><div class="line">    n_q_points);</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; present_darcy_solution_values(</div><div class="line">    n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div><div class="line"></div><div class="line">  saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                           old_saturation_solution_values);</div><div class="line">  saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">    old_old_saturation_solution, old_old_saturation_solution_values);</div><div class="line">  saturation_fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(</div><div class="line">    old_saturation_solution, old_grad_saturation_solution_values);</div><div class="line">  saturation_fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(</div><div class="line">    old_old_saturation_solution, old_old_grad_saturation_solution_values);</div><div class="line">  darcy_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(darcy_solution,</div><div class="line">                                      present_darcy_solution_values);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div><div class="line">    compute_viscosity(old_saturation_solution_values,</div><div class="line">                      old_old_saturation_solution_values,</div><div class="line">                      old_grad_saturation_solution_values,</div><div class="line">                      old_old_grad_saturation_solution_values,</div><div class="line">                      present_darcy_solution_values,</div><div class="line">                      global_max_u_F_prime,</div><div class="line">                      global_S_variation,</div><div class="line">                      saturation_fe_values.<a class="code" href="classFEValuesBase.html#a9d3a1c53c139e2553b672de682d6233e">get_cell</a>()-&gt;diameter());</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>   old_s = old_saturation_solution_values[q];</div><div class="line">        <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          present_u[d] = present_darcy_solution_values[q](d);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_i_s = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q);</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_i_s =</div><div class="line">          saturation_fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q);</div><div class="line"></div><div class="line">        local_rhs(i) +=</div><div class="line">          (time_step * fractional_flow(old_s, viscosity) * present_u *</div><div class="line">             grad_phi_i_s -</div><div class="line">           time_step * nu * old_grad_saturation_solution_values[q] *</div><div class="line">             grad_phi_i_s +</div><div class="line">           porosity * old_s * phi_i_s) *</div><div class="line">          saturation_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">      }</div><div class="line"></div><div class="line">  saturation_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                    local_dof_indices,</div><div class="line">                                                    saturation_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_saturation_rhs_boundary_term"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_boundary_term</h4>
<p>The next function is responsible for the boundary integral terms in the right hand side form of the saturation equation. For these, we have to compute the upwinding flux on the global boundary faces, i.e. we impose Dirichlet boundary conditions weakly only on inflow parts of the global boundary. As before, this has been described in <a class="el" href="step_21.html">step-21</a> so we refrain from giving more descriptions about that.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_boundary_term(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   saturation_fe_face_values,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   darcy_fe_face_values,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points =</div><div class="line">    saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; old_saturation_solution_values_face(n_face_q_points);</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; present_darcy_solution_values_face(</div><div class="line">    n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div><div class="line">  std::vector&lt;double&gt; neighbor_saturation(n_face_q_points);</div><div class="line"></div><div class="line">  saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">    old_saturation_solution, old_saturation_solution_values_face);</div><div class="line">  darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">    darcy_solution, present_darcy_solution_values_face);</div><div class="line"></div><div class="line">  SaturationBoundaryValues&lt;dim&gt; saturation_boundary_values;</div><div class="line">  saturation_boundary_values.value_list(</div><div class="line">    saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), neighbor_saturation);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">    {</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u_face;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        present_u_face[d] = present_darcy_solution_values_face[q](d);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> normal_flux =</div><div class="line">        present_u_face * saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span> is_outflow_q_point = (normal_flux &gt;= 0);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        local_rhs(i) -=</div><div class="line">          time_step * normal_flux *</div><div class="line">          fractional_flow((is_outflow_q_point == <span class="keyword">true</span> ?</div><div class="line">                             old_saturation_solution_values_face[q] :</div><div class="line">                             neighbor_saturation[q]),</div><div class="line">                          viscosity) *</div><div class="line">          saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q) *</div><div class="line">          saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">    }</div><div class="line">  saturation_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                    local_dof_indices,</div><div class="line">                                                    saturation_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimsolve"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::solve</h3>
<p>This function implements the operator splitting algorithm, i.e. in each time step it either re-computes the solution of the Darcy system or extrapolates velocity/pressure from previous time steps, then determines the size of the time step, and then updates the saturation variable. The implementation largely follows similar code in <a class="el" href="step_31.html">step-31</a>. It is, next to the <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function, the central one in this program.</p>
<p>At the beginning of the function, we ask whether to solve the pressure-velocity part by evaluating the a posteriori criterion (see the following function). If necessary, we will solve the pressure-velocity part using the GMRES solver with the Schur complement block preconditioner as is described in the introduction.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> solve_for_pressure_and_velocity =</div><div class="line">    determine_whether_to_solve_for_pressure_and_velocity();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (solve_for_pressure_and_velocity == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving Darcy (pressure-velocity) system...&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      assemble_darcy_system();</div><div class="line">      build_darcy_preconditioner();</div><div class="line"></div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> LinearSolvers::InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                           <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a>&gt;</div><div class="line">          mp_inverse(darcy_preconditioner_matrix.block(1, 1),</div><div class="line">                     *Mp_preconditioner);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">          <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#abee1d4aa6f0af5290aa7d51806bde982">TrilinosWrappers::PreconditionIC</a>,</div><div class="line">          TrilinosWrappers::PreconditionIC&gt;</div><div class="line">          preconditioner(darcy_matrix, mp_inverse, *Amg_preconditioner);</div><div class="line"></div><div class="line">        <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(darcy_matrix.m(),</div><div class="line">                                     1e-16 * darcy_rhs.l2_norm());</div><div class="line"></div><div class="line">        <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> gmres(</div><div class="line">          solver_control,</div><div class="line">          <a class="code" href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(</div><div class="line">            100));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; darcy_solution.size(); ++i)</div><div class="line">          <span class="keywordflow">if</span> (darcy_constraints.is_constrained(i))</div><div class="line">            darcy_solution(i) = 0;</div><div class="line"></div><div class="line">        gmres.solve(darcy_matrix, darcy_solution, darcy_rhs, preconditioner);</div><div class="line"></div><div class="line">        darcy_constraints.distribute(darcy_solution);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;        ...&quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot; GMRES iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        second_last_computed_darcy_solution = last_computed_darcy_solution;</div><div class="line">        last_computed_darcy_solution        = darcy_solution;</div><div class="line"></div><div class="line">        saturation_matching_last_computed_darcy_solution =</div><div class="line">          saturation_solution;</div><div class="line">      }</div><div class="line">    }</div></div><!-- fragment --><p>On the other hand, if we have decided that we don't want to compute the solution of the Darcy system for the current time step, then we need to simply extrapolate the previous two Darcy solutions to the same time as we would have computed the velocity/pressure at. We do a simple linear extrapolation, i.e. given the current length \(dt\) of the macro time step from the time when we last computed the Darcy solution to now (given by <code>current_macro_time_step</code>), and \(DT\) the length of the last macro time step (given by <code>old_macro_time_step</code>), then we get \(u^\ast = u_p + dt \frac{u_p-u_{pp}}{DT} = (1+dt/DT)u_p - dt/DT u_{pp}\), where \(u_p\) and \(u_{pp}\) are the last two computed Darcy solutions. We can implement this formula using just two lines of code.</p>
<p>Note that the algorithm here only works if we have at least two previously computed Darcy solutions from which we can extrapolate to the current time, and this is ensured by requiring re-computation of the Darcy solution for the first 2 time steps.</p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    darcy_solution = last_computed_darcy_solution;</div><div class="line">    darcy_solution.sadd(1 + current_macro_time_step / old_macro_time_step,</div><div class="line">                        -current_macro_time_step / old_macro_time_step,</div><div class="line">                        second_last_computed_darcy_solution);</div><div class="line">  }</div></div><!-- fragment --><p>With the so computed velocity vector, compute the optimal time step based on the CFL criterion discussed in the introduction...</p>
<div class="fragment"><div class="line">{</div><div class="line">  old_time_step = time_step;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_u_F_prime = get_max_u_F_prime();</div><div class="line">  <span class="keywordflow">if</span> (max_u_F_prime &gt; 0)</div><div class="line">    time_step = porosity * <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) /</div><div class="line">                saturation_degree / max_u_F_prime / 50;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    time_step = end_time - time;</div><div class="line">}</div></div><!-- fragment --><p>...and then also update the length of the macro time steps we use while we're dealing with time step sizes. In particular, this involves: (i) If we have just recomputed the Darcy solution, then the length of the previous macro time step is now fixed and the length of the current macro time step is, up to now, simply the length of the current (micro) time step. (ii) If we have not recomputed the Darcy solution, then the length of the current macro time step has just grown by <code>time_step</code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (solve_for_pressure_and_velocity == <span class="keyword">true</span>)</div><div class="line">  {</div><div class="line">    old_macro_time_step     = current_macro_time_step;</div><div class="line">    current_macro_time_step = time_step;</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  current_macro_time_step += time_step;</div></div><!-- fragment --><p>The last step in this function is to recompute the saturation solution based on the velocity field we've just obtained. This naturally happens in every time step, and we don't skip any of these computations. At the end of computing the saturation, we project back into the allowed interval \([0,1]\) to make sure our solution remains physical.</p>
<div class="fragment"><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving saturation transport equation...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    assemble_saturation_system();</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(saturation_matrix.m(),</div><div class="line">                                 1e-16 * saturation_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">    TrilinosWrappers::PreconditionIC preconditioner;</div><div class="line">    preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html#a95eff1f8abcf2ba67815b6a96a66d375">initialize</a>(saturation_matrix);</div><div class="line"></div><div class="line">    cg.solve(saturation_matrix,</div><div class="line">             saturation_solution,</div><div class="line">             saturation_rhs,</div><div class="line">             preconditioner);</div><div class="line"></div><div class="line">    saturation_constraints.distribute(saturation_solution);</div><div class="line">    project_back_saturation();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;        ...&quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimrefine_mesh"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::refine_mesh</h3>
<p>The next function does the refinement and coarsening of the mesh. It does its work in three blocks: (i) Compute refinement indicators by looking at the gradient of a solution vector extrapolated linearly from the previous two using the respective sizes of the time step (or taking the only solution we have if this is the first time step). (ii) Flagging those cells for refinement and coarsening where the gradient is larger or smaller than a certain threshold, preserving minimal and maximal levels of mesh refinement. (iii) Transferring the solution from the old to the new mesh. None of this is particularly difficult.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_grid_level,</div><div class="line">                                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> refinement_indicators(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQMidpoint.html">QMidpoint&lt;dim&gt;</a>        quadrature_formula;</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               fe_values(saturation_fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_saturation(1);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> extrapolated_saturation_solution(</div><div class="line">      saturation_solution);</div><div class="line">    <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">      extrapolated_saturation_solution.sadd((1. + time_step / old_time_step),</div><div class="line">                                            time_step / old_time_step,</div><div class="line">                                            old_saturation_solution);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = cell-&gt;active_cell_index();</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(extrapolated_saturation_solution,</div><div class="line">                                         grad_saturation);</div><div class="line"></div><div class="line">        refinement_indicators(cell_no) = grad_saturation[0].norm();</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = cell-&gt;active_cell_index();</div><div class="line">        cell-&gt;clear_coarsen_flag();</div><div class="line">        cell-&gt;clear_refine_flag();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((static_cast&lt;unsigned int&gt;(cell-&gt;level()) &lt; max_grid_level) &amp;&amp;</div><div class="line">            (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(refinement_indicators(cell_no)) &gt;</div><div class="line">             saturation_refinement_threshold))</div><div class="line">          cell-&gt;set_refine_flag();</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((static_cast&lt;unsigned int&gt;(cell-&gt;level()) &gt;</div><div class="line">                  min_grid_level) &amp;&amp;</div><div class="line">                 (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(refinement_indicators(cell_no)) &lt;</div><div class="line">                  0.5 * saturation_refinement_threshold))</div><div class="line">          cell-&gt;set_coarsen_flag();</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">  {</div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::Vector&gt; x_saturation(3);</div><div class="line">    x_saturation[0] = saturation_solution;</div><div class="line">    x_saturation[1] = old_saturation_solution;</div><div class="line">    x_saturation[2] = saturation_matching_last_computed_darcy_solution;</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::BlockVector&gt; x_darcy(2);</div><div class="line">    x_darcy[0] = last_computed_darcy_solution;</div><div class="line">    x_darcy[1] = second_last_computed_darcy_solution;</div><div class="line"></div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a> saturation_soltrans(</div><div class="line">      saturation_dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::BlockVector&gt;</a> darcy_soltrans(</div><div class="line">      darcy_dof_handler);</div><div class="line"></div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">    saturation_soltrans.prepare_for_coarsening_and_refinement(x_saturation);</div><div class="line"></div><div class="line">    darcy_soltrans.prepare_for_coarsening_and_refinement(x_darcy);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::Vector&gt; tmp_saturation(3);</div><div class="line">    tmp_saturation[0].reinit(saturation_solution);</div><div class="line">    tmp_saturation[1].reinit(saturation_solution);</div><div class="line">    tmp_saturation[2].reinit(saturation_solution);</div><div class="line">    saturation_soltrans.interpolate(x_saturation, tmp_saturation);</div><div class="line"></div><div class="line">    saturation_solution                              = tmp_saturation[0];</div><div class="line">    old_saturation_solution                          = tmp_saturation[1];</div><div class="line">    saturation_matching_last_computed_darcy_solution = tmp_saturation[2];</div><div class="line"></div><div class="line">    saturation_constraints.distribute(saturation_solution);</div><div class="line">    saturation_constraints.distribute(old_saturation_solution);</div><div class="line">    saturation_constraints.distribute(</div><div class="line">      saturation_matching_last_computed_darcy_solution);</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::BlockVector&gt; tmp_darcy(2);</div><div class="line">    tmp_darcy[0].reinit(darcy_solution);</div><div class="line">    tmp_darcy[1].reinit(darcy_solution);</div><div class="line">    darcy_soltrans.interpolate(x_darcy, tmp_darcy);</div><div class="line"></div><div class="line">    last_computed_darcy_solution        = tmp_darcy[0];</div><div class="line">    second_last_computed_darcy_solution = tmp_darcy[1];</div><div class="line"></div><div class="line">    darcy_constraints.distribute(last_computed_darcy_solution);</div><div class="line">    darcy_constraints.distribute(second_last_computed_darcy_solution);</div><div class="line"></div><div class="line">    rebuild_saturation_matrix = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimoutput_results"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::output_results</h3>
<p>This function generates graphical output. It is in essence a copy of the implementation in <a class="el" href="step_31.html">step-31</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> joint_fe(darcy_fe, 1, saturation_fe, 1);</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>     joint_dof_handler(triangulation);</div><div class="line">  joint_dof_handler.distribute_dofs(joint_fe);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_dof_handler.n_dofs() ==</div><div class="line">           darcy_dof_handler.n_dofs() + saturation_dof_handler.n_dofs(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> joint_solution(joint_dof_handler.n_dofs());</div><div class="line"></div><div class="line">  {</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_joint_dof_indices(</div><div class="line">      joint_fe.n_dofs_per_cell());</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_darcy_dof_indices(</div><div class="line">      darcy_fe.n_dofs_per_cell());</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_saturation_dof_indices(</div><div class="line">      saturation_fe.n_dofs_per_cell());</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       joint_cell      = joint_dof_handler.begin_active();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> joint_endc      = joint_dof_handler.<a class="code" href="classVector.html#a7a2a770cb19d3e5b0b69b08ffc88184f">end</a>();</div><div class="line">    <span class="keyword">auto</span>       darcy_cell      = darcy_dof_handler.begin_active();</div><div class="line">    <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; joint_cell != joint_endc;</div><div class="line">         ++joint_cell, ++darcy_cell, ++saturation_cell)</div><div class="line">      {</div><div class="line">        joint_cell-&gt;get_dof_indices(local_joint_dof_indices);</div><div class="line">        darcy_cell-&gt;get_dof_indices(local_darcy_dof_indices);</div><div class="line">        saturation_cell-&gt;get_dof_indices(local_saturation_dof_indices);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; joint_fe.n_dofs_per_cell(); ++i)</div><div class="line">          <span class="keywordflow">if</span> (joint_fe.system_to_base_index(i).first.first == 0)</div><div class="line">            {</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                       local_darcy_dof_indices.size(),</div><div class="line">                     <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">              joint_solution(local_joint_dof_indices[i]) = darcy_solution(</div><div class="line">                local_darcy_dof_indices[joint_fe.system_to_base_index(i)</div><div class="line">                                          .second]);</div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).first.first == 1,</div><div class="line">                     <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                       local_darcy_dof_indices.size(),</div><div class="line">                     <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">              joint_solution(local_joint_dof_indices[i]) =</div><div class="line">                saturation_solution(</div><div class="line">                  local_saturation_dof_indices</div><div class="line">                    [joint_fe.system_to_base_index(i).second]);</div><div class="line">            }</div><div class="line">      }</div><div class="line">  }</div><div class="line">  std::vector&lt;std::string&gt; joint_solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  joint_solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">  joint_solution_names.emplace_back(<span class="stringliteral">&quot;saturation&quot;</span>);</div><div class="line"></div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(joint_dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(joint_solution,</div><div class="line">                           joint_solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 5) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Toolfunctions"></a> </p><h3>Tool functions</h3>
<p><a class="anchor" id="TwoPhaseFlowProblemdimdetermine_whether_to_solve_for_pressure_and_velocity"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::determine_whether_to_solve_for_pressure_and_velocity</h4>
<p>This function implements the a posteriori criterion for adaptive operator splitting. The function is relatively straightforward given the way we have implemented other functions above and given the formula for the criterion derived in the paper.</p>
<p>If one decides that one wants the original IMPES method in which the Darcy equation is solved in every time step, then this can be achieved by setting the threshold value <code>AOS_threshold</code> (with a default of \(5.0\)) to zero, thereby forcing the function to always return true.</p>
<p>Finally, note that the function returns true unconditionally for the first two time steps to ensure that we have always solved the Darcy system at least twice when skipping its solution, thereby allowing us to extrapolate the velocity from the last two solutions in <code>solve()</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span> TwoPhaseFlowProblem&lt;</div><div class="line">  dim&gt;::determine_whether_to_solve_for_pressure_and_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (timestep_number &lt;= 2)</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(saturation_degree + 2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(saturation_fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; old_saturation_after_solving_pressure(n_q_points);</div><div class="line">  std::vector&lt;double&gt; present_saturation(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_global_aop_indicator = 0.0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> max_local_mobility_reciprocal_difference = 0.0;</div><div class="line">      <span class="keywordtype">double</span> max_local_permeability_inverse_l1_norm   = 0.0;</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        saturation_matching_last_computed_darcy_solution,</div><div class="line">        old_saturation_after_solving_pressure);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(saturation_solution, present_saturation);</div><div class="line"></div><div class="line">      k_inverse.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                           k_inverse_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> mobility_reciprocal_difference = <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(</div><div class="line">            mobility_inverse(present_saturation[q], viscosity) -</div><div class="line">            mobility_inverse(old_saturation_after_solving_pressure[q],</div><div class="line">                             viscosity));</div><div class="line"></div><div class="line">          max_local_mobility_reciprocal_difference =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_mobility_reciprocal_difference,</div><div class="line">                     mobility_reciprocal_difference);</div><div class="line"></div><div class="line">          max_local_permeability_inverse_l1_norm =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_permeability_inverse_l1_norm,</div><div class="line">                     <a class="code" href="classTensor.html#a93ba01d979880b278cd4b573dd9c653b">l1_norm</a>(k_inverse_values[q]));</div><div class="line">        }</div><div class="line"></div><div class="line">      max_global_aop_indicator =</div><div class="line">        <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_global_aop_indicator,</div><div class="line">                 (max_local_mobility_reciprocal_difference *</div><div class="line">                  max_local_permeability_inverse_l1_norm));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (max_global_aop_indicator &gt; AOS_threshold);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimproject_back_saturation"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::project_back_saturation</h4>
<p>The next function simply makes sure that the saturation values always remain within the physically reasonable range of \([0,1]\). While the continuous equations guarantee that this is so, the discrete equations don't. However, if we allow the discrete solution to escape this range we get into trouble because terms like \(F(S)\) and \(F&#39;(S)\) will produce unreasonable results (e.g. \(F&#39;(S)&lt;0\) for \(S&lt;0\), which would imply that the wetting fluid phase flows <em>against</em> the direction of the bulk fluid velocity)). Consequently, at the end of each time step, we simply project the saturation field back into the physically reasonable region.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::project_back_saturation()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; saturation_solution.size(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (saturation_solution(i) &lt; 0.2)</div><div class="line">      saturation_solution(i) = 0.2;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (saturation_solution(i) &gt; 1)</div><div class="line">      saturation_solution(i) = 1;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimget_max_u_F_prime"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::get_max_u_F_prime</h4>
<p>Another simpler helper function: Compute the maximum of the total velocity times the derivative of the fraction flow function, i.e., compute \(\|\mathbf{u} F&#39;(S)\|_{L_\infty(\Omega)}\). This term is used in both the computation of the time step as well as in normalizing the entropy-residual term in the artificial viscosity.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::get_max_u_F_prime()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(darcy_degree + 2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                     quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; darcy_solution_values(n_q_points,</div><div class="line">                                                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div><div class="line">  std::vector&lt;double&gt;         saturation_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_velocity_times_dF_dS = 0;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">  <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line">  <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">    {</div><div class="line">      darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(saturation_cell);</div><div class="line"></div><div class="line">      darcy_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(darcy_solution,</div><div class="line">                                          darcy_solution_values);</div><div class="line">      saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                               saturation_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">            velocity[i] = darcy_solution_values[q](i);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> dF_dS =</div><div class="line">            fractional_flow_derivative(saturation_values[q], viscosity);</div><div class="line"></div><div class="line">          max_velocity_times_dF_dS =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity_times_dF_dS, velocity.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() * dF_dS);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> max_velocity_times_dF_dS;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimget_extrapolated_saturation_range"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::get_extrapolated_saturation_range</h4>
<p>For computing the stabilization term, we need to know the range of the saturation variable. Unlike in <a class="el" href="step_31.html">step-31</a>, this range is trivially bounded by the interval \([0,1]\) but we can do a bit better by looping over a collection of quadrature points and seeing what the values are there. If we can, i.e., if there are at least two timesteps around, we can even take the values extrapolated to the next time step.</p>
<p>As before, the function is taken with minimal modifications from <a class="el" href="step_31.html">step-31</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;double, double&gt;</div><div class="line">TwoPhaseFlowProblem&lt;dim&gt;::get_extrapolated_saturation_range()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(saturation_degree + 2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(saturation_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_old_saturation_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">             max_saturation = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                        old_saturation_values);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_saturation_solution,</div><div class="line">                                        old_old_saturation_values);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> saturation =</div><div class="line">                (1. + time_step / old_time_step) * old_saturation_values[q] -</div><div class="line">                time_step / old_time_step * old_old_saturation_values[q];</div><div class="line"></div><div class="line">              min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_saturation, saturation);</div><div class="line">              max_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_saturation, saturation);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> std::make_pair(min_saturation, max_saturation);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">             max_saturation = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                        old_saturation_values);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> saturation = old_saturation_values[q];</div><div class="line"></div><div class="line">              min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_saturation, saturation);</div><div class="line">              max_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_saturation, saturation);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> std::make_pair(min_saturation, max_saturation);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimcompute_viscosity"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::compute_viscosity</h4>
<p>The final tool function is used to compute the artificial viscosity on a given cell. This isn't particularly complicated if you have the formula for it in front of you, and looking at the implementation in <a class="el" href="step_31.html">step-31</a>. The major difference to that tutorial program is that the velocity here is not simply \(\mathbf u\) but \(\mathbf u F&#39;(S)\) and some of the formulas need to be adjusted accordingly.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::compute_viscosity(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_saturation,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_saturation,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_saturation_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_saturation_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;present_darcy_values,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_max_u_F_prime,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_S_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> beta  = .4 * dim;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = 1;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (global_max_u_F_prime == 0)</div><div class="line">    <span class="keywordflow">return</span> 5e-3 * cell_diameter;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_saturation.size();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_residual             = 0;</div><div class="line">  <span class="keywordtype">double</span> max_velocity_times_dF_dS = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> use_dF_dS = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        u[d] = present_darcy_values[q](d);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> dS_dt = porosity *</div><div class="line">                           (old_saturation[q] - old_old_saturation[q]) /</div><div class="line">                           old_time_step;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> dF_dS = fractional_flow_derivative(</div><div class="line">        (old_saturation[q] + old_old_saturation[q]) / 2.0, viscosity);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_S =</div><div class="line">        u * dF_dS * (old_saturation_grads[q] + old_old_saturation_grads[q]) /</div><div class="line">        2.0;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> residual =</div><div class="line">        <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>((dS_dt + u_grad_S) *</div><div class="line">                 std::pow((old_saturation[q] + old_old_saturation[q]) / 2,</div><div class="line">                          alpha - 1.));</div><div class="line"></div><div class="line">      max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div><div class="line">      max_velocity_times_dF_dS =</div><div class="line">        <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u * u) * (use_dF_dS ? <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(dF_dS, 1.) : 1),</div><div class="line">                 max_velocity_times_dF_dS);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> c_R            = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> global_scaling = c_R * porosity *</div><div class="line">                                (global_max_u_F_prime)*global_S_variation /</div><div class="line">                                std::pow(global_Omega_diameter, alpha - 2.);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (beta *</div><div class="line">          (max_velocity_times_dF_dS)*<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(cell_diameter,</div><div class="line">                                              std::pow(cell_diameter, alpha) *</div><div class="line">                                                max_residual /</div><div class="line">                                                global_scaling));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimrun"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::run</h3>
<p>This function is, besides <code>solve()</code>, the primary function of this program as it controls the time iteration as well as when the solution is written into output files and when to do mesh refinement.</p>
<p>With the exception of the startup code that loops back to the beginning of the function through the <code>goto start_time_iteration</code> label, everything should be relatively straightforward. In any case, it mimics the corresponding function in <a class="el" href="step_31.html">step-31</a>.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TwoPhaseFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement     = (dim == 2 ? 5 : 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_pre_refinement_steps = (dim == 2 ? 3 : 2);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(initial_refinement);</div><div class="line">    global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(triangulation);</div><div class="line"></div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"></div><div class="line">  start_time_iteration:</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(saturation_dof_handler,</div><div class="line">                         saturation_constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(saturation_degree + 2),</div><div class="line">                         SaturationInitialValues&lt;dim&gt;(),</div><div class="line">                         old_saturation_solution);</div><div class="line"></div><div class="line">    time_step = old_time_step = 0;</div><div class="line">    current_macro_time_step = old_macro_time_step = 0;</div><div class="line"></div><div class="line">    time = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, dt=&quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (timestep_number % 200 == 0)</div><div class="line">          output_results();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (timestep_number % 25 == 0)</div><div class="line">          refine_mesh(initial_refinement,</div><div class="line">                      initial_refinement + n_pre_refinement_steps);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">            (pre_refinement_step &lt; n_pre_refinement_steps))</div><div class="line">          {</div><div class="line">            ++pre_refinement_step;</div><div class="line">            <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">          }</div><div class="line"></div><div class="line">        time += time_step;</div><div class="line">        ++timestep_number;</div><div class="line"></div><div class="line">        old_old_saturation_solution = old_saturation_solution;</div><div class="line">        old_saturation_solution     = saturation_solution;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (time &lt;= end_time);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step43</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main()</code> function</h3>
<p>The main function looks almost the same as in all other programs. The need to initialize the MPI subsystem for a program that uses Trilinos &ndash; even for programs that do not actually run in parallel &ndash; is explained in <a class="el" href="step_31.html">step-31</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step43;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div></div><!-- fragment --><p>This program can only be run in serial. Otherwise, throw an exception.</p>
<div class="fragment"><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-43&quot;</span>));</div><div class="line"></div><div class="line">      TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(1);</div><div class="line">      two_phase_flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The output of this program is not really much different from that of <a class="el" href="step_21.html">step-21</a>: it solves the same problem, after all. Of more importance are quantitative metrics such as the accuracy of the solution as well as the time needed to compute it. These are documented in detail in the two publications listed at the top of this page and we won't repeat them here.</p>
<p>That said, no tutorial program is complete without a couple of good pictures, so here is some output of a run in 3d:</p>
<table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-43.3d.velocity.png"/>
</div>
 <p>Velocity vectors of flow through the porous medium with random permeability model. Streaming paths of high permeability and resulting high velocity are clearly visible. </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-43.3d.streamlines.png"/>
</div>
 <p>Streamlines colored by the saturation along the streamline path. Blue streamlines indicate low saturations, i.e., the flow along these streamlines must be slow or else more fluid would have been transported along them. On the other hand, green paths indicate high velocities since the fluid front has already reached further into the domain. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-43.3d.saturation.png"/>
</div>
 <p>Streamlines with a volume rendering of the saturation, showing how far the fluid front has advanced at this time. </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-43.3d.mesh.png"/>
</div>
 <p>Surface of the mesh showing the adaptive refinement along the front. </p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>The primary objection one may have to this program is that it is still too slow: 3d computations on reasonably fine meshes are simply too expensive to be done routinely and with reasonably quick turn-around. This is similar to the situation we were in when we wrote <a class="el" href="step_31.html">step-31</a>, from which this program has taken much inspiration. The solution is similar as it was there as well: We need to parallelize the program in a way similar to how we derived <a class="el" href="step_32.html">step-32</a> out of <a class="el" href="step_31.html">step-31</a>. In fact, all of the techniques used in <a class="el" href="step_32.html">step-32</a> would be transferable to this program as well, making the program run on dozens or hundreds of processors immediately.</p>
<p>A different direction is to make the program more relevant to many other porous media applications. Specifically, one avenue is to go to the primary user of porous media flow simulators, namely the oil industry. There, applications in this area are dominated by multiphase flow (i.e., more than the two phases we have here), and the reactions they may have with each other (or any other way phases may exchange mass, such as through dissolution in and bubbling out of gas from the oil phase). Furthermore, the presence of gas often leads to compressibility effects of the fluid. Jointly, these effects are typically formulated in the widely-used "black oil model". True reactions between multiple phases also play a role in oil reservoir modeling when considering controlled burns of oil in the reservoir to raise pressure and temperature. These are much more complex problems, though, and left for future projects.</p>
<p>Finally, from a mathematical perspective, we have derived the criterion for re-computing the velocity/pressure solution at a given time step under the assumption that we want to compare the solution we would get at the current time step with that computed the last time we actually solved this system. However, in the program, whenever we did not re-compute the solution, we didn't just use the previously computed solution but instead extrapolated from the previous two times we solved the system. Consequently, the criterion was pessimistically stated: what we should really compare is the solution we would get at the current time step with the extrapolated one. Re-stating the theorem in this regard is left as an exercise.</p>
<p>There are also other ways to extend the mathematical foundation of this program; for example, one may say that it isn't the velocity we care about, but in fact the saturation. Thus, one may ask whether the criterion we use here to decide whether \(\mathbf u\) needs to be recomputed is appropriate; one may, for example, suggest that it is also important to decide whether (and by how much) a wrong velocity field in fact affects the solution of the saturation equation. This would then naturally lead to a sensitivity analysis.</p>
<p>From an algorithmic viewpoint, we have here used a criterion for refinement that is often used in engineering, namely by looking at the gradient of the solution. However, if you inspect the solution, you will find that it quickly leads to refinement almost everywhere, even in regions where it is clearly not necessary: frequently used therefore does not need to imply that it is a useful criterion to begin with. On the other hand, replacing this criterion by a different and better one should not be very difficult. For example, the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class used in many other programs should certainly be applicable to the current problem as well.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2010 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Chih-Che Chueh, University of Victoria, 2010</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University, 2010</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step43</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PressureBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PressureBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  PressureBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 1 - p[0];</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SaturationBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SaturationBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  SaturationBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (p[0] == 0)</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SaturationInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SaturationInitialValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  value) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  SaturationInitialValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0.2;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SaturationInitialValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                                  Vector&lt;double&gt; &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = SaturationInitialValues&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SingleCurvingCrack</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      KInverse()</div><div class="line">        : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">      value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                 std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> KInverse&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                   std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">        {</div><div class="line">          values[p].clear();</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> distance_to_flowline =</div><div class="line">            <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0]));</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> permeability =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::exp(-(distance_to_flowline * distance_to_flowline) /</div><div class="line">                              (0.1 * 0.1)),</div><div class="line">                     0.01);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            values[p][d][d] = 1. / permeability;</div><div class="line">        }</div><div class="line">    }</div><div class="line">  } <span class="comment">// namespace SingleCurvingCrack</span></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>RandomMedium</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      KInverse()</div><div class="line">        : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">      value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                 std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; centers;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    std::vector&lt;Point&lt;dim&gt;&gt; KInverse&lt;dim&gt;::centers = []() {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N =</div><div class="line">        (dim == 2 ? 40 : (dim == 3 ? 100 : <span class="keywordflow">throw</span> <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()));</div><div class="line"></div><div class="line">      std::vector&lt;Point&lt;dim&gt;&gt; centers_list(N);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a>; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          centers_list[i][d] = static_cast&lt;double&gt;(rand()) / RAND_MAX;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> centers_list;</div><div class="line">    }();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> KInverse&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                   std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(points.size(), values.size());</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">        {</div><div class="line">          values[p].clear();</div><div class="line"></div><div class="line">          <span class="keywordtype">double</span> permeability = 0;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; centers.size(); ++i)</div><div class="line">            permeability +=</div><div class="line">              std::exp(-(points[p] - centers[i]).norm_square() / (0.05 * 0.05));</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> normalized_permeability =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(permeability, 0.01), 4.);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            values[p][d][d] = 1. / normalized_permeability;</div><div class="line">        }</div><div class="line">    }</div><div class="line">  } <span class="comment">// namespace RandomMedium</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> mobility_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> fractional_flow(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((S &gt;= 0) &amp;&amp; (S &lt;= 1),</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Saturation is outside its physically valid range.&quot;</span>));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> S * S / (S * S + viscosity * (1 - S) * (1 - S));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> fractional_flow_derivative(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((S &gt;= 0) &amp;&amp; (S &lt;= 1),</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Saturation is outside its physically valid range.&quot;</span>));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> temp = (S * S + viscosity * (1 - S) * (1 - S));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> numerator =</div><div class="line">      2.0 * S * temp - S * S * (2.0 * S - 2.0 * viscosity * (1 - S));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> denominator = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(temp, 2.0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> F_prime = numerator / denominator;</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(F_prime &gt;= 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> F_prime;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>LinearSolvers</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                    <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">      <span class="keywordtype">void</span> vmult(<a class="code" href="classVectorType.html">VectorType</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">      <span class="keyword">const</span> PreconditionerType &amp;           preconditioner;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">      <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">      <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">      : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">      , preconditioner(preconditioner)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">    <span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">      <a class="code" href="classVectorType.html">VectorType</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>        solver_control(src.size(), 1e-7 * src.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;VectorType&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">      dst = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">try</span></div><div class="line">        {</div><div class="line">          cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, preconditioner);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">catch</span> (std::exception &amp;e)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(e.what()));</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    <span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      BlockSchurPreconditioner(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">        <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                            PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">        <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner);</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#aff5a880cfa288ecdd2a83a876abacf0d">vmult</a>(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">        darcy_matrix;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;<span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                             PreconditionerTypeMp&gt;&gt;</div><div class="line">                                 m_inverse;</div><div class="line">      <span class="keyword">const</span> PreconditionerTypeA &amp;a_preconditioner;</div><div class="line"></div><div class="line">      <span class="keyword">mutable</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::</div><div class="line">      BlockSchurPreconditioner(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">        <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                            PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">        <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner)</div><div class="line">      : darcy_matrix(&amp;S)</div><div class="line">      , m_inverse(&amp;Mpinv)</div><div class="line">      , a_preconditioner(Apreconditioner)</div><div class="line">      , tmp(<a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(darcy_matrix-&gt;block(1, 1).m()))</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::vmult(</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      a_preconditioner.vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">      darcy_matrix-&gt;block(1, 0).residual(tmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">      tmp *= -1;</div><div class="line">      m_inverse-&gt;vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div><div class="line">    }</div><div class="line">  } <span class="comment">// namespace LinearSolvers</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TwoPhaseFlowProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_dofs();</div><div class="line">    <span class="keywordtype">void</span> assemble_darcy_preconditioner();</div><div class="line">    <span class="keywordtype">void</span> build_darcy_preconditioner();</div><div class="line">    <span class="keywordtype">void</span> assemble_darcy_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_saturation_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_saturation_matrix();</div><div class="line">    <span class="keywordtype">void</span> assemble_saturation_rhs();</div><div class="line">    <span class="keywordtype">void</span> assemble_saturation_rhs_cell_term(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       saturation_fe_values,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       darcy_fe_values,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_max_u_F_prime,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_S_variation,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices);</div><div class="line">    <span class="keywordtype">void</span> assemble_saturation_rhs_boundary_term(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   saturation_fe_face_values,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   darcy_fe_face_values,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices);</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_grid_level,</div><div class="line">                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>                    get_max_u_F_prime() <span class="keyword">const</span>;</div><div class="line">    std::pair&lt;double, double&gt; get_extrapolated_saturation_range() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">bool</span>   determine_whether_to_solve_for_pressure_and_velocity() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span>   project_back_saturation();</div><div class="line">    <span class="keywordtype">double</span> compute_viscosity(</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_saturation,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_saturation,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_saturation_grads,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_saturation_grads,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;Vector&lt;double&gt;&gt; &amp;present_darcy_values,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_max_u_F_prime,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_S_variation,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <span class="keywordtype">double</span>             global_Omega_diameter;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        darcy_degree;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             darcy_fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           darcy_dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> darcy_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> darcy_preconditioner_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> darcy_matrix;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> darcy_preconditioner_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> darcy_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> darcy_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> last_computed_darcy_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> second_last_computed_darcy_solution;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        saturation_degree;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 saturation_fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           saturation_dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> saturation_constraints;</div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix saturation_matrix;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> saturation_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_saturation_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_saturation_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> saturation_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a></div><div class="line">      saturation_matching_last_computed_darcy_solution;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> saturation_refinement_threshold;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> end_time;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> current_macro_time_step;</div><div class="line">    <span class="keywordtype">double</span> old_macro_time_step;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time_step;</div><div class="line">    <span class="keywordtype">double</span>       old_time_step;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> porosity;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> AOS_threshold;</div><div class="line"></div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt; Amg_preconditioner;</div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt; Mp_preconditioner;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> rebuild_saturation_matrix;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> RandomMedium::KInverse&lt;dim&gt; k_inverse;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TwoPhaseFlowProblem&lt;dim&gt;::TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">    , global_Omega_diameter(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">    , degree(degree)</div><div class="line">    , darcy_degree(degree)</div><div class="line">    , darcy_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(darcy_degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(darcy_degree), 1)</div><div class="line">    , darcy_dof_handler(triangulation)</div><div class="line">    ,</div><div class="line"></div><div class="line">    saturation_degree(degree + 1)</div><div class="line">    , saturation_fe(saturation_degree)</div><div class="line">    , saturation_dof_handler(triangulation)</div><div class="line">    ,</div><div class="line"></div><div class="line">    saturation_refinement_threshold(0.5)</div><div class="line">    ,</div><div class="line"></div><div class="line">    time(0)</div><div class="line">    , end_time(10)</div><div class="line">    ,</div><div class="line"></div><div class="line">    current_macro_time_step(0)</div><div class="line">    , old_macro_time_step(0)</div><div class="line">    ,</div><div class="line"></div><div class="line">    time_step(0)</div><div class="line">    , old_time_step(0)</div><div class="line">    , timestep_number(0)</div><div class="line">    , viscosity(0.2)</div><div class="line">    , porosity(1.0)</div><div class="line">    , AOS_threshold(3.0)</div><div class="line">    ,</div><div class="line"></div><div class="line">    rebuild_saturation_matrix(true)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::setup_dofs()</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; darcy_block_component(dim + 1, 0);</div><div class="line">    darcy_block_component[dim] = 1;</div><div class="line">    {</div><div class="line">      darcy_dof_handler.distribute_dofs(darcy_fe);</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(darcy_dof_handler);</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(darcy_dof_handler, darcy_block_component);</div><div class="line"></div><div class="line">      darcy_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(darcy_dof_handler,</div><div class="line">                                              darcy_constraints);</div><div class="line">      darcy_constraints.close();</div><div class="line">    }</div><div class="line">    {</div><div class="line">      saturation_dof_handler.distribute_dofs(saturation_fe);</div><div class="line"></div><div class="line">      saturation_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(saturation_dof_handler,</div><div class="line">                                              saturation_constraints);</div><div class="line">      saturation_constraints.close();</div><div class="line">    }</div><div class="line">    {</div><div class="line">      darcy_preconditioner_constraints.clear();</div><div class="line"></div><div class="line">      <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(darcy_dof_handler,</div><div class="line">                                              darcy_preconditioner_constraints);</div><div class="line">      <a class="code" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a>(darcy_dof_handler,</div><div class="line">                                               darcy_preconditioner_constraints,</div><div class="line">                                               darcy_fe.component_mask(</div><div class="line">                                                 pressure));</div><div class="line"></div><div class="line">      darcy_preconditioner_constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; darcy_dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(darcy_dof_handler,</div><div class="line">                                        darcy_block_component);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = darcy_dofs_per_block[0],</div><div class="line">                       n_p = darcy_dofs_per_block[1],</div><div class="line">                       n_s = saturation_dof_handler.n_dofs();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_s &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">              &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_s &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      darcy_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">      dsp.block(0, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_u);</div><div class="line">      dsp.block(0, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_p);</div><div class="line">      dsp.block(1, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_u);</div><div class="line">      dsp.block(1, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_p);</div><div class="line"></div><div class="line">      dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (d == dim)))</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        darcy_dof_handler, coupling, dsp, darcy_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      darcy_matrix.reinit(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      Amg_preconditioner.reset();</div><div class="line">      Mp_preconditioner.reset();</div><div class="line">      darcy_preconditioner_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">      dsp.block(0, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_u);</div><div class="line">      dsp.block(0, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_p);</div><div class="line">      dsp.block(1, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_u);</div><div class="line">      dsp.block(1, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_p);</div><div class="line"></div><div class="line">      dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (c == d)</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        darcy_dof_handler, coupling, dsp, darcy_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      darcy_preconditioner_matrix.reinit(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    {</div><div class="line">      saturation_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_s, n_s);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(saturation_dof_handler,</div><div class="line">                                      dsp,</div><div class="line">                                      saturation_constraints,</div><div class="line">                                      <span class="keyword">false</span>);</div><div class="line"></div><div class="line"></div><div class="line">      saturation_matrix.reinit(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    std::vector&lt;IndexSet&gt; darcy_partitioning(2);</div><div class="line">    darcy_partitioning[0] = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_u);</div><div class="line">    darcy_partitioning[1] = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_p);</div><div class="line">    darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">    darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">    last_computed_darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">    last_computed_darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">    second_last_computed_darcy_solution.reinit(darcy_partitioning,</div><div class="line">                                               MPI_COMM_WORLD);</div><div class="line">    second_last_computed_darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">    darcy_rhs.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">    darcy_rhs.collect_sizes();</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> saturation_partitioning = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_s);</div><div class="line">    saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    saturation_matching_last_computed_darcy_solution.reinit(</div><div class="line">      saturation_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    saturation_rhs.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_preconditioner()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding darcy preconditioner...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    darcy_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(darcy_degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     darcy_fe_values(darcy_fe,</div><div class="line">                                  quadrature_formula,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     saturation_fe_values(saturation_fe,</div><div class="line">                                       quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = darcy_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">      {</div><div class="line">        darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(saturation_cell);</div><div class="line"></div><div class="line">        local_matrix = 0;</div><div class="line"></div><div class="line">        saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                                 old_saturation_values);</div><div class="line"></div><div class="line">        k_inverse.value_list(darcy_fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             k_inverse_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_saturation_values[q];</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> inverse_mobility = mobility_inverse(old_s, viscosity);</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> mobility         = 1.0 / inverse_mobility;</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> permeability = <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(k_inverse_values[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                phi_u[k]      = darcy_fe_values[velocities].value(k, q);</div><div class="line">                grad_phi_p[k] = darcy_fe_values[pressure].gradient(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  local_matrix(i, j) +=</div><div class="line">                    (k_inverse_values[q] * inverse_mobility * phi_u[i] *</div><div class="line">                       phi_u[j] +</div><div class="line">                     permeability * mobility * grad_phi_p[i] * grad_phi_p[j]) *</div><div class="line">                    darcy_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        darcy_preconditioner_constraints.distribute_local_to_global(</div><div class="line">          local_matrix, local_dof_indices, darcy_preconditioner_matrix);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::build_darcy_preconditioner()</div><div class="line">  {</div><div class="line">    assemble_darcy_preconditioner();</div><div class="line"></div><div class="line">    Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">    Amg_preconditioner-&gt;initialize(darcy_preconditioner_matrix.block(0, 0));</div><div class="line"></div><div class="line">    Mp_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">    Mp_preconditioner-&gt;initialize(darcy_preconditioner_matrix.block(1, 1));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_system()</div><div class="line">  {</div><div class="line">    darcy_matrix = 0;</div><div class="line">    darcy_rhs    = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(darcy_degree + 2);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(darcy_degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe,</div><div class="line">                                  quadrature_formula,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                       quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> darcy_fe_face_values(darcy_fe,</div><div class="line">                                           face_quadrature_formula,</div><div class="line">                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = darcy_fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> pressure_right_hand_side;</div><div class="line">    <span class="keyword">const</span> PressureBoundaryValues&lt;dim&gt;  pressure_boundary_values;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         pressure_rhs_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         boundary_values(n_face_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;         div_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;         phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">      {</div><div class="line">        darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(saturation_cell);</div><div class="line"></div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs    = 0;</div><div class="line"></div><div class="line">        saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                                 old_saturation_values);</div><div class="line"></div><div class="line">        pressure_right_hand_side.<a class="code" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">value_list</a>(</div><div class="line">          darcy_fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), pressure_rhs_values);</div><div class="line">        k_inverse.value_list(darcy_fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             k_inverse_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                phi_u[k]     = darcy_fe_values[velocities].value(k, q);</div><div class="line">                div_phi_u[k] = darcy_fe_values[velocities].divergence(k, q);</div><div class="line">                phi_p[k]     = darcy_fe_values[pressure].value(k, q);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_saturation_values[q];</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j)</div><div class="line">                  {</div><div class="line">                    local_matrix(i, j) +=</div><div class="line">                      (phi_u[i] * k_inverse_values[q] *</div><div class="line">                         mobility_inverse(old_s, viscosity) * phi_u[j] -</div><div class="line">                       div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div><div class="line">                      darcy_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                  }</div><div class="line"></div><div class="line">                local_rhs(i) +=</div><div class="line">                  (-phi_p[i] * pressure_rhs_values[q]) * darcy_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              darcy_fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line"></div><div class="line">              pressure_boundary_values.value_list(</div><div class="line">                darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), boundary_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u =</div><div class="line">                      darcy_fe_face_values[velocities].value(i, q);</div><div class="line"></div><div class="line">                    local_rhs(i) +=</div><div class="line">                      -(phi_i_u * darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q) *</div><div class="line">                        boundary_values[q] * darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                  }</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div><div class="line">            local_matrix(i, j) = local_matrix(j, i);</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        darcy_constraints.distribute_local_to_global(</div><div class="line">          local_matrix, local_rhs, local_dof_indices, darcy_matrix, darcy_rhs);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_system()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (rebuild_saturation_matrix == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line">        saturation_matrix = 0;</div><div class="line">        assemble_saturation_matrix();</div><div class="line">      }</div><div class="line"></div><div class="line">    saturation_rhs = 0;</div><div class="line">    assemble_saturation_rhs();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_matrix()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(saturation_degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                       quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs    = 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_s = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_s = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q);</div><div class="line">                  local_matrix(i, j) +=</div><div class="line">                    porosity * phi_i_s * phi_j_s * saturation_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        saturation_constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                                          local_dof_indices,</div><div class="line">                                                          saturation_matrix);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(saturation_degree + 2);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(saturation_degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                       quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> saturation_fe_face_values(saturation_fe,</div><div class="line">                                                face_quadrature_formula,</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> darcy_fe_face_values(darcy_fe,</div><div class="line">                                           face_quadrature_formula,</div><div class="line">                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> saturation_fe_face_values_neighbor(</div><div class="line">      saturation_fe, face_quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">      saturation_dof_handler.get_fe().n_dofs_per_cell();</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_max_u_F_prime = get_max_u_F_prime();</div><div class="line">    <span class="keyword">const</span> std::pair&lt;double, double&gt; global_S_range =</div><div class="line">      get_extrapolated_saturation_range();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> global_S_variation =</div><div class="line">      global_S_range.second - global_S_range.first;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell       = saturation_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc       = saturation_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       darcy_cell = darcy_dof_handler.begin_active();</div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++darcy_cell)</div><div class="line">      {</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(darcy_cell);</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        assemble_saturation_rhs_cell_term(saturation_fe_values,</div><div class="line">                                          darcy_fe_values,</div><div class="line">                                          global_max_u_F_prime,</div><div class="line">                                          global_S_variation,</div><div class="line">                                          local_dof_indices);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              darcy_fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(darcy_cell, face);</div><div class="line">              saturation_fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">              assemble_saturation_rhs_boundary_term(saturation_fe_face_values,</div><div class="line">                                                    darcy_fe_face_values,</div><div class="line">                                                    local_dof_indices);</div><div class="line">            }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_cell_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       saturation_fe_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       darcy_fe_values,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_max_u_F_prime,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_S_variation,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         old_saturation_solution_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_old_saturation_solution_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_grad_saturation_solution_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_grad_saturation_solution_values(</div><div class="line">      n_q_points);</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; present_darcy_solution_values(</div><div class="line">      n_q_points, Vector&lt;double&gt;(dim + 1));</div><div class="line"></div><div class="line">    saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                             old_saturation_solution_values);</div><div class="line">    saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">      old_old_saturation_solution, old_old_saturation_solution_values);</div><div class="line">    saturation_fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(</div><div class="line">      old_saturation_solution, old_grad_saturation_solution_values);</div><div class="line">    saturation_fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(</div><div class="line">      old_old_saturation_solution, old_old_grad_saturation_solution_values);</div><div class="line">    darcy_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(darcy_solution,</div><div class="line">                                        present_darcy_solution_values);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div><div class="line">      compute_viscosity(old_saturation_solution_values,</div><div class="line">                        old_old_saturation_solution_values,</div><div class="line">                        old_grad_saturation_solution_values,</div><div class="line">                        old_old_grad_saturation_solution_values,</div><div class="line">                        present_darcy_solution_values,</div><div class="line">                        global_max_u_F_prime,</div><div class="line">                        global_S_variation,</div><div class="line">                        saturation_fe_values.<a class="code" href="classFEValuesBase.html#a9d3a1c53c139e2553b672de682d6233e">get_cell</a>()-&gt;diameter());</div><div class="line"></div><div class="line">    Vector&lt;double&gt; local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>   old_s = old_saturation_solution_values[q];</div><div class="line">          <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            present_u[d] = present_darcy_solution_values[q](d);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_i_s = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q);</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_i_s =</div><div class="line">            saturation_fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q);</div><div class="line"></div><div class="line">          local_rhs(i) +=</div><div class="line">            (time_step * fractional_flow(old_s, viscosity) * present_u *</div><div class="line">               grad_phi_i_s -</div><div class="line">             time_step * nu * old_grad_saturation_solution_values[q] *</div><div class="line">               grad_phi_i_s +</div><div class="line">             porosity * old_s * phi_i_s) *</div><div class="line">            saturation_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        }</div><div class="line"></div><div class="line">    saturation_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                      local_dof_indices,</div><div class="line">                                                      saturation_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_boundary_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   saturation_fe_face_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   darcy_fe_face_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points =</div><div class="line">      saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; old_saturation_solution_values_face(n_face_q_points);</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; present_darcy_solution_values_face(</div><div class="line">      n_face_q_points, Vector&lt;double&gt;(dim + 1));</div><div class="line">    std::vector&lt;double&gt; neighbor_saturation(n_face_q_points);</div><div class="line"></div><div class="line">    saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">      old_saturation_solution, old_saturation_solution_values_face);</div><div class="line">    darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">      darcy_solution, present_darcy_solution_values_face);</div><div class="line"></div><div class="line">    SaturationBoundaryValues&lt;dim&gt; saturation_boundary_values;</div><div class="line">    saturation_boundary_values.value_list(</div><div class="line">      saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), neighbor_saturation);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">      {</div><div class="line">        <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u_face;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          present_u_face[d] = present_darcy_solution_values_face[q](d);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> normal_flux =</div><div class="line">          present_u_face * saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_outflow_q_point = (normal_flux &gt;= 0);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          local_rhs(i) -=</div><div class="line">            time_step * normal_flux *</div><div class="line">            fractional_flow((is_outflow_q_point == <span class="keyword">true</span> ?</div><div class="line">                               old_saturation_solution_values_face[q] :</div><div class="line">                               neighbor_saturation[q]),</div><div class="line">                            viscosity) *</div><div class="line">            saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q) *</div><div class="line">            saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">      }</div><div class="line">    saturation_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                      local_dof_indices,</div><div class="line">                                                      saturation_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> solve_for_pressure_and_velocity =</div><div class="line">      determine_whether_to_solve_for_pressure_and_velocity();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (solve_for_pressure_and_velocity == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving Darcy (pressure-velocity) system...&quot;</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_darcy_system();</div><div class="line">        build_darcy_preconditioner();</div><div class="line"></div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> LinearSolvers::InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                             TrilinosWrappers::PreconditionIC&gt;</div><div class="line">            mp_inverse(darcy_preconditioner_matrix.block(1, 1),</div><div class="line">                       *Mp_preconditioner);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">            <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#abee1d4aa6f0af5290aa7d51806bde982">TrilinosWrappers::PreconditionIC</a>,</div><div class="line">            TrilinosWrappers::PreconditionIC&gt;</div><div class="line">            preconditioner(darcy_matrix, mp_inverse, *Amg_preconditioner);</div><div class="line"></div><div class="line">          <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(darcy_matrix.m(),</div><div class="line">                                       1e-16 * darcy_rhs.l2_norm());</div><div class="line"></div><div class="line">          <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> gmres(</div><div class="line">            solver_control,</div><div class="line">            <a class="code" href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(</div><div class="line">              100));</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; darcy_solution.size(); ++i)</div><div class="line">            <span class="keywordflow">if</span> (darcy_constraints.is_constrained(i))</div><div class="line">              darcy_solution(i) = 0;</div><div class="line"></div><div class="line">          gmres.solve(darcy_matrix, darcy_solution, darcy_rhs, preconditioner);</div><div class="line"></div><div class="line">          darcy_constraints.distribute(darcy_solution);</div><div class="line"></div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;        ...&quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                    &lt;&lt; <span class="stringliteral">&quot; GMRES iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        {</div><div class="line">          second_last_computed_darcy_solution = last_computed_darcy_solution;</div><div class="line">          last_computed_darcy_solution        = darcy_solution;</div><div class="line"></div><div class="line">          saturation_matching_last_computed_darcy_solution =</div><div class="line">            saturation_solution;</div><div class="line">        }</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        darcy_solution = last_computed_darcy_solution;</div><div class="line">        darcy_solution.sadd(1 + current_macro_time_step / old_macro_time_step,</div><div class="line">                            -current_macro_time_step / old_macro_time_step,</div><div class="line">                            second_last_computed_darcy_solution);</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">    {</div><div class="line">      old_time_step = time_step;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> max_u_F_prime = get_max_u_F_prime();</div><div class="line">      <span class="keywordflow">if</span> (max_u_F_prime &gt; 0)</div><div class="line">        time_step = porosity * <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) /</div><div class="line">                    saturation_degree / max_u_F_prime / 50;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        time_step = end_time - time;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (solve_for_pressure_and_velocity == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line">        old_macro_time_step     = current_macro_time_step;</div><div class="line">        current_macro_time_step = time_step;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      current_macro_time_step += time_step;</div><div class="line"></div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving saturation transport equation...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      assemble_saturation_system();</div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(saturation_matrix.m(),</div><div class="line">                                   1e-16 * saturation_rhs.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">      TrilinosWrappers::PreconditionIC preconditioner;</div><div class="line">      preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html#a95eff1f8abcf2ba67815b6a96a66d375">initialize</a>(saturation_matrix);</div><div class="line"></div><div class="line">      cg.solve(saturation_matrix,</div><div class="line">               saturation_solution,</div><div class="line">               saturation_rhs,</div><div class="line">               preconditioner);</div><div class="line"></div><div class="line">      saturation_constraints.distribute(saturation_solution);</div><div class="line">      project_back_saturation();</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;        ...&quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_grid_level,</div><div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">  {</div><div class="line">    Vector&lt;double&gt; refinement_indicators(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQMidpoint.html">QMidpoint&lt;dim&gt;</a>        quadrature_formula;</div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               fe_values(saturation_fe,</div><div class="line">                              quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_saturation(1);</div><div class="line"></div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> extrapolated_saturation_solution(</div><div class="line">        saturation_solution);</div><div class="line">      <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">        extrapolated_saturation_solution.sadd((1. + time_step / old_time_step),</div><div class="line">                                              time_step / old_time_step,</div><div class="line">                                              old_saturation_solution);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = cell-&gt;active_cell_index();</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(extrapolated_saturation_solution,</div><div class="line">                                           grad_saturation);</div><div class="line"></div><div class="line">          refinement_indicators(cell_no) = grad_saturation[0].norm();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = cell-&gt;active_cell_index();</div><div class="line">          cell-&gt;clear_coarsen_flag();</div><div class="line">          cell-&gt;clear_refine_flag();</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> ((static_cast&lt;unsigned int&gt;(cell-&gt;level()) &lt; max_grid_level) &amp;&amp;</div><div class="line">              (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(refinement_indicators(cell_no)) &gt;</div><div class="line">               saturation_refinement_threshold))</div><div class="line">            cell-&gt;set_refine_flag();</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((static_cast&lt;unsigned int&gt;(cell-&gt;level()) &gt;</div><div class="line">                    min_grid_level) &amp;&amp;</div><div class="line">                   (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(refinement_indicators(cell_no)) &lt;</div><div class="line">                    0.5 * saturation_refinement_threshold))</div><div class="line">            cell-&gt;set_coarsen_flag();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">    {</div><div class="line">      std::vector&lt;TrilinosWrappers::MPI::Vector&gt; x_saturation(3);</div><div class="line">      x_saturation[0] = saturation_solution;</div><div class="line">      x_saturation[1] = old_saturation_solution;</div><div class="line">      x_saturation[2] = saturation_matching_last_computed_darcy_solution;</div><div class="line"></div><div class="line">      std::vector&lt;TrilinosWrappers::MPI::BlockVector&gt; x_darcy(2);</div><div class="line">      x_darcy[0] = last_computed_darcy_solution;</div><div class="line">      x_darcy[1] = second_last_computed_darcy_solution;</div><div class="line"></div><div class="line">      <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a> saturation_soltrans(</div><div class="line">        saturation_dof_handler);</div><div class="line"></div><div class="line">      <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::BlockVector&gt;</a> darcy_soltrans(</div><div class="line">        darcy_dof_handler);</div><div class="line"></div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">      saturation_soltrans.prepare_for_coarsening_and_refinement(x_saturation);</div><div class="line"></div><div class="line">      darcy_soltrans.prepare_for_coarsening_and_refinement(x_darcy);</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">      setup_dofs();</div><div class="line"></div><div class="line">      std::vector&lt;TrilinosWrappers::MPI::Vector&gt; tmp_saturation(3);</div><div class="line">      tmp_saturation[0].reinit(saturation_solution);</div><div class="line">      tmp_saturation[1].reinit(saturation_solution);</div><div class="line">      tmp_saturation[2].reinit(saturation_solution);</div><div class="line">      saturation_soltrans.interpolate(x_saturation, tmp_saturation);</div><div class="line"></div><div class="line">      saturation_solution                              = tmp_saturation[0];</div><div class="line">      old_saturation_solution                          = tmp_saturation[1];</div><div class="line">      saturation_matching_last_computed_darcy_solution = tmp_saturation[2];</div><div class="line"></div><div class="line">      saturation_constraints.distribute(saturation_solution);</div><div class="line">      saturation_constraints.distribute(old_saturation_solution);</div><div class="line">      saturation_constraints.distribute(</div><div class="line">        saturation_matching_last_computed_darcy_solution);</div><div class="line"></div><div class="line">      std::vector&lt;TrilinosWrappers::MPI::BlockVector&gt; tmp_darcy(2);</div><div class="line">      tmp_darcy[0].reinit(darcy_solution);</div><div class="line">      tmp_darcy[1].reinit(darcy_solution);</div><div class="line">      darcy_soltrans.interpolate(x_darcy, tmp_darcy);</div><div class="line"></div><div class="line">      last_computed_darcy_solution        = tmp_darcy[0];</div><div class="line">      second_last_computed_darcy_solution = tmp_darcy[1];</div><div class="line"></div><div class="line">      darcy_constraints.distribute(last_computed_darcy_solution);</div><div class="line">      darcy_constraints.distribute(second_last_computed_darcy_solution);</div><div class="line"></div><div class="line">      rebuild_saturation_matrix = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> joint_fe(darcy_fe, 1, saturation_fe, 1);</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>     joint_dof_handler(triangulation);</div><div class="line">    joint_dof_handler.distribute_dofs(joint_fe);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_dof_handler.n_dofs() ==</div><div class="line">             darcy_dof_handler.n_dofs() + saturation_dof_handler.n_dofs(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    Vector&lt;double&gt; joint_solution(joint_dof_handler.n_dofs());</div><div class="line"></div><div class="line">    {</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_joint_dof_indices(</div><div class="line">        joint_fe.n_dofs_per_cell());</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_darcy_dof_indices(</div><div class="line">        darcy_fe.n_dofs_per_cell());</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_saturation_dof_indices(</div><div class="line">        saturation_fe.n_dofs_per_cell());</div><div class="line"></div><div class="line">      <span class="keyword">auto</span>       joint_cell      = joint_dof_handler.begin_active();</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> joint_endc      = joint_dof_handler.end();</div><div class="line">      <span class="keyword">auto</span>       darcy_cell      = darcy_dof_handler.begin_active();</div><div class="line">      <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (; joint_cell != joint_endc;</div><div class="line">           ++joint_cell, ++darcy_cell, ++saturation_cell)</div><div class="line">        {</div><div class="line">          joint_cell-&gt;get_dof_indices(local_joint_dof_indices);</div><div class="line">          darcy_cell-&gt;get_dof_indices(local_darcy_dof_indices);</div><div class="line">          saturation_cell-&gt;get_dof_indices(local_saturation_dof_indices);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; joint_fe.n_dofs_per_cell(); ++i)</div><div class="line">            <span class="keywordflow">if</span> (joint_fe.system_to_base_index(i).first.first == 0)</div><div class="line">              {</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                         local_darcy_dof_indices.size(),</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                joint_solution(local_joint_dof_indices[i]) = darcy_solution(</div><div class="line">                  local_darcy_dof_indices[joint_fe.system_to_base_index(i)</div><div class="line">                                            .second]);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).first.first == 1,</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                         local_darcy_dof_indices.size(),</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                joint_solution(local_joint_dof_indices[i]) =</div><div class="line">                  saturation_solution(</div><div class="line">                    local_saturation_dof_indices</div><div class="line">                      [joint_fe.system_to_base_index(i).second]);</div><div class="line">              }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    std::vector&lt;std::string&gt; joint_solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    joint_solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">    joint_solution_names.emplace_back(<span class="stringliteral">&quot;saturation&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(joint_dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(joint_solution,</div><div class="line">                             joint_solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 5) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> TwoPhaseFlowProblem&lt;</div><div class="line">    dim&gt;::determine_whether_to_solve_for_pressure_and_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (timestep_number &lt;= 2)</div><div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(saturation_degree + 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(saturation_fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; old_saturation_after_solving_pressure(n_q_points);</div><div class="line">    std::vector&lt;double&gt; present_saturation(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_global_aop_indicator = 0.0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> max_local_mobility_reciprocal_difference = 0.0;</div><div class="line">        <span class="keywordtype">double</span> max_local_permeability_inverse_l1_norm   = 0.0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          saturation_matching_last_computed_darcy_solution,</div><div class="line">          old_saturation_after_solving_pressure);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(saturation_solution, present_saturation);</div><div class="line"></div><div class="line">        k_inverse.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             k_inverse_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> mobility_reciprocal_difference = <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(</div><div class="line">              mobility_inverse(present_saturation[q], viscosity) -</div><div class="line">              mobility_inverse(old_saturation_after_solving_pressure[q],</div><div class="line">                               viscosity));</div><div class="line"></div><div class="line">            max_local_mobility_reciprocal_difference =</div><div class="line">              <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_mobility_reciprocal_difference,</div><div class="line">                       mobility_reciprocal_difference);</div><div class="line"></div><div class="line">            max_local_permeability_inverse_l1_norm =</div><div class="line">              <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_permeability_inverse_l1_norm,</div><div class="line">                       <a class="code" href="tensor_8h.html#a93ba01d979880b278cd4b573dd9c653b">l1_norm</a>(k_inverse_values[q]));</div><div class="line">          }</div><div class="line"></div><div class="line">        max_global_aop_indicator =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_global_aop_indicator,</div><div class="line">                   (max_local_mobility_reciprocal_difference *</div><div class="line">                    max_local_permeability_inverse_l1_norm));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (max_global_aop_indicator &gt; AOS_threshold);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::project_back_saturation()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; saturation_solution.size(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (saturation_solution(i) &lt; 0.2)</div><div class="line">        saturation_solution(i) = 0.2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (saturation_solution(i) &gt; 1)</div><div class="line">        saturation_solution(i) = 1;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::get_max_u_F_prime()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(darcy_degree + 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                       quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; darcy_solution_values(n_q_points,</div><div class="line">                                                      Vector&lt;double&gt;(dim + 1));</div><div class="line">    std::vector&lt;double&gt;         saturation_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_velocity_times_dF_dS = 0;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">      {</div><div class="line">        darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(saturation_cell);</div><div class="line"></div><div class="line">        darcy_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(darcy_solution,</div><div class="line">                                            darcy_solution_values);</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                                 saturation_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">              velocity[i] = darcy_solution_values[q](i);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> dF_dS =</div><div class="line">              fractional_flow_derivative(saturation_values[q], viscosity);</div><div class="line"></div><div class="line">            max_velocity_times_dF_dS =</div><div class="line">              <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity_times_dF_dS, velocity.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() * dF_dS);</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> max_velocity_times_dF_dS;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::pair&lt;double, double&gt;</div><div class="line">  TwoPhaseFlowProblem&lt;dim&gt;::get_extrapolated_saturation_range()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(saturation_degree + 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(saturation_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_old_saturation_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">               max_saturation = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                          old_saturation_values);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_saturation_solution,</div><div class="line">                                          old_old_saturation_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> saturation =</div><div class="line">                  (1. + time_step / old_time_step) * old_saturation_values[q] -</div><div class="line">                  time_step / old_time_step * old_old_saturation_values[q];</div><div class="line"></div><div class="line">                min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_saturation, saturation);</div><div class="line">                max_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_saturation, saturation);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> std::make_pair(min_saturation, max_saturation);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">               max_saturation = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                          old_saturation_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> saturation = old_saturation_values[q];</div><div class="line"></div><div class="line">                min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_saturation, saturation);</div><div class="line">                max_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_saturation, saturation);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> std::make_pair(min_saturation, max_saturation);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::compute_viscosity(</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_saturation,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_saturation,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_saturation_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_saturation_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;Vector&lt;double&gt;&gt; &amp;present_darcy_values,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_max_u_F_prime,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_S_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta  = .4 * dim;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = 1;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (global_max_u_F_prime == 0)</div><div class="line">      <span class="keywordflow">return</span> 5e-3 * cell_diameter;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_saturation.size();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_residual             = 0;</div><div class="line">    <span class="keywordtype">double</span> max_velocity_times_dF_dS = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> use_dF_dS = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          u[d] = present_darcy_values[q](d);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> dS_dt = porosity *</div><div class="line">                             (old_saturation[q] - old_old_saturation[q]) /</div><div class="line">                             old_time_step;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> dF_dS = fractional_flow_derivative(</div><div class="line">          (old_saturation[q] + old_old_saturation[q]) / 2.0, viscosity);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_S =</div><div class="line">          u * dF_dS * (old_saturation_grads[q] + old_old_saturation_grads[q]) /</div><div class="line">          2.0;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> residual =</div><div class="line">          <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>((dS_dt + u_grad_S) *</div><div class="line">                   std::pow((old_saturation[q] + old_old_saturation[q]) / 2,</div><div class="line">                            alpha - 1.));</div><div class="line"></div><div class="line">        max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div><div class="line">        max_velocity_times_dF_dS =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u * u) * (use_dF_dS ? <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(dF_dS, 1.) : 1),</div><div class="line">                   max_velocity_times_dF_dS);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> c_R            = 1.0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> global_scaling = c_R * porosity *</div><div class="line">                                  (global_max_u_F_prime)*global_S_variation /</div><div class="line">                                  std::pow(global_Omega_diameter, alpha - 2.);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (beta *</div><div class="line">            (max_velocity_times_dF_dS)*<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(cell_diameter,</div><div class="line">                                                std::pow(cell_diameter, alpha) *</div><div class="line">                                                  max_residual /</div><div class="line">                                                  global_scaling));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TwoPhaseFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement     = (dim == 2 ? 5 : 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_pre_refinement_steps = (dim == 2 ? 3 : 2);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(initial_refinement);</div><div class="line">    global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(triangulation);</div><div class="line"></div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"></div><div class="line">  start_time_iteration:</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(saturation_dof_handler,</div><div class="line">                         saturation_constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(saturation_degree + 2),</div><div class="line">                         SaturationInitialValues&lt;dim&gt;(),</div><div class="line">                         old_saturation_solution);</div><div class="line"></div><div class="line">    time_step = old_time_step = 0;</div><div class="line">    current_macro_time_step = old_macro_time_step = 0;</div><div class="line"></div><div class="line">    time = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, dt=&quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (timestep_number % 200 == 0)</div><div class="line">          output_results();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (timestep_number % 25 == 0)</div><div class="line">          refine_mesh(initial_refinement,</div><div class="line">                      initial_refinement + n_pre_refinement_steps);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">            (pre_refinement_step &lt; n_pre_refinement_steps))</div><div class="line">          {</div><div class="line">            ++pre_refinement_step;</div><div class="line">            <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">          }</div><div class="line"></div><div class="line">        time += time_step;</div><div class="line">        ++timestep_number;</div><div class="line"></div><div class="line">        old_old_saturation_solution = old_saturation_solution;</div><div class="line">        old_saturation_solution     = saturation_solution;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (time &lt;= end_time);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step43</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step43;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-43&quot;</span>));</div><div class="line"></div><div class="line">      TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(1);</div><div class="line">      two_phase_flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_31.html">step-31</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Advectiondominatedtwophaseflowmathematicalmodel">Advection-dominated two-phase flow mathematical model.</a><a href="#Advectiondominatedtwophaseflowmathematicalmodel">Advection-dominated two-phase flow mathematical model.</a>
        <li><a href="#Adaptiveoperatorsplittingandtimestepping">Adaptive operator splitting and time stepping.</a><a href="#Adaptiveoperatorsplittingandtimestepping">Adaptive operator splitting and time stepping.</a>
        <li><a href="#Timediscretization">Time discretization.</a><a href="#Timediscretization">Time discretization.</a>
        <li><a href="#Weakformspacediscretizationforthepressurevelocitypart">Weak form, space discretization for the pressure-velocity part.</a><a href="#Weakformspacediscretizationforthepressurevelocitypart">Weak form, space discretization for the pressure-velocity part.</a>
        <li><a href="#Stabilizationweakformandspacediscretizationforthesaturationtransportequation">Stabilization, weak form and space discretization for the saturation transport equation.</a><a href="#Stabilizationweakformandspacediscretizationforthesaturationtransportequation">Stabilization, weak form and space discretization for the saturation transport equation.</a>
        <li><a href="#Adaptivemeshrefinement">Adaptive mesh refinement.</a><a href="#Adaptivemeshrefinement">Adaptive mesh refinement.</a>
        <li><a href="#Linearsystemanditspreconditioning">Linear system and its preconditioning.</a><a href="#Linearsystemanditspreconditioning">Linear system and its preconditioning.</a>
        <li><a href="#Thetestcases">The test cases.</a><a href="#Thetestcases">The test cases.</a>
        <li><a href="#Listofreferences">List of references</a><a href="#Listofreferences">List of references</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#Boundaryandinitialvalueclasses">Boundary and initial value classes</a><a href="#Boundaryandinitialvalueclasses">Boundary and initial value classes</a>
        <li><a href="#Permeabilitymodels">Permeability models</a><a href="#Permeabilitymodels">Permeability models</a>
        <li><a href="#Physicalquantities">Physical quantities</a><a href="#Physicalquantities">Physical quantities</a>
        <li><a href="#Helperclassesforsolversandpreconditioners">Helper classes for solvers and preconditioners</a><a href="#Helperclassesforsolversandpreconditioners">Helper classes for solvers and preconditioners</a>
        <li><a href="#TheTwoPhaseFlowProblemclass">The TwoPhaseFlowProblem class</a><a href="#TheTwoPhaseFlowProblemclass">The TwoPhaseFlowProblem class</a>
        <li><a href="#TwoPhaseFlowProblemdimTwoPhaseFlowProblem">TwoPhaseFlowProblem<dim>::TwoPhaseFlowProblem</a><a href="#TwoPhaseFlowProblemdimTwoPhaseFlowProblem">TwoPhaseFlowProblem<dim>::TwoPhaseFlowProblem</a>
        <li><a href="#TwoPhaseFlowProblemdimsetup_dofs">TwoPhaseFlowProblem<dim>::setup_dofs</a><a href="#TwoPhaseFlowProblemdimsetup_dofs">TwoPhaseFlowProblem<dim>::setup_dofs</a>
        <li><a href="#Assemblingmatricesandpreconditioners">Assembling matrices and preconditioners</a><a href="#Assemblingmatricesandpreconditioners">Assembling matrices and preconditioners</a>
      <ul>
        <li><a href="#TwoPhaseFlowProblemdimassemble_darcy_preconditioner">TwoPhaseFlowProblem<dim>::assemble_darcy_preconditioner</a><a href="#TwoPhaseFlowProblemdimassemble_darcy_preconditioner">TwoPhaseFlowProblem<dim>::assemble_darcy_preconditioner</a>
        <li><a href="#TwoPhaseFlowProblemdimbuild_darcy_preconditioner">TwoPhaseFlowProblem<dim>::build_darcy_preconditioner</a><a href="#TwoPhaseFlowProblemdimbuild_darcy_preconditioner">TwoPhaseFlowProblem<dim>::build_darcy_preconditioner</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_darcy_system">TwoPhaseFlowProblem<dim>::assemble_darcy_system</a><a href="#TwoPhaseFlowProblemdimassemble_darcy_system">TwoPhaseFlowProblem<dim>::assemble_darcy_system</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_saturation_system">TwoPhaseFlowProblem<dim>::assemble_saturation_system</a><a href="#TwoPhaseFlowProblemdimassemble_saturation_system">TwoPhaseFlowProblem<dim>::assemble_saturation_system</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_saturation_matrix">TwoPhaseFlowProblem<dim>::assemble_saturation_matrix</a><a href="#TwoPhaseFlowProblemdimassemble_saturation_matrix">TwoPhaseFlowProblem<dim>::assemble_saturation_matrix</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_saturation_rhs">TwoPhaseFlowProblem<dim>::assemble_saturation_rhs</a><a href="#TwoPhaseFlowProblemdimassemble_saturation_rhs">TwoPhaseFlowProblem<dim>::assemble_saturation_rhs</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_saturation_rhs_cell_term">TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_cell_term</a><a href="#TwoPhaseFlowProblemdimassemble_saturation_rhs_cell_term">TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_cell_term</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_saturation_rhs_boundary_term">TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_boundary_term</a><a href="#TwoPhaseFlowProblemdimassemble_saturation_rhs_boundary_term">TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_boundary_term</a>
      </ul>
        <li><a href="#TwoPhaseFlowProblemdimsolve">TwoPhaseFlowProblem<dim>::solve</a><a href="#TwoPhaseFlowProblemdimsolve">TwoPhaseFlowProblem<dim>::solve</a>
        <li><a href="#TwoPhaseFlowProblemdimrefine_mesh">TwoPhaseFlowProblem<dim>::refine_mesh</a><a href="#TwoPhaseFlowProblemdimrefine_mesh">TwoPhaseFlowProblem<dim>::refine_mesh</a>
        <li><a href="#TwoPhaseFlowProblemdimoutput_results">TwoPhaseFlowProblem<dim>::output_results</a><a href="#TwoPhaseFlowProblemdimoutput_results">TwoPhaseFlowProblem<dim>::output_results</a>
        <li><a href="#Toolfunctions">Tool functions</a><a href="#Toolfunctions">Tool functions</a>
      <ul>
        <li><a href="#TwoPhaseFlowProblemdimdetermine_whether_to_solve_for_pressure_and_velocity">TwoPhaseFlowProblem<dim>::determine_whether_to_solve_for_pressure_and_velocity</a><a href="#TwoPhaseFlowProblemdimdetermine_whether_to_solve_for_pressure_and_velocity">TwoPhaseFlowProblem<dim>::determine_whether_to_solve_for_pressure_and_velocity</a>
        <li><a href="#TwoPhaseFlowProblemdimproject_back_saturation">TwoPhaseFlowProblem<dim>::project_back_saturation</a><a href="#TwoPhaseFlowProblemdimproject_back_saturation">TwoPhaseFlowProblem<dim>::project_back_saturation</a>
        <li><a href="#TwoPhaseFlowProblemdimget_max_u_F_prime">TwoPhaseFlowProblem<dim>::get_max_u_F_prime</a><a href="#TwoPhaseFlowProblemdimget_max_u_F_prime">TwoPhaseFlowProblem<dim>::get_max_u_F_prime</a>
        <li><a href="#TwoPhaseFlowProblemdimget_extrapolated_saturation_range">TwoPhaseFlowProblem<dim>::get_extrapolated_saturation_range</a><a href="#TwoPhaseFlowProblemdimget_extrapolated_saturation_range">TwoPhaseFlowProblem<dim>::get_extrapolated_saturation_range</a>
        <li><a href="#TwoPhaseFlowProblemdimcompute_viscosity">TwoPhaseFlowProblem<dim>::compute_viscosity</a><a href="#TwoPhaseFlowProblemdimcompute_viscosity">TwoPhaseFlowProblem<dim>::compute_viscosity</a>
      </ul>
        <li><a href="#TwoPhaseFlowProblemdimrun">TwoPhaseFlowProblem<dim>::run</a><a href="#TwoPhaseFlowProblemdimrun">TwoPhaseFlowProblem<dim>::run</a>
        <li><a href="#Thecodemaincodefunction">The <code>main()</code> function</a><a href="#Thecodemaincodefunction">The <code>main()</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
 <em> This program was contributed by Chih-Che Chueh (University of Victoria) and Wolfgang Bangerth. Results from this program are used and discussed in the following publications (in particular in the second one):</em></p>
<p><em></p><ul>
<li>Chih-Che Chueh, Marc Secanell, Wolfgang Bangerth, Ned Djilali. Multi-level adaptive simulation of transient two-phase flow in heterogeneous porous media. Computers &amp; Fluids, 39:1585-1596, 2010</li>
<li>Chih-Che Chueh, Ned Djilali, Wolfgang Bangerth. An h-adaptive operator splitting method for two-phase flow in 3D heterogeneous porous media. SIAM Journal on Scientific Computing, 35:B149-B175, 2013.</li>
</ul>
<p></em></p>
<p><em>The implementation discussed here uses and extends parts of the <a class="el" href="step_21.html">step-21</a> and <a class="el" href="step_31.html">step-31</a> tutorial programs.</em></p>
<p><em>The work of the Chih-Che Chueh was funded through the Canada Research Chairs Program and the MITACS Network of Centres of Excellence. Parts of the work by Wolfgang Bangerth were funded through Award No. KUS-C1-016-04, made by the King Abdullah University of Science and Technology, and through an Alfred P. Sloan Research Fellowship. This material is also in parts based upon work supported by the National Science Foundation under Award No. EAR-0426271 and The California Institute of Technology; and in a continuation by the National Science Foundation under Award No. EAR-0949446 and The University of California &ndash; Davis. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation, The California Institute of Technology, or of The University of California &ndash; Davis. </em></p>
<p><a class="anchor" id="Introduction"></a><a class="anchor" id="Intro"></a> </p><h1>Introduction</h1>
<p>The simulation of multiphase flow in porous media is a ubiquitous problem, andwe have previously addressed it already in some form in <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a> . However, as was easy to see there, it faces two major difficulties:numerical accuracy and efficiency. The first is easy to see in the stationarysolver <a class="el" href="step_20.html">step-20</a> : using lowest order Raviart-Thomas elements can not be expectedto yield highly accurate solutions. We need more accurate methods. The secondreason is apparent from the time dependent <a class="el" href="step_21.html">step-21</a> : that program isexcruciatingly slow, and there is no hope to get highly accurate solutions in3d within reasonable time frames. In thisprogram, in order to overcome these two problems, there are five areas whichwe are trying to improve for a high performance simulator: </p><ul>
<li>
Higher order spatial discretizations </li>
<li>
Adaptive mesh refinement </li>
<li>
Adaptive time stepping </li>
<li>
Operator splitting </li>
<li>
Efficient solver and preconditioning </li>
</ul>
<p>Much inspiration for this program comes from <a class="el" href="step_31.html">step-31</a> but several of thetechniques discussed here are original.</p>
<p><a class="anchor" id="Advectiondominatedtwophaseflowmathematicalmodel"></a></p><h3>Advection-dominated two-phase flow mathematical model.</h3>
<p>We consider the flow of a two-phase immiscible, incompressiblefluid. Capillary and gravity effects are neglected, and viscouseffects are assumed dominant. The governing equations for such aflow that are identical to those used in <a class="el" href="step_21.html">step-21</a> and are </p><p class="formulaDsp">
\begin{align*} \mathbf{u}_t &amp;= - \mathbf{K} \lambda_t \left(S\right) \nabla p, \\ \nabla \cdot \mathbf{u}_t &amp;= q, \\ \epsilon \frac{\partial S}{\partial t} + \nabla \cdot \left( \mathbf{u}_t F\left( S \right) \right)&amp;=0, \end{align*}
</p>
<p> where \(S\) is the saturation (volume fraction between zero and one) of the second (wetting) phase, \(p\) is the pressure, \(\mathbf{K}\) is the permeability tensor, \(\lambda_t\) is the total mobility, \(\epsilon\) is the porosity, \(F\) is the fractional flow of the wetting phase, \(q\) is the source term and \(\mathbf{u}_t\) is the total velocity. The total mobility, fractional flow of the wetting phase and total velocity are respectively given by </p><p class="formulaDsp">
\begin{align*} \lambda_t(S)&amp;= \lambda_w + \lambda_{nw} = \frac{k_{rw}(S)}{\mu_w} + \frac{k_{rnw}(S)}{\mu_{nw}}, \\ F(S) &amp;= \frac{\lambda_w}{\lambda_t} = \frac{\lambda_w}{\lambda_w + \lambda_{nw}} = \frac{k_{rw}(S)/\mu_w}{k_{rw}(S)/\mu_w + k_{rnw}(S)/\mu_{nw}}, \\ \mathbf{u}_t &amp;= \mathbf{u}_w + \mathbf{u}_{nw} = -\lambda_t(S)\mathbf{K} \cdot \nabla p, \end{align*}
</p>
<p> where subscripts \(w, nw\) represent the wetting and non-wetting phases,respectively. For convenience, theporosity \(\epsilon\) in the saturation equation, which can be considered ascaling factor for the time variable, is set toone. Following a commonly used prescription for the dependence of the relativepermeabilities \(k_{rw}\) and \(k_{rnw}\) on saturation, we use </p><p class="formulaDsp">
\begin{align*} k_{rw} &amp;= S^2, \qquad&amp;\qquad k_{rnw} &amp;= \left( 1-S \right)^2. \end{align*}
</p>
<p>The porous media equations above areaugmented by initial conditions for the saturation and boundary conditions forthe pressure. Since saturation and the gradient of the pressure uniquelydetermine the velocity, no boundary conditions are necessary for the velocity.Since the flow equations do not contain time derivatives, initial conditions for the velocity and pressurevariables are not required. The flow field separates the boundary into inflow or outflowparts. Specifically, </p><p class="formulaDsp">
\[ \mathbf{\Gamma}_{in}(t) = \left\{\mathbf{x} \in \partial \Omega:\mathbf{n} \cdot \mathbf{u}_t&lt;0\right\}, \]
</p>
<p> we arrive at a complete model by also imposing boundary values for thesaturation variable on the inflow boundary \(\mathbf{\Gamma}_{in}\) .</p>
<p><a class="anchor" id="Adaptiveoperatorsplittingandtimestepping"></a></p><h3>Adaptive operator splitting and time stepping.</h3>
<p>As seen in <a class="el" href="step_21.html">step-21</a> , solving the flow equations for velocity and pressure arethe parts of the program that take far longer than the (explicit) updatingstep for the saturation variable once we know the flow variables. On the otherhand, the pressure and velocity depend only weakly on saturation, so one maythink about only solving for pressure and velocity every few time steps whileupdating the saturation in every step. If we can find a criterion for when theflow variables need to be updated, we call this splitting an "adaptiveoperator splitting" scheme. Here, we use the following a posteriori criterion to decide when to re-computepressure and velocity variables(detailed derivations and descriptions can be found in [Chueh, Djilaliand Bangerth 2011]): </p><p class="formulaDsp">
\begin{align*} \theta(n,n_p) = \max_{\kappa\in{\mathbb T}} \left( \left\| \frac 1{\lambda_t\left(S^{(n-1)}\right)} - \frac 1{\lambda_t\left(S^{(n_p)}\right)} \right\|_{L^\infty(\kappa)} \left\|\|\mathbf{K}^{-1}\|_1\right\|_{L^\infty(\kappa)} \right). \end{align*}
</p>
<p> where superscripts in parentheses denote the number of the saturation timestep at which any quantity is defined and \(n_p&lt;n\) represents the last stepwhere we actually computed the pressure and velocity. If \(\theta(n,n_p)\) exceeds a certain threshold we re-compute the flow variables; otherwise, weskip this computation in time step \(n\) and only move the saturation variableone time step forward. In short, the algorithm allows us to perform a number ofsaturation time steps of length \(\Delta t_c^{(n)}=t^{(n)}_c-t^{(n-1)}_c\) untilthe criterion above tells us to re-compute velocity and pressurevariables, leading to a macro time step of length </p><p class="formulaDsp">
\[ \Delta t_p^{(n)} = \sum_{i=n_p+1}^{n} \Delta t_c^{(i)}. \]
</p>
<p> choose the length of (micro) steps subject to the Courant-Friedrichs-Lewy(CFL) restriction according to the criterion </p><p class="formulaDsp">
\[ \Delta t_c = \frac{\textrm{min}_{K}h_{K}}{7 \|\mathbf{u}_t\|_{L^{\infty}\left(\Omega\right)}}, \]
</p>
<p> we have confirmed to be stable for the choice of finite element and timestepping scheme for the saturation equation discussed below ( \(h_K\) denotes thediameter of cell \(K\) ).The result is a scheme where neither micro nor macro timesteps are of uniform length, and both are chosen adaptively. <a class="anchor" id="Timediscretization"></a></p><h3>Time discretization.</h3>
<p>Using this time discretization, we obtain the following set of equations foreach time step from the IMPES approach (see <a class="el" href="step_21.html">step-21</a> ): </p><p class="formulaDsp">
\begin{align*} \mathbf{u}^{(n)}_t + \lambda_t\left(S^{(n-1)}\right) \mathbf{K} \nabla p^{(n)} =0, \\ \nabla \cdot \mathbf{u}^{(n)}_t = q, \\ \epsilon \left( \frac{S^{(n-1)}-S^{(n)}}{\Delta t^{(n)}_c} \right) + \mathbf{u}^{(n)}_t \cdot \nabla F\left(S^{(n-1)}\right) + F\left(S^{(n-1)}\right) \nabla \cdot \mathbf{u}^{(n)}_t =0. \end{align*}
</p>
<p>Using the fact that \(\nabla \cdot \mathbf{u}_t = q\) , the time discretesaturation equation becomes </p><p class="formulaDsp">
\begin{align*} &amp;\epsilon \left( \frac{S^{(n)}-S^{(n-1)}}{\Delta t^{(n)}_c} \right) + \mathbf{u}^{(n)}_t \cdot \nabla F\left(S^{(n-1)}\right) + F\left(S^{(n-1)}\right)q=0. \end{align*}
</p>
<p><a class="anchor" id="Weakformspacediscretizationforthepressurevelocitypart"></a></p><h3>Weak form, space discretization for the pressure-velocity part.</h3>
<p>By multiplying the equations defining the total velocity \(\mathbf u_t^{(n)}\) andthe equation that expresses its divergence in terms of source terms, with testfunctions \(\mathbf{v}\) and \(w\) respectively and then integrating terms by parts as necessary, the weak formof the problem reads: Find \(\mathbf u, p\) so that for all test functions \(\mathbf{v}, w\) there holds </p><p class="formulaDsp">
\begin{gather*} \left( \left( \mathbf{K} \lambda_t\left(S^{(n-1)}\right) \right)^{-1} \mathbf{u}^{(n)}_t, \mathbf{v}\right)_{\Omega} - \left(p^{(n)}, \nabla \cdot \mathbf{v}\right)_{\Omega} = -\left(p^{(n)}, \mathbf{n} \cdot \mathbf{v} \right)_{\partial \Omega}, \\ - \left( \nabla \cdot \mathbf{u}^{(n)}_t,w\right)_{\Omega} = - \big(q,w\big)_{\Omega}. \end{gather*}
</p>
<p> Here, \(\mathbf{n}\) represents the unit outward normal vector to \(\partial \Omega\) and the pressure \(p^{(n)}\) can be prescribed weakly on the open partof the boundary \(\partial \Omega\) whereas on those parts where a velocity isprescribed (for example impermeable boundaries with \(\mathbf n \cdot \mathbf u=0\) the term disappears altogether because \(\mathbf n \cdot \mathbf v=0\) . We use continuous finite elements to discretize the velocity and pressureequations. Specifically, we use mixed finite elements to ensure high order approximationfor both vector (e.g. a fluid velocity) and scalar variables (e.g. pressure)simultaneously. For saddle point problems, it is well established thatthe so-called Babuska-Brezzi or Ladyzhenskaya-Babuska-Brezzi (LBB) conditions[Brezzi 1991, Chen 2005] need to be satisfied to ensure stability ofthe pressure-velocity system. These stability conditions are satisfied in thepresent work by using elements for velocity that are one order higher than forthe pressure, i.e. \(u_h \in Q^d_{p+1}\) and \(p_h \in Q_p\) , where \(p=1\) , \(d\) isthe space dimension, and \(Q_s\) denotes the space of tensor product Lagrangepolynomials of degree \(s\) in each variable. <a class="anchor" id="Stabilizationweakformandspacediscretizationforthesaturationtransportequation"></a></p><h3>Stabilization, weak form and space discretization for the saturation transport equation.</h3>
<p>The chosen \(Q_1\) elements for the saturation equation do not lead to a stablediscretization without upwinding or other kinds of stabilization, and spuriousoscillations will appear in the numerical solution. Adding an artificialdiffusion term is one approach to eliminating these oscillations[Chen 2005]. On the other hand, adding too much diffusion smears sharpfronts in the solution and suffers from grid-orientation difficulties[Chen 2005]. To avoid these effects, we use the artificial diffusionterm proposed by [Guermond and Pasquetti 2008] andvalidated in [Chueh, Djilali, Bangerth 2011] and[Kronbichler, Heister and Bangerth, 2011], as well as in <a class="el" href="step_31.html">step-31</a> . This method modifies the (discrete) weak form of the saturation equationto read </p><p class="formulaDsp">
\begin{align*} \left(\epsilon \frac{\partial S_h}{\partial t},\sigma_h\right) - \left(\mathbf{u}_t F\left( S_h \right), \nabla \sigma_h\right) + \left(\mathbf n \cdot \mathbf{u}_t \hat F\left( S_h \right), \sigma_h\right)_{\partial\Omega} + (\nu(S_h) \nabla S_h, \nabla \sigma_h) &amp;=0 \qquad \forall \sigma_h, \end{align*}
</p>
<p> where \(\nu\) is the artificial diffusion parameter and \(\hat F\) is anappropriately chosen numerical flux on the boundary of the domain (we choosethe obvious full upwind flux for this). Following [Guermond and Pasquetti 2008] (and as detailed in[Chueh, Djilali and Bangerth 2011]), we usethe parameter as a piecewiseconstant function set on each cell \(K\) with the diameter \(h_{K}\) as </p><p class="formulaDsp">
\[ \nu(S_h)|_{K} = \beta \| \mathbf{u}_t \max\{F&#39;(S_h),1\} \|_{L^{\infty}(K)} \textrm{min} \left\{ h_{K},h^{\alpha}_{K} \frac{\|\textrm{Res}(S_h)\|_{L^{\infty}(K)}}{c(\mathbf{u}_t,S)} \right\} \]
</p>
<p> \(\alpha\) is a stabilization exponent and \(\beta\) is a dimensionlessuser-defined stabilization constant. Following [Guermond and Pasquetti 2008]as well as the implementation in <a class="el" href="step_31.html">step-31</a> , the velocity and saturation globalnormalization constant, \(c(\mathbf{u}_t,S)\) , and the residual \(\textrm{Res}(S)\) are respectively given by </p><p class="formulaDsp">
\[ c(\mathbf{u}_t,S) = c_R \|\mathbf{u}_t \max\{F&#39;(S),1\}\|_{L^{\infty}(\Omega)} \textrm{var}(S)^\alpha | \textrm{diam} (\Omega) |^{\alpha - 2} \]
</p>
 <p class="formulaDsp">
\[ \textrm{Res}(S) = \left( \epsilon \frac{\partial S}{\partial t} + \mathbf{u}_t \cdot \nabla F(S) + F(S)q \right) \cdot S^{\alpha - 1} \]
</p>
<p> \(c_R\) is a second dimensionless user-defined constant, \(\textrm{diam}(\Omega)\) is the diameter of the domain and \(\textrm{var}(S) = \textrm{max}_{\Omega} S - \textrm{min}_{\Omega} S\) is the range of the presentsaturation values in the entire computational domain \(\Omega\) . This stabilization scheme has a number of advantages over simpler schemes suchas finite volume (or discontinuous Galerkin) methods or streamline upwindPetrov Galerkin (SUPG) discretizations. In particular, the artificialdiffusion term acts primarily in the vicinity of discontinuitiessince the residual is small in areas where the saturation is smooth. Ittherefore provides for a higher degree of accuracy. On the other hand, it isnonlinear since \(\nu\) depends on the saturation \(S\) . We avoid this difficultyby treating all nonlinear terms explicitly, which leads to the followingfully discrete problem at time step \(n\) : </p><p class="formulaDsp">
\begin{align*} &amp;\left( \epsilon S_h^{(n)},\sigma_h\right)_{\Omega} - \Delta t^{(n)}_c \Big(F\left(S_h^{(n-1)}\right)\mathbf{u}^{*}_t,\nabla\sigma_h\Big)_{\Omega} + \Delta t^{(n)}_c \Big(F\left(S_h^{(n-1)}\right)\left(\mathbf{n}\cdot\mathbf{u}^{*}_t\right),\sigma_h\Big)_{\partial\Omega} \nonumber \\ &amp; \quad = \left( \epsilon S_h^{(n-1)},\sigma_h\right)_{\Omega} - \Delta t^{(n)}_c \bigg(\nu\left(S_h^{(n-1)}\right)\nabla S_h^{(n-1)},\nabla\sigma_h\bigg)_{\Omega} \nonumber \\ &amp; \qquad + \Delta t^{(n)}_c \bigg(\mathbf{n}\cdot\nu\left(S_h^{(n-1)}\right)\nabla S^{(n-1)},\sigma_h\bigg)_{\partial\Omega} \end{align*}
</p>
<p> where \(\mathbf{u}_t^{*}\) is the velocity linearly extrapolated from \(\mathbf{u}^{(n_p)}_t\) and \(\mathbf{u}^{(n_{pp})}_t\) to the current time \(t^{(n)}\) if \(\theta&lt;\theta^*\) while \(\mathbf{u}_t^{*}\) is \(\mathbf{u}^{(n_p)}_t\) if \(\theta&gt;\theta^*\) .Consequently, the equation is linear in \(S_h^{(n)}\) and all that is requiredis to solve with a mass matrix on the saturation space. Since the Dirichlet boundary conditions for saturation are only imposed on theinflow boundaries, the third term on the left hand side of the equation aboveneeds to be split further into two parts: </p><p class="formulaDsp">
\begin{align*} &amp;\Delta t^{(n)}_c \Big(F\left(S_h^{(n-1)}\right)\left(\mathbf{n}\cdot\mathbf{u}^{(n)}_t\right),\sigma_h\Big)_{\partial\Omega} \nonumber \\ &amp;\qquad= \Delta t^{(n)}_c \Big(F\left(S^{(n-1)}_{(+)}\right)\left(\mathbf{n}\cdot\mathbf{u}^{(n)}_{t(+)}\right),\sigma_h\Big)_{\partial\Omega_{(+)}} + \Delta t^{(n)}_c \Big(F\left(S^{(n-1)}_{(-)}\right)\left(\mathbf{n}\cdot\mathbf{u}^{(n)}_{t(-)}\right),\sigma_h\Big)_{\partial\Omega_{(-)}} \end{align*}
</p>
<p> where \(\partial\Omega_{(-)} = \left\{\mathbf{x} \in \partial\Omega : \mathbf{n} \cdot \mathbf{u}_t&lt;0\right\}\) and \(\partial\Omega_{(+)} = \left\{\mathbf{x} \in \partial\Omega : \mathbf{n} \cdot \mathbf{u}_t&gt;0\right\}\) represent inflow and outflow boundaries,respectively. We choose values using anupwind formulation, i.e. \(S^{(n-1)}_{(+)}\) and \(\mathbf{u}^{(n)}_{t(+)}\) correspond to the values taken from the present cell, while the values of \(S^{(n-1)}_{(-)}\) and \(\mathbf{u}^{(n)}_{t(-)}\) are those taken from theneighboring boundary \(\partial\Omega_{(-)}\) .</p>
<p><a class="anchor" id="Adaptivemeshrefinement"></a></p><h3>Adaptive mesh refinement.</h3>
<p>Choosing meshes adaptively to resolve sharpsaturation fronts is an essential ingredient to achieve efficiency in ouralgorithm. Here, we use the same shock-type refinement approach used in[Chueh, Djilali and Bangerth 2011] to select those cells that should be refined orcoarsened. The refinement indicator for each cell \(K\) of the triangulation iscomputed by </p><p class="formulaDsp">
\[ \eta_{K} = |\nabla S_h(\mathbf x_K)| \]
</p>
<p> \(\nabla S_h(\mathbf x_K)\) is the gradient of the discrete saturationvariable evaluated at the center \(\mathbf x_K\) of cell \(K\) . This approach isanalogous to ones frequently used in compressible flow problems, where densitygradients are used to indicate refinement. That said, as we willdiscuss at the end of the <a href="#Results">results section</a>, this turnsout to not be a very useful criterion since it leads to refinement basicallyeverywhere. We only show it here for illustrative purposes.</p>
<p><a class="anchor" id="Linearsystemanditspreconditioning"></a></p><h3>Linear system and its preconditioning.</h3>
<p>Following the discretization of the governing equationsdiscussed above, weobtain a linear system of equations in time step \((n)\) of the following form: </p><p class="formulaDsp">
\[ \left( \begin{array}{ccc} \mathbf{M}^{\mathbf{u}} &amp; \mathbf{B}^{T} &amp; \mathbf{0} \\ \mathbf{B} &amp; \mathbf{0} &amp; \mathbf{0} \\ \mathbf{H} &amp; \mathbf{0} &amp; \mathbf{M}^{S} \end{array} \right) \left( \begin{array}{c} \mathbf{U}^{(n)} \\ \mathbf{P}^{(n)} \\ \mathbf{S}^{(n)} \end{array} \right) = \left( \begin{array}{c} 0 \\ \mathbf{F}_{2} \\ \mathbf{F}_{3} \end{array} \right) \]
</p>
<p> the individual matrices and vectors are defined as follows using shape functions \(\mathbf{v}_i\) for velocity, and \(\phi_i\) for both pressure and saturation: </p><p class="formulaDsp">
\begin{align*} \mathbf{M}^{\mathbf{u}}_{ij} &amp;= \left( \left( \mathbf{K} \lambda_t\left(S^{(n-1)}\right) \right)^{-1} \mathbf{v}_{i},\mathbf{v}_{j}\right)_{\Omega}, &amp; \mathbf{M}^{S}_{ij} &amp;= \left(\epsilon \phi_i,\phi_j\right)_{\Omega} \\ \mathbf{B}_{ij} &amp;= - \left( \nabla \cdot \mathbf{v}_{j},\phi_{i}\right)_{\Omega}, &amp; \mathbf{H}_{ij} &amp;= - \Delta t^{(n)}_c \Big( F\left(S^{(n-1)}\right) \mathbf{v}_i,\nabla\phi_j\Big)_{\Omega} \\ \left(\mathbf{F}_{2}\right)_i &amp;= - \big(F\left(S^{(n-1)}\right)q,\phi_i\big)_{\Omega}, \end{align*}
</p>
<p> and \(\mathbf{F}_{3}\) as given in the definition of the stabilized transportequation. The linear system above is of block triangular form if we consider the topleft \(2\times 2\) panel of matrices as one block. We can therefore first solvefor the velocity and pressure (unless we decide to use \(\mathbf U^{(n_p)}\) inplace of the velocity)followed by a solve for the saturation variable. The first of these stepsrequires us to solve </p><p class="formulaDsp">
\[ \left( \begin{array}{cc} \mathbf{M}^{\mathbf{u}} &amp; \mathbf{B}^{T} \\ \mathbf{B} &amp; \mathbf{0} \end{array} \right) \left( \begin{array}{c} \mathbf{U}^{(n)} \\ \mathbf{P}^{(n)} \end{array} \right) = \left( \begin{array}{c} 0 \\ \mathbf{F}_{2} \end{array} \right) \]
</p>
<p> apply the Generalized Minimal Residual (GMRES) method [Saad and Schultz1986] to this linear system. The ideal preconditioner for thevelocity-pressure system is </p><p class="formulaDsp">
\begin{align*} \mathbf{P} = \left( \begin{array}{cc} \mathbf{M}^{\mathbf{u}} &amp; \mathbf{0} \\ \mathbf{B} &amp; -\mathbf{S} \end{array} \right), &amp; \qquad \mathbf{P}^{-1} = \left( \begin{array}{cc} \left(\mathbf{M}^{\mathbf{u}}\right)^{-1} &amp; \mathbf{0} \\ \mathbf{S}^{-1} \mathbf{B} \left(\mathbf{M}^{\mathbf{u}}\right)^{-1} &amp; -\mathbf{S}^{-1} \end{array} \right) \end{align*}
</p>
<p> where \(\mathbf{S}=\mathbf{B}\left(\mathbf{M}^{\mathbf{u}}\right)^{-1}\mathbf{B}^T\) isthe Schur complement [Zhang 2005] of the system. This preconditioner isoptimal since </p><p class="formulaDsp">
\begin{align*} \mathbf{P}^{-1} \left( \begin{array}{cc} \mathbf{M}^{\mathbf{u}} &amp; \mathbf{B}^{T} \\ \mathbf{B} &amp; \mathbf{0} \end{array} \right) = \left( \begin{array}{cc} \mathbf{I} &amp; \left(\mathbf{M}^{\mathbf{u}}\right)^{-1} \mathbf{B}^{T} \\ \mathbf{0} &amp; \mathbf{I} \end{array} \right), \end{align*}
</p>
<p> for which it can be shown that GMRES converges in two iterations. However, we cannot of course expect to use exact inverses of thevelocity mass matrix and the Schur complement. We therefore follow theapproach by [Silvester and Wathen 1994] originally proposed forthe Stokes system. Adapting it to the current set of equations yield thepreconditioner </p><p class="formulaDsp">
\begin{align*} \mathbf{\tilde{P}}^{-1} = \left( \begin{array}{cc} \widetilde{\left(\mathbf{{M}}^{\mathbf{u}}\right)^{-1}} &amp; \mathbf{0} \\ \widetilde{\mathbf{{S}}^{-1}} \mathbf{B} \widetilde{\left(\mathbf{{M}}^{\mathbf{u}}\right)^{-1}} &amp; -\widetilde{\mathbf{{S}}^{-1}} \end{array} \right) \end{align*}
</p>
<p> where a tilde indicates an approximation of the exact inverse matrix. Inparticular, since \(\left(\mathbf{{M}}^{\mathbf{u}}\right)^{-1}=\left( \left( \mathbf{K} \lambda_t \right)^{-1} \mathbf{v}_{i},\mathbf{v}_{j}\right)_{\Omega}\) is a sparse symmetric and positive definite matrix, we choose for \(\widetilde{\left(\mathbf{{M}}^{\mathbf{u}}\right)^{-1}}\) a single application ofa sparse incomplete Cholesky decomposition of this matrix[Golub and Van Loan 1996].We note that the Schur complement that corresponds to the porousmedia flow operator in non-mixed form, \(-\nabla \cdot [\mathbf K \lambda_t(S)]\nabla\) and \(\mathbf{\tilde {S}} = \left( \left( \mathbf{K} \lambda_t \right) \nabla \phi_{i},\nabla \phi_{j}\right)_{\Omega}\) should be a good approximation of the actual Schur complement matrix \(\mathbf S\) . Since both of these matrices are again symmetric and positive definite, weuse an incomplete Cholesky decomposition of \(\mathbf{\tilde S}\) for \(\widetilde {\mathbf{{S}}^{-1}}\) . It is important to note that \(\mathbf{\tilde S}\) needsto be built with Dirichlet boundary conditions to ensure its invertibility. Once the velocity \(\mathbf{U}^{(n)} \equiv \mathbf{u}^*_t\) is available, wecan assemble \(\mathbf{H}\) and \(\mathbf{F}_{3}\) and solve for the saturations using </p><p class="formulaDsp">
\begin{align*} \mathbf{M}^{S} \mathbf{S}^{(n)} = \mathbf{F}_{3} - \mathbf{H} \mathbf{U}^{(n)}. \end{align*}
</p>
<p> where the mass matrix \(\mathbf{M}^{S}\) is solved by the conjugate gradientmethod, using an incomplete Cholesky decomposition as preconditioner oncemore. <a class="anchor" id="Thetestcases"></a></p><h3>The test cases.</h3>
<pre class="fragment">@note  The implementation discussed here uses and extendsparts of the   @ref step_21 "step-21"  ,   @ref step_31 "step-31"   and   @ref step_33 "step-33"   tutorial programs of thislibrary. In particular, if you want to understand how it works, pleaseconsult   @ref step_21 "step-21"   for a discussion of the mathematical problem, and  @ref step_31 "step-31"   from which most of the implementation is derived. We will notdiscuss aspects of the implementation that have already been discussedin   @ref step_31 "step-31"  .
</pre><p> We show numerical results for some two-phase flow equations augmented byappropriate initial and boundary conditions in conjunction with two differentchoices of the permeability model. In the problems considered, there is nointernal source term ( \(q=0\) ). As mentioned above, quantitative numericalresults are presented in [Chueh, Djilali and Bangerth 2011]. For simplicity, we choose \(\Omega=[0,1]^d,d=2,3\) , though all methods (as wellas our implementation) should work equally well on general unstructured meshes. Initial conditions are only required for the saturation variable, and wechoose \(S(\mathbf{x},0)=0.2\) , i.e. the porous medium is initially filled by amixture of the non-wetting (80%) and wetting (20%) phases. This differs fromthe initial condition in <a class="el" href="step_21.html">step-21</a> where we had taken \(S(\mathbf{x},0)=0\) , butfor complicated mathematical reasons that are mentioned there in a longishremark, the current method using an entropy-based artificial diffusion termdoes not converge to the viscosity solution with this initial conditionwithout additional modifications to the method. We therefore choose thismodified version for the current program. Furthermore, we prescribe a linear pressure onthe boundaries: </p><p class="formulaDsp">
\[ p(\mathbf{x},t) = 1 - x \qquad \textrm{on} \quad \partial \Omega \times [0,T]. \]
</p>
<p> and saturation uniquelydetermine a velocity, and the velocity determines whether a boundary segmentis an inflow or outflow boundary. On the inflow part of the boundary, \(\mathbf{\Gamma}_{in}(t)\) , we impose </p><p class="formulaDsp">
\begin{align*} S(\mathbf{x},t) = 1 \qquad &amp; \textrm{on} \quad \mathbf{\Gamma}_{in}(t) \cap \left\{x = 0\right\}, \\ S(\mathbf{x},t) = 0 \qquad &amp; \textrm{on} \quad \mathbf{\Gamma}_{in}(t) \backslash \left\{x = 0\right\}. \end{align*}
</p>
<p> In other words, the domain is flooded by the wetting phase from the left.No boundary conditions for the saturation are required for the outflow partsof the boundary. All the numerical and physical parameters used for the 2D/3Dcases are listed in the following table: </p><table align="center" class="tutorial" width="50%">
<tr>
<th>Parameter </th><th>Symbol </th><th>Value </th><th>units </th></tr>
<tr>
<td>Porosity </td><td>\(\epsilon\) </td><td>1.0 </td><td>- </td></tr>
<tr>
<td>Viscosity (wetting) </td><td>\(\mu_w\) </td><td>0.2 </td><td>\(kg \cdot m^{-1} \cdot sec^{-1}\) </td></tr>
<tr>
<td>Viscosity (nonwetting) </td><td>\(\mu_{nw}\) </td><td>1.0 </td><td>\(kg \cdot m^{-1} \cdot sec^{-1}\) </td></tr>
<tr>
<td>Stabilization exponent </td><td>\(\alpha\) </td><td>1.0 </td><td>- </td></tr>
<tr>
<td>Stabilization constant </td><td>\(\beta\) </td><td>2D: 0.3; 3D: 0.27 </td><td>- </td></tr>
<tr>
<td>Normalization constant </td><td>\(c_R\) </td><td>1.0 </td><td>- </td></tr>
<tr>
<td>Number of high-permeability regions </td><td>\(N\) </td><td>50; 200 </td><td>- </td></tr>
<tr>
<td>Operator splitting threshold </td><td>\(\theta^\ast\) </td><td>5.0 </td><td>-  </td></tr>
</table>
<p><a class="anchor" id="Listofreferences"></a></p><h3>List of references</h3>
<pre class="fragment">&lt;ol&gt;    &lt;li&gt;  CC Chueh, N Djilali and W Bangerth.  &lt;br&gt;   An h-adaptive operator splitting method for two-phase flow in 3D  heterogeneous porous media.  &lt;br&gt;   SIAM Journal on Scientific Computing, vol. 35 (2013), pp. B149-B175
&lt;li&gt;  M. Kronbichler, T. Heister, and W. Bangerth  &lt;br&gt;   High Accuracy Mantle Convection Simulation through Modern NumericalMethods.  &lt;br&gt;   Geophysics Journal International, vol. 191 (2012), pp. 12-29
&lt;li&gt;  F Brezzi and M Fortin.  &lt;br&gt;   &lt;i&gt;Mixed and Hybrid Finite Element Methods&lt;/i&gt;.  &lt;br&gt;   Springer-Verlag, 1991.
&lt;li&gt;  Z Chen.  &lt;br&gt;   &lt;i&gt;Finite Element Methods and Their Applications&lt;/i&gt;.  &lt;br&gt;   Springer, 2005.
&lt;li&gt;  JL Guermond and R Pasquetti.  &lt;br&gt;   Entropy-based nonlinear viscosity for Fourier approximations of  conservation laws.  &lt;br&gt;   &lt;i&gt;Comptes Rendus Mathematique&lt;/i&gt;, 346(13-14):801-806, 2008.
&lt;li&gt;  CC Chueh, M Secanell, W Bangerth, and N Djilali.  &lt;br&gt;   Multi-level adaptive simulation of transient two-phase flow in  heterogeneous porous media.  &lt;br&gt;   &lt;i&gt;Computers and Fluids&lt;/i&gt;, 39:1585-1596, 2010.
&lt;li&gt;  Y Saad and MH Schultz.  &lt;br&gt;   Gmres: A generalized minimal residual algorithm for solving  nonsymmetric linear systems.  &lt;br&gt;   &lt;i&gt;SIAM Journal on Scientific and Statistical Computing&lt;/i&gt;,  7(3):856-869, 1986.
&lt;li&gt;  F Zhang.  &lt;br&gt;   &lt;i&gt;The Schur Complement and its Applications&lt;/i&gt;.  &lt;br&gt;   Springer, 2005.
&lt;li&gt;  D Silvester and A Wathen.  &lt;br&gt;   Fast iterative solution of stabilised Stokes systems part ii: Using  general block preconditioners.  &lt;br&gt;   &lt;i&gt;SIAM Journal on Numerical Analysis&lt;/i&gt;, 31(5):1352-1367, 1994.
&lt;li&gt;  GH Golub and CF van Loan.  &lt;br&gt;   &lt;i&gt;Matrix Computations&lt;/i&gt;.  &lt;br&gt;   3rd Edition, Johns Hopkins, 1996.
&lt;li&gt;  SE Buckley and MC Leverett.  &lt;br&gt;   Mechanism of fluid displacements in sands.  &lt;br&gt;   &lt;i&gt;AIME Trans.&lt;/i&gt;, 146:107-116, 1942.
&lt;/ol&gt;  
</pre><p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first step, as always, is to include the functionality of a number of deal.II and C++ header files.</p>
<p>The list includes some header files that provide vector, matrix, and preconditioner classes that implement interfaces to the respective Trilinos classes; some more information on these may be found in <a class="el" href="step_31.html">step-31</a> .</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div></div><!-- fragment --><p>At the end of this top-matter, we open a namespace for the current project into which all the following material will go, and then import all deal.II names into this namespace:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step43</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Boundaryandinitialvalueclasses"></a> </p><h3>Boundary and initial value classes</h3>
<p>The following part is taken directly from <a class="el" href="step_21.html">step-21</a> so there is no need to repeat the descriptions found there.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>PressureBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     PressureBoundaryValues()</div><div class="line">       : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">     {}</div><div class="line">  </div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">   };</div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">double</span></div><div class="line">   PressureBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span> )<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <span class="keywordflow">return</span> 1</div><div class="line">  </div><div class="line">- p[0];</div><div class="line">   }</div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>SaturationBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     SaturationBoundaryValues()</div><div class="line">       : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">     {}</div><div class="line">  </div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">   };</div><div class="line">  </div><div class="line"> </div><div class="line">  </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">double</span></div><div class="line">   SaturationBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span> )<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <span class="keywordflow">if</span> (p[0] == 0)</div><div class="line">       <span class="keywordflow">return</span> 1;</div><div class="line">     <span class="keywordflow">else</span></div><div class="line">       <span class="keywordflow">return</span> 0;</div><div class="line">   }</div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keyword">class </span>SaturationInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     SaturationInitialValues()</div><div class="line">       : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">     {}</div><div class="line">  </div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  </div><div class="line">     <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                               <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div><div class="line">   };</div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">double</span></div><div class="line">   SaturationInitialValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;  <span class="comment">/*p*/</span> ,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span> )<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <span class="keywordflow">return</span> 0.2;</div><div class="line">   }</div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> SaturationInitialValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                                   <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">       <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = SaturationInitialValues&lt;dim&gt;::value(p, c);</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="Permeabilitymodels"></a> </p><h3>Permeability models</h3>
<p>In this tutorial, we still use the two permeability models previously used in <a class="el" href="step_21.html">step-21</a> so we again refrain from commenting in detail about them.</p>
<div class="fragment"><div class="line">   <span class="keyword">namespace </span>SingleCurvingCrack</div><div class="line">   {</div><div class="line">     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">     <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">     {</div><div class="line">     <span class="keyword">public</span>:</div><div class="line">       KInverse()</div><div class="line">         : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">       {}</div><div class="line">  </div><div class="line">       <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">       value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                  std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line">     };</div><div class="line">  </div><div class="line"> </div><div class="line">     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">     <span class="keywordtype">void</span> KInverse&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                    std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(),</div><div class="line">              <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>()));</div><div class="line">  </div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">         {</div><div class="line">           values[p].clear();</div><div class="line">  </div><div class="line">           <span class="keyword">const</span> <span class="keywordtype">double</span> distance_to_flowline =</div><div class="line">             <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(points[p][1]</div><div class="line">  </div><div class="line">- 0.5</div><div class="line">  </div><div class="line">- 0.1 std::sin(10 points[p][0]));</div><div class="line">  </div><div class="line">           <span class="keyword">const</span> <span class="keywordtype">double</span> permeability =</div><div class="line">             <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::exp(-(distance_to_flowline distance_to_flowline) /</div><div class="line">                               (0.1 0.1)),</div><div class="line">                      0.01);</div><div class="line">  </div><div class="line">           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">             values[p][d][d] = 1. / permeability;</div><div class="line">         }</div><div class="line">     }</div><div class="line">   } <span class="comment">// namespace SingleCurvingCrack</span></div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keyword">namespace </span>RandomMedium</div><div class="line">   {</div><div class="line">     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">     <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">     {</div><div class="line">     <span class="keyword">public</span>:</div><div class="line">       KInverse()</div><div class="line">         : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">       {}</div><div class="line">  </div><div class="line">       <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">       value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                  std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line">  </div><div class="line">     <span class="keyword">private</span>:</div><div class="line">       <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; centers;</div><div class="line">     };</div><div class="line">  </div><div class="line"> </div><div class="line">  </div><div class="line">     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">     std::vector&lt;Point&lt;dim&gt;&gt; KInverse&lt;dim&gt;::centers = []() {</div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N =</div><div class="line">         (dim == 2 ? 40 : (dim == 3 ? 100 : <span class="keywordflow">throw</span> <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()));</div><div class="line">  </div><div class="line">       std::vector&lt;Point&lt;dim&gt;&gt; centers_list(N);</div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a>; ++i)</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">           centers_list[i][d] = static_cast&lt;double&gt;(rand()) / RAND_MAX;</div><div class="line">  </div><div class="line">       <span class="keywordflow">return</span> centers_list;</div><div class="line">     }();</div><div class="line">  </div><div class="line"> </div><div class="line">  </div><div class="line">     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">     <span class="keywordtype">void</span> KInverse&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                    std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(points.size(), values.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>());</div><div class="line">  </div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">         {</div><div class="line">           values[p].clear();</div><div class="line">  </div><div class="line">           <span class="keywordtype">double</span> permeability = 0;</div><div class="line">           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; centers.size(); ++i)</div><div class="line">             permeability +=</div><div class="line">               std::exp(-(points[p]</div><div class="line">  </div><div class="line">- centers[i]).norm_square() / (0.05 0.05));</div><div class="line">  </div><div class="line">           <span class="keyword">const</span> <span class="keywordtype">double</span> normalized_permeability =</div><div class="line">             <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(permeability, 0.01), 4.);</div><div class="line">  </div><div class="line">           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">             values[p][d][d] = 1. / normalized_permeability;</div><div class="line">         }</div><div class="line">     }</div><div class="line">   } <span class="comment">// namespace RandomMedium</span></div></div><!-- fragment --><p><a class="anchor" id="Physicalquantities"></a> </p><h3>Physical quantities</h3>
<p>The implementations of all the physical quantities such as total mobility \(\lambda_t\) and fractional flow of water \(F\) are taken from <a class="el" href="step_21.html">step-21</a> so again we don't have do any comment about them. Compared to <a class="el" href="step_21.html">step-21</a> we have added checks that the saturation passed to these functions is in fact within the physically valid range. Furthermore, given that the wetting phase moves at speed \(\mathbf u F&#39;(S)\) it is clear that \(F&#39;(S)\) must be greater or equal to zero, so we assert that as well to make sure that our calculations to get at the formula for the derivative made sense.</p>
<div class="fragment"><div class="line">   <span class="keywordtype">double</span> mobility_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">   {</div><div class="line">     <span class="keywordflow">return</span> 1.0 / (1.0 / viscosity S S + (1</div><div class="line">  </div><div class="line">- S) (1</div><div class="line">  </div><div class="line">- S));</div><div class="line">   }</div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keywordtype">double</span> fractional_flow(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">   {</div><div class="line">     <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((S &gt;= 0) &amp;&amp; (S &lt;= 1),</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Saturation is outside its physically valid range.&quot;</span>));</div><div class="line">  </div><div class="line">     <span class="keywordflow">return</span> S S / (S S + viscosity (1</div><div class="line">  </div><div class="line">- S) (1</div><div class="line">  </div><div class="line">- S));</div><div class="line">   }</div><div class="line">  </div><div class="line"> </div><div class="line">   <span class="keywordtype">double</span> fractional_flow_derivative(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">   {</div><div class="line">     <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((S &gt;= 0) &amp;&amp; (S &lt;= 1),</div><div class="line">            <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Saturation is outside its physically valid range.&quot;</span>));</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> temp = (S S + viscosity (1</div><div class="line">  </div><div class="line">- S) (1</div><div class="line">  </div><div class="line">- S));</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> numerator =</div><div class="line">       2.0 S temp</div><div class="line">  </div><div class="line">- S S (2.0 S</div><div class="line">  </div><div class="line">- 2.0 viscosity (1</div><div class="line">  </div><div class="line">- S));</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> denominator = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(temp, 2.0);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> F_prime = numerator / denominator;</div><div class="line">  </div><div class="line">     <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(F_prime &gt;= 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">  </div><div class="line">     <span class="keywordflow">return</span> F_prime;</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="Helperclassesforsolversandpreconditioners"></a> </p><h3>Helper classes for solvers and preconditioners</h3>
<p>In this first part we define a number of classes that we need in the construction of linear solvers and preconditioners. This part is essentially the same as that used in <a class="el" href="step_31.html">step-31</a> . The only difference is that the original variable name stokes_matrix is replaced by another name darcy_matrix to match our problem.</p>
<div class="fragment"><div class="line">   <span class="keyword">namespace </span>LinearSolvers</div><div class="line">   {</div><div class="line">     <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">     <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">     {</div><div class="line">     <span class="keyword">public</span>:</div><div class="line">       InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                     <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line">  </div><div class="line"> </div><div class="line">       <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">       <span class="keywordtype">void</span> vmult(<a class="code" href="classVectorType.html">VectorType</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src) <span class="keyword">const</span>;</div><div class="line">  </div><div class="line">     <span class="keyword">private</span>:</div><div class="line">       <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">       <span class="keyword">const</span> PreconditionerType &amp;           preconditioner;</div><div class="line">     };</div><div class="line">  </div><div class="line"> </div><div class="line">     <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">     InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">       <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">       <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">       : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">       , preconditioner(preconditioner)</div><div class="line">     {}</div><div class="line">  </div><div class="line"> </div><div class="line">  </div><div class="line">     <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">     <span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">       <a class="code" href="classVectorType.html">VectorType</a> &amp;      dst,</div><div class="line">       <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       <a class="code" href="classSolverControl.html">SolverControl</a>        solver_control(src.size(), 1e-7 src.l2_norm());</div><div class="line">       <a class="code" href="classSolverCG.html">SolverCG&lt;VectorType&gt;</a> cg(solver_control);</div><div class="line">  </div><div class="line">       dst = 0;</div><div class="line">  </div><div class="line">       <span class="keywordflow">try</span></div><div class="line">         {</div><div class="line">           cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, preconditioner);</div><div class="line">         }</div><div class="line">       <span class="keywordflow">catch</span> (std::exception &amp;e)</div><div class="line">         {</div><div class="line">           <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(e.what()));</div><div class="line">         }</div><div class="line">     }</div><div class="line">  </div><div class="line">     <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">     <span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">     {</div><div class="line">     <span class="keyword">public</span>:</div><div class="line">       BlockSchurPreconditioner(</div><div class="line">         <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">         <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                             PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">         <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner);</div><div class="line">  </div><div class="line">       <span class="keywordtype">void</span> <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#aff5a880cfa288ecdd2a83a876abacf0d">vmult</a>(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src) <span class="keyword">const</span>;</div><div class="line">  </div><div class="line">     <span class="keyword">private</span>:</div><div class="line">       <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">         darcy_matrix;</div><div class="line">       <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;<span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                              PreconditionerTypeMp&gt;&gt;</div><div class="line">                                  m_inverse;</div><div class="line">       <span class="keyword">const</span> PreconditionerTypeA &amp;a_preconditioner;</div><div class="line">  </div><div class="line">       <span class="keyword">mutable</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp;</div><div class="line">     };</div><div class="line">  </div><div class="line"> </div><div class="line">  </div><div class="line">     <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">     BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::</div><div class="line">       BlockSchurPreconditioner(</div><div class="line">         <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">         <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                             PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">         <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner)</div><div class="line">       : darcy_matrix(&amp;S)</div><div class="line">       , m_inverse(&amp;Mpinv)</div><div class="line">       , a_preconditioner(Apreconditioner)</div><div class="line">       , tmp(<a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(darcy_matrix-&gt;block(1, 1).m()))</div><div class="line">     {}</div><div class="line">  </div><div class="line"> </div><div class="line">     <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">     <span class="keywordtype">void</span></div><div class="line">     BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::vmult(</div><div class="line">       <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">       <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       a_preconditioner.vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">       darcy_matrix-&gt;block(1, 0).residual(tmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">       tmp=</div><div class="line">  </div><div class="line">-1;</div><div class="line">       m_inverse-&gt;vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div><div class="line">     }</div><div class="line">   } <span class="comment">// namespace LinearSolvers</span></div></div><!-- fragment --><p><a class="anchor" id="TheTwoPhaseFlowProblemclass"></a> </p><h3>The TwoPhaseFlowProblem class</h3>
<p>The definition of the class that defines the top-level logic of solving the time-dependent advection-dominated two-phase flow problem (or Buckley-Leverett problem [Buckley 1942]) is mainly based on tutorial programs <a class="el" href="step_21.html">step-21</a> and <a class="el" href="step_33.html">step-33</a> , and in particular on <a class="el" href="step_31.html">step-31</a> where we have used basically the same general structure as done here. As in <a class="el" href="step_31.html">step-31</a> , the key routines to look for in the implementation below are the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> and <code>solve()</code> functions. The main difference to <a class="el" href="step_31.html">step-31</a> is that, since adaptive operator splitting is considered, we need a couple more member variables to hold the last two computed Darcy (velocity/pressure) solutions in addition to the current one (which is either computed directly, or extrapolated from the previous two), and we need to remember the last two times we computed the Darcy solution. We also need a helper function that figures out whether we do indeed need to recompute the Darcy solution. Unlike <a class="el" href="step_31.html">step-31</a> , this step uses one more <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object called darcy_preconditioner_constraints. This constraint object is used only for assembling the matrix for the Darcy preconditioner and includes hanging node constraints as well as Dirichlet boundary value constraints for the pressure variable. We need this because we are building a Laplace matrix for the pressure as an approximation of the Schur complement) which is only positive definite if boundary conditions are applied. The collection of member functions and variables thus declared in this class is then rather similar to those in <a class="el" href="step_31.html">step-31</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>TwoPhaseFlowProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_dofs();</div><div class="line">  <span class="keywordtype">void</span> assemble_darcy_preconditioner();</div><div class="line">  <span class="keywordtype">void</span> build_darcy_preconditioner();</div><div class="line">  <span class="keywordtype">void</span> assemble_darcy_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_saturation_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_saturation_matrix();</div><div class="line">  <span class="keywordtype">void</span> assemble_saturation_rhs();</div><div class="line">  <span class="keywordtype">void</span> assemble_saturation_rhs_cell_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       saturation_fe_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       darcy_fe_values,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_max_u_F_prime,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_S_variation,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices);</div><div class="line">  <span class="keywordtype">void</span> assemble_saturation_rhs_boundary_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   saturation_fe_face_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   darcy_fe_face_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices);</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_grid_level,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div></div><!-- fragment --><p>We follow with a number of helper functions that are used in a variety of places throughout the program:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span>                    get_max_u_F_prime() <span class="keyword">const</span>;</div><div class="line">std::pair&lt;double, double&gt; get_extrapolated_saturation_range() <span class="keyword">const</span>;</div><div class="line"><span class="keywordtype">bool</span>   determine_whether_to_solve_for_pressure_and_velocity() <span class="keyword">const</span>;</div><div class="line"><span class="keywordtype">void</span>   project_back_saturation();</div><div class="line"><span class="keywordtype">double</span> compute_viscosity(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_saturation,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_saturation,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_saturation_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_saturation_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;present_darcy_values,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_max_u_F_prime,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_S_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter) <span class="keyword">const</span>;</div></div><!-- fragment --><p>This all is followed by the member variables, most of which are similar to the ones in <a class="el" href="step_31.html">step-31</a> , with the exception of the ones that pertain to the macro time stepping for the velocity/pressure system:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="keywordtype">double</span>             global_Omega_diameter;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        darcy_degree;</div><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             darcy_fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           darcy_dof_handler;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> darcy_constraints;</div><div class="line"></div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> darcy_preconditioner_constraints;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> darcy_matrix;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> darcy_preconditioner_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> darcy_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> darcy_rhs;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> last_computed_darcy_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> second_last_computed_darcy_solution;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        saturation_degree;</div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 saturation_fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           saturation_dof_handler;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> saturation_constraints;</div><div class="line"></div><div class="line">TrilinosWrappers::SparseMatrix saturation_matrix;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> saturation_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_saturation_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_saturation_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> saturation_rhs;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a></div><div class="line">  saturation_matching_last_computed_darcy_solution;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> saturation_refinement_threshold;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span>       time;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> end_time;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> current_macro_time_step;</div><div class="line"><span class="keywordtype">double</span> old_macro_time_step;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span>       time_step;</div><div class="line"><span class="keywordtype">double</span>       old_time_step;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> viscosity;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> porosity;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> AOS_threshold;</div><div class="line"></div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt; Amg_preconditioner;</div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt; Mp_preconditioner;</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> rebuild_saturation_matrix;</div></div><!-- fragment --><p>At the very end we declare a variable that denotes the material model. Compared to <a class="el" href="step_21.html">step-21</a> , we do this here as a member variable since we will want to use it in a variety of places and so having a central place where such a variable is declared will make it simpler to replace one class by another (e.g. replace RandomMedium::KInverse by SingleCurvingCrack::KInverse).</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> RandomMedium::KInverse&lt;dim&gt; k_inverse;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimTwoPhaseFlowProblem"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::TwoPhaseFlowProblem</h3>
<p>The constructor of this class is an extension of the constructors in <a class="el" href="step_21.html">step-21</a> and <a class="el" href="step_31.html">step-31</a> . We need to add the various variables that concern the saturation. As discussed in the introduction, we are going to use \(Q_2 \times Q_1\) (Taylor-Hood) elements again for the Darcy system, an element combination that fulfills the Ladyzhenskaya-Babuska-Brezzi (LBB) conditions [Brezzi and Fortin 1991, Chen 2005], and \(Q_1\) elements for the saturation. However, by using variables that store the polynomial degree of the Darcy and temperature finite elements, it is easy to consistently modify the degree of the elements as well as all quadrature formulas used on them downstream. Moreover, we initialize the time stepping variables related to operator splitting as well as the option for matrix assembly and preconditioning:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TwoPhaseFlowProblem&lt;dim&gt;::TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">  , global_Omega_diameter(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">  , degree(degree)</div><div class="line">  , darcy_degree(degree)</div><div class="line">  , darcy_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(darcy_degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(darcy_degree), 1)</div><div class="line">  , darcy_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  saturation_degree(degree + 1)</div><div class="line">  , saturation_fe(saturation_degree)</div><div class="line">  , saturation_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  saturation_refinement_threshold(0.5)</div><div class="line">  ,</div><div class="line"></div><div class="line">  time(0)</div><div class="line">  , end_time(10)</div><div class="line">  ,</div><div class="line"></div><div class="line">  current_macro_time_step(0)</div><div class="line">  , old_macro_time_step(0)</div><div class="line">  ,</div><div class="line"></div><div class="line">  time_step(0)</div><div class="line">  , old_time_step(0)</div><div class="line">  , timestep_number(0)</div><div class="line">  , viscosity(0.2)</div><div class="line">  , porosity(1.0)</div><div class="line">  , AOS_threshold(3.0)</div><div class="line">  ,</div><div class="line"></div><div class="line">  rebuild_saturation_matrix(true)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimsetup_dofs"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::setup_dofs</h3>
<p>This is the function that sets up the <a class="el" href="classDoFHandler.html">DoFHandler</a> objects we have here (one for the Darcy part and one for the saturation part) as well as set to the right sizes the various objects required for the linear algebra in this program. Its basic operations are similar to what <a class="el" href="step_31.html">step-31</a> did. The body of the function first enumerates all degrees of freedom for the Darcy and saturation systems. For the Darcy part, degrees of freedom are then sorted to ensure that velocities precede pressure DoFs so that we can partition the Darcy matrix into a \(2 \times 2\) matrix. Then, we need to incorporate hanging node constraints and Dirichlet boundary value constraints into darcy_preconditioner_constraints. The boundary condition constraints are only set on the pressure component since the Schur complement preconditioner that corresponds to the porous media flow operator in non-mixed form, \(-\nabla \cdot [\mathbf K \lambda_t(S)]\nabla\) , acts only on the pressure variable. Therefore, we use a component_mask that filters out the velocity component, so that the condensation is performed on pressure degrees of freedom only. After having done so, we count the number of degrees of freedom in the various blocks. This information is then used to create the sparsity pattern for the Darcy and saturation system matrices as well as the preconditioner matrix from which we build the Darcy preconditioner. As in <a class="el" href="step_31.html">step-31</a> , we choose to create the pattern using the blocked version of <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>. So, for this, we follow the same way as <a class="el" href="step_31.html">step-31</a> did and we don't have to repeat descriptions again for the rest of the member function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; darcy_block_component(dim + 1, 0);</div><div class="line">  darcy_block_component[dim] = 1;</div><div class="line">  {</div><div class="line">    darcy_dof_handler.distribute_dofs(darcy_fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(darcy_dof_handler);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(darcy_dof_handler, darcy_block_component);</div><div class="line"></div><div class="line">    darcy_constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(darcy_dof_handler,</div><div class="line">                                            darcy_constraints);</div><div class="line">    darcy_constraints.close();</div><div class="line">  }</div><div class="line">  {</div><div class="line">    saturation_dof_handler.distribute_dofs(saturation_fe);</div><div class="line"></div><div class="line">    saturation_constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(saturation_dof_handler,</div><div class="line">                                            saturation_constraints);</div><div class="line">    saturation_constraints.close();</div><div class="line">  }</div><div class="line">  {</div><div class="line">    darcy_preconditioner_constraints.clear();</div><div class="line"></div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(darcy_dof_handler,</div><div class="line">                                            darcy_preconditioner_constraints);</div><div class="line">    <a class="code" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a>(darcy_dof_handler,</div><div class="line">                                             darcy_preconditioner_constraints,</div><div class="line">                                             darcy_fe.component_mask(</div><div class="line">                                               pressure));</div><div class="line"></div><div class="line">    darcy_preconditioner_constraints.close();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; darcy_dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(darcy_dof_handler,</div><div class="line">                                      darcy_block_component);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = darcy_dofs_per_block[0],</div><div class="line">                     n_p = darcy_dofs_per_block[1],</div><div class="line">                     n_s = saturation_dof_handler.n_dofs();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_s &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">            &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_s &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    darcy_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">    dsp.block(0, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_u);</div><div class="line">    dsp.block(0, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_p);</div><div class="line">    dsp.block(1, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_u);</div><div class="line">    dsp.block(1, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_p);</div><div class="line"></div><div class="line">    dsp.collect_sizes();</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (d == dim)))</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">      darcy_dof_handler, coupling, dsp, darcy_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    darcy_matrix.reinit(dsp);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    Amg_preconditioner.reset();</div><div class="line">    Mp_preconditioner.reset();</div><div class="line">    darcy_preconditioner_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">    dsp.block(0, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_u);</div><div class="line">    dsp.block(0, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_p);</div><div class="line">    dsp.block(1, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_u);</div><div class="line">    dsp.block(1, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_p);</div><div class="line"></div><div class="line">    dsp.collect_sizes();</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        <span class="keywordflow">if</span> (c == d)</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">      darcy_dof_handler, coupling, dsp, darcy_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    darcy_preconditioner_matrix.reinit(dsp);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  {</div><div class="line">    saturation_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_s, n_s);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(saturation_dof_handler,</div><div class="line">                                    dsp,</div><div class="line">                                    saturation_constraints,</div><div class="line">                                    <span class="keyword">false</span>);</div><div class="line"></div><div class="line"></div><div class="line">    saturation_matrix.reinit(dsp);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::vector&lt;IndexSet&gt; darcy_partitioning(2);</div><div class="line">  darcy_partitioning[0] = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_u);</div><div class="line">  darcy_partitioning[1] = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_p);</div><div class="line">  darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">  darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">  last_computed_darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">  last_computed_darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">  second_last_computed_darcy_solution.reinit(darcy_partitioning,</div><div class="line">                                             MPI_COMM_WORLD);</div><div class="line">  second_last_computed_darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">  darcy_rhs.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">  darcy_rhs.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> saturation_partitioning = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_s);</div><div class="line">  saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  saturation_matching_last_computed_darcy_solution.reinit(</div><div class="line">    saturation_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  saturation_rhs.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblingmatricesandpreconditioners"></a> </p><h3>Assembling matrices and preconditioners</h3>
<p>The next few functions are devoted to setting up the various system and preconditioner matrices and right hand sides that we have to deal with in this program.</p>
<pre class="fragment">&lt;a name="TwoPhaseFlowProblemdimassemble_darcy_preconditioner"&gt;&lt;/a&gt;  &lt;h4&gt;TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_preconditioner&lt;/h4&gt;
</pre><p>This function assembles the matrix we use for preconditioning the Darcy system. What we need are a vector mass matrix weighted by \(\left(\mathbf{K} \lambda_t\right)^{-1}\) on the velocity components and a mass matrix weighted by \(\left(\mathbf{K} \lambda_t\right)\) on the pressure component. We start by generating a quadrature object of appropriate order, the <a class="el" href="classFEValues.html">FEValues</a> object that can give values and gradients at the quadrature points (together with quadrature weights). Next we create data structures for the cell matrix and the relation between local and global DoFs. The vectors phi_u and grad_phi_p are going to hold the values of the basis functions in order to faster build up the local matrices, as was already done in <a class="el" href="step_22.html">step-22</a> . Before we start the loop over all active cells, we have to specify which components are pressure and which are velocity. The creation of the local matrix is rather simple. There are only a term weighted by \(\left(\mathbf{K} \lambda_t\right)^{-1}\) (on the velocity) and a Laplace matrix weighted by \(\left(\mathbf{K} \lambda_t\right)\) to be generated, so the creation of the local matrix is done in essentially two lines. Since the material model functions at the top of this file only provide the inverses of the permeability and mobility, we have to compute \(\mathbf K\) and \(\lambda_t\) by hand from the given values, once per quadrature point. Once the local matrix is ready (loop over rows and columns in the local matrix on each quadrature point), we get the local DoF indices and write the local information into the global matrix. We do this by directly applying the constraints (i.e. darcy_preconditioner_constraints) that takes care of hanging node and zero Dirichlet boundary condition constraints. By doing so, we don't have to do that afterwards, and we later don't have to use <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense</a> and <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>, both functions that would need to modify matrix and vector entries and so are difficult to write for the Trilinos classes where we don't immediately have access to individual memory locations.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_preconditioner()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding darcy preconditioner...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  darcy_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(darcy_degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     darcy_fe_values(darcy_fe,</div><div class="line">                                quadrature_formula,</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     saturation_fe_values(saturation_fe,</div><div class="line">                                     quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = darcy_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; phi_u(dofs_per_cell);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">  <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">    {</div><div class="line">      darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(saturation_cell);</div><div class="line"></div><div class="line">      local_matrix = 0;</div><div class="line"></div><div class="line">      saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                               old_saturation_values);</div><div class="line"></div><div class="line">      k_inverse.value_list(darcy_fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                           k_inverse_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_saturation_values[q];</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> inverse_mobility = mobility_inverse(old_s, viscosity);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> mobility         = 1.0 / inverse_mobility;</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> permeability = <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(k_inverse_values[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              phi_u[k]      = darcy_fe_values[velocities].value(k, q);</div><div class="line">              grad_phi_p[k] = darcy_fe_values[pressure].gradient(k, q);</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                local_matrix(i, j) +=</div><div class="line">                  (k_inverse_values[q] inverse_mobility phi_u[i]</div><div class="line">                     phi_u[j] +</div><div class="line">                   permeability mobility grad_phi_p[i] grad_phi_p[j])</div><div class="line">                  darcy_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      darcy_preconditioner_constraints.distribute_local_to_global(</div><div class="line">        local_matrix, local_dof_indices, darcy_preconditioner_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimbuild_darcy_preconditioner"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::build_darcy_preconditioner</h4>
<p>After calling the above functions to assemble the preconditioner matrix, this function generates the inner preconditioners that are going to be used for the Schur complement block preconditioner. The preconditioners need to be regenerated at every saturation time step since they depend on the saturation \(S\) that varies with time. In here, we set up the preconditioner for the velocity-velocity matrix \(\mathbf{M}^{\mathbf{u}}\) and the Schur complement \(\mathbf{S}\) . As explained in the introduction, we are going to use an IC preconditioner based on the vector matrix \(\mathbf{M}^{\mathbf{u}}\) and another based on the scalar Laplace matrix \(\tilde{\mathbf{S}}^p\) (which is spectrally close to the Schur complement of the Darcy matrix). Usually, the <a class="el" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a> class can be seen as a good black-box preconditioner which does not need any special knowledge of the matrix structure and/or the operator that's behind it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::build_darcy_preconditioner()</div><div class="line">{</div><div class="line">  assemble_darcy_preconditioner();</div><div class="line"></div><div class="line">  Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">  Amg_preconditioner-&gt;initialize(darcy_preconditioner_matrix.block(0, 0));</div><div class="line"></div><div class="line">  Mp_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">  Mp_preconditioner-&gt;initialize(darcy_preconditioner_matrix.block(1, 1));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_darcy_system"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_system</h4>
<p>This is the function that assembles the linear system for the Darcy system. Regarding the technical details of implementation, the procedures are similar to those in <a class="el" href="step_22.html">step-22</a> and <a class="el" href="step_31.html">step-31</a> . We reset matrix and vector, create a quadrature formula on the cells, and then create the respective <a class="el" href="classFEValues.html">FEValues</a> object. There is one thing that needs to be commented: since we have a separate finite element and <a class="el" href="classDoFHandler.html">DoFHandler</a> for the saturation, we need to generate a second <a class="el" href="classFEValues.html">FEValues</a> object for the proper evaluation of the saturation solution. This isn't too complicated to realize here: just use the saturation structures and set an update flag for the basis function values which we need for evaluation of the saturation solution. The only important part to remember here is that the same quadrature formula is used for both <a class="el" href="classFEValues.html">FEValues</a> objects to ensure that we get matching information when we loop over the quadrature points of the two objects. The declarations proceed with some shortcuts for array sizes, the creation of the local matrix, right hand side as well as the vector for the indices of the local dofs compared to the global system.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_system()</div><div class="line">   {</div><div class="line">     darcy_matrix = 0;</div><div class="line">     darcy_rhs    = 0;</div><div class="line">  </div><div class="line">     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(darcy_degree + 2);</div><div class="line">     <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt; face_quadrature_formula(darcy_degree + 2);</div><div class="line">  </div><div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe,</div><div class="line">                                   quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                        quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  </div><div class="line">     <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> darcy_fe_face_values(darcy_fe,</div><div class="line">                                            face_quadrature_formula,</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = darcy_fe.n_dofs_per_cell();</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line">  </div><div class="line">     <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">     <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div><div class="line">  </div><div class="line">     std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> pressure_right_hand_side;</div><div class="line">     <span class="keyword">const</span> PressureBoundaryValues&lt;dim&gt;  pressure_boundary_values;</div><div class="line">  </div><div class="line">     std::vector&lt;double&gt;         pressure_rhs_values(n_q_points);</div><div class="line">     std::vector&lt;double&gt;         boundary_values(n_face_q_points);</div><div class="line">     std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div></div><!-- fragment --><p>Next we need a vector that will contain the values of the saturation solution at the previous time level at the quadrature points to assemble the saturation dependent coefficients in the Darcy equations. The set of vectors we create next hold the evaluations of the basis functions as well as their gradients that will be used for creating the matrices. Putting these into their own arrays rather than asking the <a class="el" href="classFEValues.html">FEValues</a> object for this information each time it is needed is an optimization to accelerate the assembly process, see <a class="el" href="step_22.html">step-22</a> for details. The last two declarations are used to extract the individual blocks (velocity, pressure, saturation) from the total FE system.</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line"></div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;         div_phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;         phi_p(dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div></div><!-- fragment --><p>Now start the loop over all cells in the problem. We are working on two different DoFHandlers for this assembly routine, so we must have two different cell iterators for the two objects in use. This might seem a bit peculiar, but since both the Darcy system and the saturation system use the same grid we can assume that the two iterators run in sync over the cells of the two <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. The first statements within the loop are again all very familiar, doing the update of the finite element data as specified by the update flags, zeroing out the local arrays and getting the values of the old solution at the quadrature points. At this point we also have to get the values of the saturation function of the previous time step at the quadrature points. To this end, we can use the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues::get_function_values</a> (previously already used in <a class="el" href="step_9.html">step-9</a> , <a class="el" href="step_14.html">step-14</a> and <a class="el" href="step_15.html">step-15</a> ), a function that takes a solution vector and returns a list of function values at the quadrature points of the present cell. In fact, it returns the complete vector-valued solution at each quadrature point, i.e. not only the saturation but also the velocities and pressure. Then we are ready to loop over the quadrature points on the cell to do the integration. The formula for this follows in a straightforward way from what has been discussed in the introduction. Once this is done, we start the loop over the rows and columns of the local matrix and feed the matrix with the relevant products. The last step in the loop over all cells is to enter the local contributions into the global matrix and vector structures to the positions specified in local_dof_indices. Again, we let the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class do the insertion of the cell matrix elements to the global matrix, which already condenses the hanging node constraints.</p>
<div class="fragment"><div class="line">     <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">     <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">     <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line">  </div><div class="line">     <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">       {</div><div class="line">         darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">         saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(saturation_cell);</div><div class="line">  </div><div class="line">         local_matrix = 0;</div><div class="line">         local_rhs    = 0;</div><div class="line">  </div><div class="line">         saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                                  old_saturation_values);</div><div class="line">  </div><div class="line">         pressure_right_hand_side.<a class="code" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">value_list</a>(</div><div class="line">           darcy_fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), pressure_rhs_values);</div><div class="line">         k_inverse.value_list(darcy_fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                              k_inverse_values);</div><div class="line">  </div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">           {</div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">               {</div><div class="line">                 phi_u[k]     = darcy_fe_values[velocities].value(k, q);</div><div class="line">                 div_phi_u[k] = darcy_fe_values[velocities].divergence(k, q);</div><div class="line">                 phi_p[k]     = darcy_fe_values[pressure].value(k, q);</div><div class="line">               }</div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">               {</div><div class="line">                 <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_saturation_values[q];</div><div class="line">                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j)</div><div class="line">                   {</div><div class="line">                     local_matrix(i, j) +=</div><div class="line">                       (phi_u[i] k_inverse_values[q]</div><div class="line">                          mobility_inverse(old_s, viscosity) phi_u[j]</div><div class="line">  </div><div class="line">-</div><div class="line">                        div_phi_u[i] phi_p[j]</div><div class="line">  </div><div class="line">- phi_p[i] div_phi_u[j])</div><div class="line">                       darcy_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                   }</div><div class="line">  </div><div class="line">                 local_rhs(i) +=</div><div class="line">                   (-phi_p[i] pressure_rhs_values[q]) darcy_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">               }</div><div class="line">           }</div><div class="line">  </div><div class="line">         <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">           <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">             {</div><div class="line">               darcy_fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">  </div><div class="line">               pressure_boundary_values.value_list(</div><div class="line">                 darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), boundary_values);</div><div class="line">  </div><div class="line">               <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                   {</div><div class="line">                     <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u =</div><div class="line">                       darcy_fe_face_values[velocities].value(i, q);</div><div class="line">  </div><div class="line">                     local_rhs(i) +=</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-(phi_i_u darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q)</div><div class="line">                         boundary_values[q] darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                   }</div><div class="line">             }</div><div class="line">  </div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div><div class="line">             local_matrix(i, j) = local_matrix(j, i);</div><div class="line">  </div><div class="line">         cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">  </div><div class="line">         darcy_constraints.distribute_local_to_global(</div><div class="line">           local_matrix, local_rhs, local_dof_indices, darcy_matrix, darcy_rhs);</div><div class="line">       }</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_saturation_system"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_system</h4>
<p>This function is to assemble the linear system for the saturation transport equation. It calls, if necessary, two other member functions: assemble_saturation_matrix() and assemble_saturation_rhs(). The former function then assembles the saturation matrix that only needs to be changed occasionally. On the other hand, the latter function that assembles the right hand side must be called at every saturation time step.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_system()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_saturation_matrix == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      saturation_matrix = 0;</div><div class="line">      assemble_saturation_matrix();</div><div class="line">    }</div><div class="line"></div><div class="line">  saturation_rhs = 0;</div><div class="line">  assemble_saturation_rhs();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_saturation_matrix"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_matrix</h4>
<p>This function is easily understood since it only forms a simple mass matrix for the left hand side of the saturation linear system by basis functions phi_i_s and phi_j_s only. Finally, as usual, we enter the local contribution into the global matrix by specifying the position in local_dof_indices. This is done by letting the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class do the insertion of the cell matrix elements to the global matrix, which already condenses the hanging node constraints.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_matrix()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(saturation_degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                     quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      local_matrix = 0;</div><div class="line">      local_rhs    = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_s = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_s = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q);</div><div class="line">                local_matrix(i, j) +=</div><div class="line">                  porosity phi_i_s phi_j_s saturation_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      saturation_constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                                        local_dof_indices,</div><div class="line">                                                        saturation_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_saturation_rhs"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs</h4>
<p>This function is to assemble the right hand side of the saturation transport equation. Before going about it, we have to create two <a class="el" href="classFEValues.html">FEValues</a> objects for the Darcy and saturation systems respectively and, in addition, two <a class="el" href="classFEFaceValues.html">FEFaceValues</a> objects for the two systems because we have a boundary integral term in the weak form of saturation equation. For the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object of the saturation system, we also require normal vectors, which we request using the update_normal_vectors flag. Next, before looping over all the cells, we have to compute some parameters (e.g. global_u_infty, global_S_variation, and global_Omega_diameter) that the artificial viscosity \(\nu\) needs. This is largely the same as was done in <a class="el" href="step_31.html">step-31</a> , so you may see there for more information. The real works starts with the loop over all the saturation and Darcy cells to put the local contributions into the global vector. In this loop, in order to simplify the implementation, we split some of the work into two helper functions: assemble_saturation_rhs_cell_term and assemble_saturation_rhs_boundary_term. We note that we insert cell or boundary contributions into the global vector in the two functions rather than in this present function.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs()</div><div class="line">   {</div><div class="line">     <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(saturation_degree + 2);</div><div class="line">     <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt; face_quadrature_formula(saturation_degree + 2);</div><div class="line">  </div><div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                        quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">     <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> saturation_fe_face_values(saturation_fe,</div><div class="line">                                                 face_quadrature_formula,</div><div class="line">                                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">     <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> darcy_fe_face_values(darcy_fe,</div><div class="line">                                            face_quadrature_formula,</div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">     <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> saturation_fe_face_values_neighbor(</div><div class="line">       saturation_fe, face_quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">       saturation_dof_handler.get_fe().n_dofs_per_cell();</div><div class="line">     std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_max_u_F_prime = get_max_u_F_prime();</div><div class="line">     <span class="keyword">const</span> std::pair&lt;double, double&gt; global_S_range =</div><div class="line">       get_extrapolated_saturation_range();</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> global_S_variation =</div><div class="line">       global_S_range.second</div><div class="line">  </div><div class="line">- global_S_range.first;</div><div class="line">  </div><div class="line">     <span class="keyword">auto</span>       cell       = saturation_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">     <span class="keyword">const</span> <span class="keyword">auto</span> endc       = saturation_dof_handler.end();</div><div class="line">     <span class="keyword">auto</span>       darcy_cell = darcy_dof_handler.begin_active();</div><div class="line">     <span class="keywordflow">for</span> (; cell != endc; ++cell, ++darcy_cell)</div><div class="line">       {</div><div class="line">         saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">         darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(darcy_cell);</div><div class="line">  </div><div class="line">         cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">  </div><div class="line">         assemble_saturation_rhs_cell_term(saturation_fe_values,</div><div class="line">                                           darcy_fe_values,</div><div class="line">                                           global_max_u_F_prime,</div><div class="line">                                           global_S_variation,</div><div class="line">                                           local_dof_indices);</div><div class="line">  </div><div class="line">         <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">           <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">             {</div><div class="line">               darcy_fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(darcy_cell, face);</div><div class="line">               saturation_fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">               assemble_saturation_rhs_boundary_term(saturation_fe_face_values,</div><div class="line">                                                     darcy_fe_face_values,</div><div class="line">                                                     local_dof_indices);</div><div class="line">             }</div><div class="line">       }</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_saturation_rhs_cell_term"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_cell_term</h4>
<p>This function takes care of integrating the cell terms of the right hand side of the saturation equation, and then assembling it into the global right hand side vector. Given the discussion in the introduction, the form of these contributions is clear. The only tricky part is getting the artificial viscosity and all that is necessary to compute it. The first half of the function is devoted to this task. The last part of the function is copying the local contributions into the global vector with position specified in local_dof_indices.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_cell_term(</div><div class="line">     <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       saturation_fe_values,</div><div class="line">     <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       darcy_fe_values,</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_max_u_F_prime,</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_S_variation,</div><div class="line">     <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices)</div><div class="line">   {</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line">  </div><div class="line">     std::vector&lt;double&gt;         old_saturation_solution_values(n_q_points);</div><div class="line">     std::vector&lt;double&gt;         old_old_saturation_solution_values(n_q_points);</div><div class="line">     std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_grad_saturation_solution_values(n_q_points);</div><div class="line">     std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_grad_saturation_solution_values(</div><div class="line">       n_q_points);</div><div class="line">     std::vector&lt;Vector&lt;double&gt;&gt; present_darcy_solution_values(</div><div class="line">       n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div><div class="line">  </div><div class="line">     saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                              old_saturation_solution_values);</div><div class="line">     saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">       old_old_saturation_solution, old_old_saturation_solution_values);</div><div class="line">     saturation_fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(</div><div class="line">       old_saturation_solution, old_grad_saturation_solution_values);</div><div class="line">     saturation_fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(</div><div class="line">       old_old_saturation_solution, old_old_grad_saturation_solution_values);</div><div class="line">     darcy_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(darcy_solution,</div><div class="line">                                         present_darcy_solution_values);</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div><div class="line">       compute_viscosity(old_saturation_solution_values,</div><div class="line">                         old_old_saturation_solution_values,</div><div class="line">                         old_grad_saturation_solution_values,</div><div class="line">                         old_old_grad_saturation_solution_values,</div><div class="line">                         present_darcy_solution_values,</div><div class="line">                         global_max_u_F_prime,</div><div class="line">                         global_S_variation,</div><div class="line">                         saturation_fe_values.<a class="code" href="classFEValuesBase.html#a9d3a1c53c139e2553b672de682d6233e">get_cell</a>()-&gt;diameter());</div><div class="line">  </div><div class="line">     <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs(dofs_per_cell);</div><div class="line">  </div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">         {</div><div class="line">           <span class="keyword">const</span> <span class="keywordtype">double</span>   old_s = old_saturation_solution_values[q];</div><div class="line">           <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u;</div><div class="line">           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">             present_u[d] = present_darcy_solution_values[q](d);</div><div class="line">  </div><div class="line">           <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_i_s = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q);</div><div class="line">           <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_i_s =</div><div class="line">             saturation_fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q);</div><div class="line">  </div><div class="line">           local_rhs(i) +=</div><div class="line">             (time_step fractional_flow(old_s, viscosity) present_u</div><div class="line">                grad_phi_i_s</div><div class="line">  </div><div class="line">-</div><div class="line">              time_step nu old_grad_saturation_solution_values[q]</div><div class="line">                grad_phi_i_s +</div><div class="line">              porosity old_s phi_i_s)</div><div class="line">             saturation_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">         }</div><div class="line">  </div><div class="line">     saturation_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                       local_dof_indices,</div><div class="line">                                                       saturation_rhs);</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_saturation_rhs_boundary_term"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_boundary_term</h4>
<p>The next function is responsible for the boundary integral terms in the right hand side form of the saturation equation. For these, we have to compute the upwinding flux on the global boundary faces, i.e. we impose Dirichlet boundary conditions weakly only on inflow parts of the global boundary. As before, this has been described in <a class="el" href="step_21.html">step-21</a> so we refrain from giving more descriptions about that.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_boundary_term(</div><div class="line">     <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   saturation_fe_face_values,</div><div class="line">     <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   darcy_fe_face_values,</div><div class="line">     <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices)</div><div class="line">   {</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points =</div><div class="line">       saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line">  </div><div class="line">     <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs(dofs_per_cell);</div><div class="line">  </div><div class="line">     std::vector&lt;double&gt; old_saturation_solution_values_face(n_face_q_points);</div><div class="line">     std::vector&lt;Vector&lt;double&gt;&gt; present_darcy_solution_values_face(</div><div class="line">       n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div><div class="line">     std::vector&lt;double&gt; neighbor_saturation(n_face_q_points);</div><div class="line">  </div><div class="line">     saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">       old_saturation_solution, old_saturation_solution_values_face);</div><div class="line">     darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">       darcy_solution, present_darcy_solution_values_face);</div><div class="line">  </div><div class="line">     SaturationBoundaryValues&lt;dim&gt; saturation_boundary_values;</div><div class="line">     saturation_boundary_values.value_list(</div><div class="line">       saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), neighbor_saturation);</div><div class="line">  </div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">       {</div><div class="line">         <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u_face;</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">           present_u_face[d] = present_darcy_solution_values_face[q](d);</div><div class="line">  </div><div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span> normal_flux =</div><div class="line">           present_u_face saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line">  </div><div class="line">         <span class="keyword">const</span> <span class="keywordtype">bool</span> is_outflow_q_point = (normal_flux &gt;= 0);</div><div class="line">  </div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">           local_rhs(i)</div><div class="line">  </div><div class="line">-=</div><div class="line">             time_step normal_flux</div><div class="line">             fractional_flow((is_outflow_q_point == <span class="keyword">true</span> ?</div><div class="line">                                old_saturation_solution_values_face[q] :</div><div class="line">                                neighbor_saturation[q]),</div><div class="line">                             viscosity)</div><div class="line">             saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q)</div><div class="line">             saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">       }</div><div class="line">     saturation_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                       local_dof_indices,</div><div class="line">                                                       saturation_rhs);</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimsolve"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::solve</h3>
<p>This function implements the operator splitting algorithm, i.e. in each time step it either re-computes the solution of the Darcy system or extrapolates velocity/pressure from previous time steps, then determines the size of the time step, and then updates the saturation variable. The implementation largely follows similar code in <a class="el" href="step_31.html">step-31</a> . It is, next to the <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function, the central one in this program. At the beginning of the function, we ask whether to solve the pressure-velocity part by evaluating the a posteriori criterion (see the following function). If necessary, we will solve the pressure-velocity part using the GMRES solver with the Schur complement block preconditioner as is described in the introduction.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> solve_for_pressure_and_velocity =</div><div class="line">    determine_whether_to_solve_for_pressure_and_velocity();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (solve_for_pressure_and_velocity == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving Darcy (pressure-velocity) system...&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      assemble_darcy_system();</div><div class="line">      build_darcy_preconditioner();</div><div class="line"></div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> LinearSolvers::InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                           TrilinosWrappers::PreconditionIC&gt;</div><div class="line">          mp_inverse(darcy_preconditioner_matrix.block(1, 1),</div><div class="line">                    Mp_preconditioner);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">          <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#abee1d4aa6f0af5290aa7d51806bde982">TrilinosWrappers::PreconditionIC</a>,</div><div class="line">          TrilinosWrappers::PreconditionIC&gt;</div><div class="line">          preconditioner(darcy_matrix, mp_inverse,Amg_preconditioner);</div><div class="line"></div><div class="line">        <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(darcy_matrix.m(),</div><div class="line">                                     1e-16 darcy_rhs.l2_norm());</div><div class="line"></div><div class="line">        <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> gmres(</div><div class="line">          solver_control,</div><div class="line">          <a class="code" href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(</div><div class="line">            100));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; darcy_solution.size(); ++i)</div><div class="line">          <span class="keywordflow">if</span> (darcy_constraints.is_constrained(i))</div><div class="line">            darcy_solution(i) = 0;</div><div class="line"></div><div class="line">        gmres.solve(darcy_matrix, darcy_solution, darcy_rhs, preconditioner);</div><div class="line"></div><div class="line">        darcy_constraints.distribute(darcy_solution);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;        ...&quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot; GMRES iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        second_last_computed_darcy_solution = last_computed_darcy_solution;</div><div class="line">        last_computed_darcy_solution        = darcy_solution;</div><div class="line"></div><div class="line">        saturation_matching_last_computed_darcy_solution =</div><div class="line">          saturation_solution;</div><div class="line">      }</div><div class="line">    }</div></div><!-- fragment --><p>On the other hand, if we have decided that we don't want to compute the solution of the Darcy system for the current time step, then we need to simply extrapolate the previous two Darcy solutions to the same time as we would have computed the velocity/pressure at. We do a simple linear extrapolation, i.e. given the current length \(dt\) of the macro time step from the time when we last computed the Darcy solution to now (given by <code>current_macro_time_step</code> ), and \(DT\) the length of the last macro time step (given by <code>old_macro_time_step</code> ), then we get \(u^\ast = u_p + dt \frac{u_p-u_{pp}}{DT} = (1+dt/DT)u_p - dt/DT u_{pp}\) , where \(u_p\) and \(u_{pp}\) are the last two computed Darcy solutions. We can implement this formula using just two lines of code. Note that the algorithm here only works if we have at least two previously computed Darcy solutions from which we can extrapolate to the current time, and this is ensured by requiring re-computation of the Darcy solution for the first 2 time steps.</p>
<div class="fragment"><div class="line">     <span class="keywordflow">else</span></div><div class="line">       {</div><div class="line">         darcy_solution = last_computed_darcy_solution;</div><div class="line">         darcy_solution.sadd(1 + current_macro_time_step / old_macro_time_step,</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-current_macro_time_step / old_macro_time_step,</div><div class="line">                             second_last_computed_darcy_solution);</div><div class="line">       }</div></div><!-- fragment --><p>With the so computed velocity vector, compute the optimal time step based on the CFL criterion discussed in the introduction...</p>
<div class="fragment"><div class="line">     {</div><div class="line">       old_time_step = time_step;</div><div class="line">  </div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">double</span> max_u_F_prime = get_max_u_F_prime();</div><div class="line">       <span class="keywordflow">if</span> (max_u_F_prime &gt; 0)</div><div class="line">         time_step = porosity <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) /</div><div class="line">                     saturation_degree / max_u_F_prime / 50;</div><div class="line">       <span class="keywordflow">else</span></div><div class="line">         time_step = end_time</div><div class="line">  </div><div class="line">- time;</div><div class="line">     }</div></div><!-- fragment --><p>...and then also update the length of the macro time steps we use while we're dealing with time step sizes. In particular, this involves: (i) If we have just recomputed the Darcy solution, then the length of the previous macro time step is now fixed and the length of the current macro time step is, up to now, simply the length of the current (micro) time step. (ii) If we have not recomputed the Darcy solution, then the length of the current macro time step has just grown by <code>time_step</code> .</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (solve_for_pressure_and_velocity == <span class="keyword">true</span>)</div><div class="line">  {</div><div class="line">    old_macro_time_step     = current_macro_time_step;</div><div class="line">    current_macro_time_step = time_step;</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  current_macro_time_step += time_step;</div></div><!-- fragment --><p>The last step in this function is to recompute the saturation solution based on the velocity field we've just obtained. This naturally happens in every time step, and we don't skip any of these computations. At the end of computing the saturation, we project back into the allowed interval \([0,1]\) to make sure our solution remains physical.</p>
<div class="fragment"><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving saturation transport equation...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    assemble_saturation_system();</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(saturation_matrix.m(),</div><div class="line">                                 1e-16 saturation_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">    TrilinosWrappers::PreconditionIC preconditioner;</div><div class="line">    preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html#a95eff1f8abcf2ba67815b6a96a66d375">initialize</a>(saturation_matrix);</div><div class="line"></div><div class="line">    cg.solve(saturation_matrix,</div><div class="line">             saturation_solution,</div><div class="line">             saturation_rhs,</div><div class="line">             preconditioner);</div><div class="line"></div><div class="line">    saturation_constraints.distribute(saturation_solution);</div><div class="line">    project_back_saturation();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;        ...&quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimrefine_mesh"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::refine_mesh</h3>
<p>The next function does the refinement and coarsening of the mesh. It does its work in three blocks: (i) Compute refinement indicators by looking at the gradient of a solution vector extrapolated linearly from the previous two using the respective sizes of the time step (or taking the only solution we have if this is the first time step). (ii) Flagging those cells for refinement and coarsening where the gradient is larger or smaller than a certain threshold, preserving minimal and maximal levels of mesh refinement. (iii) Transferring the solution from the old to the new mesh. None of this is particularly difficult.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_grid_level,</div><div class="line">                                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> refinement_indicators(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQMidpoint.html">QMidpoint&lt;dim&gt;</a>        quadrature_formula;</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               fe_values(saturation_fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_saturation(1);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> extrapolated_saturation_solution(</div><div class="line">      saturation_solution);</div><div class="line">    <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">      extrapolated_saturation_solution.sadd((1. + time_step / old_time_step),</div><div class="line">                                            time_step / old_time_step,</div><div class="line">                                            old_saturation_solution);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = cell-&gt;active_cell_index();</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(extrapolated_saturation_solution,</div><div class="line">                                         grad_saturation);</div><div class="line"></div><div class="line">        refinement_indicators(cell_no) = grad_saturation[0].norm();</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = cell-&gt;active_cell_index();</div><div class="line">        cell-&gt;clear_coarsen_flag();</div><div class="line">        cell-&gt;clear_refine_flag();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((static_cast&lt;unsigned int&gt;(cell-&gt;level()) &lt; max_grid_level) &amp;&amp;</div><div class="line">            (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(refinement_indicators(cell_no)) &gt;</div><div class="line">             saturation_refinement_threshold))</div><div class="line">          cell-&gt;set_refine_flag();</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((static_cast&lt;unsigned int&gt;(cell-&gt;level()) &gt;</div><div class="line">                  min_grid_level) &amp;&amp;</div><div class="line">                 (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(refinement_indicators(cell_no)) &lt;</div><div class="line">                  0.5 saturation_refinement_threshold))</div><div class="line">          cell-&gt;set_coarsen_flag();</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">  {</div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::Vector&gt; x_saturation(3);</div><div class="line">    x_saturation[0] = saturation_solution;</div><div class="line">    x_saturation[1] = old_saturation_solution;</div><div class="line">    x_saturation[2] = saturation_matching_last_computed_darcy_solution;</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::BlockVector&gt; x_darcy(2);</div><div class="line">    x_darcy[0] = last_computed_darcy_solution;</div><div class="line">    x_darcy[1] = second_last_computed_darcy_solution;</div><div class="line"></div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a> saturation_soltrans(</div><div class="line">      saturation_dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::BlockVector&gt;</a> darcy_soltrans(</div><div class="line">      darcy_dof_handler);</div><div class="line"></div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">    saturation_soltrans.prepare_for_coarsening_and_refinement(x_saturation);</div><div class="line"></div><div class="line">    darcy_soltrans.prepare_for_coarsening_and_refinement(x_darcy);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::Vector&gt; tmp_saturation(3);</div><div class="line">    tmp_saturation[0].reinit(saturation_solution);</div><div class="line">    tmp_saturation[1].reinit(saturation_solution);</div><div class="line">    tmp_saturation[2].reinit(saturation_solution);</div><div class="line">    saturation_soltrans.interpolate(x_saturation, tmp_saturation);</div><div class="line"></div><div class="line">    saturation_solution                              = tmp_saturation[0];</div><div class="line">    old_saturation_solution                          = tmp_saturation[1];</div><div class="line">    saturation_matching_last_computed_darcy_solution = tmp_saturation[2];</div><div class="line"></div><div class="line">    saturation_constraints.distribute(saturation_solution);</div><div class="line">    saturation_constraints.distribute(old_saturation_solution);</div><div class="line">    saturation_constraints.distribute(</div><div class="line">      saturation_matching_last_computed_darcy_solution);</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::BlockVector&gt; tmp_darcy(2);</div><div class="line">    tmp_darcy[0].reinit(darcy_solution);</div><div class="line">    tmp_darcy[1].reinit(darcy_solution);</div><div class="line">    darcy_soltrans.interpolate(x_darcy, tmp_darcy);</div><div class="line"></div><div class="line">    last_computed_darcy_solution        = tmp_darcy[0];</div><div class="line">    second_last_computed_darcy_solution = tmp_darcy[1];</div><div class="line"></div><div class="line">    darcy_constraints.distribute(last_computed_darcy_solution);</div><div class="line">    darcy_constraints.distribute(second_last_computed_darcy_solution);</div><div class="line"></div><div class="line">    rebuild_saturation_matrix = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimoutput_results"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::output_results</h3>
<p>This function generates graphical output. It is in essence a copy of the implementation in <a class="el" href="step_31.html">step-31</a> .</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> joint_fe(darcy_fe, 1, saturation_fe, 1);</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>     joint_dof_handler(triangulation);</div><div class="line">  joint_dof_handler.distribute_dofs(joint_fe);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_dof_handler.n_dofs() ==</div><div class="line">           darcy_dof_handler.n_dofs() + saturation_dof_handler.n_dofs(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> joint_solution(joint_dof_handler.n_dofs());</div><div class="line"></div><div class="line">  {</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_joint_dof_indices(</div><div class="line">      joint_fe.n_dofs_per_cell());</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_darcy_dof_indices(</div><div class="line">      darcy_fe.n_dofs_per_cell());</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_saturation_dof_indices(</div><div class="line">      saturation_fe.n_dofs_per_cell());</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       joint_cell      = joint_dof_handler.begin_active();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> joint_endc      = joint_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       darcy_cell      = darcy_dof_handler.begin_active();</div><div class="line">    <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; joint_cell != joint_endc;</div><div class="line">         ++joint_cell, ++darcy_cell, ++saturation_cell)</div><div class="line">      {</div><div class="line">        joint_cell-&gt;get_dof_indices(local_joint_dof_indices);</div><div class="line">        darcy_cell-&gt;get_dof_indices(local_darcy_dof_indices);</div><div class="line">        saturation_cell-&gt;get_dof_indices(local_saturation_dof_indices);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; joint_fe.n_dofs_per_cell(); ++i)</div><div class="line">          <span class="keywordflow">if</span> (joint_fe.system_to_base_index(i).first.first == 0)</div><div class="line">            {</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                       local_darcy_dof_indices.size(),</div><div class="line">                     <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">              joint_solution(local_joint_dof_indices[i]) = darcy_solution(</div><div class="line">                local_darcy_dof_indices[joint_fe.system_to_base_index(i)</div><div class="line">                                          .second]);</div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).first.first == 1,</div><div class="line">                     <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                       local_darcy_dof_indices.size(),</div><div class="line">                     <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">              joint_solution(local_joint_dof_indices[i]) =</div><div class="line">                saturation_solution(</div><div class="line">                  local_saturation_dof_indices</div><div class="line">                    [joint_fe.system_to_base_index(i).second]);</div><div class="line">            }</div><div class="line">      }</div><div class="line">  }</div><div class="line">  std::vector&lt;std::string&gt; joint_solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  joint_solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">  joint_solution_names.emplace_back(<span class="stringliteral">&quot;saturation&quot;</span>);</div><div class="line"></div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(joint_dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(joint_solution,</div><div class="line">                           joint_solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 5) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Toolfunctions"></a> </p><h3>Tool functions</h3>
<pre class="fragment">&lt;a name="TwoPhaseFlowProblemdimdetermine_whether_to_solve_for_pressure_and_velocity"&gt;&lt;/a&gt;  &lt;h4&gt;TwoPhaseFlowProblem&lt;dim&gt;::determine_whether_to_solve_for_pressure_and_velocity&lt;/h4&gt;
</pre><p>This function implements the a posteriori criterion for adaptive operator splitting. The function is relatively straightforward given the way we have implemented other functions above and given the formula for the criterion derived in the paper. If one decides that one wants the original IMPES method in which the Darcy equation is solved in every time step, then this can be achieved by setting the threshold value <code>AOS_threshold</code> (with a default of \(5.0\) ) to zero, thereby forcing the function to always return true. Finally, note that the function returns true unconditionally for the first two time steps to ensure that we have always solved the Darcy system at least twice when skipping its solution, thereby allowing us to extrapolate the velocity from the last two solutions in <code>solve()</code> .</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">bool</span> TwoPhaseFlowProblem&lt;</div><div class="line">     dim&gt;::determine_whether_to_solve_for_pressure_and_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <span class="keywordflow">if</span> (timestep_number &lt;= 2)</div><div class="line">       <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(saturation_degree + 2);</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  </div><div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(saturation_fe,</div><div class="line">                             quadrature_formula,</div><div class="line">                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">  </div><div class="line">     std::vector&lt;double&gt; old_saturation_after_solving_pressure(n_q_points);</div><div class="line">     std::vector&lt;double&gt; present_saturation(n_q_points);</div><div class="line">  </div><div class="line">     std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line">  </div><div class="line">     <span class="keywordtype">double</span> max_global_aop_indicator = 0.0;</div><div class="line">  </div><div class="line">     <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">       {</div><div class="line">         <span class="keywordtype">double</span> max_local_mobility_reciprocal_difference = 0.0;</div><div class="line">         <span class="keywordtype">double</span> max_local_permeability_inverse_l1_norm   = 0.0;</div><div class="line">  </div><div class="line">         fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">         fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">           saturation_matching_last_computed_darcy_solution,</div><div class="line">           old_saturation_after_solving_pressure);</div><div class="line">         fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(saturation_solution, present_saturation);</div><div class="line">  </div><div class="line">         k_inverse.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                              k_inverse_values);</div><div class="line">  </div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">           {</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">double</span> mobility_reciprocal_difference = <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(</div><div class="line">               mobility_inverse(present_saturation[q], viscosity)</div><div class="line">  </div><div class="line">-</div><div class="line">               mobility_inverse(old_saturation_after_solving_pressure[q],</div><div class="line">                                viscosity));</div><div class="line">  </div><div class="line">             max_local_mobility_reciprocal_difference =</div><div class="line">               <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_mobility_reciprocal_difference,</div><div class="line">                        mobility_reciprocal_difference);</div><div class="line">  </div><div class="line">             max_local_permeability_inverse_l1_norm =</div><div class="line">               <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_permeability_inverse_l1_norm,</div><div class="line">                        <a class="code" href="classTensor.html#a93ba01d979880b278cd4b573dd9c653b">l1_norm</a>(k_inverse_values[q]));</div><div class="line">           }</div><div class="line">  </div><div class="line">         max_global_aop_indicator =</div><div class="line">           <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_global_aop_indicator,</div><div class="line">                    (max_local_mobility_reciprocal_difference</div><div class="line">                     max_local_permeability_inverse_l1_norm));</div><div class="line">       }</div><div class="line">  </div><div class="line">     <span class="keywordflow">return</span> (max_global_aop_indicator &gt; AOS_threshold);</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimproject_back_saturation"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::project_back_saturation</h4>
<p>The next function simply makes sure that the saturation values always remain within the physically reasonable range of \([0,1]\) . While the continuous equations guarantee that this is so, the discrete equations don't. However, if we allow the discrete solution to escape this range we get into trouble because terms like \(F(S)\) and \(F&#39;(S)\) will produce unreasonable results (e.g. \(F&#39;(S)&lt;0\) for \(S&lt;0\) , which would imply that the wetting fluid phase flows <em>against</em> the direction of the bulk fluid velocity)). Consequently, at the end of each time step, we simply project the saturation field back into the physically reasonable region.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::project_back_saturation()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; saturation_solution.size(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (saturation_solution(i) &lt; 0.2)</div><div class="line">      saturation_solution(i) = 0.2;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (saturation_solution(i) &gt; 1)</div><div class="line">      saturation_solution(i) = 1;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimget_max_u_F_prime"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::get_max_u_F_prime</h4>
<p>Another simpler helper function: Compute the maximum of the total velocity times the derivative of the fraction flow function, i.e., compute \(\|\mathbf{u} F&#39;(S)\|_{L_\infty(\Omega)}\) . This term is used in both the computation of the time step as well as in normalizing the entropy-residual term in the artificial viscosity.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::get_max_u_F_prime()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(darcy_degree + 2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                     quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; darcy_solution_values(n_q_points,</div><div class="line">                                                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div><div class="line">  std::vector&lt;double&gt;         saturation_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_velocity_times_dF_dS = 0;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">  <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line">  <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">    {</div><div class="line">      darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(saturation_cell);</div><div class="line"></div><div class="line">      darcy_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(darcy_solution,</div><div class="line">                                          darcy_solution_values);</div><div class="line">      saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                               saturation_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">            velocity[i] = darcy_solution_values[q](i);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> dF_dS =</div><div class="line">            fractional_flow_derivative(saturation_values[q], viscosity);</div><div class="line"></div><div class="line">          max_velocity_times_dF_dS =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity_times_dF_dS, velocity.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() dF_dS);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> max_velocity_times_dF_dS;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimget_extrapolated_saturation_range"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::get_extrapolated_saturation_range</h4>
<p>For computing the stabilization term, we need to know the range of the saturation variable. Unlike in <a class="el" href="step_31.html">step-31</a> , this range is trivially bounded by the interval \([0,1]\) but we can do a bit better by looping over a collection of quadrature points and seeing what the values are there. If we can, i.e., if there are at least two timesteps around, we can even take the values extrapolated to the next time step. As before, the function is taken with minimal modifications from <a class="el" href="step_31.html">step-31</a> .</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   std::pair&lt;double, double&gt;</div><div class="line">   TwoPhaseFlowProblem&lt;dim&gt;::get_extrapolated_saturation_range()<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(saturation_degree + 2);</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  </div><div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(saturation_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">     std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line">     std::vector&lt;double&gt; old_old_saturation_values(n_q_points);</div><div class="line">  </div><div class="line">     <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">       {</div><div class="line">         <span class="keywordtype">double</span> min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">                max_saturation =</div><div class="line">  </div><div class="line">-<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line">  </div><div class="line">         <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">           {</div><div class="line">             fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">             fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                           old_saturation_values);</div><div class="line">             fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_saturation_solution,</div><div class="line">                                           old_old_saturation_values);</div><div class="line">  </div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">               {</div><div class="line">                 <span class="keyword">const</span> <span class="keywordtype">double</span> saturation =</div><div class="line">                   (1. + time_step / old_time_step) old_saturation_values[q]</div><div class="line">  </div><div class="line">-</div><div class="line">                   time_step / old_time_step old_old_saturation_values[q];</div><div class="line">  </div><div class="line">                 min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_saturation, saturation);</div><div class="line">                 max_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_saturation, saturation);</div><div class="line">               }</div><div class="line">           }</div><div class="line">  </div><div class="line">         <span class="keywordflow">return</span> std::make_pair(min_saturation, max_saturation);</div><div class="line">       }</div><div class="line">     <span class="keywordflow">else</span></div><div class="line">       {</div><div class="line">         <span class="keywordtype">double</span> min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">                max_saturation =</div><div class="line">  </div><div class="line">-<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line">  </div><div class="line">         <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">           {</div><div class="line">             fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">             fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                           old_saturation_values);</div><div class="line">  </div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">               {</div><div class="line">                 <span class="keyword">const</span> <span class="keywordtype">double</span> saturation = old_saturation_values[q];</div><div class="line">  </div><div class="line">                 min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_saturation, saturation);</div><div class="line">                 max_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_saturation, saturation);</div><div class="line">               }</div><div class="line">           }</div><div class="line">  </div><div class="line">         <span class="keywordflow">return</span> std::make_pair(min_saturation, max_saturation);</div><div class="line">       }</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimcompute_viscosity"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::compute_viscosity</h4>
<p>The final tool function is used to compute the artificial viscosity on a given cell. This isn't particularly complicated if you have the formula for it in front of you, and looking at the implementation in <a class="el" href="step_31.html">step-31</a> . The major difference to that tutorial program is that the velocity here is not simply \(\mathbf u\) but \(\mathbf u F&#39;(S)\) and some of the formulas need to be adjusted accordingly.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::compute_viscosity(</div><div class="line">     <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_saturation,</div><div class="line">     <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_saturation,</div><div class="line">     <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_saturation_grads,</div><div class="line">     <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_saturation_grads,</div><div class="line">     <span class="keyword">const</span> std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;present_darcy_values,</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_max_u_F_prime,</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_S_variation,</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> beta  = .4 dim;</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = 1;</div><div class="line">  </div><div class="line">     <span class="keywordflow">if</span> (global_max_u_F_prime == 0)</div><div class="line">       <span class="keywordflow">return</span> 5e-3 cell_diameter;</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_saturation.size();</div><div class="line">  </div><div class="line">     <span class="keywordtype">double</span> max_residual             = 0;</div><div class="line">     <span class="keywordtype">double</span> max_velocity_times_dF_dS = 0;</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">bool</span> use_dF_dS = <span class="keyword">true</span>;</div><div class="line">  </div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">       {</div><div class="line">         <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u;</div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">           u[d] = present_darcy_values[q](d);</div><div class="line">  </div><div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span> dS_dt = porosity</div><div class="line">                              (old_saturation[q]</div><div class="line">  </div><div class="line">- old_old_saturation[q]) /</div><div class="line">                              old_time_step;</div><div class="line">  </div><div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span> dF_dS = fractional_flow_derivative(</div><div class="line">           (old_saturation[q] + old_old_saturation[q]) / 2.0, viscosity);</div><div class="line">  </div><div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_S =</div><div class="line">           u dF_dS (old_saturation_grads[q] + old_old_saturation_grads[q]) /</div><div class="line">           2.0;</div><div class="line">  </div><div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span> residual =</div><div class="line">           <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>((dS_dt + u_grad_S)</div><div class="line">                    std::pow((old_saturation[q] + old_old_saturation[q]) / 2,</div><div class="line">                             alpha</div><div class="line">  </div><div class="line">- 1.));</div><div class="line">  </div><div class="line">         max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div><div class="line">         max_velocity_times_dF_dS =</div><div class="line">           <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u u) (use_dF_dS ? <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(dF_dS, 1.) : 1),</div><div class="line">                    max_velocity_times_dF_dS);</div><div class="line">       }</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> c_R            = 1.0;</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> global_scaling = c_R porosity</div><div class="line">                                   (global_max_u_F_prime)*global_S_variation /</div><div class="line">                                   <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(global_Omega_diameter, alpha</div><div class="line">  </div><div class="line">- 2.);</div><div class="line">  </div><div class="line">     <span class="keywordflow">return</span> (beta</div><div class="line">             (max_velocity_times_dF_dS)*<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(cell_diameter,</div><div class="line">                                                 std::pow(cell_diameter, alpha)</div><div class="line">                                                   max_residual /</div><div class="line">                                                   global_scaling));</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimrun"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::run</h3>
<p>This function is, besides <code>solve()</code> , the primary function of this program as it controls the time iteration as well as when the solution is written into output files and when to do mesh refinement. With the exception of the startup code that loops back to the beginning of the function through the <code>goto start_time_iteration</code> label, everything should be relatively straightforward. In any case, it mimics the corresponding function in <a class="el" href="step_31.html">step-31</a> .</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TwoPhaseFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement     = (dim == 2 ? 5 : 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_pre_refinement_steps = (dim == 2 ? 3 : 2);</div><div class="line"> </div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(initial_refinement);</div><div class="line">    global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(triangulation);</div><div class="line"> </div><div class="line">    setup_dofs();</div><div class="line"> </div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"> </div><div class="line">  start_time_iteration:</div><div class="line"> </div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(saturation_dof_handler,</div><div class="line">                         saturation_constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(saturation_degree + 2),</div><div class="line">                         SaturationInitialValues&lt;dim&gt;(),</div><div class="line">                         old_saturation_solution);</div><div class="line"> </div><div class="line">    time_step = old_time_step = 0;</div><div class="line">    current_macro_time_step = old_macro_time_step = 0;</div><div class="line"> </div><div class="line">    time = 0;</div><div class="line"> </div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, dt=&quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">        solve();</div><div class="line"> </div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">        <span class="keywordflow">if</span> (timestep_number % 200 == 0)</div><div class="line">          output_results();</div><div class="line"> </div><div class="line">        <span class="keywordflow">if</span> (timestep_number % 25 == 0)</div><div class="line">          refine_mesh(initial_refinement,</div><div class="line">                      initial_refinement + n_pre_refinement_steps);</div><div class="line"> </div><div class="line">        <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">            (pre_refinement_step &lt; n_pre_refinement_steps))</div><div class="line">          {</div><div class="line">            ++pre_refinement_step;</div><div class="line">            <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">          }</div><div class="line"> </div><div class="line">        time += time_step;</div><div class="line">        ++timestep_number;</div><div class="line"> </div><div class="line">        old_old_saturation_solution = old_saturation_solution;</div><div class="line">        old_saturation_solution     = saturation_solution;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (time &lt;= end_time);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step43</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main()</code> function</h3>
<p>The main function looks almost the same as in all other programs. The need to initialize the MPI subsystem for a program that uses Trilinos</p>
<ul>
<li>even for programs that do not actually run in parallel</li>
<li>is explained in <a class="el" href="step_31.html">step-31</a> .</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, charargv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step43;</div><div class="line"> </div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div></div><!-- fragment --><p>This program can only be run in serial. Otherwise, throw an exception.</p>
<div class="fragment"><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-43&quot;</span>));</div><div class="line"> </div><div class="line">      TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(1);</div><div class="line">      two_phase_flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"> </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The output of this program is not really much different from that of <a class="el" href="step_21.html">step-21</a> : it solves the same problem, after all. Of more importance arequantitative metrics such as the accuracy of the solution as well asthe time needed to compute it. These are documented in detail in thetwo publications listed at the top of this page and we won't repeatthem here. That said, no tutorial program is complete without a couple of goodpictures, so here is some output of a run in 3d: </p><table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-43.3d.velocity.png"/>
</div>
 <p>Velocity vectors of flow through the porous medium with random permeability model. Streaming paths of high permeability and resulting high velocity are clearly visible. </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-43.3d.streamlines.png"/>
</div>
 <p>Streamlines colored by the saturation along the streamline path. Blue streamlines indicate low saturations, i.e., the flow along these streamlines must be slow or else more fluid would have been transported along them. On the other hand, green paths indicate high velocities since the fluid front has already reached further into the domain. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-43.3d.saturation.png"/>
</div>
 <p>Streamlines with a volume rendering of the saturation, showing how far the fluid front has advanced at this time. </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-43.3d.mesh.png"/>
</div>
 <p>Surface of the mesh showing the adaptive refinement along the front. </p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>The primary objection one may have to this program is that it is still tooslow: 3d computations on reasonably fine meshes are simply too expensive to bedone routinely and with reasonably quick turn-around. This is similar to thesituation we were in when we wrote <a class="el" href="step_31.html">step-31</a> , from which this program has takenmuch inspiration. The solution is similar as it was there as well: We need toparallelize the program in a way similar to how we derived <a class="el" href="step_32.html">step-32</a> out of <a class="el" href="step_31.html">step-31</a> . In fact, all of the techniques used in <a class="el" href="step_32.html">step-32</a> would be transferableto this program as well, making the program run on dozens or hundreds ofprocessors immediately. A different direction is to make the program more relevant to many otherporous media applications. Specifically, one avenue is to go to the primaryuser of porous media flow simulators, namely the oil industry. There,applications in this area are dominated by multiphase flow (i.e., more thanthe two phases we have here), and the reactions they may have with each other(or any other way phases may exchange mass, such as through dissolution in andbubbling out of gas from the oil phase). Furthermore, the presence of gasoften leads to compressibility effects of the fluid. Jointly, these effectsare typically formulated in the widely-used "black oil model". True reactionsbetween multiple phases also play a role in oil reservoir modeling whenconsidering controlled burns of oil in the reservoir to raise pressure andtemperature. These are much more complex problems, though, and left for futureprojects. Finally, from a mathematical perspective, we have derived thecriterion for re-computing the velocity/pressure solution at a giventime step under the assumption that we want to compare the solution wewould get at the current time step with that computed the last time weactually solved this system. However, in the program, whenever we didnot re-compute the solution, we didn't just use the previouslycomputed solution but instead extrapolated from the previous two timeswe solved the system. Consequently, the criterion was pessimisticallystated: what we should really compare is the solution we would get atthe current time step with the extrapolated one. Re-stating thetheorem in this regard is left as an exercise. There are also other ways to extend the mathematical foundation ofthis program; for example, one may say that it isn't the velocity wecare about, but in fact the saturation. Thus, one may ask whether thecriterion we use here to decide whether \(\mathbf u\) needs to berecomputed is appropriate; one may, for example, suggest that it isalso important to decide whether (and by how much) a wrong velocityfield in fact affects the solution of the saturation equation. Thiswould then naturally lead to a sensitivity analysis. From an algorithmic viewpoint, we have here used a criterion for refinementthat is often used in engineering, namely by looking at the gradient ofthe solution. However, if you inspect the solution, you will find thatit quickly leads to refinement almost everywhere, even in regions where itis clearly not necessary: frequently used therefore does not need to implythat it is a useful criterion to begin with. On the other hand, replacingthis criterion by a different and better one should not be very difficult.For example, the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class used in many other programsshould certainly be applicable to the current problem as well.</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2010 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Chih-Che Chueh, University of Victoria, 2010</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University, 2010</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step43</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PressureBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PressureBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  PressureBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 1 - p[0];</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SaturationBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SaturationBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  SaturationBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (p[0] == 0)</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SaturationInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SaturationInitialValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  value) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  SaturationInitialValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0.2;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SaturationInitialValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                                  Vector&lt;double&gt; &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = SaturationInitialValues&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SingleCurvingCrack</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      KInverse()</div><div class="line">        : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">      value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                 std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> KInverse&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                   std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">        {</div><div class="line">          values[p].clear();</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> distance_to_flowline =</div><div class="line">            <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0]));</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> permeability =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::exp(-(distance_to_flowline * distance_to_flowline) /</div><div class="line">                              (0.1 * 0.1)),</div><div class="line">                     0.01);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            values[p][d][d] = 1. / permeability;</div><div class="line">        }</div><div class="line">    }</div><div class="line">  } <span class="comment">// namespace SingleCurvingCrack</span></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>RandomMedium</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      KInverse()</div><div class="line">        : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">      value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                 std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; centers;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    std::vector&lt;Point&lt;dim&gt;&gt; KInverse&lt;dim&gt;::centers = []() {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N =</div><div class="line">        (dim == 2 ? 40 : (dim == 3 ? 100 : <span class="keywordflow">throw</span> <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()));</div><div class="line"></div><div class="line">      std::vector&lt;Point&lt;dim&gt;&gt; centers_list(N);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a>; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          centers_list[i][d] = static_cast&lt;double&gt;(rand()) / RAND_MAX;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> centers_list;</div><div class="line">    }();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> KInverse&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                   std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(points.size(), values.size());</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">        {</div><div class="line">          values[p].clear();</div><div class="line"></div><div class="line">          <span class="keywordtype">double</span> permeability = 0;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; centers.size(); ++i)</div><div class="line">            permeability +=</div><div class="line">              std::exp(-(points[p] - centers[i]).norm_square() / (0.05 * 0.05));</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> normalized_permeability =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(permeability, 0.01), 4.);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            values[p][d][d] = 1. / normalized_permeability;</div><div class="line">        }</div><div class="line">    }</div><div class="line">  } <span class="comment">// namespace RandomMedium</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> mobility_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> fractional_flow(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((S &gt;= 0) &amp;&amp; (S &lt;= 1),</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Saturation is outside its physically valid range.&quot;</span>));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> S * S / (S * S + viscosity * (1 - S) * (1 - S));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> fractional_flow_derivative(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((S &gt;= 0) &amp;&amp; (S &lt;= 1),</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Saturation is outside its physically valid range.&quot;</span>));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> temp = (S * S + viscosity * (1 - S) * (1 - S));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> numerator =</div><div class="line">      2.0 * S * temp - S * S * (2.0 * S - 2.0 * viscosity * (1 - S));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> denominator = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(temp, 2.0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> F_prime = numerator / denominator;</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(F_prime &gt;= 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> F_prime;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>LinearSolvers</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                    <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">      <span class="keywordtype">void</span> vmult(<a class="code" href="classVectorType.html">VectorType</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">      <span class="keyword">const</span> PreconditionerType &amp;           preconditioner;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">      <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">      <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">      : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">      , preconditioner(preconditioner)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">    <span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">      <a class="code" href="classVectorType.html">VectorType</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>        solver_control(src.size(), 1e-7 * src.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;VectorType&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">      dst = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">try</span></div><div class="line">        {</div><div class="line">          cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, preconditioner);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">catch</span> (std::exception &amp;e)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(e.what()));</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    <span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      BlockSchurPreconditioner(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">        <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                            PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">        <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner);</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#aff5a880cfa288ecdd2a83a876abacf0d">vmult</a>(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">        darcy_matrix;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;<span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                             PreconditionerTypeMp&gt;&gt;</div><div class="line">                                 m_inverse;</div><div class="line">      <span class="keyword">const</span> PreconditionerTypeA &amp;a_preconditioner;</div><div class="line"></div><div class="line">      <span class="keyword">mutable</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::</div><div class="line">      BlockSchurPreconditioner(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">        <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                            PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">        <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner)</div><div class="line">      : darcy_matrix(&amp;S)</div><div class="line">      , m_inverse(&amp;Mpinv)</div><div class="line">      , a_preconditioner(Apreconditioner)</div><div class="line">      , tmp(<a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(darcy_matrix-&gt;block(1, 1).m()))</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::vmult(</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      a_preconditioner.vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">      darcy_matrix-&gt;block(1, 0).residual(tmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">      tmp *= -1;</div><div class="line">      m_inverse-&gt;vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div><div class="line">    }</div><div class="line">  } <span class="comment">// namespace LinearSolvers</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TwoPhaseFlowProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_dofs();</div><div class="line">    <span class="keywordtype">void</span> assemble_darcy_preconditioner();</div><div class="line">    <span class="keywordtype">void</span> build_darcy_preconditioner();</div><div class="line">    <span class="keywordtype">void</span> assemble_darcy_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_saturation_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_saturation_matrix();</div><div class="line">    <span class="keywordtype">void</span> assemble_saturation_rhs();</div><div class="line">    <span class="keywordtype">void</span> assemble_saturation_rhs_cell_term(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       saturation_fe_values,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       darcy_fe_values,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_max_u_F_prime,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_S_variation,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices);</div><div class="line">    <span class="keywordtype">void</span> assemble_saturation_rhs_boundary_term(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   saturation_fe_face_values,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   darcy_fe_face_values,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices);</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_grid_level,</div><div class="line">                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>                    get_max_u_F_prime() <span class="keyword">const</span>;</div><div class="line">    std::pair&lt;double, double&gt; get_extrapolated_saturation_range() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">bool</span>   determine_whether_to_solve_for_pressure_and_velocity() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span>   project_back_saturation();</div><div class="line">    <span class="keywordtype">double</span> compute_viscosity(</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_saturation,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_saturation,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_saturation_grads,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_saturation_grads,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;Vector&lt;double&gt;&gt; &amp;present_darcy_values,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_max_u_F_prime,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_S_variation,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <span class="keywordtype">double</span>             global_Omega_diameter;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        darcy_degree;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             darcy_fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           darcy_dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> darcy_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> darcy_preconditioner_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> darcy_matrix;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> darcy_preconditioner_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> darcy_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> darcy_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> last_computed_darcy_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> second_last_computed_darcy_solution;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        saturation_degree;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 saturation_fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           saturation_dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> saturation_constraints;</div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix saturation_matrix;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> saturation_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_saturation_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_saturation_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> saturation_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a></div><div class="line">      saturation_matching_last_computed_darcy_solution;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> saturation_refinement_threshold;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> end_time;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> current_macro_time_step;</div><div class="line">    <span class="keywordtype">double</span> old_macro_time_step;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time_step;</div><div class="line">    <span class="keywordtype">double</span>       old_time_step;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> porosity;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> AOS_threshold;</div><div class="line"></div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt; Amg_preconditioner;</div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt; Mp_preconditioner;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> rebuild_saturation_matrix;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> RandomMedium::KInverse&lt;dim&gt; k_inverse;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TwoPhaseFlowProblem&lt;dim&gt;::TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">    , global_Omega_diameter(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">    , degree(degree)</div><div class="line">    , darcy_degree(degree)</div><div class="line">    , darcy_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(darcy_degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(darcy_degree), 1)</div><div class="line">    , darcy_dof_handler(triangulation)</div><div class="line">    ,</div><div class="line"></div><div class="line">    saturation_degree(degree + 1)</div><div class="line">    , saturation_fe(saturation_degree)</div><div class="line">    , saturation_dof_handler(triangulation)</div><div class="line">    ,</div><div class="line"></div><div class="line">    saturation_refinement_threshold(0.5)</div><div class="line">    ,</div><div class="line"></div><div class="line">    time(0)</div><div class="line">    , end_time(10)</div><div class="line">    ,</div><div class="line"></div><div class="line">    current_macro_time_step(0)</div><div class="line">    , old_macro_time_step(0)</div><div class="line">    ,</div><div class="line"></div><div class="line">    time_step(0)</div><div class="line">    , old_time_step(0)</div><div class="line">    , timestep_number(0)</div><div class="line">    , viscosity(0.2)</div><div class="line">    , porosity(1.0)</div><div class="line">    , AOS_threshold(3.0)</div><div class="line">    ,</div><div class="line"></div><div class="line">    rebuild_saturation_matrix(true)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::setup_dofs()</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; darcy_block_component(dim + 1, 0);</div><div class="line">    darcy_block_component[dim] = 1;</div><div class="line">    {</div><div class="line">      darcy_dof_handler.distribute_dofs(darcy_fe);</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(darcy_dof_handler);</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(darcy_dof_handler, darcy_block_component);</div><div class="line"></div><div class="line">      darcy_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(darcy_dof_handler,</div><div class="line">                                              darcy_constraints);</div><div class="line">      darcy_constraints.close();</div><div class="line">    }</div><div class="line">    {</div><div class="line">      saturation_dof_handler.distribute_dofs(saturation_fe);</div><div class="line"></div><div class="line">      saturation_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(saturation_dof_handler,</div><div class="line">                                              saturation_constraints);</div><div class="line">      saturation_constraints.close();</div><div class="line">    }</div><div class="line">    {</div><div class="line">      darcy_preconditioner_constraints.clear();</div><div class="line"></div><div class="line">      <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(darcy_dof_handler,</div><div class="line">                                              darcy_preconditioner_constraints);</div><div class="line">      <a class="code" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a>(darcy_dof_handler,</div><div class="line">                                               darcy_preconditioner_constraints,</div><div class="line">                                               darcy_fe.component_mask(</div><div class="line">                                                 pressure));</div><div class="line"></div><div class="line">      darcy_preconditioner_constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; darcy_dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(darcy_dof_handler,</div><div class="line">                                        darcy_block_component);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = darcy_dofs_per_block[0],</div><div class="line">                       n_p = darcy_dofs_per_block[1],</div><div class="line">                       n_s = saturation_dof_handler.n_dofs();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_s &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">              &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_s &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      darcy_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">      dsp.block(0, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_u);</div><div class="line">      dsp.block(0, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_p);</div><div class="line">      dsp.block(1, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_u);</div><div class="line">      dsp.block(1, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_p);</div><div class="line"></div><div class="line">      dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (d == dim)))</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        darcy_dof_handler, coupling, dsp, darcy_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      darcy_matrix.reinit(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      Amg_preconditioner.reset();</div><div class="line">      Mp_preconditioner.reset();</div><div class="line">      darcy_preconditioner_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">      dsp.block(0, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_u);</div><div class="line">      dsp.block(0, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_p);</div><div class="line">      dsp.block(1, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_u);</div><div class="line">      dsp.block(1, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_p);</div><div class="line"></div><div class="line">      dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (c == d)</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        darcy_dof_handler, coupling, dsp, darcy_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      darcy_preconditioner_matrix.reinit(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    {</div><div class="line">      saturation_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_s, n_s);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(saturation_dof_handler,</div><div class="line">                                      dsp,</div><div class="line">                                      saturation_constraints,</div><div class="line">                                      <span class="keyword">false</span>);</div><div class="line"></div><div class="line"></div><div class="line">      saturation_matrix.reinit(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    std::vector&lt;IndexSet&gt; darcy_partitioning(2);</div><div class="line">    darcy_partitioning[0] = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_u);</div><div class="line">    darcy_partitioning[1] = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_p);</div><div class="line">    darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">    darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">    last_computed_darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">    last_computed_darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">    second_last_computed_darcy_solution.reinit(darcy_partitioning,</div><div class="line">                                               MPI_COMM_WORLD);</div><div class="line">    second_last_computed_darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">    darcy_rhs.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">    darcy_rhs.collect_sizes();</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> saturation_partitioning = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_s);</div><div class="line">    saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    saturation_matching_last_computed_darcy_solution.reinit(</div><div class="line">      saturation_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    saturation_rhs.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_preconditioner()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding darcy preconditioner...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    darcy_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(darcy_degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     darcy_fe_values(darcy_fe,</div><div class="line">                                  quadrature_formula,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     saturation_fe_values(saturation_fe,</div><div class="line">                                       quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = darcy_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">      {</div><div class="line">        darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(saturation_cell);</div><div class="line"></div><div class="line">        local_matrix = 0;</div><div class="line"></div><div class="line">        saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                                 old_saturation_values);</div><div class="line"></div><div class="line">        k_inverse.value_list(darcy_fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             k_inverse_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_saturation_values[q];</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> inverse_mobility = mobility_inverse(old_s, viscosity);</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> mobility         = 1.0 / inverse_mobility;</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> permeability = <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(k_inverse_values[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                phi_u[k]      = darcy_fe_values[velocities].value(k, q);</div><div class="line">                grad_phi_p[k] = darcy_fe_values[pressure].gradient(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  local_matrix(i, j) +=</div><div class="line">                    (k_inverse_values[q] * inverse_mobility * phi_u[i] *</div><div class="line">                       phi_u[j] +</div><div class="line">                     permeability * mobility * grad_phi_p[i] * grad_phi_p[j]) *</div><div class="line">                    darcy_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        darcy_preconditioner_constraints.distribute_local_to_global(</div><div class="line">          local_matrix, local_dof_indices, darcy_preconditioner_matrix);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::build_darcy_preconditioner()</div><div class="line">  {</div><div class="line">    assemble_darcy_preconditioner();</div><div class="line"></div><div class="line">    Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">    Amg_preconditioner-&gt;initialize(darcy_preconditioner_matrix.block(0, 0));</div><div class="line"></div><div class="line">    Mp_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">    Mp_preconditioner-&gt;initialize(darcy_preconditioner_matrix.block(1, 1));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_system()</div><div class="line">  {</div><div class="line">    darcy_matrix = 0;</div><div class="line">    darcy_rhs    = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(darcy_degree + 2);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(darcy_degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe,</div><div class="line">                                  quadrature_formula,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                       quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> darcy_fe_face_values(darcy_fe,</div><div class="line">                                           face_quadrature_formula,</div><div class="line">                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = darcy_fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> pressure_right_hand_side;</div><div class="line">    <span class="keyword">const</span> PressureBoundaryValues&lt;dim&gt;  pressure_boundary_values;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         pressure_rhs_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         boundary_values(n_face_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;         div_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;         phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">      {</div><div class="line">        darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(saturation_cell);</div><div class="line"></div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs    = 0;</div><div class="line"></div><div class="line">        saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                                 old_saturation_values);</div><div class="line"></div><div class="line">        pressure_right_hand_side.<a class="code" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">value_list</a>(</div><div class="line">          darcy_fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), pressure_rhs_values);</div><div class="line">        k_inverse.value_list(darcy_fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             k_inverse_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                phi_u[k]     = darcy_fe_values[velocities].value(k, q);</div><div class="line">                div_phi_u[k] = darcy_fe_values[velocities].divergence(k, q);</div><div class="line">                phi_p[k]     = darcy_fe_values[pressure].value(k, q);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_saturation_values[q];</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j)</div><div class="line">                  {</div><div class="line">                    local_matrix(i, j) +=</div><div class="line">                      (phi_u[i] * k_inverse_values[q] *</div><div class="line">                         mobility_inverse(old_s, viscosity) * phi_u[j] -</div><div class="line">                       div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div><div class="line">                      darcy_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                  }</div><div class="line"></div><div class="line">                local_rhs(i) +=</div><div class="line">                  (-phi_p[i] * pressure_rhs_values[q]) * darcy_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              darcy_fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line"></div><div class="line">              pressure_boundary_values.value_list(</div><div class="line">                darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), boundary_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u =</div><div class="line">                      darcy_fe_face_values[velocities].value(i, q);</div><div class="line"></div><div class="line">                    local_rhs(i) +=</div><div class="line">                      -(phi_i_u * darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q) *</div><div class="line">                        boundary_values[q] * darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                  }</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div><div class="line">            local_matrix(i, j) = local_matrix(j, i);</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        darcy_constraints.distribute_local_to_global(</div><div class="line">          local_matrix, local_rhs, local_dof_indices, darcy_matrix, darcy_rhs);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_system()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (rebuild_saturation_matrix == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line">        saturation_matrix = 0;</div><div class="line">        assemble_saturation_matrix();</div><div class="line">      }</div><div class="line"></div><div class="line">    saturation_rhs = 0;</div><div class="line">    assemble_saturation_rhs();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_matrix()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(saturation_degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                       quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs    = 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_s = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_s = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q);</div><div class="line">                  local_matrix(i, j) +=</div><div class="line">                    porosity * phi_i_s * phi_j_s * saturation_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        saturation_constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                                          local_dof_indices,</div><div class="line">                                                          saturation_matrix);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(saturation_degree + 2);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(saturation_degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                       quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> saturation_fe_face_values(saturation_fe,</div><div class="line">                                                face_quadrature_formula,</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> darcy_fe_face_values(darcy_fe,</div><div class="line">                                           face_quadrature_formula,</div><div class="line">                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> saturation_fe_face_values_neighbor(</div><div class="line">      saturation_fe, face_quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">      saturation_dof_handler.get_fe().n_dofs_per_cell();</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_max_u_F_prime = get_max_u_F_prime();</div><div class="line">    <span class="keyword">const</span> std::pair&lt;double, double&gt; global_S_range =</div><div class="line">      get_extrapolated_saturation_range();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> global_S_variation =</div><div class="line">      global_S_range.second - global_S_range.first;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell       = saturation_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc       = saturation_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       darcy_cell = darcy_dof_handler.begin_active();</div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++darcy_cell)</div><div class="line">      {</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(darcy_cell);</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        assemble_saturation_rhs_cell_term(saturation_fe_values,</div><div class="line">                                          darcy_fe_values,</div><div class="line">                                          global_max_u_F_prime,</div><div class="line">                                          global_S_variation,</div><div class="line">                                          local_dof_indices);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              darcy_fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(darcy_cell, face);</div><div class="line">              saturation_fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">              assemble_saturation_rhs_boundary_term(saturation_fe_face_values,</div><div class="line">                                                    darcy_fe_face_values,</div><div class="line">                                                    local_dof_indices);</div><div class="line">            }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_cell_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       saturation_fe_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       darcy_fe_values,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_max_u_F_prime,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_S_variation,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         old_saturation_solution_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_old_saturation_solution_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_grad_saturation_solution_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_grad_saturation_solution_values(</div><div class="line">      n_q_points);</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; present_darcy_solution_values(</div><div class="line">      n_q_points, Vector&lt;double&gt;(dim + 1));</div><div class="line"></div><div class="line">    saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                             old_saturation_solution_values);</div><div class="line">    saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">      old_old_saturation_solution, old_old_saturation_solution_values);</div><div class="line">    saturation_fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(</div><div class="line">      old_saturation_solution, old_grad_saturation_solution_values);</div><div class="line">    saturation_fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(</div><div class="line">      old_old_saturation_solution, old_old_grad_saturation_solution_values);</div><div class="line">    darcy_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(darcy_solution,</div><div class="line">                                        present_darcy_solution_values);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div><div class="line">      compute_viscosity(old_saturation_solution_values,</div><div class="line">                        old_old_saturation_solution_values,</div><div class="line">                        old_grad_saturation_solution_values,</div><div class="line">                        old_old_grad_saturation_solution_values,</div><div class="line">                        present_darcy_solution_values,</div><div class="line">                        global_max_u_F_prime,</div><div class="line">                        global_S_variation,</div><div class="line">                        saturation_fe_values.<a class="code" href="classFEValuesBase.html#a9d3a1c53c139e2553b672de682d6233e">get_cell</a>()-&gt;diameter());</div><div class="line"></div><div class="line">    Vector&lt;double&gt; local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>   old_s = old_saturation_solution_values[q];</div><div class="line">          <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            present_u[d] = present_darcy_solution_values[q](d);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_i_s = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q);</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_i_s =</div><div class="line">            saturation_fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q);</div><div class="line"></div><div class="line">          local_rhs(i) +=</div><div class="line">            (time_step * fractional_flow(old_s, viscosity) * present_u *</div><div class="line">               grad_phi_i_s -</div><div class="line">             time_step * nu * old_grad_saturation_solution_values[q] *</div><div class="line">               grad_phi_i_s +</div><div class="line">             porosity * old_s * phi_i_s) *</div><div class="line">            saturation_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        }</div><div class="line"></div><div class="line">    saturation_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                      local_dof_indices,</div><div class="line">                                                      saturation_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_boundary_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   saturation_fe_face_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   darcy_fe_face_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points =</div><div class="line">      saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; old_saturation_solution_values_face(n_face_q_points);</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; present_darcy_solution_values_face(</div><div class="line">      n_face_q_points, Vector&lt;double&gt;(dim + 1));</div><div class="line">    std::vector&lt;double&gt; neighbor_saturation(n_face_q_points);</div><div class="line"></div><div class="line">    saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">      old_saturation_solution, old_saturation_solution_values_face);</div><div class="line">    darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">      darcy_solution, present_darcy_solution_values_face);</div><div class="line"></div><div class="line">    SaturationBoundaryValues&lt;dim&gt; saturation_boundary_values;</div><div class="line">    saturation_boundary_values.value_list(</div><div class="line">      saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), neighbor_saturation);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">      {</div><div class="line">        <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u_face;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          present_u_face[d] = present_darcy_solution_values_face[q](d);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> normal_flux =</div><div class="line">          present_u_face * saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_outflow_q_point = (normal_flux &gt;= 0);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          local_rhs(i) -=</div><div class="line">            time_step * normal_flux *</div><div class="line">            fractional_flow((is_outflow_q_point == <span class="keyword">true</span> ?</div><div class="line">                               old_saturation_solution_values_face[q] :</div><div class="line">                               neighbor_saturation[q]),</div><div class="line">                            viscosity) *</div><div class="line">            saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q) *</div><div class="line">            saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">      }</div><div class="line">    saturation_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                      local_dof_indices,</div><div class="line">                                                      saturation_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> solve_for_pressure_and_velocity =</div><div class="line">      determine_whether_to_solve_for_pressure_and_velocity();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (solve_for_pressure_and_velocity == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving Darcy (pressure-velocity) system...&quot;</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_darcy_system();</div><div class="line">        build_darcy_preconditioner();</div><div class="line"></div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> LinearSolvers::InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                             TrilinosWrappers::PreconditionIC&gt;</div><div class="line">            mp_inverse(darcy_preconditioner_matrix.block(1, 1),</div><div class="line">                       *Mp_preconditioner);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">            <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#abee1d4aa6f0af5290aa7d51806bde982">TrilinosWrappers::PreconditionIC</a>,</div><div class="line">            TrilinosWrappers::PreconditionIC&gt;</div><div class="line">            preconditioner(darcy_matrix, mp_inverse, *Amg_preconditioner);</div><div class="line"></div><div class="line">          <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(darcy_matrix.m(),</div><div class="line">                                       1e-16 * darcy_rhs.l2_norm());</div><div class="line"></div><div class="line">          <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> gmres(</div><div class="line">            solver_control,</div><div class="line">            <a class="code" href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(</div><div class="line">              100));</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; darcy_solution.size(); ++i)</div><div class="line">            <span class="keywordflow">if</span> (darcy_constraints.is_constrained(i))</div><div class="line">              darcy_solution(i) = 0;</div><div class="line"></div><div class="line">          gmres.solve(darcy_matrix, darcy_solution, darcy_rhs, preconditioner);</div><div class="line"></div><div class="line">          darcy_constraints.distribute(darcy_solution);</div><div class="line"></div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;        ...&quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                    &lt;&lt; <span class="stringliteral">&quot; GMRES iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        {</div><div class="line">          second_last_computed_darcy_solution = last_computed_darcy_solution;</div><div class="line">          last_computed_darcy_solution        = darcy_solution;</div><div class="line"></div><div class="line">          saturation_matching_last_computed_darcy_solution =</div><div class="line">            saturation_solution;</div><div class="line">        }</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        darcy_solution = last_computed_darcy_solution;</div><div class="line">        darcy_solution.sadd(1 + current_macro_time_step / old_macro_time_step,</div><div class="line">                            -current_macro_time_step / old_macro_time_step,</div><div class="line">                            second_last_computed_darcy_solution);</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">    {</div><div class="line">      old_time_step = time_step;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> max_u_F_prime = get_max_u_F_prime();</div><div class="line">      <span class="keywordflow">if</span> (max_u_F_prime &gt; 0)</div><div class="line">        time_step = porosity * <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) /</div><div class="line">                    saturation_degree / max_u_F_prime / 50;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        time_step = end_time - time;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (solve_for_pressure_and_velocity == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line">        old_macro_time_step     = current_macro_time_step;</div><div class="line">        current_macro_time_step = time_step;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      current_macro_time_step += time_step;</div><div class="line"></div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving saturation transport equation...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      assemble_saturation_system();</div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(saturation_matrix.m(),</div><div class="line">                                   1e-16 * saturation_rhs.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">      TrilinosWrappers::PreconditionIC preconditioner;</div><div class="line">      preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html#a95eff1f8abcf2ba67815b6a96a66d375">initialize</a>(saturation_matrix);</div><div class="line"></div><div class="line">      cg.solve(saturation_matrix,</div><div class="line">               saturation_solution,</div><div class="line">               saturation_rhs,</div><div class="line">               preconditioner);</div><div class="line"></div><div class="line">      saturation_constraints.distribute(saturation_solution);</div><div class="line">      project_back_saturation();</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;        ...&quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_grid_level,</div><div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">  {</div><div class="line">    Vector&lt;double&gt; refinement_indicators(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQMidpoint.html">QMidpoint&lt;dim&gt;</a>        quadrature_formula;</div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               fe_values(saturation_fe,</div><div class="line">                              quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_saturation(1);</div><div class="line"></div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> extrapolated_saturation_solution(</div><div class="line">        saturation_solution);</div><div class="line">      <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">        extrapolated_saturation_solution.sadd((1. + time_step / old_time_step),</div><div class="line">                                              time_step / old_time_step,</div><div class="line">                                              old_saturation_solution);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = cell-&gt;active_cell_index();</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(extrapolated_saturation_solution,</div><div class="line">                                           grad_saturation);</div><div class="line"></div><div class="line">          refinement_indicators(cell_no) = grad_saturation[0].norm();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = cell-&gt;active_cell_index();</div><div class="line">          cell-&gt;clear_coarsen_flag();</div><div class="line">          cell-&gt;clear_refine_flag();</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> ((static_cast&lt;unsigned int&gt;(cell-&gt;level()) &lt; max_grid_level) &amp;&amp;</div><div class="line">              (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(refinement_indicators(cell_no)) &gt;</div><div class="line">               saturation_refinement_threshold))</div><div class="line">            cell-&gt;set_refine_flag();</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((static_cast&lt;unsigned int&gt;(cell-&gt;level()) &gt;</div><div class="line">                    min_grid_level) &amp;&amp;</div><div class="line">                   (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(refinement_indicators(cell_no)) &lt;</div><div class="line">                    0.5 * saturation_refinement_threshold))</div><div class="line">            cell-&gt;set_coarsen_flag();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">    {</div><div class="line">      std::vector&lt;TrilinosWrappers::MPI::Vector&gt; x_saturation(3);</div><div class="line">      x_saturation[0] = saturation_solution;</div><div class="line">      x_saturation[1] = old_saturation_solution;</div><div class="line">      x_saturation[2] = saturation_matching_last_computed_darcy_solution;</div><div class="line"></div><div class="line">      std::vector&lt;TrilinosWrappers::MPI::BlockVector&gt; x_darcy(2);</div><div class="line">      x_darcy[0] = last_computed_darcy_solution;</div><div class="line">      x_darcy[1] = second_last_computed_darcy_solution;</div><div class="line"></div><div class="line">      <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a> saturation_soltrans(</div><div class="line">        saturation_dof_handler);</div><div class="line"></div><div class="line">      <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::BlockVector&gt;</a> darcy_soltrans(</div><div class="line">        darcy_dof_handler);</div><div class="line"></div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">      saturation_soltrans.prepare_for_coarsening_and_refinement(x_saturation);</div><div class="line"></div><div class="line">      darcy_soltrans.prepare_for_coarsening_and_refinement(x_darcy);</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">      setup_dofs();</div><div class="line"></div><div class="line">      std::vector&lt;TrilinosWrappers::MPI::Vector&gt; tmp_saturation(3);</div><div class="line">      tmp_saturation[0].reinit(saturation_solution);</div><div class="line">      tmp_saturation[1].reinit(saturation_solution);</div><div class="line">      tmp_saturation[2].reinit(saturation_solution);</div><div class="line">      saturation_soltrans.interpolate(x_saturation, tmp_saturation);</div><div class="line"></div><div class="line">      saturation_solution                              = tmp_saturation[0];</div><div class="line">      old_saturation_solution                          = tmp_saturation[1];</div><div class="line">      saturation_matching_last_computed_darcy_solution = tmp_saturation[2];</div><div class="line"></div><div class="line">      saturation_constraints.distribute(saturation_solution);</div><div class="line">      saturation_constraints.distribute(old_saturation_solution);</div><div class="line">      saturation_constraints.distribute(</div><div class="line">        saturation_matching_last_computed_darcy_solution);</div><div class="line"></div><div class="line">      std::vector&lt;TrilinosWrappers::MPI::BlockVector&gt; tmp_darcy(2);</div><div class="line">      tmp_darcy[0].reinit(darcy_solution);</div><div class="line">      tmp_darcy[1].reinit(darcy_solution);</div><div class="line">      darcy_soltrans.interpolate(x_darcy, tmp_darcy);</div><div class="line"></div><div class="line">      last_computed_darcy_solution        = tmp_darcy[0];</div><div class="line">      second_last_computed_darcy_solution = tmp_darcy[1];</div><div class="line"></div><div class="line">      darcy_constraints.distribute(last_computed_darcy_solution);</div><div class="line">      darcy_constraints.distribute(second_last_computed_darcy_solution);</div><div class="line"></div><div class="line">      rebuild_saturation_matrix = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> joint_fe(darcy_fe, 1, saturation_fe, 1);</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>     joint_dof_handler(triangulation);</div><div class="line">    joint_dof_handler.distribute_dofs(joint_fe);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_dof_handler.n_dofs() ==</div><div class="line">             darcy_dof_handler.n_dofs() + saturation_dof_handler.n_dofs(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    Vector&lt;double&gt; joint_solution(joint_dof_handler.n_dofs());</div><div class="line"></div><div class="line">    {</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_joint_dof_indices(</div><div class="line">        joint_fe.n_dofs_per_cell());</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_darcy_dof_indices(</div><div class="line">        darcy_fe.n_dofs_per_cell());</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_saturation_dof_indices(</div><div class="line">        saturation_fe.n_dofs_per_cell());</div><div class="line"></div><div class="line">      <span class="keyword">auto</span>       joint_cell      = joint_dof_handler.begin_active();</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> joint_endc      = joint_dof_handler.end();</div><div class="line">      <span class="keyword">auto</span>       darcy_cell      = darcy_dof_handler.begin_active();</div><div class="line">      <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (; joint_cell != joint_endc;</div><div class="line">           ++joint_cell, ++darcy_cell, ++saturation_cell)</div><div class="line">        {</div><div class="line">          joint_cell-&gt;get_dof_indices(local_joint_dof_indices);</div><div class="line">          darcy_cell-&gt;get_dof_indices(local_darcy_dof_indices);</div><div class="line">          saturation_cell-&gt;get_dof_indices(local_saturation_dof_indices);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; joint_fe.n_dofs_per_cell(); ++i)</div><div class="line">            <span class="keywordflow">if</span> (joint_fe.system_to_base_index(i).first.first == 0)</div><div class="line">              {</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                         local_darcy_dof_indices.size(),</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                joint_solution(local_joint_dof_indices[i]) = darcy_solution(</div><div class="line">                  local_darcy_dof_indices[joint_fe.system_to_base_index(i)</div><div class="line">                                            .second]);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).first.first == 1,</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                         local_darcy_dof_indices.size(),</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                joint_solution(local_joint_dof_indices[i]) =</div><div class="line">                  saturation_solution(</div><div class="line">                    local_saturation_dof_indices</div><div class="line">                      [joint_fe.system_to_base_index(i).second]);</div><div class="line">              }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    std::vector&lt;std::string&gt; joint_solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    joint_solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">    joint_solution_names.emplace_back(<span class="stringliteral">&quot;saturation&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(joint_dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(joint_solution,</div><div class="line">                             joint_solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 5) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> TwoPhaseFlowProblem&lt;</div><div class="line">    dim&gt;::determine_whether_to_solve_for_pressure_and_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (timestep_number &lt;= 2)</div><div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(saturation_degree + 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(saturation_fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; old_saturation_after_solving_pressure(n_q_points);</div><div class="line">    std::vector&lt;double&gt; present_saturation(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_global_aop_indicator = 0.0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> max_local_mobility_reciprocal_difference = 0.0;</div><div class="line">        <span class="keywordtype">double</span> max_local_permeability_inverse_l1_norm   = 0.0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          saturation_matching_last_computed_darcy_solution,</div><div class="line">          old_saturation_after_solving_pressure);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(saturation_solution, present_saturation);</div><div class="line"></div><div class="line">        k_inverse.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             k_inverse_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> mobility_reciprocal_difference = <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(</div><div class="line">              mobility_inverse(present_saturation[q], viscosity) -</div><div class="line">              mobility_inverse(old_saturation_after_solving_pressure[q],</div><div class="line">                               viscosity));</div><div class="line"></div><div class="line">            max_local_mobility_reciprocal_difference =</div><div class="line">              <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_mobility_reciprocal_difference,</div><div class="line">                       mobility_reciprocal_difference);</div><div class="line"></div><div class="line">            max_local_permeability_inverse_l1_norm =</div><div class="line">              <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_permeability_inverse_l1_norm,</div><div class="line">                       <a class="code" href="tensor_8h.html#a93ba01d979880b278cd4b573dd9c653b">l1_norm</a>(k_inverse_values[q]));</div><div class="line">          }</div><div class="line"></div><div class="line">        max_global_aop_indicator =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_global_aop_indicator,</div><div class="line">                   (max_local_mobility_reciprocal_difference *</div><div class="line">                    max_local_permeability_inverse_l1_norm));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (max_global_aop_indicator &gt; AOS_threshold);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::project_back_saturation()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; saturation_solution.size(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (saturation_solution(i) &lt; 0.2)</div><div class="line">        saturation_solution(i) = 0.2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (saturation_solution(i) &gt; 1)</div><div class="line">        saturation_solution(i) = 1;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::get_max_u_F_prime()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(darcy_degree + 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                       quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; darcy_solution_values(n_q_points,</div><div class="line">                                                      Vector&lt;double&gt;(dim + 1));</div><div class="line">    std::vector&lt;double&gt;         saturation_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_velocity_times_dF_dS = 0;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">      {</div><div class="line">        darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(saturation_cell);</div><div class="line"></div><div class="line">        darcy_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(darcy_solution,</div><div class="line">                                            darcy_solution_values);</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                                 saturation_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">              velocity[i] = darcy_solution_values[q](i);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> dF_dS =</div><div class="line">              fractional_flow_derivative(saturation_values[q], viscosity);</div><div class="line"></div><div class="line">            max_velocity_times_dF_dS =</div><div class="line">              <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity_times_dF_dS, velocity.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() * dF_dS);</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> max_velocity_times_dF_dS;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::pair&lt;double, double&gt;</div><div class="line">  TwoPhaseFlowProblem&lt;dim&gt;::get_extrapolated_saturation_range()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(saturation_degree + 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(saturation_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_old_saturation_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">               max_saturation = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                          old_saturation_values);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_saturation_solution,</div><div class="line">                                          old_old_saturation_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> saturation =</div><div class="line">                  (1. + time_step / old_time_step) * old_saturation_values[q] -</div><div class="line">                  time_step / old_time_step * old_old_saturation_values[q];</div><div class="line"></div><div class="line">                min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_saturation, saturation);</div><div class="line">                max_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_saturation, saturation);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> std::make_pair(min_saturation, max_saturation);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">               max_saturation = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                          old_saturation_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> saturation = old_saturation_values[q];</div><div class="line"></div><div class="line">                min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_saturation, saturation);</div><div class="line">                max_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_saturation, saturation);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> std::make_pair(min_saturation, max_saturation);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::compute_viscosity(</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_saturation,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_saturation,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_saturation_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_saturation_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;Vector&lt;double&gt;&gt; &amp;present_darcy_values,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_max_u_F_prime,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_S_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta  = .4 * dim;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = 1;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (global_max_u_F_prime == 0)</div><div class="line">      <span class="keywordflow">return</span> 5e-3 * cell_diameter;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_saturation.size();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_residual             = 0;</div><div class="line">    <span class="keywordtype">double</span> max_velocity_times_dF_dS = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> use_dF_dS = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          u[d] = present_darcy_values[q](d);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> dS_dt = porosity *</div><div class="line">                             (old_saturation[q] - old_old_saturation[q]) /</div><div class="line">                             old_time_step;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> dF_dS = fractional_flow_derivative(</div><div class="line">          (old_saturation[q] + old_old_saturation[q]) / 2.0, viscosity);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_S =</div><div class="line">          u * dF_dS * (old_saturation_grads[q] + old_old_saturation_grads[q]) /</div><div class="line">          2.0;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> residual =</div><div class="line">          <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>((dS_dt + u_grad_S) *</div><div class="line">                   std::pow((old_saturation[q] + old_old_saturation[q]) / 2,</div><div class="line">                            alpha - 1.));</div><div class="line"></div><div class="line">        max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div><div class="line">        max_velocity_times_dF_dS =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u * u) * (use_dF_dS ? <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(dF_dS, 1.) : 1),</div><div class="line">                   max_velocity_times_dF_dS);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> c_R            = 1.0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> global_scaling = c_R * porosity *</div><div class="line">                                  (global_max_u_F_prime)*global_S_variation /</div><div class="line">                                  std::pow(global_Omega_diameter, alpha - 2.);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (beta *</div><div class="line">            (max_velocity_times_dF_dS)*<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(cell_diameter,</div><div class="line">                                                std::pow(cell_diameter, alpha) *</div><div class="line">                                                  max_residual /</div><div class="line">                                                  global_scaling));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TwoPhaseFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement     = (dim == 2 ? 5 : 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_pre_refinement_steps = (dim == 2 ? 3 : 2);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(initial_refinement);</div><div class="line">    global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(triangulation);</div><div class="line"></div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"></div><div class="line">  start_time_iteration:</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(saturation_dof_handler,</div><div class="line">                         saturation_constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(saturation_degree + 2),</div><div class="line">                         SaturationInitialValues&lt;dim&gt;(),</div><div class="line">                         old_saturation_solution);</div><div class="line"></div><div class="line">    time_step = old_time_step = 0;</div><div class="line">    current_macro_time_step = old_macro_time_step = 0;</div><div class="line"></div><div class="line">    time = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, dt=&quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (timestep_number % 200 == 0)</div><div class="line">          output_results();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (timestep_number % 25 == 0)</div><div class="line">          refine_mesh(initial_refinement,</div><div class="line">                      initial_refinement + n_pre_refinement_steps);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">            (pre_refinement_step &lt; n_pre_refinement_steps))</div><div class="line">          {</div><div class="line">            ++pre_refinement_step;</div><div class="line">            <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">          }</div><div class="line"></div><div class="line">        time += time_step;</div><div class="line">        ++timestep_number;</div><div class="line"></div><div class="line">        old_old_saturation_solution = old_saturation_solution;</div><div class="line">        old_saturation_solution     = saturation_solution;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (time &lt;= end_time);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step43</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step43;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-43&quot;</span>));</div><div class="line"></div><div class="line">      TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(1);</div><div class="line">      two_phase_flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_31.html">step-31</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Advectiondominatedtwophaseflowmathematicalmodel">Advection-dominated two-phase flow mathematical model.</a>
        <li><a href="#Adaptiveoperatorsplittingandtimestepping">Adaptive operator splitting and time stepping.</a>
        <li><a href="#Timediscretization">Time discretization.</a>
        <li><a href="#Weakformspacediscretizationforthepressurevelocitypart">Weak form, space discretization for the pressure-velocity part.</a>
        <li><a href="#Stabilizationweakformandspacediscretizationforthesaturationtransportequation">Stabilization, weak form and space discretization for the saturation transport equation.</a>
        <li><a href="#Adaptivemeshrefinement">Adaptive mesh refinement.</a>
        <li><a href="#Linearsystemanditspreconditioning">Linear system and its preconditioning.</a>
        <li><a href="#Thetestcases">The test cases.</a>
        <li><a href="#Listofreferences">List of references</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Boundaryandinitialvalueclasses">Boundary and initial value classes</a>
        <li><a href="#Permeabilitymodels">Permeability models</a>
        <li><a href="#Physicalquantities">Physical quantities</a>
        <li><a href="#Helperclassesforsolversandpreconditioners">Helper classes for solvers and preconditioners</a>
        <li><a href="#TheTwoPhaseFlowProblemclass">The TwoPhaseFlowProblem class</a>
        <li><a href="#TwoPhaseFlowProblemdimTwoPhaseFlowProblem">TwoPhaseFlowProblem<dim>::TwoPhaseFlowProblem</a>
        <li><a href="#TwoPhaseFlowProblemdimsetup_dofs">TwoPhaseFlowProblem<dim>::setup_dofs</a>
        <li><a href="#Assemblingmatricesandpreconditioners">Assembling matrices and preconditioners</a>
      <ul>
        <li><a href="#TwoPhaseFlowProblemdimassemble_darcy_preconditioner">TwoPhaseFlowProblem<dim>::assemble_darcy_preconditioner</a>
        <li><a href="#TwoPhaseFlowProblemdimbuild_darcy_preconditioner">TwoPhaseFlowProblem<dim>::build_darcy_preconditioner</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_darcy_system">TwoPhaseFlowProblem<dim>::assemble_darcy_system</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_saturation_system">TwoPhaseFlowProblem<dim>::assemble_saturation_system</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_saturation_matrix">TwoPhaseFlowProblem<dim>::assemble_saturation_matrix</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_saturation_rhs">TwoPhaseFlowProblem<dim>::assemble_saturation_rhs</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_saturation_rhs_cell_term">TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_cell_term</a>
        <li><a href="#TwoPhaseFlowProblemdimassemble_saturation_rhs_boundary_term">TwoPhaseFlowProblem<dim>::assemble_saturation_rhs_boundary_term</a>
      </ul>
        <li><a href="#TwoPhaseFlowProblemdimsolve">TwoPhaseFlowProblem<dim>::solve</a>
        <li><a href="#TwoPhaseFlowProblemdimrefine_mesh">TwoPhaseFlowProblem<dim>::refine_mesh</a>
        <li><a href="#TwoPhaseFlowProblemdimoutput_results">TwoPhaseFlowProblem<dim>::output_results</a>
        <li><a href="#Toolfunctions">Tool functions</a>
      <ul>
        <li><a href="#TwoPhaseFlowProblemdimdetermine_whether_to_solve_for_pressure_and_velocity">TwoPhaseFlowProblem<dim>::determine_whether_to_solve_for_pressure_and_velocity</a>
        <li><a href="#TwoPhaseFlowProblemdimproject_back_saturation">TwoPhaseFlowProblem<dim>::project_back_saturation</a>
        <li><a href="#TwoPhaseFlowProblemdimget_max_u_F_prime">TwoPhaseFlowProblem<dim>::get_max_u_F_prime</a>
        <li><a href="#TwoPhaseFlowProblemdimget_extrapolated_saturation_range">TwoPhaseFlowProblem<dim>::get_extrapolated_saturation_range</a>
        <li><a href="#TwoPhaseFlowProblemdimcompute_viscosity">TwoPhaseFlowProblem<dim>::compute_viscosity</a>
      </ul>
        <li><a href="#TwoPhaseFlowProblemdimrun">TwoPhaseFlowProblem<dim>::run</a>
        <li><a href="#Thecodemaincodefunction">The <code>main()</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-43/doc/intro.dox</p>
<p><br />
</p>
<p><em> This program was contributed by Chih-Che Chueh (University of Victoria) and Wolfgang Bangerth. Results from this program are used and discussed in the following publications (in particular in the second one):</em></p>
<p><em></p><ul>
<li>Chih-Che Chueh, Marc Secanell, Wolfgang Bangerth, Ned Djilali. Multi-level adaptive simulation of transient two-phase flow in heterogeneous porous media. Computers &amp; Fluids, 39:1585-1596, 2010</li>
<li>Chih-Che Chueh, Ned Djilali, Wolfgang Bangerth. An h-adaptive operator splitting method for two-phase flow in 3D heterogeneous porous media. SIAM Journal on Scientific Computing, 35:B149-B175, 2013.</li>
</ul>
<p></em></p>
<p><em>The implementation discussed here uses and extends parts of the <a class="el" href="step_21.html">step-21</a> and <a class="el" href="step_31.html">step-31</a> tutorial programs.</em></p>
<p><em>The work of the Chih-Che Chueh was funded through the Canada Research Chairs Program and the MITACS Network of Centres of Excellence. Parts of the work by Wolfgang Bangerth were funded through Award No. KUS-C1-016-04, made by the King Abdullah University of Science and Technology, and through an Alfred P. Sloan Research Fellowship. This material is also in parts based upon work supported by the National Science Foundation under Award No. EAR-0426271 and The California Institute of Technology; and in a continuation by the National Science Foundation under Award No. EAR-0949446 and The University of California &ndash; Davis. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation, The California Institute of Technology, or of The University of California &ndash; Davis. </em></p>
<p><a class="anchor" id="Introduction"></a><a class="anchor" id="Intro"></a></p><h1>Introduction</h1>
<p>。</p>
<p>多孔介质中的多相流模拟是一个无处不在的问题，我们以前在步骤20和步骤21中已经以某种形式解决了这个问题。然而，正如在那里很容易看到的那样，它面临两个主要困难：数值精度和效率。第一个问题在第20步的静止求解器中很容易看到：使用最低阶的Raviart-Thomas元素不可能产生高度精确的解决方案。我们需要更精确的方法。第二个原因从时间相关的步骤-21中可以看出：该程序慢得令人发指，没有希望在合理的时间范围内得到高度准确的三维解。</p>
<p>在这个项目中，为了克服这两个问题，有五个方面我们正在努力改进，以实现高性能的模拟器。</p>
<ul>
<li>
高阶空间离散 </li>
<li>
自适应网格细化 </li>
<li>
自适应时间步进 </li>
<li>
运算器分割 </li>
<li>
高效求解器和预处理 </li>
</ul>
<p>这个计划的大部分灵感来自第31步，但这里讨论的几个技术是原创的。</p>
<p><a class="anchor" id="Advectiondominatedtwophaseflowmathematicalmodel"></a></p><h3>Advection-dominated two-phase flow mathematical model.</h3>
<p>我们考虑的是两相不相溶的不可压缩流体的流动。毛细管和重力效应被忽略了，粘性效应被假定为主导。这种流动的管理方程与步骤21中使用的方程相同，为</p>
<p class="formulaDsp">
\begin{align*} \mathbf{u}_t &amp;= - \mathbf{K} \lambda_t \left(S\right) \nabla p, \\ \nabla \cdot \mathbf{u}_t &amp;= q, \\ \epsilon \frac{\partial S}{\partial t} + \nabla \cdot \left( \mathbf{u}_t F\left( S \right) \right)&amp;=0, \end{align*}
</p>
<p>其中 \(S\) 是第二（润湿）相的饱和度（体积分数在零和一之间）， \(p\) 是压力， \(\mathbf{K}\) 是渗透率张量， \(\lambda_t\) 是总流动性， \(\epsilon\) 是孔隙度， \(F\) 是湿润相的分流量， \(q\) 是源项， \(\mathbf{u}_t\) 是总速度。总流动性、润湿相的部分流量和总速度分别由以下公式给出</p>
<p class="formulaDsp">
\begin{align*} \lambda_t(S)&amp;= \lambda_w + \lambda_{nw} = \frac{k_{rw}(S)}{\mu_w} + \frac{k_{rnw}(S)}{\mu_{nw}}, \\ F(S) &amp;= \frac{\lambda_w}{\lambda_t} = \frac{\lambda_w}{\lambda_w + \lambda_{nw}} = \frac{k_{rw}(S)/\mu_w}{k_{rw}(S)/\mu_w + k_{rnw}(S)/\mu_{nw}}, \\ \mathbf{u}_t &amp;= \mathbf{u}_w + \mathbf{u}_{nw} = -\lambda_t(S)\mathbf{K} \cdot \nabla p, \end{align*}
</p>
<p>其中下标 \(w, nw\) 分别代表湿润和非湿润阶段。</p>
<p>为方便起见，饱和度方程中的孔隙度 \(\epsilon\) 可被视为时间变量的比例系数，被设定为1。根据相对渗透率 \(k_{rw}\) 和 \(k_{rnw}\) 对饱和度的依赖性的常用规定，我们用</p>
<p class="formulaDsp">
\begin{align*} k_{rw} &amp;= S^2, \qquad&amp;\qquad k_{rnw} &amp;= \left( 1-S \right)^2. \end{align*}
</p>
<p>上面的多孔介质方程由饱和度的初始条件和压力的边界条件来补充。由于饱和度和压力梯度唯一地决定了速度，所以速度的边界条件是没有必要的。由于流动方程不包含时间导数，因此不需要速度和压力变量的初始条件。流场将边界分为流入或流出部分。具体来说。</p>
<p class="formulaDsp">
\[ \mathbf{\Gamma}_{in}(t) = \left\{\mathbf{x} \in \partial \Omega:\mathbf{n} \cdot \mathbf{u}_t&lt;0\right\}, \]
</p>
<p>我们通过在流入边界上施加饱和变量的边界值，得出一个完整的模型 \(\mathbf{\Gamma}_{in}\) 。</p>
<p><a class="anchor" id="Adaptiveoperatorsplittingandtimestepping"></a></p><h3>Adaptive operator splitting and time stepping.</h3>
<p>从第21步可以看出，一旦我们知道了流量变量，求解速度和压力的流量方程是程序中花费时间远大于饱和度变量的（明确）更新步骤的部分。另一方面，压力和速度对饱和度的依赖性很弱，因此可以考虑每隔几步只求解压力和速度，而每步更新饱和度。如果我们能找到一个关于何时需要更新流量变量的标准，我们把这种拆分称为 "自适应算子拆分 "方案。</p>
<p>在这里，我们使用以下后验标准来决定何时重新计算压力和速度变量（详细的推导和描述可以在[Chueh, Djilali and Bangerth 2011]中找到）。</p>
<p class="formulaDsp">
\begin{align*} \theta(n,n_p) = \max_{\kappa\in{\mathbb T}} \left( \left\| \frac 1{\lambda_t\left(S^{(n-1)}\right)} - \frac 1{\lambda_t\left(S^{(n_p)}\right)} \right\|_{L^\infty(\kappa)} \left\|\|\mathbf{K}^{-1}\|_1\right\|_{L^\infty(\kappa)} \right). \end{align*}
</p>
<p>其中括号内的上标表示定义任何数量的饱和时间步数， \(n_p&lt;n\) 代表我们实际计算压力和速度的最后一步。如果 \(\theta(n,n_p)\) 超过某个阈值，我们就重新计算流量变量；否则，我们在时间步骤 \(n\) 中跳过这个计算，只将饱和变量向前移动一个时间步骤。</p>
<p>简而言之，该算法允许我们执行若干长度为 \(\Delta t_c^{(n)}=t^{(n)}_c-t^{(n-1)}_c\) 的饱和时间步长，直到上述标准告诉我们重新计算速度和压力变量，导致一个长度为</p>
<p class="formulaDsp">
\[ \Delta t_p^{(n)} = \sum_{i=n_p+1}^{n} \Delta t_c^{(i)}. \]
</p>
<p>我们根据Courant-Friedrichs-Lewy（CFL）限制来选择（微型）步骤的长度，标准是</p>
<p class="formulaDsp">
\[ \Delta t_c = \frac{\textrm{min}_{K}h_{K}}{7 \|\mathbf{u}_t\|_{L^{\infty}\left(\Omega\right)}}, \]
</p>
<p>我们已经证实，对于下面讨论的饱和方程的有限元和时间步长方案的选择是稳定的（ \(h_K\) 表示单元 \(K\) 的直径）。其结果是一个方案，微观和宏观的时间步长都不统一，两者都是自适应选择。</p>
<p><a class="anchor" id="Timediscretization"></a></p><h3>Time discretization.</h3>
<p>利用这种时间离散化，我们从IMPES方法中得到每个时间步骤的以下方程组（见步骤21）。</p>
<p class="formulaDsp">
\begin{align*} \mathbf{u}^{(n)}_t + \lambda_t\left(S^{(n-1)}\right) \mathbf{K} \nabla p^{(n)} =0, \\ \nabla \cdot \mathbf{u}^{(n)}_t = q, \\ \epsilon \left( \frac{S^{(n-1)}-S^{(n)}}{\Delta t^{(n)}_c} \right) + \mathbf{u}^{(n)}_t \cdot \nabla F\left(S^{(n-1)}\right) + F\left(S^{(n-1)}\right) \nabla \cdot \mathbf{u}^{(n)}_t =0. \end{align*}
</p>
<p>利用 \(\nabla \cdot \mathbf{u}_t = q\) 这一事实，时间离散的饱和度方程变为</p>
<p class="formulaDsp">
\begin{align*} &amp;\epsilon \left( \frac{S^{(n)}-S^{(n-1)}}{\Delta t^{(n)}_c} \right) + \mathbf{u}^{(n)}_t \cdot \nabla F\left(S^{(n-1)}\right) + F\left(S^{(n-1)}\right)q=0. \end{align*}
</p>
<p><a class="anchor" id="Weakformspacediscretizationforthepressurevelocitypart"></a></p><h3>Weak form, space discretization for the pressure-velocity part.</h3>
<p>通过将定义总速度的方程 \(\mathbf u_t^{(n)}\) 和用源项表示其发散的方程分别与测试函数 \(\mathbf{v}\) 和 \(w\) 相乘，然后根据需要进行分项积分，问题的弱形式为。找出 \(\mathbf u, p\) ，以便对所有测试函数 \(\mathbf{v}, w\) 而言，存在</p>
<p class="formulaDsp">
\begin{gather*} \left( \left( \mathbf{K} \lambda_t\left(S^{(n-1)}\right) \right)^{-1} \mathbf{u}^{(n)}_t, \mathbf{v}\right)_{\Omega} - \left(p^{(n)}, \nabla \cdot \mathbf{v}\right)_{\Omega} = -\left(p^{(n)}, \mathbf{n} \cdot \mathbf{v} \right)_{\partial \Omega}, \\ - \left( \nabla \cdot \mathbf{u}^{(n)}_t,w\right)_{\Omega} = - \big(q,w\big)_{\Omega}. \end{gather*}
</p>
<p>这里， \(\mathbf{n}\) 代表 \(\partial \Omega\) 的单位外向法向量，压力 \(p^{(n)}\) 可以在边界 \(\partial \Omega\) 的开放部分弱化规定，而在那些规定了速度的部分（例如具有 \(\mathbf n \cdot \mathbf u=0\) 的不渗透边界，该术语完全消失了，因为 \(\mathbf n \cdot \mathbf v=0\) 。</p>
<p>我们使用连续有限元来离散速度和压力方程。具体来说，我们使用混合有限元来确保同时对矢量变量（如流体速度）和标量变量（如压力）进行高阶逼近。对于鞍点问题，公认的是需要满足所谓的Babuska-Brezzi或Ladyzhenskaya-Babuska-Brezzi（LBB）条件[Brezzi 1991, Chen 2005]以确保压力-速度系统的稳定性。在本工作中，通过使用比压力高一阶的速度元素，即 \(u_h \in Q^d_{p+1}\) 和 \(p_h \in Q_p\) 来满足这些稳定性条件，其中 \(p=1\) ， \(d\) 是空间维度， \(Q_s\) 表示每个变量的张量积Lagrange多项式的空间 \(s\) 。</p>
<p><a class="anchor" id="Stabilizationweakformandspacediscretizationforthesaturationtransportequation"></a></p><h3>Stabilization, weak form and space discretization for the saturation transport equation.</h3>
<p>为饱和方程选择的 \(Q_1\) 元素在没有上卷或其他类型的稳定化的情况下不会导致稳定的离散化，并且在数值解中会出现虚假的震荡。添加一个人工扩散项是消除这些振荡的一种方法[Chen 2005]。另一方面，添加过多的扩散项会在解中涂抹出尖锐的锋面，并且会出现网格定向困难[Chen 2005]。为了避免这些影响，我们使用了由[Guermond和Pasquetti 2008]提出并在[Chueh, Djilali, Bangerth 2011]和[Kronbichler, Heister and Bangerth, 2011]以及步骤31中验证的人工扩散项。</p>
<p>这种方法修改了饱和度方程的（离散）弱形式，改为</p>
<p class="formulaDsp">
\begin{align*} \left(\epsilon \frac{\partial S_h}{\partial t},\sigma_h\right) - \left(\mathbf{u}_t F\left( S_h \right), \nabla \sigma_h\right) + \left(\mathbf n \cdot \mathbf{u}_t \hat F\left( S_h \right), \sigma_h\right)_{\partial\Omega} + (\nu(S_h) \nabla S_h, \nabla \sigma_h) &amp;=0 \qquad \forall \sigma_h, \end{align*}
</p>
<p>其中 \(\nu\) 是人工扩散参数， \(\hat F\) 是域的边界上适当选择的数值通量（我们为此选择明显的全上风通量）。</p>
<p>根据[Guermond and Pasquetti 2008]（以及[Chueh, Djilali and Bangerth 2011]中的详细说明），我们将参数作为一个片状常数函数，设置在直径为 \(K\) 的每个单元上，为</p>
<p class="formulaDsp">
\[ \nu(S_h)|_{K} = \beta \| \mathbf{u}_t \max\{F&#39;(S_h),1\} \|_{L^{\infty}(K)} \textrm{min} \left\{ h_{K},h^{\alpha}_{K} \frac{\|\textrm{Res}(S_h)\|_{L^{\infty}(K)}}{c(\mathbf{u}_t,S)} \right\} \]
</p>
<p>其中 \(\alpha\) 为稳定化指数， \(\beta\) 为用户定义的无量纲稳定化常数。按照[Guermond和Pasquetti 2008]以及步骤31的实现，速度和饱和度全局归一化常数 \(c(\mathbf{u}_t,S)\) 和残差 \(\textrm{Res}(S)\) 分别为</p>
<p class="formulaDsp">
\[ c(\mathbf{u}_t,S) = c_R \|\mathbf{u}_t \max\{F&#39;(S),1\}\|_{L^{\infty}(\Omega)} \textrm{var}(S)^\alpha | \textrm{diam} (\Omega) |^{\alpha - 2} \]
</p>
<p>和</p>
<p class="formulaDsp">
\[ \textrm{Res}(S) = \left( \epsilon \frac{\partial S}{\partial t} + \mathbf{u}_t \cdot \nabla F(S) + F(S)q \right) \cdot S^{\alpha - 1} \]
</p>
<p>其中 \(c_R\) 是用户定义的第二个无维常数， \(\textrm{diam}(\Omega)\) 是域的直径， \(\textrm{var}(S) = \textrm{max}_{\Omega} S - \textrm{min}_{\Omega} S\) 是整个计算域中目前饱和值的范围 \(\Omega\) 。</p>
<p>这种稳定方案与更简单的方案，如有限体积（或不连续Galerkin）方法或流线型上风Petrov Galerkin（SUPG）离散法相比有很多优点。特别是，人工扩散项主要作用于不连续点附近，因为在饱和度平稳的地区，残差很小。因此，它提供了一个更高的精度。另一方面，它是非线性的，因为 \(\nu\) 取决于饱和度 \(S\) 。我们通过明确处理所有的非线性项来避免这一困难，这导致了以下时间步长的完全离散问题 \(n\) 。</p>
<p class="formulaDsp">
\begin{align*} &amp;\left( \epsilon S_h^{(n)},\sigma_h\right)_{\Omega} - \Delta t^{(n)}_c \Big(F\left(S_h^{(n-1)}\right)\mathbf{u}^{*}_t,\nabla\sigma_h\Big)_{\Omega} + \Delta t^{(n)}_c \Big(F\left(S_h^{(n-1)}\right)\left(\mathbf{n}\cdot\mathbf{u}^{*}_t\right),\sigma_h\Big)_{\partial\Omega} \nonumber \\ &amp; \quad = \left( \epsilon S_h^{(n-1)},\sigma_h\right)_{\Omega} - \Delta t^{(n)}_c \bigg(\nu\left(S_h^{(n-1)}\right)\nabla S_h^{(n-1)},\nabla\sigma_h\bigg)_{\Omega} \nonumber \\ &amp; \qquad + \Delta t^{(n)}_c \bigg(\mathbf{n}\cdot\nu\left(S_h^{(n-1)}\right)\nabla S^{(n-1)},\sigma_h\bigg)_{\partial\Omega} \end{align*}
</p>
<p>其中 \(\mathbf{u}_t^{*}\) 是从 \(\mathbf{u}^{(n_p)}_t\) 和 \(\mathbf{u}^{(n_{pp})}_t\) 线性外推到当前时间 \(t^{(n)}\) 的速度，如果 \(\theta&lt;\theta^*\) ，而 \(\mathbf{u}_t^{*}\) 是 \(\mathbf{u}^{(n_p)}_t\) ，如果 \(\theta&gt;\theta^*\) 。因此，该方程在 \(S_h^{(n)}\) 中是线性的，所需要的是用饱和空间上的质量矩阵来解决。</p>
<p>由于饱和度的Dirichlet边界条件只施加在流入边界上，所以上述方程左边的第三个项需要进一步分成两部分。</p>
<p class="formulaDsp">
\begin{align*} &amp;\Delta t^{(n)}_c \Big(F\left(S_h^{(n-1)}\right)\left(\mathbf{n}\cdot\mathbf{u}^{(n)}_t\right),\sigma_h\Big)_{\partial\Omega} \nonumber \\ &amp;\qquad= \Delta t^{(n)}_c \Big(F\left(S^{(n-1)}_{(+)}\right)\left(\mathbf{n}\cdot\mathbf{u}^{(n)}_{t(+)}\right),\sigma_h\Big)_{\partial\Omega_{(+)}} + \Delta t^{(n)}_c \Big(F\left(S^{(n-1)}_{(-)}\right)\left(\mathbf{n}\cdot\mathbf{u}^{(n)}_{t(-)}\right),\sigma_h\Big)_{\partial\Omega_{(-)}} \end{align*}
</p>
<p>其中 \(\partial\Omega_{(-)} = \left\{\mathbf{x} \in \partial\Omega : \mathbf{n} \cdot \mathbf{u}_t&lt;0\right\}\) 和 \(\partial\Omega_{(+)} = \left\{\mathbf{x} \in \partial\Omega : \mathbf{n} \cdot \mathbf{u}_t&gt;0\right\}\) 分别代表流入和流出的边界。我们使用上风公式选择数值，即 \(S^{(n-1)}_{(+)}\) 和 \(\mathbf{u}^{(n)}_{t(+)}\) 对应于从当前单元中提取的数值，而 \(S^{(n-1)}_{(-)}\) 和 \(\mathbf{u}^{(n)}_{t(-)}\) 的数值是来自邻近的边界 \(\partial\Omega_{(-)}\) 。</p>
<p><a class="anchor" id="Adaptivemeshrefinement"></a></p><h3>Adaptive mesh refinement.</h3>
<p>适应性地选择网格以解决尖锐的饱和前沿是我们算法中实现效率的一个基本要素。在这里，我们使用[Chueh, Djilali and Bangerth 2011]中使用的相同的冲击型细化方法来选择那些应该被细化或粗化的单元。三角形的每个单元 \(K\) 的细化指标是通过以下方式计算的</p>
<p class="formulaDsp">
\[ \eta_{K} = |\nabla S_h(\mathbf x_K)| \]
</p>
<p>其中 \(\nabla S_h(\mathbf x_K)\) 是在 \(\mathbf x_K\) 单元的中心评价的离散饱和变量的梯度。这种方法类似于可压缩流动问题中经常使用的方法，即用密度梯度来表示细化。也就是说，正如我们将在<a href="#Results">results section</a>的结尾处讨论的那样，这被证明不是一个非常有用的标准，因为它基本上到处都导致细化。我们在这里只是为了说明问题而展示它。</p>
<p><a class="anchor" id="Linearsystemanditspreconditioning"></a></p><h3>Linear system and its preconditioning.</h3>
<p>按照上面讨论的治理方程的离散化，我们得到一个时间步长为 \((n)\) 的线性方程组，形式如下。</p>
<p class="formulaDsp">
\[ \left( \begin{array}{ccc} \mathbf{M}^{\mathbf{u}} &amp; \mathbf{B}^{T} &amp; \mathbf{0} \\ \mathbf{B} &amp; \mathbf{0} &amp; \mathbf{0} \\ \mathbf{H} &amp; \mathbf{0} &amp; \mathbf{M}^{S} \end{array} \right) \left( \begin{array}{c} \mathbf{U}^{(n)} \\ \mathbf{P}^{(n)} \\ \mathbf{S}^{(n)} \end{array} \right) = \left( \begin{array}{c} 0 \\ \mathbf{F}_{2} \\ \mathbf{F}_{3} \end{array} \right) \]
</p>
<p>其中各个矩阵和向量的定义如下，使用形状函数 \(\mathbf{v}_i\) 表示速度， \(\phi_i\) 表示压力和饱和度。</p>
<p class="formulaDsp">
\begin{align*} \mathbf{M}^{\mathbf{u}}_{ij} &amp;= \left( \left( \mathbf{K} \lambda_t\left(S^{(n-1)}\right) \right)^{-1} \mathbf{v}_{i},\mathbf{v}_{j}\right)_{\Omega}, &amp; \mathbf{M}^{S}_{ij} &amp;= \left(\epsilon \phi_i,\phi_j\right)_{\Omega} \\ \mathbf{B}_{ij} &amp;= - \left( \nabla \cdot \mathbf{v}_{j},\phi_{i}\right)_{\Omega}, &amp; \mathbf{H}_{ij} &amp;= - \Delta t^{(n)}_c \Big( F\left(S^{(n-1)}\right) \mathbf{v}_i,\nabla\phi_j\Big)_{\Omega} \\ \left(\mathbf{F}_{2}\right)_i &amp;= - \big(F\left(S^{(n-1)}\right)q,\phi_i\big)_{\Omega}, \end{align*}
</p>
<p>和 \(\mathbf{F}_{3}\) 在稳定传输方程的定义中给出。</p>
<p>如果我们把左上角的 \(2\times 2\) 板块的矩阵视为一个板块，那么上面的线性系统是块状三角形形式。因此，我们可以首先求解速度和压力（除非我们决定用 \(\mathbf U^{(n_p)}\) 来代替速度），然后再求解饱和度变量。其中第一个步骤要求我们解决</p>
<p class="formulaDsp">
\[ \left( \begin{array}{cc} \mathbf{M}^{\mathbf{u}} &amp; \mathbf{B}^{T} \\ \mathbf{B} &amp; \mathbf{0} \end{array} \right) \left( \begin{array}{c} \mathbf{U}^{(n)} \\ \mathbf{P}^{(n)} \end{array} \right) = \left( \begin{array}{c} 0 \\ \mathbf{F}_{2} \end{array} \right) \]
</p>
<p>我们对这个线性系统采用广义最小残差（GMRES）方法[Saad和Schultz 1986]。速度-压力系统的理想预处理方法是</p>
<p class="formulaDsp">
\begin{align*} \mathbf{P} = \left( \begin{array}{cc} \mathbf{M}^{\mathbf{u}} &amp; \mathbf{0} \\ \mathbf{B} &amp; -\mathbf{S} \end{array} \right), &amp; \qquad \mathbf{P}^{-1} = \left( \begin{array}{cc} \left(\mathbf{M}^{\mathbf{u}}\right)^{-1} &amp; \mathbf{0} \\ \mathbf{S}^{-1} \mathbf{B} \left(\mathbf{M}^{\mathbf{u}}\right)^{-1} &amp; -\mathbf{S}^{-1} \end{array} \right) \end{align*}
</p>
<p>其中 \(\mathbf{S}=\mathbf{B}\left(\mathbf{M}^{\mathbf{u}}\right)^{-1}\mathbf{B}^T\) 是系统的Schur补充[Zhang 2005]。这个预处理程序是最优的，因为</p>
<p class="formulaDsp">
\begin{align*} \mathbf{P}^{-1} \left( \begin{array}{cc} \mathbf{M}^{\mathbf{u}} &amp; \mathbf{B}^{T} \\ \mathbf{B} &amp; \mathbf{0} \end{array} \right) = \left( \begin{array}{cc} \mathbf{I} &amp; \left(\mathbf{M}^{\mathbf{u}}\right)^{-1} \mathbf{B}^{T} \\ \mathbf{0} &amp; \mathbf{I} \end{array} \right), \end{align*}
</p>
<p>对其而言，可以证明GMRES在两次迭代中收敛。</p>
<p>然而，我们当然不能指望使用速度质量矩阵和Schur补数的精确求逆。因此，我们采用[Silvester and Wathen 1994]最初为斯托克斯系统提出的方法。将其适用于当前的方程组，得到预处理程序</p>
<p class="formulaDsp">
\begin{align*} \mathbf{\tilde{P}}^{-1} = \left( \begin{array}{cc} \widetilde{\left(\mathbf{{M}}^{\mathbf{u}}\right)^{-1}} &amp; \mathbf{0} \\ \widetilde{\mathbf{{S}}^{-1}} \mathbf{B} \widetilde{\left(\mathbf{{M}}^{\mathbf{u}}\right)^{-1}} &amp; -\widetilde{\mathbf{{S}}^{-1}} \end{array} \right) \end{align*}
</p>
<p>其中蒂尔德表示精确逆矩阵的近似值。特别是，由于 \(\left(\mathbf{{M}}^{\mathbf{u}}\right)^{-1}=\left( \left( \mathbf{K} \lambda_t \right)^{-1} \mathbf{v}_{i},\mathbf{v}_{j}\right)_{\Omega}\) 是一个稀疏的对称和正定矩阵，我们为 \(\widetilde{\left(\mathbf{{M}}^{\mathbf{u}}\right)^{-1}}\) 选择了这个矩阵的稀疏不完全Cholesky分解的单一应用[Golub和Van Loan 1996]。我们注意到，对应于非混合形式的多孔介质流动算子的舒尔补， \(-\nabla \cdot [\mathbf K \lambda_t(S)]\nabla\) 和 \(\mathbf{\tilde {S}} = \left( \left( \mathbf{K} \lambda_t \right) \nabla \phi_{i},\nabla \phi_{j}\right)_{\Omega}\) 应该是实际舒尔补矩阵 \(\mathbf S\) 的良好近似。由于这两个矩阵又都是对称和正定的，所以我们用 \(\mathbf{\tilde S}\) 的不完全Cholesky分解来表示 \(\widetilde {\mathbf{{S}}^{-1}}\) 。需要注意的是， \(\mathbf{\tilde S}\) 需要用Dirichlet边界条件建立，以确保其可逆性。</p>
<p>一旦有了速度 \(\mathbf{U}^{(n)} \equiv \mathbf{u}^*_t\) ，我们就可以把 \(\mathbf{H}\) 和 \(\mathbf{F}_{3}\) 组合起来，用以下方法解决饱和度的问题</p>
<p class="formulaDsp">
\begin{align*} \mathbf{M}^{S} \mathbf{S}^{(n)} = \mathbf{F}_{3} - \mathbf{H} \mathbf{U}^{(n)}. \end{align*}
</p>
<p>其中质量矩阵 \(\mathbf{M}^{S}\) 用共轭梯度法求解，再一次使用不完全的Cholesky分解作为预处理。</p>
<p><a class="anchor" id="Thetestcases"></a></p><h3>The test cases.</h3>
<dl class="section note"><dt>Note</dt><dd>这里讨论的实现使用并扩展了这个库的步骤21、步骤31和步骤33教程的部分程序。特别是，如果你想了解它是如何工作的，请参考<a class="el" href="step_21.html">step-21</a>关于数学问题的讨论，以及<a class="el" href="step_31.html">step-31</a>，大部分的实现都来自于此。我们将不讨论在步骤31中已经讨论过的实现的各个方面。</dd></dl>
<p>我们展示了一些两相流方程的数值结果，这些方程通过适当的初始和边界条件，结合两种不同的渗透率模型的选择而得到增强。在所考虑的问题中，没有内部源项（ \(q=0\) ）。如上所述，定量的数值结果在[Chueh, Djilali and Bangerth 2011]中提出。</p>
<p>为了简单起见，我们选择了 \(\Omega=[0,1]^d,d=2,3\) ，尽管所有的方法（以及我们的实现）在一般的非结构化网格上都应该同样工作。</p>
<p>初始条件只需要饱和变量，我们选择 \(S(\mathbf{x},0)=0.2\) ，即多孔介质最初是由非湿润（80）和湿润（20）相的混合物填充。这与步骤21中的初始条件不同，在该步骤中我们采用了 \(S(\mathbf{x},0)=0\) ，但由于复杂的数学原因，在那里的长篇评论中提到，目前使用基于熵的人工扩散项的方法在不对方法进行额外修改的情况下不能收敛到这个初始条件的粘度解。因此，我们在目前的计划中选择了这个修改过的版本。</p>
<p>此外，我们在边界上规定了一个线性压力。</p>
<p class="formulaDsp">
\[ p(\mathbf{x},t) = 1 - x \qquad \textrm{on} \quad \partial \Omega \times [0,T]. \]
</p>
<p>压力和饱和度唯一地决定了速度，而速度决定了一个边界段是流入还是流出的边界。在边界的流入部分， \(\mathbf{\Gamma}_{in}(t)\) ，我们规定</p>
<p class="formulaDsp">
\begin{align*} S(\mathbf{x},t) = 1 \qquad &amp; \textrm{on} \quad \mathbf{\Gamma}_{in}(t) \cap \left\{x = 0\right\}, \\ S(\mathbf{x},t) = 0 \qquad &amp; \textrm{on} \quad \mathbf{\Gamma}_{in}(t) \backslash \left\{x = 0\right\}. \end{align*}
</p>
<p>换句话说，该领域被来自左边的湿润相淹没。对于边界的流出部分，不需要饱和的边界条件。</p>
<p>所有用于二维/三维案例的数值和物理参数都列在下表中。</p>
<table align="center" class="tutorial" width="50%">
<tr>
<th>Parameter </th><th>Symbol </th><th>Value </th><th>units </th></tr>
<tr>
<td>Porosity </td><td>\(\epsilon\) </td><td>1.0 </td><td>- </td></tr>
<tr>
<td>Viscosity (wetting) </td><td>\(\mu_w\) </td><td>0.2 </td><td>\(kg \cdot m^{-1} \cdot sec^{-1}\) </td></tr>
<tr>
<td>Viscosity (nonwetting) </td><td>\(\mu_{nw}\) </td><td>1.0 </td><td>\(kg \cdot m^{-1} \cdot sec^{-1}\) </td></tr>
<tr>
<td>Stabilization exponent </td><td>\(\alpha\) </td><td>1.0 </td><td>- </td></tr>
<tr>
<td>Stabilization constant </td><td>\(\beta\) </td><td>2D: 0.3; 3D: 0.27 </td><td>- </td></tr>
<tr>
<td>Normalization constant </td><td>\(c_R\) </td><td>1.0 </td><td>- </td></tr>
<tr>
<td>Number of high-permeability regions </td><td>\(N\) </td><td>50; 200 </td><td>- </td></tr>
<tr>
<td>Operator splitting threshold </td><td>\(\theta^\ast\) </td><td>5.0 </td><td>-  </td></tr>
</table>
<p><a class="anchor" id="Listofreferences"></a></p><h3>List of references</h3>
<ol>
<li>
<p class="startli">CC Chueh, N Djilali and W Bangerth. <br />
 三维异质多孔介质中两相流的h-适应性算子分割方法。 <br />
 SIAM科学计算杂志，第35卷（2013），第B149-B175页</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">M. Kronbichler, T. Heister, and W. Bangerth <br />
 通过现代数值方法进行高精度地幔对流模拟。 <br />
 Geophysics Journal International, vol. 191 (2012), pp.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">F Brezzi和M Fortin。 <br />
 <em>Mixed and Hybrid Finite Element Methods</em>. <br />
 Springer-Verlag, 1991.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Z陈。 <br />
 <em>Finite Element Methods and Their Applications</em>. <br />
 Springer, 2005.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">JL Guermond和R Pasquetti. <br />
 基于熵的非线性粘度的守恒定律的傅里叶近似。 <br />
 <em>Comptes Rendus Mathematique</em>, 346(13-14): 801-806, 2008.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">CC Chueh, M Secanell, W Bangerth, and N Djilali. <br />
 异质多孔介质中瞬态两相流的多级自适应模拟。 <br />
 <em>Computers and Fluids</em>, 39:1585-1596, 2010.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Y Saad和MH Schultz。 <br />
 Gmres:用于解决非对称线性系统的广义最小残差算法。 <br />
 <em>SIAM Journal on Scientific and Statistical Computing</em>, 7(3):856-869, 1986.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">F张。 <br />
 <em>The Schur Complement and its Applications</em>. <br />
 Springer, 2005.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">D Silvester和A Wathen。 <br />
 稳定的斯托克斯系统的快速迭代解第二部分：使用一般的块状先决条件。 <br />
 <em>SIAM Journal on Numerical Analysis</em>, 31(5):1352-1367, 1994.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">GH Golub和CF van Loan。 <br />
 <em>Matrix Computations</em>. <br />
 第三版，约翰霍普金斯大学，1996年。</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">SE Buckley和MC Leverett。 <br />
 沙子中流体位移的机制。 <br />
 <em>AIME Trans.</em>, 146:107-116, 1942.</p>
<p class="endli"></p>
</li>
</ol>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first step, as always, is to include the functionality of a number of deal.II and C++ header files.</p>
<p>The list includes some header files that provide vector, matrix, and preconditioner classes that implement interfaces to the respective Trilinos classes; some more information on these may be found in <a class="el" href="step_31.html">step-31</a>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div></div><!-- fragment --><p>At the end of this top-matter, we open a namespace for the current project into which all the following material will go, and then import all deal.II names into this namespace:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step43</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Boundaryandinitialvalueclasses"></a> </p><h3>Boundary and initial value classes</h3>
<p>The following part is taken directly from <a class="el" href="step_21.html">step-21</a> so there is no need to repeat the descriptions found there.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PressureBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  PressureBoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">PressureBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 1 - p[0];</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SaturationBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SaturationBoundaryValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">SaturationBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (p[0] == 0)</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>SaturationInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  SaturationInitialValues()</div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">  {}</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                            <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span></div><div class="line">SaturationInitialValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> 0.2;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> SaturationInitialValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                                <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">    <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = SaturationInitialValues&lt;dim&gt;::value(p, c);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Permeabilitymodels"></a> </p><h3>Permeability models</h3>
<p>In this tutorial, we still use the two permeability models previously used in <a class="el" href="step_21.html">step-21</a> so we again refrain from commenting in detail about them.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>SingleCurvingCrack</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    KInverse()</div><div class="line">      : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">    value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">               std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> KInverse&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                 std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">      {</div><div class="line">        values[p].clear();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> distance_to_flowline =</div><div class="line">          <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0]));</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> permeability =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::exp(-(distance_to_flowline * distance_to_flowline) /</div><div class="line">                            (0.1 * 0.1)),</div><div class="line">                   0.01);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          values[p][d][d] = 1. / permeability;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace SingleCurvingCrack</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>RandomMedium</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    KInverse()</div><div class="line">      : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">    value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">               std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; centers;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::vector&lt;Point&lt;dim&gt;&gt; KInverse&lt;dim&gt;::centers = []() {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N =</div><div class="line">      (dim == 2 ? 40 : (dim == 3 ? 100 : <span class="keywordflow">throw</span> <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()));</div><div class="line"></div><div class="line">    std::vector&lt;Point&lt;dim&gt;&gt; centers_list(N);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a>; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        centers_list[i][d] = static_cast&lt;double&gt;(rand()) / RAND_MAX;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> centers_list;</div><div class="line">  }();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> KInverse&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                 std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(points.size(), values.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">      {</div><div class="line">        values[p].clear();</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> permeability = 0;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; centers.size(); ++i)</div><div class="line">          permeability +=</div><div class="line">            std::exp(-(points[p] - centers[i]).norm_square() / (0.05 * 0.05));</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> normalized_permeability =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(permeability, 0.01), 4.);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          values[p][d][d] = 1. / normalized_permeability;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace RandomMedium</span></div></div><!-- fragment --><p><a class="anchor" id="Physicalquantities"></a> </p><h3>Physical quantities</h3>
<p>The implementations of all the physical quantities such as total mobility \(\lambda_t\) and fractional flow of water \(F\) are taken from <a class="el" href="step_21.html">step-21</a> so again we don't have do any comment about them. Compared to <a class="el" href="step_21.html">step-21</a> we have added checks that the saturation passed to these functions is in fact within the physically valid range. Furthermore, given that the wetting phase moves at speed \(\mathbf u F&#39;(S)\) it is clear that \(F&#39;(S)\) must be greater or equal to zero, so we assert that as well to make sure that our calculations to get at the formula for the derivative made sense.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> mobility_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> fractional_flow(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((S &gt;= 0) &amp;&amp; (S &lt;= 1),</div><div class="line">         <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Saturation is outside its physically valid range.&quot;</span>));</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> S * S / (S * S + viscosity * (1 - S) * (1 - S));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">double</span> fractional_flow_derivative(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((S &gt;= 0) &amp;&amp; (S &lt;= 1),</div><div class="line">         <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Saturation is outside its physically valid range.&quot;</span>));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> temp = (S * S + viscosity * (1 - S) * (1 - S));</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> numerator =</div><div class="line">    2.0 * S * temp - S * S * (2.0 * S - 2.0 * viscosity * (1 - S));</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> denominator = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(temp, 2.0);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> F_prime = numerator / denominator;</div><div class="line"></div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(F_prime &gt;= 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> F_prime;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Helperclassesforsolversandpreconditioners"></a> </p><h3>Helper classes for solvers and preconditioners</h3>
<p>In this first part we define a number of classes that we need in the construction of linear solvers and preconditioners. This part is essentially the same as that used in <a class="el" href="step_31.html">step-31</a>. The only difference is that the original variable name stokes_matrix is replaced by another name darcy_matrix to match our problem.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>LinearSolvers</div><div class="line">{</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                  <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">    <span class="keywordtype">void</span> vmult(<a class="code" href="classVectorType.html">VectorType</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">    <span class="keyword">const</span> PreconditionerType &amp;           preconditioner;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">    <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">    <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">    : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">    , preconditioner(preconditioner)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">  <span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">    <a class="code" href="classVectorType.html">VectorType</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>        solver_control(src.size(), 1e-7 * src.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;VectorType&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">    dst = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">try</span></div><div class="line">      {</div><div class="line">        cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, preconditioner);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">catch</span> (std::exception &amp;e)</div><div class="line">      {</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(e.what()));</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">  <span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BlockSchurPreconditioner(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">      <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                          PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">      <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner);</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#aff5a880cfa288ecdd2a83a876abacf0d">vmult</a>(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">               <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">      darcy_matrix;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;<span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                           PreconditionerTypeMp&gt;&gt;</div><div class="line">                               m_inverse;</div><div class="line">    <span class="keyword">const</span> PreconditionerTypeA &amp;a_preconditioner;</div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">  BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::</div><div class="line">    BlockSchurPreconditioner(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">      <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                          PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">      <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner)</div><div class="line">    : darcy_matrix(&amp;S)</div><div class="line">    , m_inverse(&amp;Mpinv)</div><div class="line">    , a_preconditioner(Apreconditioner)</div><div class="line">    , tmp(<a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(darcy_matrix-&gt;block(1, 1).m()))</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::vmult(</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    a_preconditioner.vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">    darcy_matrix-&gt;block(1, 0).residual(tmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">    tmp *= -1;</div><div class="line">    m_inverse-&gt;vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace LinearSolvers</span></div></div><!-- fragment --><p><a class="anchor" id="TheTwoPhaseFlowProblemclass"></a> </p><h3>The TwoPhaseFlowProblem class</h3>
<p>The definition of the class that defines the top-level logic of solving the time-dependent advection-dominated two-phase flow problem (or Buckley-Leverett problem [Buckley 1942]) is mainly based on tutorial programs <a class="el" href="step_21.html">step-21</a> and <a class="el" href="step_33.html">step-33</a>, and in particular on <a class="el" href="step_31.html">step-31</a> where we have used basically the same general structure as done here. As in <a class="el" href="step_31.html">step-31</a>, the key routines to look for in the implementation below are the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> and <code>solve()</code> functions.</p>
<p>The main difference to <a class="el" href="step_31.html">step-31</a> is that, since adaptive operator splitting is considered, we need a couple more member variables to hold the last two computed Darcy (velocity/pressure) solutions in addition to the current one (which is either computed directly, or extrapolated from the previous two), and we need to remember the last two times we computed the Darcy solution. We also need a helper function that figures out whether we do indeed need to recompute the Darcy solution.</p>
<p>Unlike <a class="el" href="step_31.html">step-31</a>, this step uses one more <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object called darcy_preconditioner_constraints. This constraint object is used only for assembling the matrix for the Darcy preconditioner and includes hanging node constraints as well as Dirichlet boundary value constraints for the pressure variable. We need this because we are building a Laplace matrix for the pressure as an approximation of the Schur complement) which is only positive definite if boundary conditions are applied.</p>
<p>The collection of member functions and variables thus declared in this class is then rather similar to those in <a class="el" href="step_31.html">step-31</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>TwoPhaseFlowProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_dofs();</div><div class="line">  <span class="keywordtype">void</span> assemble_darcy_preconditioner();</div><div class="line">  <span class="keywordtype">void</span> build_darcy_preconditioner();</div><div class="line">  <span class="keywordtype">void</span> assemble_darcy_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_saturation_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_saturation_matrix();</div><div class="line">  <span class="keywordtype">void</span> assemble_saturation_rhs();</div><div class="line">  <span class="keywordtype">void</span> assemble_saturation_rhs_cell_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       saturation_fe_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       darcy_fe_values,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_max_u_F_prime,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_S_variation,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices);</div><div class="line">  <span class="keywordtype">void</span> assemble_saturation_rhs_boundary_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   saturation_fe_face_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   darcy_fe_face_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices);</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_grid_level,</div><div class="line">                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line">  <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div></div><!-- fragment --><p>We follow with a number of helper functions that are used in a variety of places throughout the program:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span>                    get_max_u_F_prime() <span class="keyword">const</span>;</div><div class="line">std::pair&lt;double, double&gt; get_extrapolated_saturation_range() <span class="keyword">const</span>;</div><div class="line"><span class="keywordtype">bool</span>   determine_whether_to_solve_for_pressure_and_velocity() <span class="keyword">const</span>;</div><div class="line"><span class="keywordtype">void</span>   project_back_saturation();</div><div class="line"><span class="keywordtype">double</span> compute_viscosity(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_saturation,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_saturation,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_saturation_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_saturation_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;present_darcy_values,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_max_u_F_prime,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_S_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter) <span class="keyword">const</span>;</div></div><!-- fragment --><p>This all is followed by the member variables, most of which are similar to the ones in <a class="el" href="step_31.html">step-31</a>, with the exception of the ones that pertain to the macro time stepping for the velocity/pressure system:</p>
<div class="fragment"><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"><span class="keywordtype">double</span>             global_Omega_diameter;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        darcy_degree;</div><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             darcy_fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           darcy_dof_handler;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> darcy_constraints;</div><div class="line"></div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> darcy_preconditioner_constraints;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> darcy_matrix;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> darcy_preconditioner_matrix;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> darcy_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> darcy_rhs;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> last_computed_darcy_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> second_last_computed_darcy_solution;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        saturation_degree;</div><div class="line"><a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 saturation_fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           saturation_dof_handler;</div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> saturation_constraints;</div><div class="line"></div><div class="line">TrilinosWrappers::SparseMatrix saturation_matrix;</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> saturation_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_saturation_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_saturation_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> saturation_rhs;</div><div class="line"></div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a></div><div class="line">  saturation_matching_last_computed_darcy_solution;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> saturation_refinement_threshold;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span>       time;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> end_time;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> current_macro_time_step;</div><div class="line"><span class="keywordtype">double</span> old_macro_time_step;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span>       time_step;</div><div class="line"><span class="keywordtype">double</span>       old_time_step;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> viscosity;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> porosity;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> AOS_threshold;</div><div class="line"></div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt; Amg_preconditioner;</div><div class="line">std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt; Mp_preconditioner;</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> rebuild_saturation_matrix;</div></div><!-- fragment --><p>At the very end we declare a variable that denotes the material model. Compared to <a class="el" href="step_21.html">step-21</a>, we do this here as a member variable since we will want to use it in a variety of places and so having a central place where such a variable is declared will make it simpler to replace one class by another (e.g. replace RandomMedium::KInverse by SingleCurvingCrack::KInverse).</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> RandomMedium::KInverse&lt;dim&gt; k_inverse;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimTwoPhaseFlowProblem"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::TwoPhaseFlowProblem</h3>
<p>The constructor of this class is an extension of the constructors in <a class="el" href="step_21.html">step-21</a> and <a class="el" href="step_31.html">step-31</a>. We need to add the various variables that concern the saturation. As discussed in the introduction, we are going to use \(Q_2 \times Q_1\) (Taylor-Hood) elements again for the Darcy system, an element combination that fulfills the Ladyzhenskaya-Babuska-Brezzi (LBB) conditions [Brezzi and Fortin 1991, Chen 2005], and \(Q_1\) elements for the saturation. However, by using variables that store the polynomial degree of the Darcy and temperature finite elements, it is easy to consistently modify the degree of the elements as well as all quadrature formulas used on them downstream. Moreover, we initialize the time stepping variables related to operator splitting as well as the option for matrix assembly and preconditioning:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">TwoPhaseFlowProblem&lt;dim&gt;::TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">  , global_Omega_diameter(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">  , degree(degree)</div><div class="line">  , darcy_degree(degree)</div><div class="line">  , darcy_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(darcy_degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(darcy_degree), 1)</div><div class="line">  , darcy_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  saturation_degree(degree + 1)</div><div class="line">  , saturation_fe(saturation_degree)</div><div class="line">  , saturation_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  saturation_refinement_threshold(0.5)</div><div class="line">  ,</div><div class="line"></div><div class="line">  time(0)</div><div class="line">  , end_time(10)</div><div class="line">  ,</div><div class="line"></div><div class="line">  current_macro_time_step(0)</div><div class="line">  , old_macro_time_step(0)</div><div class="line">  ,</div><div class="line"></div><div class="line">  time_step(0)</div><div class="line">  , old_time_step(0)</div><div class="line">  , timestep_number(0)</div><div class="line">  , viscosity(0.2)</div><div class="line">  , porosity(1.0)</div><div class="line">  , AOS_threshold(3.0)</div><div class="line">  ,</div><div class="line"></div><div class="line">  rebuild_saturation_matrix(true)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimsetup_dofs"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::setup_dofs</h3>
<p>This is the function that sets up the <a class="el" href="classDoFHandler.html">DoFHandler</a> objects we have here (one for the Darcy part and one for the saturation part) as well as set to the right sizes the various objects required for the linear algebra in this program. Its basic operations are similar to what <a class="el" href="step_31.html">step-31</a> did.</p>
<p>The body of the function first enumerates all degrees of freedom for the Darcy and saturation systems. For the Darcy part, degrees of freedom are then sorted to ensure that velocities precede pressure DoFs so that we can partition the Darcy matrix into a \(2 \times 2\) matrix.</p>
<p>Then, we need to incorporate hanging node constraints and Dirichlet boundary value constraints into darcy_preconditioner_constraints. The boundary condition constraints are only set on the pressure component since the Schur complement preconditioner that corresponds to the porous media flow operator in non-mixed form, \(-\nabla \cdot [\mathbf K \lambda_t(S)]\nabla\), acts only on the pressure variable. Therefore, we use a component_mask that filters out the velocity component, so that the condensation is performed on pressure degrees of freedom only.</p>
<p>After having done so, we count the number of degrees of freedom in the various blocks. This information is then used to create the sparsity pattern for the Darcy and saturation system matrices as well as the preconditioner matrix from which we build the Darcy preconditioner. As in <a class="el" href="step_31.html">step-31</a>, we choose to create the pattern using the blocked version of <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>. So, for this, we follow the same way as <a class="el" href="step_31.html">step-31</a> did and we don't have to repeat descriptions again for the rest of the member function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; darcy_block_component(dim + 1, 0);</div><div class="line">  darcy_block_component[dim] = 1;</div><div class="line">  {</div><div class="line">    darcy_dof_handler.distribute_dofs(darcy_fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(darcy_dof_handler);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(darcy_dof_handler, darcy_block_component);</div><div class="line"></div><div class="line">    darcy_constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(darcy_dof_handler,</div><div class="line">                                            darcy_constraints);</div><div class="line">    darcy_constraints.close();</div><div class="line">  }</div><div class="line">  {</div><div class="line">    saturation_dof_handler.distribute_dofs(saturation_fe);</div><div class="line"></div><div class="line">    saturation_constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(saturation_dof_handler,</div><div class="line">                                            saturation_constraints);</div><div class="line">    saturation_constraints.close();</div><div class="line">  }</div><div class="line">  {</div><div class="line">    darcy_preconditioner_constraints.clear();</div><div class="line"></div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(darcy_dof_handler,</div><div class="line">                                            darcy_preconditioner_constraints);</div><div class="line">    <a class="code" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a>(darcy_dof_handler,</div><div class="line">                                             darcy_preconditioner_constraints,</div><div class="line">                                             darcy_fe.component_mask(</div><div class="line">                                               pressure));</div><div class="line"></div><div class="line">    darcy_preconditioner_constraints.close();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; darcy_dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(darcy_dof_handler,</div><div class="line">                                      darcy_block_component);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = darcy_dofs_per_block[0],</div><div class="line">                     n_p = darcy_dofs_per_block[1],</div><div class="line">                     n_s = saturation_dof_handler.n_dofs();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_s &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">            &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_s &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    darcy_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">    dsp.block(0, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_u);</div><div class="line">    dsp.block(0, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_p);</div><div class="line">    dsp.block(1, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_u);</div><div class="line">    dsp.block(1, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_p);</div><div class="line"></div><div class="line">    dsp.collect_sizes();</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (d == dim)))</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">      darcy_dof_handler, coupling, dsp, darcy_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    darcy_matrix.reinit(dsp);</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    Amg_preconditioner.reset();</div><div class="line">    Mp_preconditioner.reset();</div><div class="line">    darcy_preconditioner_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">    dsp.block(0, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_u);</div><div class="line">    dsp.block(0, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_p);</div><div class="line">    dsp.block(1, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_u);</div><div class="line">    dsp.block(1, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_p);</div><div class="line"></div><div class="line">    dsp.collect_sizes();</div><div class="line"></div><div class="line">    <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        <span class="keywordflow">if</span> (c == d)</div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">      darcy_dof_handler, coupling, dsp, darcy_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    darcy_preconditioner_matrix.reinit(dsp);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  {</div><div class="line">    saturation_matrix.clear();</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_s, n_s);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(saturation_dof_handler,</div><div class="line">                                    dsp,</div><div class="line">                                    saturation_constraints,</div><div class="line">                                    <span class="keyword">false</span>);</div><div class="line"></div><div class="line"></div><div class="line">    saturation_matrix.reinit(dsp);</div><div class="line">  }</div><div class="line"></div><div class="line">  std::vector&lt;IndexSet&gt; darcy_partitioning(2);</div><div class="line">  darcy_partitioning[0] = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_u);</div><div class="line">  darcy_partitioning[1] = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_p);</div><div class="line">  darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">  darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">  last_computed_darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">  last_computed_darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">  second_last_computed_darcy_solution.reinit(darcy_partitioning,</div><div class="line">                                             MPI_COMM_WORLD);</div><div class="line">  second_last_computed_darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">  darcy_rhs.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">  darcy_rhs.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> saturation_partitioning = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_s);</div><div class="line">  saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  saturation_matching_last_computed_darcy_solution.reinit(</div><div class="line">    saturation_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  saturation_rhs.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Assemblingmatricesandpreconditioners"></a> </p><h3>Assembling matrices and preconditioners</h3>
<p>The next few functions are devoted to setting up the various system and preconditioner matrices and right hand sides that we have to deal with in this program.</p>
<p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_darcy_preconditioner"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_preconditioner</h4>
<p>This function assembles the matrix we use for preconditioning the Darcy system. What we need are a vector mass matrix weighted by \(\left(\mathbf{K} \lambda_t\right)^{-1}\) on the velocity components and a mass matrix weighted by \(\left(\mathbf{K} \lambda_t\right)\) on the pressure component. We start by generating a quadrature object of appropriate order, the <a class="el" href="classFEValues.html">FEValues</a> object that can give values and gradients at the quadrature points (together with quadrature weights). Next we create data structures for the cell matrix and the relation between local and global DoFs. The vectors phi_u and grad_phi_p are going to hold the values of the basis functions in order to faster build up the local matrices, as was already done in <a class="el" href="step_22.html">step-22</a>. Before we start the loop over all active cells, we have to specify which components are pressure and which are velocity.</p>
<p>The creation of the local matrix is rather simple. There are only a term weighted by \(\left(\mathbf{K} \lambda_t\right)^{-1}\) (on the velocity) and a Laplace matrix weighted by \(\left(\mathbf{K} \lambda_t\right)\) to be generated, so the creation of the local matrix is done in essentially two lines. Since the material model functions at the top of this file only provide the inverses of the permeability and mobility, we have to compute \(\mathbf K\) and \(\lambda_t\) by hand from the given values, once per quadrature point.</p>
<p>Once the local matrix is ready (loop over rows and columns in the local matrix on each quadrature point), we get the local DoF indices and write the local information into the global matrix. We do this by directly applying the constraints (i.e. darcy_preconditioner_constraints) that takes care of hanging node and zero Dirichlet boundary condition constraints. By doing so, we don't have to do that afterwards, and we later don't have to use <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense</a> and <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>, both functions that would need to modify matrix and vector entries and so are difficult to write for the Trilinos classes where we don't immediately have access to individual memory locations.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_preconditioner()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding darcy preconditioner...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  darcy_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(darcy_degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     darcy_fe_values(darcy_fe,</div><div class="line">                                quadrature_formula,</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     saturation_fe_values(saturation_fe,</div><div class="line">                                     quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = darcy_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; phi_u(dofs_per_cell);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">  <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">  <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">    {</div><div class="line">      darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(saturation_cell);</div><div class="line"></div><div class="line">      local_matrix = 0;</div><div class="line"></div><div class="line">      saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                               old_saturation_values);</div><div class="line"></div><div class="line">      k_inverse.value_list(darcy_fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                           k_inverse_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_saturation_values[q];</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> inverse_mobility = mobility_inverse(old_s, viscosity);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> mobility         = 1.0 / inverse_mobility;</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> permeability = <a class="code" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a>(k_inverse_values[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              phi_u[k]      = darcy_fe_values[velocities].value(k, q);</div><div class="line">              grad_phi_p[k] = darcy_fe_values[pressure].gradient(k, q);</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                local_matrix(i, j) +=</div><div class="line">                  (k_inverse_values[q] * inverse_mobility * phi_u[i] *</div><div class="line">                     phi_u[j] +</div><div class="line">                   permeability * mobility * grad_phi_p[i] * grad_phi_p[j]) *</div><div class="line">                  darcy_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      darcy_preconditioner_constraints.distribute_local_to_global(</div><div class="line">        local_matrix, local_dof_indices, darcy_preconditioner_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimbuild_darcy_preconditioner"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::build_darcy_preconditioner</h4>
<p>After calling the above functions to assemble the preconditioner matrix, this function generates the inner preconditioners that are going to be used for the Schur complement block preconditioner. The preconditioners need to be regenerated at every saturation time step since they depend on the saturation \(S\) that varies with time.</p>
<p>In here, we set up the preconditioner for the velocity-velocity matrix \(\mathbf{M}^{\mathbf{u}}\) and the Schur complement \(\mathbf{S}\). As explained in the introduction, we are going to use an IC preconditioner based on the vector matrix \(\mathbf{M}^{\mathbf{u}}\) and another based on the scalar Laplace matrix \(\tilde{\mathbf{S}}^p\) (which is spectrally close to the Schur complement of the Darcy matrix). Usually, the <a class="el" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a> class can be seen as a good black-box preconditioner which does not need any special knowledge of the matrix structure and/or the operator that's behind it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::build_darcy_preconditioner()</div><div class="line">{</div><div class="line">  assemble_darcy_preconditioner();</div><div class="line"></div><div class="line">  Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">  Amg_preconditioner-&gt;initialize(darcy_preconditioner_matrix.block(0, 0));</div><div class="line"></div><div class="line">  Mp_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">  Mp_preconditioner-&gt;initialize(darcy_preconditioner_matrix.block(1, 1));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_darcy_system"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_system</h4>
<p>This is the function that assembles the linear system for the Darcy system.</p>
<p>Regarding the technical details of implementation, the procedures are similar to those in <a class="el" href="step_22.html">step-22</a> and <a class="el" href="step_31.html">step-31</a>. We reset matrix and vector, create a quadrature formula on the cells, and then create the respective <a class="el" href="classFEValues.html">FEValues</a> object.</p>
<p>There is one thing that needs to be commented: since we have a separate finite element and <a class="el" href="classDoFHandler.html">DoFHandler</a> for the saturation, we need to generate a second <a class="el" href="classFEValues.html">FEValues</a> object for the proper evaluation of the saturation solution. This isn't too complicated to realize here: just use the saturation structures and set an update flag for the basis function values which we need for evaluation of the saturation solution. The only important part to remember here is that the same quadrature formula is used for both <a class="el" href="classFEValues.html">FEValues</a> objects to ensure that we get matching information when we loop over the quadrature points of the two objects.</p>
<p>The declarations proceed with some shortcuts for array sizes, the creation of the local matrix, right hand side as well as the vector for the indices of the local dofs compared to the global system.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_system()</div><div class="line">{</div><div class="line">  darcy_matrix = 0;</div><div class="line">  darcy_rhs    = 0;</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(darcy_degree + 2);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(darcy_degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe,</div><div class="line">                                quadrature_formula,</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                     quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> darcy_fe_face_values(darcy_fe,</div><div class="line">                                         face_quadrature_formula,</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = darcy_fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> pressure_right_hand_side;</div><div class="line">  <span class="keyword">const</span> PressureBoundaryValues&lt;dim&gt;  pressure_boundary_values;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;         pressure_rhs_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;         boundary_values(n_face_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div></div><!-- fragment --><p>Next we need a vector that will contain the values of the saturation solution at the previous time level at the quadrature points to assemble the saturation dependent coefficients in the Darcy equations.</p>
<p>The set of vectors we create next hold the evaluations of the basis functions as well as their gradients that will be used for creating the matrices. Putting these into their own arrays rather than asking the <a class="el" href="classFEValues.html">FEValues</a> object for this information each time it is needed is an optimization to accelerate the assembly process, see <a class="el" href="step_22.html">step-22</a> for details.</p>
<p>The last two declarations are used to extract the individual blocks (velocity, pressure, saturation) from the total FE system.</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line"></div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;         div_phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;         phi_p(dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div></div><!-- fragment --><p>Now start the loop over all cells in the problem. We are working on two different DoFHandlers for this assembly routine, so we must have two different cell iterators for the two objects in use. This might seem a bit peculiar, but since both the Darcy system and the saturation system use the same grid we can assume that the two iterators run in sync over the cells of the two <a class="el" href="classDoFHandler.html">DoFHandler</a> objects.</p>
<p>The first statements within the loop are again all very familiar, doing the update of the finite element data as specified by the update flags, zeroing out the local arrays and getting the values of the old solution at the quadrature points. At this point we also have to get the values of the saturation function of the previous time step at the quadrature points. To this end, we can use the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues::get_function_values</a> (previously already used in <a class="el" href="step_9.html">step-9</a>, <a class="el" href="step_14.html">step-14</a> and <a class="el" href="step_15.html">step-15</a>), a function that takes a solution vector and returns a list of function values at the quadrature points of the present cell. In fact, it returns the complete vector-valued solution at each quadrature point, i.e. not only the saturation but also the velocities and pressure.</p>
<p>Then we are ready to loop over the quadrature points on the cell to do the integration. The formula for this follows in a straightforward way from what has been discussed in the introduction.</p>
<p>Once this is done, we start the loop over the rows and columns of the local matrix and feed the matrix with the relevant products.</p>
<p>The last step in the loop over all cells is to enter the local contributions into the global matrix and vector structures to the positions specified in local_dof_indices. Again, we let the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class do the insertion of the cell matrix elements to the global matrix, which already condenses the hanging node constraints.</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">  <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">    {</div><div class="line">      darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(saturation_cell);</div><div class="line"></div><div class="line">      local_matrix = 0;</div><div class="line">      local_rhs    = 0;</div><div class="line"></div><div class="line">      saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                               old_saturation_values);</div><div class="line"></div><div class="line">      pressure_right_hand_side.<a class="code" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">value_list</a>(</div><div class="line">        darcy_fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), pressure_rhs_values);</div><div class="line">      k_inverse.value_list(darcy_fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                           k_inverse_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              phi_u[k]     = darcy_fe_values[velocities].value(k, q);</div><div class="line">              div_phi_u[k] = darcy_fe_values[velocities].divergence(k, q);</div><div class="line">              phi_p[k]     = darcy_fe_values[pressure].value(k, q);</div><div class="line">            }</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_saturation_values[q];</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j)</div><div class="line">                {</div><div class="line">                  local_matrix(i, j) +=</div><div class="line">                    (phi_u[i] * k_inverse_values[q] *</div><div class="line">                       mobility_inverse(old_s, viscosity) * phi_u[j] -</div><div class="line">                     div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div><div class="line">                    darcy_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                }</div><div class="line"></div><div class="line">              local_rhs(i) +=</div><div class="line">                (-phi_p[i] * pressure_rhs_values[q]) * darcy_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">          {</div><div class="line">            darcy_fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line"></div><div class="line">            pressure_boundary_values.value_list(</div><div class="line">              darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), boundary_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u =</div><div class="line">                    darcy_fe_face_values[velocities].value(i, q);</div><div class="line"></div><div class="line">                  local_rhs(i) +=</div><div class="line">                    -(phi_i_u * darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q) *</div><div class="line">                      boundary_values[q] * darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                }</div><div class="line">          }</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div><div class="line">          local_matrix(i, j) = local_matrix(j, i);</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      darcy_constraints.distribute_local_to_global(</div><div class="line">        local_matrix, local_rhs, local_dof_indices, darcy_matrix, darcy_rhs);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_saturation_system"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_system</h4>
<p>This function is to assemble the linear system for the saturation transport equation. It calls, if necessary, two other member functions: assemble_saturation_matrix() and assemble_saturation_rhs(). The former function then assembles the saturation matrix that only needs to be changed occasionally. On the other hand, the latter function that assembles the right hand side must be called at every saturation time step.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_system()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_saturation_matrix == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      saturation_matrix = 0;</div><div class="line">      assemble_saturation_matrix();</div><div class="line">    }</div><div class="line"></div><div class="line">  saturation_rhs = 0;</div><div class="line">  assemble_saturation_rhs();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_saturation_matrix"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_matrix</h4>
<p>This function is easily understood since it only forms a simple mass matrix for the left hand side of the saturation linear system by basis functions phi_i_s and phi_j_s only. Finally, as usual, we enter the local contribution into the global matrix by specifying the position in local_dof_indices. This is done by letting the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class do the insertion of the cell matrix elements to the global matrix, which already condenses the hanging node constraints.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_matrix()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(saturation_degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                     quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      local_matrix = 0;</div><div class="line">      local_rhs    = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_s = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q);</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_s = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q);</div><div class="line">                local_matrix(i, j) +=</div><div class="line">                  porosity * phi_i_s * phi_j_s * saturation_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      saturation_constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                                        local_dof_indices,</div><div class="line">                                                        saturation_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_saturation_rhs"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs</h4>
<p>This function is to assemble the right hand side of the saturation transport equation. Before going about it, we have to create two <a class="el" href="classFEValues.html">FEValues</a> objects for the Darcy and saturation systems respectively and, in addition, two <a class="el" href="classFEFaceValues.html">FEFaceValues</a> objects for the two systems because we have a boundary integral term in the weak form of saturation equation. For the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object of the saturation system, we also require normal vectors, which we request using the update_normal_vectors flag.</p>
<p>Next, before looping over all the cells, we have to compute some parameters (e.g. global_u_infty, global_S_variation, and global_Omega_diameter) that the artificial viscosity \(\nu\) needs. This is largely the same as was done in <a class="el" href="step_31.html">step-31</a>, so you may see there for more information.</p>
<p>The real works starts with the loop over all the saturation and Darcy cells to put the local contributions into the global vector. In this loop, in order to simplify the implementation, we split some of the work into two helper functions: assemble_saturation_rhs_cell_term and assemble_saturation_rhs_boundary_term. We note that we insert cell or boundary contributions into the global vector in the two functions rather than in this present function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(saturation_degree + 2);</div><div class="line">  <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(saturation_degree + 2);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                     quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> saturation_fe_face_values(saturation_fe,</div><div class="line">                                              face_quadrature_formula,</div><div class="line">                                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> darcy_fe_face_values(darcy_fe,</div><div class="line">                                         face_quadrature_formula,</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> saturation_fe_face_values_neighbor(</div><div class="line">    saturation_fe, face_quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">    saturation_dof_handler.get_fe().n_dofs_per_cell();</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_max_u_F_prime = get_max_u_F_prime();</div><div class="line">  <span class="keyword">const</span> std::pair&lt;double, double&gt; global_S_range =</div><div class="line">    get_extrapolated_saturation_range();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> global_S_variation =</div><div class="line">    global_S_range.second - global_S_range.first;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span>       cell       = saturation_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> endc       = saturation_dof_handler.end();</div><div class="line">  <span class="keyword">auto</span>       darcy_cell = darcy_dof_handler.begin_active();</div><div class="line">  <span class="keywordflow">for</span> (; cell != endc; ++cell, ++darcy_cell)</div><div class="line">    {</div><div class="line">      saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(darcy_cell);</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      assemble_saturation_rhs_cell_term(saturation_fe_values,</div><div class="line">                                        darcy_fe_values,</div><div class="line">                                        global_max_u_F_prime,</div><div class="line">                                        global_S_variation,</div><div class="line">                                        local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">        <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">          {</div><div class="line">            darcy_fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(darcy_cell, face);</div><div class="line">            saturation_fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">            assemble_saturation_rhs_boundary_term(saturation_fe_face_values,</div><div class="line">                                                  darcy_fe_face_values,</div><div class="line">                                                  local_dof_indices);</div><div class="line">          }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_saturation_rhs_cell_term"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_cell_term</h4>
<p>This function takes care of integrating the cell terms of the right hand side of the saturation equation, and then assembling it into the global right hand side vector. Given the discussion in the introduction, the form of these contributions is clear. The only tricky part is getting the artificial viscosity and all that is necessary to compute it. The first half of the function is devoted to this task.</p>
<p>The last part of the function is copying the local contributions into the global vector with position specified in local_dof_indices.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_cell_term(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       saturation_fe_values,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       darcy_fe_values,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_max_u_F_prime,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_S_variation,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;         old_saturation_solution_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt;         old_old_saturation_solution_values(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_grad_saturation_solution_values(n_q_points);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_grad_saturation_solution_values(</div><div class="line">    n_q_points);</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; present_darcy_solution_values(</div><div class="line">    n_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div><div class="line"></div><div class="line">  saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                           old_saturation_solution_values);</div><div class="line">  saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">    old_old_saturation_solution, old_old_saturation_solution_values);</div><div class="line">  saturation_fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(</div><div class="line">    old_saturation_solution, old_grad_saturation_solution_values);</div><div class="line">  saturation_fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(</div><div class="line">    old_old_saturation_solution, old_old_grad_saturation_solution_values);</div><div class="line">  darcy_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(darcy_solution,</div><div class="line">                                      present_darcy_solution_values);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div><div class="line">    compute_viscosity(old_saturation_solution_values,</div><div class="line">                      old_old_saturation_solution_values,</div><div class="line">                      old_grad_saturation_solution_values,</div><div class="line">                      old_old_grad_saturation_solution_values,</div><div class="line">                      present_darcy_solution_values,</div><div class="line">                      global_max_u_F_prime,</div><div class="line">                      global_S_variation,</div><div class="line">                      saturation_fe_values.<a class="code" href="classFEValuesBase.html#a9d3a1c53c139e2553b672de682d6233e">get_cell</a>()-&gt;diameter());</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>   old_s = old_saturation_solution_values[q];</div><div class="line">        <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          present_u[d] = present_darcy_solution_values[q](d);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_i_s = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q);</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_i_s =</div><div class="line">          saturation_fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q);</div><div class="line"></div><div class="line">        local_rhs(i) +=</div><div class="line">          (time_step * fractional_flow(old_s, viscosity) * present_u *</div><div class="line">             grad_phi_i_s -</div><div class="line">           time_step * nu * old_grad_saturation_solution_values[q] *</div><div class="line">             grad_phi_i_s +</div><div class="line">           porosity * old_s * phi_i_s) *</div><div class="line">          saturation_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">      }</div><div class="line"></div><div class="line">  saturation_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                    local_dof_indices,</div><div class="line">                                                    saturation_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimassemble_saturation_rhs_boundary_term"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_boundary_term</h4>
<p>The next function is responsible for the boundary integral terms in the right hand side form of the saturation equation. For these, we have to compute the upwinding flux on the global boundary faces, i.e. we impose Dirichlet boundary conditions weakly only on inflow parts of the global boundary. As before, this has been described in <a class="el" href="step_21.html">step-21</a> so we refrain from giving more descriptions about that.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_boundary_term(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   saturation_fe_face_values,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   darcy_fe_face_values,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points =</div><div class="line">    saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; old_saturation_solution_values_face(n_face_q_points);</div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; present_darcy_solution_values_face(</div><div class="line">    n_face_q_points, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div><div class="line">  std::vector&lt;double&gt; neighbor_saturation(n_face_q_points);</div><div class="line"></div><div class="line">  saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">    old_saturation_solution, old_saturation_solution_values_face);</div><div class="line">  darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">    darcy_solution, present_darcy_solution_values_face);</div><div class="line"></div><div class="line">  SaturationBoundaryValues&lt;dim&gt; saturation_boundary_values;</div><div class="line">  saturation_boundary_values.value_list(</div><div class="line">    saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), neighbor_saturation);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">    {</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u_face;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        present_u_face[d] = present_darcy_solution_values_face[q](d);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> normal_flux =</div><div class="line">        present_u_face * saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span> is_outflow_q_point = (normal_flux &gt;= 0);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        local_rhs(i) -=</div><div class="line">          time_step * normal_flux *</div><div class="line">          fractional_flow((is_outflow_q_point == <span class="keyword">true</span> ?</div><div class="line">                             old_saturation_solution_values_face[q] :</div><div class="line">                             neighbor_saturation[q]),</div><div class="line">                          viscosity) *</div><div class="line">          saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q) *</div><div class="line">          saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">    }</div><div class="line">  saturation_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                    local_dof_indices,</div><div class="line">                                                    saturation_rhs);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimsolve"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::solve</h3>
<p>This function implements the operator splitting algorithm, i.e. in each time step it either re-computes the solution of the Darcy system or extrapolates velocity/pressure from previous time steps, then determines the size of the time step, and then updates the saturation variable. The implementation largely follows similar code in <a class="el" href="step_31.html">step-31</a>. It is, next to the <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function, the central one in this program.</p>
<p>At the beginning of the function, we ask whether to solve the pressure-velocity part by evaluating the a posteriori criterion (see the following function). If necessary, we will solve the pressure-velocity part using the GMRES solver with the Schur complement block preconditioner as is described in the introduction.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> solve_for_pressure_and_velocity =</div><div class="line">    determine_whether_to_solve_for_pressure_and_velocity();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (solve_for_pressure_and_velocity == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving Darcy (pressure-velocity) system...&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      assemble_darcy_system();</div><div class="line">      build_darcy_preconditioner();</div><div class="line"></div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> LinearSolvers::InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                           TrilinosWrappers::PreconditionIC&gt;</div><div class="line">          mp_inverse(darcy_preconditioner_matrix.block(1, 1),</div><div class="line">                     *Mp_preconditioner);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">          <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#abee1d4aa6f0af5290aa7d51806bde982">TrilinosWrappers::PreconditionIC</a>,</div><div class="line">          TrilinosWrappers::PreconditionIC&gt;</div><div class="line">          preconditioner(darcy_matrix, mp_inverse, *Amg_preconditioner);</div><div class="line"></div><div class="line">        <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(darcy_matrix.m(),</div><div class="line">                                     1e-16 * darcy_rhs.l2_norm());</div><div class="line"></div><div class="line">        <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> gmres(</div><div class="line">          solver_control,</div><div class="line">          <a class="code" href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(</div><div class="line">            100));</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; darcy_solution.size(); ++i)</div><div class="line">          <span class="keywordflow">if</span> (darcy_constraints.is_constrained(i))</div><div class="line">            darcy_solution(i) = 0;</div><div class="line"></div><div class="line">        gmres.solve(darcy_matrix, darcy_solution, darcy_rhs, preconditioner);</div><div class="line"></div><div class="line">        darcy_constraints.distribute(darcy_solution);</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;        ...&quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot; GMRES iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line"></div><div class="line">      {</div><div class="line">        second_last_computed_darcy_solution = last_computed_darcy_solution;</div><div class="line">        last_computed_darcy_solution        = darcy_solution;</div><div class="line"></div><div class="line">        saturation_matching_last_computed_darcy_solution =</div><div class="line">          saturation_solution;</div><div class="line">      }</div><div class="line">    }</div></div><!-- fragment --><p>On the other hand, if we have decided that we don't want to compute the solution of the Darcy system for the current time step, then we need to simply extrapolate the previous two Darcy solutions to the same time as we would have computed the velocity/pressure at. We do a simple linear extrapolation, i.e. given the current length \(dt\) of the macro time step from the time when we last computed the Darcy solution to now (given by <code>current_macro_time_step</code>), and \(DT\) the length of the last macro time step (given by <code>old_macro_time_step</code>), then we get \(u^\ast = u_p + dt \frac{u_p-u_{pp}}{DT} = (1+dt/DT)u_p - dt/DT u_{pp}\), where \(u_p\) and \(u_{pp}\) are the last two computed Darcy solutions. We can implement this formula using just two lines of code.</p>
<p>Note that the algorithm here only works if we have at least two previously computed Darcy solutions from which we can extrapolate to the current time, and this is ensured by requiring re-computation of the Darcy solution for the first 2 time steps.</p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    darcy_solution = last_computed_darcy_solution;</div><div class="line">    darcy_solution.sadd(1 + current_macro_time_step / old_macro_time_step,</div><div class="line">                        -current_macro_time_step / old_macro_time_step,</div><div class="line">                        second_last_computed_darcy_solution);</div><div class="line">  }</div></div><!-- fragment --><p>With the so computed velocity vector, compute the optimal time step based on the CFL criterion discussed in the introduction...</p>
<div class="fragment"><div class="line">{</div><div class="line">  old_time_step = time_step;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> max_u_F_prime = get_max_u_F_prime();</div><div class="line">  <span class="keywordflow">if</span> (max_u_F_prime &gt; 0)</div><div class="line">    time_step = porosity * <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) /</div><div class="line">                saturation_degree / max_u_F_prime / 50;</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    time_step = end_time - time;</div><div class="line">}</div></div><!-- fragment --><p>...and then also update the length of the macro time steps we use while we're dealing with time step sizes. In particular, this involves: (i) If we have just recomputed the Darcy solution, then the length of the previous macro time step is now fixed and the length of the current macro time step is, up to now, simply the length of the current (micro) time step. (ii) If we have not recomputed the Darcy solution, then the length of the current macro time step has just grown by <code>time_step</code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (solve_for_pressure_and_velocity == <span class="keyword">true</span>)</div><div class="line">  {</div><div class="line">    old_macro_time_step     = current_macro_time_step;</div><div class="line">    current_macro_time_step = time_step;</div><div class="line">  }</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  current_macro_time_step += time_step;</div></div><!-- fragment --><p>The last step in this function is to recompute the saturation solution based on the velocity field we've just obtained. This naturally happens in every time step, and we don't skip any of these computations. At the end of computing the saturation, we project back into the allowed interval \([0,1]\) to make sure our solution remains physical.</p>
<div class="fragment"><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving saturation transport equation...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    assemble_saturation_system();</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(saturation_matrix.m(),</div><div class="line">                                 1e-16 * saturation_rhs.l2_norm());</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">    TrilinosWrappers::PreconditionIC preconditioner;</div><div class="line">    preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html#a95eff1f8abcf2ba67815b6a96a66d375">initialize</a>(saturation_matrix);</div><div class="line"></div><div class="line">    cg.solve(saturation_matrix,</div><div class="line">             saturation_solution,</div><div class="line">             saturation_rhs,</div><div class="line">             preconditioner);</div><div class="line"></div><div class="line">    saturation_constraints.distribute(saturation_solution);</div><div class="line">    project_back_saturation();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;        ...&quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimrefine_mesh"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::refine_mesh</h3>
<p>The next function does the refinement and coarsening of the mesh. It does its work in three blocks: (i) Compute refinement indicators by looking at the gradient of a solution vector extrapolated linearly from the previous two using the respective sizes of the time step (or taking the only solution we have if this is the first time step). (ii) Flagging those cells for refinement and coarsening where the gradient is larger or smaller than a certain threshold, preserving minimal and maximal levels of mesh refinement. (iii) Transferring the solution from the old to the new mesh. None of this is particularly difficult.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_grid_level,</div><div class="line">                                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> refinement_indicators(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQMidpoint.html">QMidpoint&lt;dim&gt;</a>        quadrature_formula;</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               fe_values(saturation_fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_saturation(1);</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> extrapolated_saturation_solution(</div><div class="line">      saturation_solution);</div><div class="line">    <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">      extrapolated_saturation_solution.sadd((1. + time_step / old_time_step),</div><div class="line">                                            time_step / old_time_step,</div><div class="line">                                            old_saturation_solution);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = cell-&gt;active_cell_index();</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(extrapolated_saturation_solution,</div><div class="line">                                         grad_saturation);</div><div class="line"></div><div class="line">        refinement_indicators(cell_no) = grad_saturation[0].norm();</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = cell-&gt;active_cell_index();</div><div class="line">        cell-&gt;clear_coarsen_flag();</div><div class="line">        cell-&gt;clear_refine_flag();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((static_cast&lt;unsigned int&gt;(cell-&gt;level()) &lt; max_grid_level) &amp;&amp;</div><div class="line">            (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(refinement_indicators(cell_no)) &gt;</div><div class="line">             saturation_refinement_threshold))</div><div class="line">          cell-&gt;set_refine_flag();</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((static_cast&lt;unsigned int&gt;(cell-&gt;level()) &gt;</div><div class="line">                  min_grid_level) &amp;&amp;</div><div class="line">                 (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(refinement_indicators(cell_no)) &lt;</div><div class="line">                  0.5 * saturation_refinement_threshold))</div><div class="line">          cell-&gt;set_coarsen_flag();</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">  {</div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::Vector&gt; x_saturation(3);</div><div class="line">    x_saturation[0] = saturation_solution;</div><div class="line">    x_saturation[1] = old_saturation_solution;</div><div class="line">    x_saturation[2] = saturation_matching_last_computed_darcy_solution;</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::BlockVector&gt; x_darcy(2);</div><div class="line">    x_darcy[0] = last_computed_darcy_solution;</div><div class="line">    x_darcy[1] = second_last_computed_darcy_solution;</div><div class="line"></div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a> saturation_soltrans(</div><div class="line">      saturation_dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::BlockVector&gt;</a> darcy_soltrans(</div><div class="line">      darcy_dof_handler);</div><div class="line"></div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">    saturation_soltrans.prepare_for_coarsening_and_refinement(x_saturation);</div><div class="line"></div><div class="line">    darcy_soltrans.prepare_for_coarsening_and_refinement(x_darcy);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::Vector&gt; tmp_saturation(3);</div><div class="line">    tmp_saturation[0].reinit(saturation_solution);</div><div class="line">    tmp_saturation[1].reinit(saturation_solution);</div><div class="line">    tmp_saturation[2].reinit(saturation_solution);</div><div class="line">    saturation_soltrans.interpolate(x_saturation, tmp_saturation);</div><div class="line"></div><div class="line">    saturation_solution                              = tmp_saturation[0];</div><div class="line">    old_saturation_solution                          = tmp_saturation[1];</div><div class="line">    saturation_matching_last_computed_darcy_solution = tmp_saturation[2];</div><div class="line"></div><div class="line">    saturation_constraints.distribute(saturation_solution);</div><div class="line">    saturation_constraints.distribute(old_saturation_solution);</div><div class="line">    saturation_constraints.distribute(</div><div class="line">      saturation_matching_last_computed_darcy_solution);</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::BlockVector&gt; tmp_darcy(2);</div><div class="line">    tmp_darcy[0].reinit(darcy_solution);</div><div class="line">    tmp_darcy[1].reinit(darcy_solution);</div><div class="line">    darcy_soltrans.interpolate(x_darcy, tmp_darcy);</div><div class="line"></div><div class="line">    last_computed_darcy_solution        = tmp_darcy[0];</div><div class="line">    second_last_computed_darcy_solution = tmp_darcy[1];</div><div class="line"></div><div class="line">    darcy_constraints.distribute(last_computed_darcy_solution);</div><div class="line">    darcy_constraints.distribute(second_last_computed_darcy_solution);</div><div class="line"></div><div class="line">    rebuild_saturation_matrix = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimoutput_results"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::output_results</h3>
<p>This function generates graphical output. It is in essence a copy of the implementation in <a class="el" href="step_31.html">step-31</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> joint_fe(darcy_fe, 1, saturation_fe, 1);</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>     joint_dof_handler(triangulation);</div><div class="line">  joint_dof_handler.distribute_dofs(joint_fe);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_dof_handler.n_dofs() ==</div><div class="line">           darcy_dof_handler.n_dofs() + saturation_dof_handler.n_dofs(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> joint_solution(joint_dof_handler.n_dofs());</div><div class="line"></div><div class="line">  {</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_joint_dof_indices(</div><div class="line">      joint_fe.n_dofs_per_cell());</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_darcy_dof_indices(</div><div class="line">      darcy_fe.n_dofs_per_cell());</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_saturation_dof_indices(</div><div class="line">      saturation_fe.n_dofs_per_cell());</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       joint_cell      = joint_dof_handler.begin_active();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> joint_endc      = joint_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       darcy_cell      = darcy_dof_handler.begin_active();</div><div class="line">    <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; joint_cell != joint_endc;</div><div class="line">         ++joint_cell, ++darcy_cell, ++saturation_cell)</div><div class="line">      {</div><div class="line">        joint_cell-&gt;get_dof_indices(local_joint_dof_indices);</div><div class="line">        darcy_cell-&gt;get_dof_indices(local_darcy_dof_indices);</div><div class="line">        saturation_cell-&gt;get_dof_indices(local_saturation_dof_indices);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; joint_fe.n_dofs_per_cell(); ++i)</div><div class="line">          <span class="keywordflow">if</span> (joint_fe.system_to_base_index(i).first.first == 0)</div><div class="line">            {</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                       local_darcy_dof_indices.size(),</div><div class="line">                     <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">              joint_solution(local_joint_dof_indices[i]) = darcy_solution(</div><div class="line">                local_darcy_dof_indices[joint_fe.system_to_base_index(i)</div><div class="line">                                          .second]);</div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).first.first == 1,</div><div class="line">                     <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">              <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                       local_darcy_dof_indices.size(),</div><div class="line">                     <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">              joint_solution(local_joint_dof_indices[i]) =</div><div class="line">                saturation_solution(</div><div class="line">                  local_saturation_dof_indices</div><div class="line">                    [joint_fe.system_to_base_index(i).second]);</div><div class="line">            }</div><div class="line">      }</div><div class="line">  }</div><div class="line">  std::vector&lt;std::string&gt; joint_solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  joint_solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">  joint_solution_names.emplace_back(<span class="stringliteral">&quot;saturation&quot;</span>);</div><div class="line"></div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    data_component_interpretation(</div><div class="line">      dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  data_component_interpretation.push_back(</div><div class="line">    <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(joint_dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(joint_solution,</div><div class="line">                           joint_solution_names,</div><div class="line">                           <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                           data_component_interpretation);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 5) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Toolfunctions"></a> </p><h3>Tool functions</h3>
<p><a class="anchor" id="TwoPhaseFlowProblemdimdetermine_whether_to_solve_for_pressure_and_velocity"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::determine_whether_to_solve_for_pressure_and_velocity</h4>
<p>This function implements the a posteriori criterion for adaptive operator splitting. The function is relatively straightforward given the way we have implemented other functions above and given the formula for the criterion derived in the paper.</p>
<p>If one decides that one wants the original IMPES method in which the Darcy equation is solved in every time step, then this can be achieved by setting the threshold value <code>AOS_threshold</code> (with a default of \(5.0\)) to zero, thereby forcing the function to always return true.</p>
<p>Finally, note that the function returns true unconditionally for the first two time steps to ensure that we have always solved the Darcy system at least twice when skipping its solution, thereby allowing us to extrapolate the velocity from the last two solutions in <code>solve()</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">bool</span> TwoPhaseFlowProblem&lt;</div><div class="line">  dim&gt;::determine_whether_to_solve_for_pressure_and_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (timestep_number &lt;= 2)</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(saturation_degree + 2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(saturation_fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; old_saturation_after_solving_pressure(n_q_points);</div><div class="line">  std::vector&lt;double&gt; present_saturation(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_global_aop_indicator = 0.0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> max_local_mobility_reciprocal_difference = 0.0;</div><div class="line">      <span class="keywordtype">double</span> max_local_permeability_inverse_l1_norm   = 0.0;</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">        saturation_matching_last_computed_darcy_solution,</div><div class="line">        old_saturation_after_solving_pressure);</div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(saturation_solution, present_saturation);</div><div class="line"></div><div class="line">      k_inverse.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                           k_inverse_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> mobility_reciprocal_difference = <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(</div><div class="line">            mobility_inverse(present_saturation[q], viscosity) -</div><div class="line">            mobility_inverse(old_saturation_after_solving_pressure[q],</div><div class="line">                             viscosity));</div><div class="line"></div><div class="line">          max_local_mobility_reciprocal_difference =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_mobility_reciprocal_difference,</div><div class="line">                     mobility_reciprocal_difference);</div><div class="line"></div><div class="line">          max_local_permeability_inverse_l1_norm =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_permeability_inverse_l1_norm,</div><div class="line">                     <a class="code" href="classTensor.html#a93ba01d979880b278cd4b573dd9c653b">l1_norm</a>(k_inverse_values[q]));</div><div class="line">        }</div><div class="line"></div><div class="line">      max_global_aop_indicator =</div><div class="line">        <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_global_aop_indicator,</div><div class="line">                 (max_local_mobility_reciprocal_difference *</div><div class="line">                  max_local_permeability_inverse_l1_norm));</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (max_global_aop_indicator &gt; AOS_threshold);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimproject_back_saturation"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::project_back_saturation</h4>
<p>The next function simply makes sure that the saturation values always remain within the physically reasonable range of \([0,1]\). While the continuous equations guarantee that this is so, the discrete equations don't. However, if we allow the discrete solution to escape this range we get into trouble because terms like \(F(S)\) and \(F&#39;(S)\) will produce unreasonable results (e.g. \(F&#39;(S)&lt;0\) for \(S&lt;0\), which would imply that the wetting fluid phase flows <em>against</em> the direction of the bulk fluid velocity)). Consequently, at the end of each time step, we simply project the saturation field back into the physically reasonable region.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::project_back_saturation()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; saturation_solution.size(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (saturation_solution(i) &lt; 0.2)</div><div class="line">      saturation_solution(i) = 0.2;</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (saturation_solution(i) &gt; 1)</div><div class="line">      saturation_solution(i) = 1;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimget_max_u_F_prime"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::get_max_u_F_prime</h4>
<p>Another simpler helper function: Compute the maximum of the total velocity times the derivative of the fraction flow function, i.e., compute \(\|\mathbf{u} F&#39;(S)\|_{L_\infty(\Omega)}\). This term is used in both the computation of the time step as well as in normalizing the entropy-residual term in the artificial viscosity.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::get_max_u_F_prime()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(darcy_degree + 2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                     quadrature_formula,</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  std::vector&lt;Vector&lt;double&gt;&gt; darcy_solution_values(n_q_points,</div><div class="line">                                                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a>(dim + 1));</div><div class="line">  std::vector&lt;double&gt;         saturation_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_velocity_times_dF_dS = 0;</div><div class="line"></div><div class="line">  <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">  <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line">  <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">    {</div><div class="line">      darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(saturation_cell);</div><div class="line"></div><div class="line">      darcy_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(darcy_solution,</div><div class="line">                                          darcy_solution_values);</div><div class="line">      saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                               saturation_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">            velocity[i] = darcy_solution_values[q](i);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> dF_dS =</div><div class="line">            fractional_flow_derivative(saturation_values[q], viscosity);</div><div class="line"></div><div class="line">          max_velocity_times_dF_dS =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity_times_dF_dS, velocity.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() * dF_dS);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> max_velocity_times_dF_dS;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimget_extrapolated_saturation_range"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::get_extrapolated_saturation_range</h4>
<p>For computing the stabilization term, we need to know the range of the saturation variable. Unlike in <a class="el" href="step_31.html">step-31</a>, this range is trivially bounded by the interval \([0,1]\) but we can do a bit better by looping over a collection of quadrature points and seeing what the values are there. If we can, i.e., if there are at least two timesteps around, we can even take the values extrapolated to the next time step.</p>
<p>As before, the function is taken with minimal modifications from <a class="el" href="step_31.html">step-31</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;double, double&gt;</div><div class="line">TwoPhaseFlowProblem&lt;dim&gt;::get_extrapolated_saturation_range()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(saturation_degree + 2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(saturation_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_old_saturation_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">             max_saturation = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                        old_saturation_values);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_saturation_solution,</div><div class="line">                                        old_old_saturation_values);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> saturation =</div><div class="line">                (1. + time_step / old_time_step) * old_saturation_values[q] -</div><div class="line">                time_step / old_time_step * old_old_saturation_values[q];</div><div class="line"></div><div class="line">              min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_saturation, saturation);</div><div class="line">              max_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_saturation, saturation);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> std::make_pair(min_saturation, max_saturation);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">             max_saturation = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                        old_saturation_values);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> saturation = old_saturation_values[q];</div><div class="line"></div><div class="line">              min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_saturation, saturation);</div><div class="line">              max_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_saturation, saturation);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> std::make_pair(min_saturation, max_saturation);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimcompute_viscosity"></a> </p><h4>TwoPhaseFlowProblem&lt;dim&gt;::compute_viscosity</h4>
<p>The final tool function is used to compute the artificial viscosity on a given cell. This isn't particularly complicated if you have the formula for it in front of you, and looking at the implementation in <a class="el" href="step_31.html">step-31</a>. The major difference to that tutorial program is that the velocity here is not simply \(\mathbf u\) but \(\mathbf u F&#39;(S)\) and some of the formulas need to be adjusted accordingly.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::compute_viscosity(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_saturation,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_saturation,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_saturation_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_saturation_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt; &amp;present_darcy_values,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_max_u_F_prime,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_S_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> beta  = .4 * dim;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = 1;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (global_max_u_F_prime == 0)</div><div class="line">    <span class="keywordflow">return</span> 5e-3 * cell_diameter;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_saturation.size();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_residual             = 0;</div><div class="line">  <span class="keywordtype">double</span> max_velocity_times_dF_dS = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> use_dF_dS = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u;</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        u[d] = present_darcy_values[q](d);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> dS_dt = porosity *</div><div class="line">                           (old_saturation[q] - old_old_saturation[q]) /</div><div class="line">                           old_time_step;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> dF_dS = fractional_flow_derivative(</div><div class="line">        (old_saturation[q] + old_old_saturation[q]) / 2.0, viscosity);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_S =</div><div class="line">        u * dF_dS * (old_saturation_grads[q] + old_old_saturation_grads[q]) /</div><div class="line">        2.0;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> residual =</div><div class="line">        <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>((dS_dt + u_grad_S) *</div><div class="line">                 std::pow((old_saturation[q] + old_old_saturation[q]) / 2,</div><div class="line">                          alpha - 1.));</div><div class="line"></div><div class="line">      max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div><div class="line">      max_velocity_times_dF_dS =</div><div class="line">        <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u * u) * (use_dF_dS ? <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(dF_dS, 1.) : 1),</div><div class="line">                 max_velocity_times_dF_dS);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> c_R            = 1.0;</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> global_scaling = c_R * porosity *</div><div class="line">                                (global_max_u_F_prime)*global_S_variation /</div><div class="line">                                std::pow(global_Omega_diameter, alpha - 2.);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (beta *</div><div class="line">          (max_velocity_times_dF_dS)*<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(cell_diameter,</div><div class="line">                                              std::pow(cell_diameter, alpha) *</div><div class="line">                                                max_residual /</div><div class="line">                                                global_scaling));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TwoPhaseFlowProblemdimrun"></a> </p><h3>TwoPhaseFlowProblem&lt;dim&gt;::run</h3>
<p>This function is, besides <code>solve()</code>, the primary function of this program as it controls the time iteration as well as when the solution is written into output files and when to do mesh refinement.</p>
<p>With the exception of the startup code that loops back to the beginning of the function through the <code>goto start_time_iteration</code> label, everything should be relatively straightforward. In any case, it mimics the corresponding function in <a class="el" href="step_31.html">step-31</a>.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TwoPhaseFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement     = (dim == 2 ? 5 : 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_pre_refinement_steps = (dim == 2 ? 3 : 2);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(initial_refinement);</div><div class="line">    global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(triangulation);</div><div class="line"></div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"></div><div class="line">  start_time_iteration:</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(saturation_dof_handler,</div><div class="line">                         saturation_constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(saturation_degree + 2),</div><div class="line">                         SaturationInitialValues&lt;dim&gt;(),</div><div class="line">                         old_saturation_solution);</div><div class="line"></div><div class="line">    time_step = old_time_step = 0;</div><div class="line">    current_macro_time_step = old_macro_time_step = 0;</div><div class="line"></div><div class="line">    time = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, dt=&quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (timestep_number % 200 == 0)</div><div class="line">          output_results();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (timestep_number % 25 == 0)</div><div class="line">          refine_mesh(initial_refinement,</div><div class="line">                      initial_refinement + n_pre_refinement_steps);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">            (pre_refinement_step &lt; n_pre_refinement_steps))</div><div class="line">          {</div><div class="line">            ++pre_refinement_step;</div><div class="line">            <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">          }</div><div class="line"></div><div class="line">        time += time_step;</div><div class="line">        ++timestep_number;</div><div class="line"></div><div class="line">        old_old_saturation_solution = old_saturation_solution;</div><div class="line">        old_saturation_solution     = saturation_solution;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (time &lt;= end_time);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step43</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main()</code> function</h3>
<p>The main function looks almost the same as in all other programs. The need to initialize the MPI subsystem for a program that uses Trilinos &ndash; even for programs that do not actually run in parallel &ndash; is explained in <a class="el" href="step_31.html">step-31</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step43;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div></div><!-- fragment --><p>This program can only be run in serial. Otherwise, throw an exception.</p>
<div class="fragment"><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-43&quot;</span>));</div><div class="line"></div><div class="line">      TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(1);</div><div class="line">      two_phase_flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-43/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>这个程序的输出与第21步的输出其实没有什么不同：毕竟它解决的是同一个问题。更重要的是定量指标，如解决方案的准确性以及计算所需的时间。这些在本页顶部列出的两份出版物中都有详细记载，我们在此不再重复。</p>
<p>也就是说，如果没有几张好的照片，任何教程程序都是不完整的，所以这里有一些三维运行的输出。</p>
<table align="center" class="tutorial" cellspacing="3" cellpadding="3">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-43.3d.velocity.png"/>
</div>
 <p>Velocity vectors of flow through the porous medium with random permeability model. Streaming paths of high permeability and resulting high velocity are clearly visible. </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-43.3d.streamlines.png"/>
</div>
 <p>Streamlines colored by the saturation along the streamline path. Blue streamlines indicate low saturations, i.e., the flow along these streamlines must be slow or else more fluid would have been transported along them. On the other hand, green paths indicate high velocities since the fluid front has already reached further into the domain. </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-43.3d.saturation.png"/>
</div>
 <p>Streamlines with a volume rendering of the saturation, showing how far the fluid front has advanced at this time. </p>
<p class="endtd"></p>
</td><td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-43.3d.mesh.png"/>
</div>
 <p>Surface of the mesh showing the adaptive refinement along the front. </p>
<p class="endtd"></p>
</td></tr>
</table>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>人们对这个程序的主要反对意见是它仍然太慢了：在合理的细网格上的三维计算实在是太昂贵了，无法以合理的快速周转来进行常规计算。这与我们写<a class="el" href="step_31.html">step-31</a>时的情况相似，这个程序从它那里得到了很多灵感。解决办法也是类似的，因为它也在那里。我们需要以类似于从第31步衍生出第32步的方式来并行化这个程序。事实上，步骤32中使用的所有技术也可以转移到这个程序中，使程序立即在几十或几百个处理器上运行。</p>
<p>一个不同的方向是使该程序与许多其他多孔介质的应用更加相关。具体来说，一个途径是去找多孔介质流动模拟器的主要用户，即石油工业。在那里，该领域的应用以多相流（即超过我们这里的两相）为主，以及它们之间可能发生的反应（或任何其他相的质量交换方式，如通过溶解和从油相中冒出的气体）。此外，气体的存在往往会导致流体的可压缩性效应。这些效应通常共同组成了广泛使用的 "黑油模型"。在考虑储层中石油的控制性燃烧以提高压力和温度时，多相之间的真正反应也在油藏模型中发挥作用。不过，这些问题要复杂得多，留待今后的项目研究。</p>
<p>最后，从数学的角度来看，我们得出了在某一时间步长重新计算速度/压力解的标准，其前提是我们要把在当前时间步长会得到的解与上次实际解这个系统时计算的解进行比较。然而，在程序中，每当我们没有重新计算解决方案时，我们并不只是使用之前计算的解决方案，而是从之前两次求解系统的结果中推算出来。因此，该标准被悲观地表述为：我们真正应该比较的是在当前时间步长得到的解与外推的解。在这方面重述该定理是一个练习。</p>
<p>也有其他方法可以扩展这个程序的数学基础；例如，人们可以说，我们关心的不是速度，而实际上是饱和度。因此，人们可能会问，我们在这里用来决定 \(\mathbf u\) 是否需要重新计算的标准是否合适；例如，人们可能会提出，决定一个错误的速度场事实上是否会影响饱和方程的解（以及影响的程度）也很重要。这自然会导致敏感性分析。</p>
<p>从算法的角度来看，我们在这里使用了一个工程中经常使用的细化标准，即通过查看解的梯度。然而，如果你检查解决方案，你会发现它几乎在所有地方都迅速导致细化，甚至在明显没有必要的区域：因此经常使用并不需要暗示它是一个有用的标准开始。另一方面，用一个不同的、更好的标准来取代这个标准应该不是很困难。例如，许多其他程序中使用的KellyErrorEstimator类当然也应该适用于当前的问题。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2010 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Chih-Che Chueh, University of Victoria, 2010</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University, 2010</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor__function_8h.html">deal.II/base/tensor_function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step43</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>PressureBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    PressureBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  PressureBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 1 - p[0];</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SaturationBoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SaturationBoundaryValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  SaturationBoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (p[0] == 0)</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>SaturationInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    SaturationInitialValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              Vector&lt;double&gt; &amp;  value) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span></div><div class="line">  SaturationInitialValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> 0.2;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> SaturationInitialValues&lt;dim&gt;::vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                                  Vector&lt;double&gt; &amp;values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">      <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(c) = SaturationInitialValues&lt;dim&gt;::value(p, c);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>SingleCurvingCrack</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      KInverse()</div><div class="line">        : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">      value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                 std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> KInverse&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                   std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(points.size() == values.size(),</div><div class="line">             <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(points.size(), values.size()));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">        {</div><div class="line">          values[p].clear();</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> distance_to_flowline =</div><div class="line">            <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(points[p][1] - 0.5 - 0.1 * std::sin(10 * points[p][0]));</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> permeability =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::exp(-(distance_to_flowline * distance_to_flowline) /</div><div class="line">                              (0.1 * 0.1)),</div><div class="line">                     0.01);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            values[p][d][d] = 1. / permeability;</div><div class="line">        }</div><div class="line">    }</div><div class="line">  } <span class="comment">// namespace SingleCurvingCrack</span></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>RandomMedium</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>KInverse : <span class="keyword">public</span> <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      KInverse()</div><div class="line">        : <a class="code" href="classTensorFunction.html">TensorFunction</a>&lt;2, dim&gt;()</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span></div><div class="line">      value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                 std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values) <span class="keyword">const override</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">static</span> std::vector&lt;Point&lt;dim&gt;&gt; centers;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    std::vector&lt;Point&lt;dim&gt;&gt; KInverse&lt;dim&gt;::centers = []() {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> N =</div><div class="line">        (dim == 2 ? 40 : (dim == 3 ? 100 : <span class="keywordflow">throw</span> <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()));</div><div class="line"></div><div class="line">      std::vector&lt;Point&lt;dim&gt;&gt; centers_list(N);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a>; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          centers_list[i][d] = static_cast&lt;double&gt;(rand()) / RAND_MAX;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> centers_list;</div><div class="line">    }();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keywordtype">void</span> KInverse&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                   std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a>&gt; &amp;  values)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(points.size(), values.size());</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; points.size(); ++p)</div><div class="line">        {</div><div class="line">          values[p].clear();</div><div class="line"></div><div class="line">          <span class="keywordtype">double</span> permeability = 0;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; centers.size(); ++i)</div><div class="line">            permeability +=</div><div class="line">              std::exp(-(points[p] - centers[i]).norm_square() / (0.05 * 0.05));</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> normalized_permeability =</div><div class="line">            <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(permeability, 0.01), 4.);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            values[p][d][d] = 1. / normalized_permeability;</div><div class="line">        }</div><div class="line">    }</div><div class="line">  } <span class="comment">// namespace RandomMedium</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> mobility_inverse(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">return</span> 1.0 / (1.0 / viscosity * S * S + (1 - S) * (1 - S));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> fractional_flow(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((S &gt;= 0) &amp;&amp; (S &lt;= 1),</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Saturation is outside its physically valid range.&quot;</span>));</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> S * S / (S * S + viscosity * (1 - S) * (1 - S));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> fractional_flow_derivative(<span class="keyword">const</span> <span class="keywordtype">double</span> S, <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((S &gt;= 0) &amp;&amp; (S &lt;= 1),</div><div class="line">           <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Saturation is outside its physically valid range.&quot;</span>));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> temp = (S * S + viscosity * (1 - S) * (1 - S));</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> numerator =</div><div class="line">      2.0 * S * temp - S * S * (2.0 * S - 2.0 * viscosity * (1 - S));</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> denominator = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(temp, 2.0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> F_prime = numerator / denominator;</div><div class="line"></div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(F_prime &gt;= 0, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> F_prime;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>LinearSolvers</div><div class="line">  {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                    <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">      <span class="keywordtype">void</span> vmult(<a class="code" href="classVectorType.html">VectorType</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">      <span class="keyword">const</span> PreconditionerType &amp;           preconditioner;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">      <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">      <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">      : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">      , preconditioner(preconditioner)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">    <span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">      <a class="code" href="classVectorType.html">VectorType</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>        solver_control(src.size(), 1e-7 * src.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;VectorType&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">      dst = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">try</span></div><div class="line">        {</div><div class="line">          cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, preconditioner);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">catch</span> (std::exception &amp;e)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(e.what()));</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    <span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      BlockSchurPreconditioner(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">        <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                            PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">        <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner);</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#aff5a880cfa288ecdd2a83a876abacf0d">vmult</a>(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">        darcy_matrix;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;<span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                             PreconditionerTypeMp&gt;&gt;</div><div class="line">                                 m_inverse;</div><div class="line">      <span class="keyword">const</span> PreconditionerTypeA &amp;a_preconditioner;</div><div class="line"></div><div class="line">      <span class="keyword">mutable</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::</div><div class="line">      BlockSchurPreconditioner(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">        <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                            PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">        <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner)</div><div class="line">      : darcy_matrix(&amp;S)</div><div class="line">      , m_inverse(&amp;Mpinv)</div><div class="line">      , a_preconditioner(Apreconditioner)</div><div class="line">      , tmp(<a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(darcy_matrix-&gt;block(1, 1).m()))</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::vmult(</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      a_preconditioner.vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">      darcy_matrix-&gt;block(1, 0).residual(tmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">      tmp *= -1;</div><div class="line">      m_inverse-&gt;vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div><div class="line">    }</div><div class="line">  } <span class="comment">// namespace LinearSolvers</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TwoPhaseFlowProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_dofs();</div><div class="line">    <span class="keywordtype">void</span> assemble_darcy_preconditioner();</div><div class="line">    <span class="keywordtype">void</span> build_darcy_preconditioner();</div><div class="line">    <span class="keywordtype">void</span> assemble_darcy_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_saturation_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_saturation_matrix();</div><div class="line">    <span class="keywordtype">void</span> assemble_saturation_rhs();</div><div class="line">    <span class="keywordtype">void</span> assemble_saturation_rhs_cell_term(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       saturation_fe_values,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       darcy_fe_values,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_max_u_F_prime,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_S_variation,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices);</div><div class="line">    <span class="keywordtype">void</span> assemble_saturation_rhs_boundary_term(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   saturation_fe_face_values,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   darcy_fe_face_values,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices);</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_grid_level,</div><div class="line">                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line">    <span class="keywordtype">void</span> output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>                    get_max_u_F_prime() <span class="keyword">const</span>;</div><div class="line">    std::pair&lt;double, double&gt; get_extrapolated_saturation_range() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">bool</span>   determine_whether_to_solve_for_pressure_and_velocity() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span>   project_back_saturation();</div><div class="line">    <span class="keywordtype">double</span> compute_viscosity(</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_saturation,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_saturation,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_saturation_grads,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_saturation_grads,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;Vector&lt;double&gt;&gt; &amp;present_darcy_values,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_max_u_F_prime,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_S_variation,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <span class="keywordtype">double</span>             global_Omega_diameter;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        darcy_degree;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             darcy_fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           darcy_dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> darcy_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> darcy_preconditioner_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> darcy_matrix;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> darcy_preconditioner_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> darcy_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> darcy_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> last_computed_darcy_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> second_last_computed_darcy_solution;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        saturation_degree;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 saturation_fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           saturation_dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> saturation_constraints;</div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix saturation_matrix;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> saturation_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_saturation_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_saturation_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> saturation_rhs;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a></div><div class="line">      saturation_matching_last_computed_darcy_solution;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> saturation_refinement_threshold;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> end_time;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> current_macro_time_step;</div><div class="line">    <span class="keywordtype">double</span> old_macro_time_step;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time_step;</div><div class="line">    <span class="keywordtype">double</span>       old_time_step;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> viscosity;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> porosity;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> AOS_threshold;</div><div class="line"></div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt; Amg_preconditioner;</div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt; Mp_preconditioner;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> rebuild_saturation_matrix;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> RandomMedium::KInverse&lt;dim&gt; k_inverse;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  TwoPhaseFlowProblem&lt;dim&gt;::TwoPhaseFlowProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">    , global_Omega_diameter(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">    , degree(degree)</div><div class="line">    , darcy_degree(degree)</div><div class="line">    , darcy_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(darcy_degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(darcy_degree), 1)</div><div class="line">    , darcy_dof_handler(triangulation)</div><div class="line">    ,</div><div class="line"></div><div class="line">    saturation_degree(degree + 1)</div><div class="line">    , saturation_fe(saturation_degree)</div><div class="line">    , saturation_dof_handler(triangulation)</div><div class="line">    ,</div><div class="line"></div><div class="line">    saturation_refinement_threshold(0.5)</div><div class="line">    ,</div><div class="line"></div><div class="line">    time(0)</div><div class="line">    , end_time(10)</div><div class="line">    ,</div><div class="line"></div><div class="line">    current_macro_time_step(0)</div><div class="line">    , old_macro_time_step(0)</div><div class="line">    ,</div><div class="line"></div><div class="line">    time_step(0)</div><div class="line">    , old_time_step(0)</div><div class="line">    , timestep_number(0)</div><div class="line">    , viscosity(0.2)</div><div class="line">    , porosity(1.0)</div><div class="line">    , AOS_threshold(3.0)</div><div class="line">    ,</div><div class="line"></div><div class="line">    rebuild_saturation_matrix(true)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::setup_dofs()</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; darcy_block_component(dim + 1, 0);</div><div class="line">    darcy_block_component[dim] = 1;</div><div class="line">    {</div><div class="line">      darcy_dof_handler.distribute_dofs(darcy_fe);</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(darcy_dof_handler);</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(darcy_dof_handler, darcy_block_component);</div><div class="line"></div><div class="line">      darcy_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(darcy_dof_handler,</div><div class="line">                                              darcy_constraints);</div><div class="line">      darcy_constraints.close();</div><div class="line">    }</div><div class="line">    {</div><div class="line">      saturation_dof_handler.distribute_dofs(saturation_fe);</div><div class="line"></div><div class="line">      saturation_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(saturation_dof_handler,</div><div class="line">                                              saturation_constraints);</div><div class="line">      saturation_constraints.close();</div><div class="line">    }</div><div class="line">    {</div><div class="line">      darcy_preconditioner_constraints.clear();</div><div class="line"></div><div class="line">      <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(darcy_dof_handler,</div><div class="line">                                              darcy_preconditioner_constraints);</div><div class="line">      <a class="code" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a>(darcy_dof_handler,</div><div class="line">                                               darcy_preconditioner_constraints,</div><div class="line">                                               darcy_fe.component_mask(</div><div class="line">                                                 pressure));</div><div class="line"></div><div class="line">      darcy_preconditioner_constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; darcy_dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(darcy_dof_handler,</div><div class="line">                                        darcy_block_component);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = darcy_dofs_per_block[0],</div><div class="line">                       n_p = darcy_dofs_per_block[1],</div><div class="line">                       n_s = saturation_dof_handler.n_dofs();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_s &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">              &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_s &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      darcy_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">      dsp.block(0, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_u);</div><div class="line">      dsp.block(0, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_p);</div><div class="line">      dsp.block(1, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_u);</div><div class="line">      dsp.block(1, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_p);</div><div class="line"></div><div class="line">      dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (d == dim)))</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        darcy_dof_handler, coupling, dsp, darcy_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      darcy_matrix.reinit(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      Amg_preconditioner.reset();</div><div class="line">      Mp_preconditioner.reset();</div><div class="line">      darcy_preconditioner_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">      dsp.block(0, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_u);</div><div class="line">      dsp.block(0, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_u, n_p);</div><div class="line">      dsp.block(1, 0).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_u);</div><div class="line">      dsp.block(1, 1).<a class="code" href="classDynamicSparsityPattern.html#aa32f9f3ebad084d001349cd3ddb4074e">reinit</a>(n_p, n_p);</div><div class="line"></div><div class="line">      dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (c == d)</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        darcy_dof_handler, coupling, dsp, darcy_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      darcy_preconditioner_matrix.reinit(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    {</div><div class="line">      saturation_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_s, n_s);</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(saturation_dof_handler,</div><div class="line">                                      dsp,</div><div class="line">                                      saturation_constraints,</div><div class="line">                                      <span class="keyword">false</span>);</div><div class="line"></div><div class="line"></div><div class="line">      saturation_matrix.reinit(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    std::vector&lt;IndexSet&gt; darcy_partitioning(2);</div><div class="line">    darcy_partitioning[0] = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_u);</div><div class="line">    darcy_partitioning[1] = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_p);</div><div class="line">    darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">    darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">    last_computed_darcy_solution.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">    last_computed_darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">    second_last_computed_darcy_solution.reinit(darcy_partitioning,</div><div class="line">                                               MPI_COMM_WORLD);</div><div class="line">    second_last_computed_darcy_solution.collect_sizes();</div><div class="line"></div><div class="line">    darcy_rhs.reinit(darcy_partitioning, MPI_COMM_WORLD);</div><div class="line">    darcy_rhs.collect_sizes();</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> saturation_partitioning = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_s);</div><div class="line">    saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_old_saturation_solution.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    saturation_matching_last_computed_darcy_solution.reinit(</div><div class="line">      saturation_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    saturation_rhs.reinit(saturation_partitioning, MPI_COMM_WORLD);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_preconditioner()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding darcy preconditioner...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    darcy_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(darcy_degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     darcy_fe_values(darcy_fe,</div><div class="line">                                  quadrature_formula,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     saturation_fe_values(saturation_fe,</div><div class="line">                                       quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = darcy_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">      {</div><div class="line">        darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(saturation_cell);</div><div class="line"></div><div class="line">        local_matrix = 0;</div><div class="line"></div><div class="line">        saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                                 old_saturation_values);</div><div class="line"></div><div class="line">        k_inverse.value_list(darcy_fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             k_inverse_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_saturation_values[q];</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> inverse_mobility = mobility_inverse(old_s, viscosity);</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> mobility         = 1.0 / inverse_mobility;</div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> permeability = <a class="code" href="symmetric__tensor_8h.html#a3656e2f6095f612536b06139a6a2ca39">invert</a>(k_inverse_values[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                phi_u[k]      = darcy_fe_values[velocities].value(k, q);</div><div class="line">                grad_phi_p[k] = darcy_fe_values[pressure].gradient(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  local_matrix(i, j) +=</div><div class="line">                    (k_inverse_values[q] * inverse_mobility * phi_u[i] *</div><div class="line">                       phi_u[j] +</div><div class="line">                     permeability * mobility * grad_phi_p[i] * grad_phi_p[j]) *</div><div class="line">                    darcy_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        darcy_preconditioner_constraints.distribute_local_to_global(</div><div class="line">          local_matrix, local_dof_indices, darcy_preconditioner_matrix);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::build_darcy_preconditioner()</div><div class="line">  {</div><div class="line">    assemble_darcy_preconditioner();</div><div class="line"></div><div class="line">    Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">    Amg_preconditioner-&gt;initialize(darcy_preconditioner_matrix.block(0, 0));</div><div class="line"></div><div class="line">    Mp_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">    Mp_preconditioner-&gt;initialize(darcy_preconditioner_matrix.block(1, 1));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_darcy_system()</div><div class="line">  {</div><div class="line">    darcy_matrix = 0;</div><div class="line">    darcy_rhs    = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(darcy_degree + 2);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(darcy_degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe,</div><div class="line">                                  quadrature_formula,</div><div class="line">                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                       quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> darcy_fe_face_values(darcy_fe,</div><div class="line">                                           face_quadrature_formula,</div><div class="line">                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = darcy_fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points      = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points = face_quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> pressure_right_hand_side;</div><div class="line">    <span class="keyword">const</span> PressureBoundaryValues&lt;dim&gt;  pressure_boundary_values;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         pressure_rhs_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         boundary_values(n_face_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;         div_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;         phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">      {</div><div class="line">        darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(saturation_cell);</div><div class="line"></div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs    = 0;</div><div class="line"></div><div class="line">        saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                                 old_saturation_values);</div><div class="line"></div><div class="line">        pressure_right_hand_side.<a class="code" href="classFunctions_1_1ConstantFunction.html#a6a3224d6e805fa73629130e021a7285b">value_list</a>(</div><div class="line">          darcy_fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), pressure_rhs_values);</div><div class="line">        k_inverse.value_list(darcy_fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             k_inverse_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                phi_u[k]     = darcy_fe_values[velocities].value(k, q);</div><div class="line">                div_phi_u[k] = darcy_fe_values[velocities].divergence(k, q);</div><div class="line">                phi_p[k]     = darcy_fe_values[pressure].value(k, q);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> old_s = old_saturation_values[q];</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt;= i; ++j)</div><div class="line">                  {</div><div class="line">                    local_matrix(i, j) +=</div><div class="line">                      (phi_u[i] * k_inverse_values[q] *</div><div class="line">                         mobility_inverse(old_s, viscosity) * phi_u[j] -</div><div class="line">                       div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div><div class="line">                      darcy_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                  }</div><div class="line"></div><div class="line">                local_rhs(i) +=</div><div class="line">                  (-phi_p[i] * pressure_rhs_values[q]) * darcy_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              darcy_fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line"></div><div class="line">              pressure_boundary_values.value_list(</div><div class="line">                darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), boundary_values);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                  {</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i_u =</div><div class="line">                      darcy_fe_face_values[velocities].value(i, q);</div><div class="line"></div><div class="line">                    local_rhs(i) +=</div><div class="line">                      -(phi_i_u * darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q) *</div><div class="line">                        boundary_values[q] * darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));</div><div class="line">                  }</div><div class="line">            }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = i + 1; j &lt; dofs_per_cell; ++j)</div><div class="line">            local_matrix(i, j) = local_matrix(j, i);</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        darcy_constraints.distribute_local_to_global(</div><div class="line">          local_matrix, local_rhs, local_dof_indices, darcy_matrix, darcy_rhs);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_system()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (rebuild_saturation_matrix == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line">        saturation_matrix = 0;</div><div class="line">        assemble_saturation_matrix();</div><div class="line">      }</div><div class="line"></div><div class="line">    saturation_rhs = 0;</div><div class="line">    assemble_saturation_rhs();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_matrix()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(saturation_degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                       quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe.n_dofs_per_cell();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs    = 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_s = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q);</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_s = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q);</div><div class="line">                  local_matrix(i, j) +=</div><div class="line">                    porosity * phi_i_s * phi_j_s * saturation_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">                }</div><div class="line">            }</div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        saturation_constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                                          local_dof_indices,</div><div class="line">                                                          saturation_matrix);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula(saturation_degree + 2);</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; face_quadrature_formula(saturation_degree + 2);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                       quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> saturation_fe_face_values(saturation_fe,</div><div class="line">                                                face_quadrature_formula,</div><div class="line">                                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> darcy_fe_face_values(darcy_fe,</div><div class="line">                                           face_quadrature_formula,</div><div class="line">                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> saturation_fe_face_values_neighbor(</div><div class="line">      saturation_fe, face_quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell =</div><div class="line">      saturation_dof_handler.get_fe().n_dofs_per_cell();</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                    global_max_u_F_prime = get_max_u_F_prime();</div><div class="line">    <span class="keyword">const</span> std::pair&lt;double, double&gt; global_S_range =</div><div class="line">      get_extrapolated_saturation_range();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> global_S_variation =</div><div class="line">      global_S_range.second - global_S_range.first;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell       = saturation_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc       = saturation_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       darcy_cell = darcy_dof_handler.begin_active();</div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++darcy_cell)</div><div class="line">      {</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(darcy_cell);</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        assemble_saturation_rhs_cell_term(saturation_fe_values,</div><div class="line">                                          darcy_fe_values,</div><div class="line">                                          global_max_u_F_prime,</div><div class="line">                                          global_S_variation,</div><div class="line">                                          local_dof_indices);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;face : cell-&gt;face_iterators())</div><div class="line">          <span class="keywordflow">if</span> (face-&gt;at_boundary())</div><div class="line">            {</div><div class="line">              darcy_fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(darcy_cell, face);</div><div class="line">              saturation_fe_face_values.<a class="code" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">reinit</a>(cell, face);</div><div class="line">              assemble_saturation_rhs_boundary_term(saturation_fe_face_values,</div><div class="line">                                                    darcy_fe_face_values,</div><div class="line">                                                    local_dof_indices);</div><div class="line">            }</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_cell_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       saturation_fe_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;                       darcy_fe_values,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_max_u_F_prime,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                global_S_variation,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         old_saturation_solution_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_old_saturation_solution_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_grad_saturation_solution_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_grad_saturation_solution_values(</div><div class="line">      n_q_points);</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; present_darcy_solution_values(</div><div class="line">      n_q_points, Vector&lt;double&gt;(dim + 1));</div><div class="line"></div><div class="line">    saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                             old_saturation_solution_values);</div><div class="line">    saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">      old_old_saturation_solution, old_old_saturation_solution_values);</div><div class="line">    saturation_fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(</div><div class="line">      old_saturation_solution, old_grad_saturation_solution_values);</div><div class="line">    saturation_fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(</div><div class="line">      old_old_saturation_solution, old_old_grad_saturation_solution_values);</div><div class="line">    darcy_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(darcy_solution,</div><div class="line">                                        present_darcy_solution_values);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div><div class="line">      compute_viscosity(old_saturation_solution_values,</div><div class="line">                        old_old_saturation_solution_values,</div><div class="line">                        old_grad_saturation_solution_values,</div><div class="line">                        old_old_grad_saturation_solution_values,</div><div class="line">                        present_darcy_solution_values,</div><div class="line">                        global_max_u_F_prime,</div><div class="line">                        global_S_variation,</div><div class="line">                        saturation_fe_values.<a class="code" href="classFEValuesBase.html#a9d3a1c53c139e2553b672de682d6233e">get_cell</a>()-&gt;diameter());</div><div class="line"></div><div class="line">    Vector&lt;double&gt; local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>   old_s = old_saturation_solution_values[q];</div><div class="line">          <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u;</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            present_u[d] = present_darcy_solution_values[q](d);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span>         phi_i_s = saturation_fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q);</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> grad_phi_i_s =</div><div class="line">            saturation_fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q);</div><div class="line"></div><div class="line">          local_rhs(i) +=</div><div class="line">            (time_step * fractional_flow(old_s, viscosity) * present_u *</div><div class="line">               grad_phi_i_s -</div><div class="line">             time_step * nu * old_grad_saturation_solution_values[q] *</div><div class="line">               grad_phi_i_s +</div><div class="line">             porosity * old_s * phi_i_s) *</div><div class="line">            saturation_fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">        }</div><div class="line"></div><div class="line">    saturation_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                      local_dof_indices,</div><div class="line">                                                      saturation_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::assemble_saturation_rhs_boundary_term(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   saturation_fe_face_values,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValues.html">FEFaceValues&lt;dim&gt;</a> &amp;                   darcy_fe_face_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_face_q_points =</div><div class="line">      saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; old_saturation_solution_values_face(n_face_q_points);</div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; present_darcy_solution_values_face(</div><div class="line">      n_face_q_points, Vector&lt;double&gt;(dim + 1));</div><div class="line">    std::vector&lt;double&gt; neighbor_saturation(n_face_q_points);</div><div class="line"></div><div class="line">    saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">      old_saturation_solution, old_saturation_solution_values_face);</div><div class="line">    darcy_fe_face_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">      darcy_solution, present_darcy_solution_values_face);</div><div class="line"></div><div class="line">    SaturationBoundaryValues&lt;dim&gt; saturation_boundary_values;</div><div class="line">    saturation_boundary_values.value_list(</div><div class="line">      saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), neighbor_saturation);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_face_q_points; ++q)</div><div class="line">      {</div><div class="line">        <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> present_u_face;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          present_u_face[d] = present_darcy_solution_values_face[q](d);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> normal_flux =</div><div class="line">          present_u_face * saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a>(q);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> is_outflow_q_point = (normal_flux &gt;= 0);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          local_rhs(i) -=</div><div class="line">            time_step * normal_flux *</div><div class="line">            fractional_flow((is_outflow_q_point == <span class="keyword">true</span> ?</div><div class="line">                               old_saturation_solution_values_face[q] :</div><div class="line">                               neighbor_saturation[q]),</div><div class="line">                            viscosity) *</div><div class="line">            saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q) *</div><div class="line">            saturation_fe_face_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);</div><div class="line">      }</div><div class="line">    saturation_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                      local_dof_indices,</div><div class="line">                                                      saturation_rhs);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> solve_for_pressure_and_velocity =</div><div class="line">      determine_whether_to_solve_for_pressure_and_velocity();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (solve_for_pressure_and_velocity == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving Darcy (pressure-velocity) system...&quot;</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_darcy_system();</div><div class="line">        build_darcy_preconditioner();</div><div class="line"></div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> LinearSolvers::InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                             TrilinosWrappers::PreconditionIC&gt;</div><div class="line">            mp_inverse(darcy_preconditioner_matrix.block(1, 1),</div><div class="line">                       *Mp_preconditioner);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">            <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#abee1d4aa6f0af5290aa7d51806bde982">TrilinosWrappers::PreconditionIC</a>,</div><div class="line">            TrilinosWrappers::PreconditionIC&gt;</div><div class="line">            preconditioner(darcy_matrix, mp_inverse, *Amg_preconditioner);</div><div class="line"></div><div class="line">          <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(darcy_matrix.m(),</div><div class="line">                                       1e-16 * darcy_rhs.l2_norm());</div><div class="line"></div><div class="line">          <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> gmres(</div><div class="line">            solver_control,</div><div class="line">            <a class="code" href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(</div><div class="line">              100));</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; darcy_solution.size(); ++i)</div><div class="line">            <span class="keywordflow">if</span> (darcy_constraints.is_constrained(i))</div><div class="line">              darcy_solution(i) = 0;</div><div class="line"></div><div class="line">          gmres.solve(darcy_matrix, darcy_solution, darcy_rhs, preconditioner);</div><div class="line"></div><div class="line">          darcy_constraints.distribute(darcy_solution);</div><div class="line"></div><div class="line">          std::cout &lt;&lt; <span class="stringliteral">&quot;        ...&quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                    &lt;&lt; <span class="stringliteral">&quot; GMRES iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line"></div><div class="line">        {</div><div class="line">          second_last_computed_darcy_solution = last_computed_darcy_solution;</div><div class="line">          last_computed_darcy_solution        = darcy_solution;</div><div class="line"></div><div class="line">          saturation_matching_last_computed_darcy_solution =</div><div class="line">            saturation_solution;</div><div class="line">        }</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        darcy_solution = last_computed_darcy_solution;</div><div class="line">        darcy_solution.sadd(1 + current_macro_time_step / old_macro_time_step,</div><div class="line">                            -current_macro_time_step / old_macro_time_step,</div><div class="line">                            second_last_computed_darcy_solution);</div><div class="line">      }</div><div class="line"></div><div class="line"></div><div class="line">    {</div><div class="line">      old_time_step = time_step;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> max_u_F_prime = get_max_u_F_prime();</div><div class="line">      <span class="keywordflow">if</span> (max_u_F_prime &gt; 0)</div><div class="line">        time_step = porosity * <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) /</div><div class="line">                    saturation_degree / max_u_F_prime / 50;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        time_step = end_time - time;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (solve_for_pressure_and_velocity == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line">        old_macro_time_step     = current_macro_time_step;</div><div class="line">        current_macro_time_step = time_step;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      current_macro_time_step += time_step;</div><div class="line"></div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving saturation transport equation...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      assemble_saturation_system();</div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(saturation_matrix.m(),</div><div class="line">                                   1e-16 * saturation_rhs.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">      TrilinosWrappers::PreconditionIC preconditioner;</div><div class="line">      preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html#a95eff1f8abcf2ba67815b6a96a66d375">initialize</a>(saturation_matrix);</div><div class="line"></div><div class="line">      cg.solve(saturation_matrix,</div><div class="line">               saturation_solution,</div><div class="line">               saturation_rhs,</div><div class="line">               preconditioner);</div><div class="line"></div><div class="line">      saturation_constraints.distribute(saturation_solution);</div><div class="line">      project_back_saturation();</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;        ...&quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; CG iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> min_grid_level,</div><div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">  {</div><div class="line">    Vector&lt;double&gt; refinement_indicators(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQMidpoint.html">QMidpoint&lt;dim&gt;</a>        quadrature_formula;</div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>               fe_values(saturation_fe,</div><div class="line">                              quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_saturation(1);</div><div class="line"></div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> extrapolated_saturation_solution(</div><div class="line">        saturation_solution);</div><div class="line">      <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">        extrapolated_saturation_solution.sadd((1. + time_step / old_time_step),</div><div class="line">                                              time_step / old_time_step,</div><div class="line">                                              old_saturation_solution);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = cell-&gt;active_cell_index();</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(extrapolated_saturation_solution,</div><div class="line">                                           grad_saturation);</div><div class="line"></div><div class="line">          refinement_indicators(cell_no) = grad_saturation[0].norm();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = cell-&gt;active_cell_index();</div><div class="line">          cell-&gt;clear_coarsen_flag();</div><div class="line">          cell-&gt;clear_refine_flag();</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> ((static_cast&lt;unsigned int&gt;(cell-&gt;level()) &lt; max_grid_level) &amp;&amp;</div><div class="line">              (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(refinement_indicators(cell_no)) &gt;</div><div class="line">               saturation_refinement_threshold))</div><div class="line">            cell-&gt;set_refine_flag();</div><div class="line">          <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((static_cast&lt;unsigned int&gt;(cell-&gt;level()) &gt;</div><div class="line">                    min_grid_level) &amp;&amp;</div><div class="line">                   (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(refinement_indicators(cell_no)) &lt;</div><div class="line">                    0.5 * saturation_refinement_threshold))</div><div class="line">            cell-&gt;set_coarsen_flag();</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line">    {</div><div class="line">      std::vector&lt;TrilinosWrappers::MPI::Vector&gt; x_saturation(3);</div><div class="line">      x_saturation[0] = saturation_solution;</div><div class="line">      x_saturation[1] = old_saturation_solution;</div><div class="line">      x_saturation[2] = saturation_matching_last_computed_darcy_solution;</div><div class="line"></div><div class="line">      std::vector&lt;TrilinosWrappers::MPI::BlockVector&gt; x_darcy(2);</div><div class="line">      x_darcy[0] = last_computed_darcy_solution;</div><div class="line">      x_darcy[1] = second_last_computed_darcy_solution;</div><div class="line"></div><div class="line">      <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a> saturation_soltrans(</div><div class="line">        saturation_dof_handler);</div><div class="line"></div><div class="line">      <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::BlockVector&gt;</a> darcy_soltrans(</div><div class="line">        darcy_dof_handler);</div><div class="line"></div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">      saturation_soltrans.prepare_for_coarsening_and_refinement(x_saturation);</div><div class="line"></div><div class="line">      darcy_soltrans.prepare_for_coarsening_and_refinement(x_darcy);</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">      setup_dofs();</div><div class="line"></div><div class="line">      std::vector&lt;TrilinosWrappers::MPI::Vector&gt; tmp_saturation(3);</div><div class="line">      tmp_saturation[0].reinit(saturation_solution);</div><div class="line">      tmp_saturation[1].reinit(saturation_solution);</div><div class="line">      tmp_saturation[2].reinit(saturation_solution);</div><div class="line">      saturation_soltrans.interpolate(x_saturation, tmp_saturation);</div><div class="line"></div><div class="line">      saturation_solution                              = tmp_saturation[0];</div><div class="line">      old_saturation_solution                          = tmp_saturation[1];</div><div class="line">      saturation_matching_last_computed_darcy_solution = tmp_saturation[2];</div><div class="line"></div><div class="line">      saturation_constraints.distribute(saturation_solution);</div><div class="line">      saturation_constraints.distribute(old_saturation_solution);</div><div class="line">      saturation_constraints.distribute(</div><div class="line">        saturation_matching_last_computed_darcy_solution);</div><div class="line"></div><div class="line">      std::vector&lt;TrilinosWrappers::MPI::BlockVector&gt; tmp_darcy(2);</div><div class="line">      tmp_darcy[0].reinit(darcy_solution);</div><div class="line">      tmp_darcy[1].reinit(darcy_solution);</div><div class="line">      darcy_soltrans.interpolate(x_darcy, tmp_darcy);</div><div class="line"></div><div class="line">      last_computed_darcy_solution        = tmp_darcy[0];</div><div class="line">      second_last_computed_darcy_solution = tmp_darcy[1];</div><div class="line"></div><div class="line">      darcy_constraints.distribute(last_computed_darcy_solution);</div><div class="line">      darcy_constraints.distribute(second_last_computed_darcy_solution);</div><div class="line"></div><div class="line">      rebuild_saturation_matrix = <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> joint_fe(darcy_fe, 1, saturation_fe, 1);</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>     joint_dof_handler(triangulation);</div><div class="line">    joint_dof_handler.distribute_dofs(joint_fe);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_dof_handler.n_dofs() ==</div><div class="line">             darcy_dof_handler.n_dofs() + saturation_dof_handler.n_dofs(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line"></div><div class="line">    Vector&lt;double&gt; joint_solution(joint_dof_handler.n_dofs());</div><div class="line"></div><div class="line">    {</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_joint_dof_indices(</div><div class="line">        joint_fe.n_dofs_per_cell());</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_darcy_dof_indices(</div><div class="line">        darcy_fe.n_dofs_per_cell());</div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_saturation_dof_indices(</div><div class="line">        saturation_fe.n_dofs_per_cell());</div><div class="line"></div><div class="line">      <span class="keyword">auto</span>       joint_cell      = joint_dof_handler.begin_active();</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> joint_endc      = joint_dof_handler.end();</div><div class="line">      <span class="keyword">auto</span>       darcy_cell      = darcy_dof_handler.begin_active();</div><div class="line">      <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (; joint_cell != joint_endc;</div><div class="line">           ++joint_cell, ++darcy_cell, ++saturation_cell)</div><div class="line">        {</div><div class="line">          joint_cell-&gt;get_dof_indices(local_joint_dof_indices);</div><div class="line">          darcy_cell-&gt;get_dof_indices(local_darcy_dof_indices);</div><div class="line">          saturation_cell-&gt;get_dof_indices(local_saturation_dof_indices);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; joint_fe.n_dofs_per_cell(); ++i)</div><div class="line">            <span class="keywordflow">if</span> (joint_fe.system_to_base_index(i).first.first == 0)</div><div class="line">              {</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                         local_darcy_dof_indices.size(),</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                joint_solution(local_joint_dof_indices[i]) = darcy_solution(</div><div class="line">                  local_darcy_dof_indices[joint_fe.system_to_base_index(i)</div><div class="line">                                            .second]);</div><div class="line">              }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">              {</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).first.first == 1,</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(joint_fe.system_to_base_index(i).second &lt;</div><div class="line">                         local_darcy_dof_indices.size(),</div><div class="line">                       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>());</div><div class="line">                joint_solution(local_joint_dof_indices[i]) =</div><div class="line">                  saturation_solution(</div><div class="line">                    local_saturation_dof_indices</div><div class="line">                      [joint_fe.system_to_base_index(i).second]);</div><div class="line">              }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    std::vector&lt;std::string&gt; joint_solution_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    joint_solution_names.emplace_back(<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line">    joint_solution_names.emplace_back(<span class="stringliteral">&quot;saturation&quot;</span>);</div><div class="line"></div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      data_component_interpretation(</div><div class="line">        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    data_component_interpretation.push_back(</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(joint_dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(joint_solution,</div><div class="line">                             joint_solution_names,</div><div class="line">                             <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                             data_component_interpretation);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 5) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">bool</span> TwoPhaseFlowProblem&lt;</div><div class="line">    dim&gt;::determine_whether_to_solve_for_pressure_and_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (timestep_number &lt;= 2)</div><div class="line">      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(saturation_degree + 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(saturation_fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; old_saturation_after_solving_pressure(n_q_points);</div><div class="line">    std::vector&lt;double&gt; present_saturation(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; k_inverse_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_global_aop_indicator = 0.0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> max_local_mobility_reciprocal_difference = 0.0;</div><div class="line">        <span class="keywordtype">double</span> max_local_permeability_inverse_l1_norm   = 0.0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(</div><div class="line">          saturation_matching_last_computed_darcy_solution,</div><div class="line">          old_saturation_after_solving_pressure);</div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(saturation_solution, present_saturation);</div><div class="line"></div><div class="line">        k_inverse.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             k_inverse_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> mobility_reciprocal_difference = <a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(</div><div class="line">              mobility_inverse(present_saturation[q], viscosity) -</div><div class="line">              mobility_inverse(old_saturation_after_solving_pressure[q],</div><div class="line">                               viscosity));</div><div class="line"></div><div class="line">            max_local_mobility_reciprocal_difference =</div><div class="line">              <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_mobility_reciprocal_difference,</div><div class="line">                       mobility_reciprocal_difference);</div><div class="line"></div><div class="line">            max_local_permeability_inverse_l1_norm =</div><div class="line">              <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_local_permeability_inverse_l1_norm,</div><div class="line">                       <a class="code" href="tensor_8h.html#a93ba01d979880b278cd4b573dd9c653b">l1_norm</a>(k_inverse_values[q]));</div><div class="line">          }</div><div class="line"></div><div class="line">        max_global_aop_indicator =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_global_aop_indicator,</div><div class="line">                   (max_local_mobility_reciprocal_difference *</div><div class="line">                    max_local_permeability_inverse_l1_norm));</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (max_global_aop_indicator &gt; AOS_threshold);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> TwoPhaseFlowProblem&lt;dim&gt;::project_back_saturation()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; saturation_solution.size(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (saturation_solution(i) &lt; 0.2)</div><div class="line">        saturation_solution(i) = 0.2;</div><div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (saturation_solution(i) &gt; 1)</div><div class="line">        saturation_solution(i) = 1;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::get_max_u_F_prime()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(darcy_degree + 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> darcy_fe_values(darcy_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> saturation_fe_values(saturation_fe,</div><div class="line">                                       quadrature_formula,</div><div class="line">                                       <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; darcy_solution_values(n_q_points,</div><div class="line">                                                      Vector&lt;double&gt;(dim + 1));</div><div class="line">    std::vector&lt;double&gt;         saturation_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_velocity_times_dF_dS = 0;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell            = darcy_dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc            = darcy_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       saturation_cell = saturation_dof_handler.begin_active();</div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++saturation_cell)</div><div class="line">      {</div><div class="line">        darcy_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(saturation_cell);</div><div class="line"></div><div class="line">        darcy_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(darcy_solution,</div><div class="line">                                            darcy_solution_values);</div><div class="line">        saturation_fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                                 saturation_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> velocity;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">              velocity[i] = darcy_solution_values[q](i);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> dF_dS =</div><div class="line">              fractional_flow_derivative(saturation_values[q], viscosity);</div><div class="line"></div><div class="line">            max_velocity_times_dF_dS =</div><div class="line">              <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity_times_dF_dS, velocity.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() * dF_dS);</div><div class="line">          }</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> max_velocity_times_dF_dS;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::pair&lt;double, double&gt;</div><div class="line">  TwoPhaseFlowProblem&lt;dim&gt;::get_extrapolated_saturation_range()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>  quadrature_formula(saturation_degree + 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(saturation_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;double&gt; old_saturation_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_old_saturation_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">               max_saturation = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                          old_saturation_values);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_saturation_solution,</div><div class="line">                                          old_old_saturation_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> saturation =</div><div class="line">                  (1. + time_step / old_time_step) * old_saturation_values[q] -</div><div class="line">                  time_step / old_time_step * old_old_saturation_values[q];</div><div class="line"></div><div class="line">                min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_saturation, saturation);</div><div class="line">                max_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_saturation, saturation);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> std::make_pair(min_saturation, max_saturation);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">               max_saturation = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : saturation_dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_saturation_solution,</div><div class="line">                                          old_saturation_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> saturation = old_saturation_values[q];</div><div class="line"></div><div class="line">                min_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_saturation, saturation);</div><div class="line">                max_saturation = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_saturation, saturation);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> std::make_pair(min_saturation, max_saturation);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> TwoPhaseFlowProblem&lt;dim&gt;::compute_viscosity(</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_saturation,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_saturation,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_saturation_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_saturation_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;Vector&lt;double&gt;&gt; &amp;present_darcy_values,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_max_u_F_prime,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_S_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> beta  = .4 * dim;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = 1;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (global_max_u_F_prime == 0)</div><div class="line">      <span class="keywordflow">return</span> 5e-3 * cell_diameter;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_saturation.size();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_residual             = 0;</div><div class="line">    <span class="keywordtype">double</span> max_velocity_times_dF_dS = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> use_dF_dS = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          u[d] = present_darcy_values[q](d);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> dS_dt = porosity *</div><div class="line">                             (old_saturation[q] - old_old_saturation[q]) /</div><div class="line">                             old_time_step;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> dF_dS = fractional_flow_derivative(</div><div class="line">          (old_saturation[q] + old_old_saturation[q]) / 2.0, viscosity);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_S =</div><div class="line">          u * dF_dS * (old_saturation_grads[q] + old_old_saturation_grads[q]) /</div><div class="line">          2.0;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> residual =</div><div class="line">          <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>((dS_dt + u_grad_S) *</div><div class="line">                   std::pow((old_saturation[q] + old_old_saturation[q]) / 2,</div><div class="line">                            alpha - 1.));</div><div class="line"></div><div class="line">        max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div><div class="line">        max_velocity_times_dF_dS =</div><div class="line">          <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u * u) * (use_dF_dS ? <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(dF_dS, 1.) : 1),</div><div class="line">                   max_velocity_times_dF_dS);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> c_R            = 1.0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> global_scaling = c_R * porosity *</div><div class="line">                                  (global_max_u_F_prime)*global_S_variation /</div><div class="line">                                  std::pow(global_Omega_diameter, alpha - 2.);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (beta *</div><div class="line">            (max_velocity_times_dF_dS)*<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(cell_diameter,</div><div class="line">                                                std::pow(cell_diameter, alpha) *</div><div class="line">                                                  max_residual /</div><div class="line">                                                  global_scaling));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">TwoPhaseFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement     = (dim == 2 ? 5 : 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_pre_refinement_steps = (dim == 2 ? 3 : 2);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(initial_refinement);</div><div class="line">    global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(triangulation);</div><div class="line"></div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"></div><div class="line">  start_time_iteration:</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(saturation_dof_handler,</div><div class="line">                         saturation_constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(saturation_degree + 2),</div><div class="line">                         SaturationInitialValues&lt;dim&gt;(),</div><div class="line">                         old_saturation_solution);</div><div class="line"></div><div class="line">    time_step = old_time_step = 0;</div><div class="line">    current_macro_time_step = old_macro_time_step = 0;</div><div class="line"></div><div class="line">    time = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; <span class="stringliteral">&quot;, dt=&quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (timestep_number % 200 == 0)</div><div class="line">          output_results();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (timestep_number % 25 == 0)</div><div class="line">          refine_mesh(initial_refinement,</div><div class="line">                      initial_refinement + n_pre_refinement_steps);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">            (pre_refinement_step &lt; n_pre_refinement_steps))</div><div class="line">          {</div><div class="line">            ++pre_refinement_step;</div><div class="line">            <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">          }</div><div class="line"></div><div class="line">        time += time_step;</div><div class="line">        ++timestep_number;</div><div class="line"></div><div class="line">        old_old_saturation_solution = old_saturation_solution;</div><div class="line">        old_saturation_solution     = saturation_solution;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (time &lt;= end_time);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step43</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step43;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-43&quot;</span>));</div><div class="line"></div><div class="line">      TwoPhaseFlowProblem&lt;2&gt; two_phase_flow_problem(1);</div><div class="line">      two_phase_flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
