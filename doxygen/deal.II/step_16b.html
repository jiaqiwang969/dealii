<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_16b.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-16b tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-16b tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_16.html">step-16</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thetestcase">The testcase</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Theintegratoroneachcell">The integrator on each cell</a>
        <li><a href="#ThecodeLaplaceProblemcodeclasstemplate">The <code>LaplaceProblem</code> class template</a>
        <li><a href="#ThecodeLaplaceProblemcodeclassimplementation">The <code>LaplaceProblem</code> class implementation</a>
      <ul>
        <li><a href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a>
        <li><a href="#LaplaceProblemassemble_system">LaplaceProblem::assemble_system</a>
        <li><a href="#LaplaceProblemassemble_multigrid">LaplaceProblem::assemble_multigrid</a>
        <li><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a>
        <li><a href="#Postprocessing">Postprocessing</a>
        <li><a href="#LaplaceProblemrun">LaplaceProblem::run</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This is a variant of <a class="el" href="step_16.html">step-16</a> with the only change that we are using the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework with the pre-made LocalIntegrator helper classes instead of manually assembling the matrices.</p>
<p>The details of this framework on how it is used in practice will be explained as part of this tutorial program.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>The problem we solve here is the same as the one in <a class="el" href="step_16.html">step-16</a>.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Again, the first few include files are already known, so we won't comment on them:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div></div><!-- fragment --><p>These, now, are the include necessary for the multilevel methods. The first one declares how to handle Dirichlet boundary conditions on each of the levels of the multigrid method. For the actual description of the degrees of freedom, we do not need any new include file because <a class="el" href="classDoFHandler.html">DoFHandler</a> already has all necessary methods implemented. We will only need to distribute the DoFs for the levels further down.</p>
<p>The rest of the include files deals with the mechanics of multigrid as a linear operator (solver or preconditioner).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div></div><!-- fragment --><p>Finally we include the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework. This framework through its function <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> and <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">integration_loop()</a>, automates loops over cells and assembling of data into vectors, matrices, etc. It obeys constraints automatically. Since we have to build several matrices and have to be aware of several sets of constraints, this will save us a lot of headache.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="meshworker_2dof__info_8h.html">deal.II/meshworker/dof_info.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integration__info_8h.html">deal.II/meshworker/integration_info.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="simple_8h.html">deal.II/meshworker/simple.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="output_8h.html">deal.II/meshworker/output.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="loop_8h.html">deal.II/meshworker/loop.h</a>&gt;</span></div></div><!-- fragment --><p>In order to save effort, we use the pre-implemented Laplacian found in</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="laplace_8h.html">deal.II/integrators/laplace.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="l2_8h.html">deal.II/integrators/l2.h</a>&gt;</span></div></div><!-- fragment --><p>This is C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step16</div><div class="line">{</div></div><!-- fragment --><p><a class="anchor" id="Theintegratoroneachcell"></a> </p><h3>The integrator on each cell</h3>
<p>The <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">MeshWorker::integration_loop()</a> expects a class that provides functions for integration on cells and boundary and interior faces. This is done by the following class. In the constructor, we tell the loop that cell integrals should be computed (the 'true'), but integrals should not be computed on boundary and interior faces (the two 'false'). Accordingly, we only need a cell function, but none for the faces.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>LaplaceIntegrator : <span class="keyword">public</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LaplaceIntegrator();</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html#a44cc05e3e905a8cd5af4c12d3026ea2a">cell</a>(MeshWorker::DoFInfo&lt;dim&gt; &amp;        dinfo,</div><div class="line">                    <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">LaplaceIntegrator&lt;dim&gt;::LaplaceIntegrator()</div><div class="line">  : <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::LocalIntegrator&lt;dim&gt;(true, false, false)</div><div class="line">{}</div></div><!-- fragment --><p>Next the actual integrator on each cell. We solve a Poisson problem with a coefficient one in the right half plane and one tenth in the left half plane.</p>
<p>The <a class="el" href="classMeshWorker_1_1LocalResults.html">MeshWorker::LocalResults</a> base class of <a class="el" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo</a> contains objects that can be filled in this local integrator. How many objects are created is determined inside the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework by the assembler class. Here, we test for instance that one matrix is required (<a class="el" href="classMeshWorker_1_1LocalResults.html#ac63bee72524d6f8c064b23e3ccb576af">MeshWorker::LocalResults::n_matrices()</a>). The matrices are accessed through <a class="el" href="classMeshWorker_1_1LocalResults.html#a06c5d817ce47a4c26966df1cdcebeac4">MeshWorker::LocalResults::matrix()</a>, which takes the number of the matrix as its first argument. The second argument is only used for integrals over faces when there are two matrices for each test function used. Then, a second matrix with indicator 'true' would exist with the same index.</p>
<p><a class="el" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo</a> provides one or several <a class="el" href="classFEValues.html">FEValues</a> objects, which below are used by <a class="el" href="namespaceLocalIntegrators_1_1Laplace.html#a733b581e72bfe9d27cc59501a35bcd30">LocalIntegrators::Laplace::cell_matrix()</a> or <a class="el" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">LocalIntegrators::L2::L2()</a>. Since we are assembling only a single PDE, there is also only one of these objects with index zero.</p>
<p>In addition, we note that this integrator serves to compute the matrices for the multilevel preconditioner as well as the matrix and the right hand side for the global system. Since the assembler for a system requires an additional vector, <a class="el" href="classMeshWorker_1_1LocalResults.html#a18a21989c69233694473c643d44df24f">MeshWorker::LocalResults::n_vectors()</a> is returning a nonzero value. Accordingly, we fill a right hand side vector at the end of this function. Since LocalResults can deal with several <a class="el" href="classBlockVector.html">BlockVector</a> objects, but we are again in the simplest case here, we enter the information into block zero of vector zero.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">LaplaceIntegrator&lt;dim&gt;::cell(MeshWorker::DoFInfo&lt;dim&gt; &amp;        dinfo,</div><div class="line">                             <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac63bee72524d6f8c064b23e3ccb576af">n_matrices</a>(), 1);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient = (dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;center()(0) &gt; 0.) ? .1 : 1.;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#a733b581e72bfe9d27cc59501a35bcd30">LocalIntegrators::Laplace::cell_matrix</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a06c5d817ce47a4c26966df1cdcebeac4">matrix</a>(0, <span class="keyword">false</span>).matrix,</div><div class="line">                                         info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div><div class="line">                                         coefficient);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a18a21989c69233694473c643d44df24f">n_vectors</a>() &gt; 0)</div><div class="line">    {</div><div class="line">      std::vector&lt;double&gt; rhs(info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0).n_quadrature_points, 1.);</div><div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">LocalIntegrators::L2::L2</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a13d325f993aa366ce5f837f37d96a90b">vector</a>(0).block(0),</div><div class="line">                               info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div><div class="line">                               rhs);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceProblemcodeclasstemplate"></a> </p><h3>The <code>LaplaceProblem</code> class template</h3>
<p>This main class is basically the same class as in <a class="el" href="step_6.html">step-6</a>. As far as member functions is concerned, the only addition is the <code>assemble_multigrid</code> function that assembles the matrices that correspond to the discrete operators on intermediate levels:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>LaplaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_multigrid();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> refine_grid();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div></div><!-- fragment --><p>The following members are the essential data structures for the multigrid method. The first two represent the sparsity patterns and the matrices on individual levels of the multilevel hierarchy, very much like the objects for the global mesh above.</p>
<p>Then we have two new matrices only needed for multigrid methods with local smoothing on adaptive meshes. They convey data between the interior part of the refined region and the refinement edge, as outlined in detail in the <a class="el" href="DEALGlossary.html#mg_paper">multigrid paper</a>.</p>
<p>The last object stores information about the boundary indices on each level and information about indices lying on a refinement edge between two different refinement levels. It thus serves a similar purpose as <a class="el" href="classAffineConstraints.html">AffineConstraints</a>, but on each level.</p>
<div class="fragment"><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a>      mg_sparsity_patterns;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_in;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_out;</div><div class="line">  <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a>                   mg_constrained_dofs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceProblemcodeclassimplementation"></a> </p><h3>The <code>LaplaceProblem</code> class implementation</h3>
<p>Just one short remark about the constructor of the <a class="el" href="classTriangulation.html">Triangulation</a>: by convention, all adaptively refined triangulations in deal.II never change by more than one level across a face between cells. For our multigrid algorithms, however, we need a slightly stricter guarantee, namely that the mesh also does not change by more than refinement level across vertices that might connect two cells. In other words, we must prevent the following situation:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt="limit_level_difference_at_vertices.png"/>
</div>
<p>This is achieved by passing the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">Triangulation::limit_level_difference_at_vertices</a> flag to the constructor of the triangulation class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">LaplaceProblem&lt;dim&gt;::LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">  , fe(degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , degree(degree)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsetup_system"></a> </p><h4>LaplaceProblem::setup_system</h4>
<p>In addition to just distributing the degrees of freedom in the <a class="el" href="classDoFHandler.html">DoFHandler</a>, we do the same on each level. Then, we follow the same procedure as before to set up the system on the leaf mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; (by level: &quot;</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.n_levels(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level)</div><div class="line">            &lt;&lt; (level == triangulation.n_levels() - 1 ? <span class="stringliteral">&quot;)&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>);</div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">  std::set&lt;types::boundary_id&gt; dirichlet_boundary_ids = {0};</div><div class="line">  <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> homogeneous_dirichlet_bc;</div><div class="line">  <span class="keyword">const</span> std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt;</div><div class="line">    dirichlet_boundary_functions = {</div><div class="line">      {<a class="code" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>(0), &amp;homogeneous_dirichlet_bc}};</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           dirichlet_boundary_functions,</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">condense</a>(dsp);</div><div class="line">  sparsity_pattern.copy_from(dsp);</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>The multigrid constraints have to be initialized. They need to know about the boundary values as well, so we pass the <code>dirichlet_boundary</code> here as well.</p>
<div class="fragment"><div class="line">mg_constrained_dofs.clear();</div><div class="line">mg_constrained_dofs.initialize(dof_handler);</div><div class="line">mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                   dirichlet_boundary_ids);</div></div><!-- fragment --><p>Now for the things that concern the multigrid data structures. First, we resize the multilevel objects to hold matrices and sparsity patterns for every level. The coarse level is zero (this is mandatory right now but may change in a future revision). Note that these functions take a complete, inclusive range here (not a starting index and size), so the finest level is <code>n_levels-1</code>. We first have to resize the container holding the <a class="el" href="classSparseMatrix.html">SparseMatrix</a> classes, since they have to release their <a class="el" href="classSparsityPattern.html">SparsityPattern</a> before the can be destroyed upon resizing.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">mg_interface_in.resize(0, n_levels - 1);</div><div class="line">mg_interface_in.clear_elements();</div><div class="line">mg_interface_out.resize(0, n_levels - 1);</div><div class="line">mg_interface_out.clear_elements();</div><div class="line">mg_matrices.resize(0, n_levels - 1);</div><div class="line">mg_matrices.clear_elements();</div><div class="line">mg_sparsity_patterns.resize(0, n_levels - 1);</div></div><!-- fragment --><p>Now, we have to provide a matrix on each level. To this end, we first use the <a class="el" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a> function to generate a preliminary compressed sparsity pattern on each level (see the <a class="el" href="group__Sparsity.html">Sparsity patterns</a> module for more information on this topic) and then copy it over to the one we really want. The next step is to initialize both kinds of level matrices with these sparsity patterns.</p>
<p>It may be worth pointing out that the interface matrices only have entries for degrees of freedom that sit at or next to the interface between coarser and finer levels of the mesh. They are therefore even sparser than the matrices on the individual levels of our multigrid hierarchy. If we were more concerned about memory usage (and possibly the speed with which we can multiply with these matrices), we should use separate and different sparsity patterns for these two kinds of matrices.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                 dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">      <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line"></div><div class="line">      mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line"></div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">      mg_interface_in[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">      mg_interface_out[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_system"></a> </p><h4>LaplaceProblem::assemble_system</h4>
<p>The following function assembles the linear system on the finest level of the mesh. Since we want to reuse the code here for the level assembling below, we use the local integrator class LaplaceIntegrator and leave the loops to the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework. Thus, this function first sets up the objects necessary for this framework, namely</p><ul>
<li>a <a class="el" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox</a> object, which will provide all the required data in quadrature points on the cell. This object can be seen as an extension of <a class="el" href="classFEValues.html">FEValues</a>, providing a lot more useful information,</li>
<li>a <a class="el" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo</a> object, which on the one hand side extends the functionality of cell iterators, but also provides space for return values in its base class LocalResults,</li>
<li>an assembler, in this case for the whole system. The term 'simple' here refers to the fact that the global system does not have a block structure,</li>
<li>the local integrator, which implements the actual forms.</li>
</ul>
<p>After the loop has combined all of these into a matrix and a right hand side, there is one thing left to do: the assemblers leave matrix rows and columns of constrained degrees of freedom untouched. Therefore, we put a one on the diagonal to make the whole system well posed. The value one, or any fixed value has the advantage, that its effect on the spectrum of the matrix is easily understood. Since the corresponding eigenvectors form an invariant subspace, the value chosen does not affect the convergence of Krylov space solvers.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>                      mapping;</div><div class="line">  <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">  <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>                         update_flags =</div><div class="line">    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a>;</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">  MeshWorker::DoFInfo&lt;dim&gt; dof_info(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html">MeshWorker::Assembler::SystemSimple&lt;SparseMatrix&lt;double&gt;</a>, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt;</div><div class="line">    assembler;</div><div class="line">  assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html#abcc84b6bcef2300bcab47448c9289da7">initialize</a>(constraints);</div><div class="line">  assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html#abcc84b6bcef2300bcab47448c9289da7">initialize</a>(system_matrix, system_rhs);</div><div class="line"></div><div class="line">  LaplaceIntegrator&lt;dim&gt; matrix_integrator;</div><div class="line">  MeshWorker::integration_loop&lt;dim, dim&gt;(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                                         dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                                         dof_info,</div><div class="line">                                         info_box,</div><div class="line">                                         matrix_integrator,</div><div class="line">                                         assembler);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (constraints.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(i))</div><div class="line">      system_matrix.set(i, i, 1.);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_multigrid"></a> </p><h4>LaplaceProblem::assemble_multigrid</h4>
<p>The next function is the one that builds the linear operators (matrices) that define the multigrid method on each level of the mesh. The integration core is the same as above, but the loop below will go over all existing cells instead of just the active ones, and the results must be entered into the correct level matrices. Fortunately, <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> hides most of that from us, and thus the difference between this function and the previous lies only in the setup of the assembler and the different iterators in the loop. Also, fixing up the matrices in the end is a little more complicated.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid()</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>                      mapping;</div><div class="line">  <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">  <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>                         update_flags =</div><div class="line">    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a>;</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">  MeshWorker::DoFInfo&lt;dim&gt; dof_info(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html">MeshWorker::Assembler::MGMatrixSimple&lt;SparseMatrix&lt;double&gt;</a>&gt; assembler;</div><div class="line">  assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#aba020fe5832606b5a7ec4c3c54526adb">initialize</a>(mg_constrained_dofs);</div><div class="line">  assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#aba020fe5832606b5a7ec4c3c54526adb">initialize</a>(mg_matrices);</div><div class="line">  assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#a2509230e8e7076a818fb0e8a774dae40">initialize_interfaces</a>(mg_interface_in, mg_interface_out);</div><div class="line"></div><div class="line">  LaplaceIntegrator&lt;dim&gt; matrix_integrator;</div><div class="line">  MeshWorker::integration_loop&lt;dim, dim&gt;(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                                         dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                                         dof_info,</div><div class="line">                                         info_box,</div><div class="line">                                         matrix_integrator,</div><div class="line">                                         assembler);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.n_levels();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level); ++i)</div><div class="line">        <span class="keywordflow">if</span> (mg_constrained_dofs.is_boundary_index(level, i) ||</div><div class="line">            mg_constrained_dofs.at_refinement_edge(level, i))</div><div class="line">          mg_matrices[level].<span class="keyword">set</span>(i, i, 1.);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsolve"></a> </p><h4>LaplaceProblem::solve</h4>
<p>This is the other function that is significantly different in support of the multigrid solver (or, in fact, the preconditioner for which we use the multigrid method).</p>
<p>Let us start out by setting up two of the components of multilevel methods: transfer operators between levels, and a solver on the coarsest level. In finite element methods, the transfer operators are derived from the finite element function spaces involved and can often be computed in a generic way independent of the problem under consideration. In that case, we can use the <a class="el" href="classMGTransferPrebuilt.html">MGTransferPrebuilt</a> class that, given the constraints of the final linear system and the <a class="el" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> object that knows about the boundary conditions on the each level and the degrees of freedom on interfaces between different refinement level can build the matrices for those transfer operations from a <a class="el" href="classDoFHandler.html">DoFHandler</a> object with level degrees of freedom.</p>
<p>The second part of the following lines deals with the coarse grid solver. Since our coarse grid is very coarse indeed, we decide for a direct solver (a <a class="el" href="classHouseholder.html">Householder</a> decomposition of the coarsest level matrix), even if its implementation is not particularly sophisticated. If our coarse mesh had many more cells than the five we have here, something better suited would obviously be necessary here.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt; mg_transfer(mg_constrained_dofs);</div><div class="line">  mg_transfer.build(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">  coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">  <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">  coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div></div><!-- fragment --><p>The next component of a multilevel solver or preconditioner is that we need a smoother on each level. A common choice for this is to use the application of a relaxation method (such as the SOR, Jacobi or Richardson method) or a small number of iterations of a solver method (such as CG or GMRES). The <a class="el" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a> and <a class="el" href="classMGSmootherPrecondition.html">MGSmootherPrecondition</a> classes provide support for these two kinds of smoothers. Here, we opt for the application of a single SOR iteration. To this end, we define an appropriate alias and then setup a smoother object.</p>
<p>The last step is to initialize the smoother object with our level matrices and to set some smoothing parameters. The <code>initialize()</code> function can optionally take additional arguments that will be passed to the smoother object on each level. In the current case for the SOR smoother, this could, for example, include a relaxation parameter. However, we here leave these at their default values. The call to <code>set_steps()</code> indicates that we will use two pre- and two post-smoothing steps on each level; to use a variable number of smoother steps on different levels, more options can be set in the constructor call to the <code>mg_smoother</code> object.</p>
<p>The last step results from the fact that we use the SOR method as a smoother - which is not symmetric - but we use the conjugate gradient iteration (which requires a symmetric preconditioner) below, we need to let the multilevel preconditioner make sure that we get a symmetric operator even for nonsymmetric smoothers:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line"><a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation&lt;Smoother, Vector&lt;double&gt;</a>&gt; mg_smoother;</div><div class="line">mg_smoother.<a class="code" href="classmg_1_1SmootherRelaxation.html#ae9e03c626c50a1b13dffe338f5f977b0">initialize</a>(mg_matrices);</div><div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(2);</div><div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#abed2837ee4e224f94c6a98405906df8f">set_symmetric</a>(<span class="keyword">true</span>);</div></div><!-- fragment --><p>The next preparatory step is that we must wrap our level and interface matrices in an object having the required multiplication functions. We will create two objects for the interface objects going from coarse to fine and the other way around; the multigrid algorithm will later use the transpose operator for the latter operation, allowing us to initialize both up and down versions of the operator with the matrices we already built:</p>
<div class="fragment"><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix(mg_matrices);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_up(mg_interface_in);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_down(mg_interface_out);</div></div><!-- fragment --><p>Now, we are ready to set up the V-cycle operator and the multilevel preconditioner.</p>
<div class="fragment"><div class="line"><a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">  mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);</div><div class="line"><a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_down, mg_interface_up);</div><div class="line"></div><div class="line"><a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt;&gt;</div><div class="line">  preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div></div><!-- fragment --><p>With all this together, we can finally get about solving the linear system in the usual way:</p>
<div class="fragment"><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">  solution = 0;</div><div class="line"></div><div class="line">  solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Postprocessing"></a> </p><h4>Postprocessing</h4>
<p>The following two functions postprocess a solution once it is computed. In particular, the first one refines the mesh at the beginning of each cycle while the second one outputs results at the end of each such cycle. The functions are almost unchanged from those in <a class="el" href="step_6.html">step-6</a>, with the exception of one minor difference: we generate output in VTK format, to use the more modern visualization programs available today compared to those that were available when <a class="el" href="step_6.html">step-6</a> was written.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::refine_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">    solution,</div><div class="line">    estimated_error_per_cell);</div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.03);</div><div class="line">  triangulation.execute_coarsening_and_refinement();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemrun"></a> </p><h4>LaplaceProblem::run</h4>
<p>Like several of the functions above, this is almost exactly a copy of the corresponding function in <a class="el" href="step_6.html">step-6</a>. The only difference is the call to <code>assemble_multigrid</code> that takes care of forming the matrices on every level that we need in the multigrid method.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 8; ++cycle)</div><div class="line">      {</div><div class="line">        <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">            triangulation.refine_global(1);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid();</div><div class="line"></div><div class="line">        <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">                &lt;&lt; triangulation.n_active_cells() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line">        assemble_multigrid();</div><div class="line"></div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step16</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>This is again the same function as in <a class="el" href="step_6.html">step-6</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step16;</div><div class="line"></div><div class="line">      <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(2);</div><div class="line"></div><div class="line">      LaplaceProblem&lt;2&gt; laplace_problem(1);</div><div class="line">      laplace_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>As in <a class="el" href="step_16.html">step-16</a>, the solution looks like this on the finest mesh:</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-16.solution.png"/>
</div>
 <p>The output is formatted in a slightly different way compared to <a class="el" href="step_16.html">step-16</a> but is functionally the same and shows the same convergence properties: </p><pre>
DEAL::Cycle 0
DEAL::   Number of active cells:       20
DEAL::   Number of degrees of freedom: 25 (by level: 8, 25)
DEAL:cg::Starting value 0.510691
DEAL:cg::Convergence step 6 value 4.59193e-14
DEAL::Cycle 1
DEAL::   Number of active cells:       44
DEAL::   Number of degrees of freedom: 55 (by level: 8, 25, 45)
DEAL:cg::Starting value 0.440678
DEAL:cg::Convergence step 8 value 1.99419e-13
DEAL::Cycle 2
DEAL::   Number of active cells:       86
DEAL::   Number of degrees of freedom: 105 (by level: 8, 25, 69, 49)
DEAL:cg::Starting value 0.371855
DEAL:cg::Convergence step 9 value 1.13984e-13
DEAL::Cycle 3
DEAL::   Number of active cells:       170
DEAL::   Number of degrees of freedom: 200 (by level: 8, 25, 77, 174)
DEAL:cg::Starting value 0.318967
DEAL:cg::Convergence step 9 value 2.62112e-13
DEAL::Cycle 4
DEAL::   Number of active cells:       332
DEAL::   Number of degrees of freedom: 388 (by level: 8, 25, 86, 231, 204)
DEAL:cg::Starting value 0.276534
DEAL:cg::Convergence step 10 value 1.69562e-13
DEAL::Cycle 5
DEAL::   Number of active cells:       632
DEAL::   Number of degrees of freedom: 714 (by level: 8, 25, 89, 231, 514, 141)
DEAL:cg::Starting value 0.215300
DEAL:cg::Convergence step 10 value 6.47463e-13
DEAL::Cycle 6
DEAL::   Number of active cells:       1202
DEAL::   Number of degrees of freedom: 1332 (by level: 8, 25, 89, 282, 771, 435, 257)
DEAL:cg::Starting value 0.175848
DEAL:cg::Convergence step 10 value 1.80664e-13
DEAL::Cycle 7
DEAL::   Number of active cells:       2288
DEAL::   Number of degrees of freedom: 2511 (by level: 8, 25, 89, 318, 779, 1420, 829, 30)
DEAL:cg::Starting value 0.136724
DEAL:cg::Convergence step 11 value 9.73331e-14
</pre><p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2003 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Guido Kanschat, University of Heidelberg, 2003</span></div><div class="line"><span class="comment"> *          Baerbel Janssen, University of Heidelberg, 2010</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University, 2010</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="meshworker_2dof__info_8h.html">deal.II/meshworker/dof_info.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integration__info_8h.html">deal.II/meshworker/integration_info.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="simple_8h.html">deal.II/meshworker/simple.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="output_8h.html">deal.II/meshworker/output.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="loop_8h.html">deal.II/meshworker/loop.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="laplace_8h.html">deal.II/integrators/laplace.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="l2_8h.html">deal.II/integrators/l2.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step16</div><div class="line">{</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceIntegrator : <span class="keyword">public</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceIntegrator();</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> cell(MeshWorker::DoFInfo&lt;dim&gt; &amp;        dinfo,</div><div class="line">                      <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceIntegrator&lt;dim&gt;::LaplaceIntegrator()</div><div class="line">    : <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::LocalIntegrator&lt;dim&gt;(true, false, false)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  LaplaceIntegrator&lt;dim&gt;::cell(MeshWorker::DoFInfo&lt;dim&gt; &amp;        dinfo,</div><div class="line">                               <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac63bee72524d6f8c064b23e3ccb576af">n_matrices</a>(), 1);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient = (dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;center()(0) &gt; 0.) ? .1 : 1.;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#a733b581e72bfe9d27cc59501a35bcd30">LocalIntegrators::Laplace::cell_matrix</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a06c5d817ce47a4c26966df1cdcebeac4">matrix</a>(0, <span class="keyword">false</span>).matrix,</div><div class="line">                                           info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div><div class="line">                                           coefficient);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a18a21989c69233694473c643d44df24f">n_vectors</a>() &gt; 0)</div><div class="line">      {</div><div class="line">        std::vector&lt;double&gt; rhs(info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0).n_quadrature_points, 1.);</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">LocalIntegrators::L2::L2</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a13d325f993aa366ce5f837f37d96a90b">vector</a>(0).block(0),</div><div class="line">                                 info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div><div class="line">                                 rhs);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_multigrid();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> refine_grid();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a>      mg_sparsity_patterns;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_in;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_out;</div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a>                   mg_constrained_dofs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceProblem&lt;dim&gt;::LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">    , fe(degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , degree(degree)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (by level: &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.n_levels(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level)</div><div class="line">              &lt;&lt; (level == triangulation.n_levels() - 1 ? <span class="stringliteral">&quot;)&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>);</div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt; dirichlet_boundary_ids = {0};</div><div class="line">    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> homogeneous_dirichlet_bc;</div><div class="line">    <span class="keyword">const</span> std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt;</div><div class="line">      dirichlet_boundary_functions = {</div><div class="line">        {<a class="code" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>(0), &amp;homogeneous_dirichlet_bc}};</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             dirichlet_boundary_functions,</div><div class="line">                                             constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">condense</a>(dsp);</div><div class="line">    sparsity_pattern.copy_from(dsp);</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    mg_constrained_dofs.clear();</div><div class="line">    mg_constrained_dofs.initialize(dof_handler);</div><div class="line">    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                       dirichlet_boundary_ids);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">    mg_interface_in.resize(0, n_levels - 1);</div><div class="line">    mg_interface_in.clear_elements();</div><div class="line">    mg_interface_out.resize(0, n_levels - 1);</div><div class="line">    mg_interface_out.clear_elements();</div><div class="line">    mg_matrices.resize(0, n_levels - 1);</div><div class="line">    mg_matrices.clear_elements();</div><div class="line">    mg_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                   dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">        <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line"></div><div class="line">        mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line"></div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">        mg_interface_in[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">        mg_interface_out[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>                      mapping;</div><div class="line">    <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">    <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>                         update_flags =</div><div class="line">      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a>;</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">    MeshWorker::DoFInfo&lt;dim&gt; dof_info(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html">MeshWorker::Assembler::SystemSimple&lt;SparseMatrix&lt;double&gt;</a>, Vector&lt;double&gt;&gt;</div><div class="line">      assembler;</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html#abcc84b6bcef2300bcab47448c9289da7">initialize</a>(constraints);</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html#abcc84b6bcef2300bcab47448c9289da7">initialize</a>(system_matrix, system_rhs);</div><div class="line"></div><div class="line">    LaplaceIntegrator&lt;dim&gt; matrix_integrator;</div><div class="line">    MeshWorker::integration_loop&lt;dim, dim&gt;(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                                           dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                                           dof_info,</div><div class="line">                                           info_box,</div><div class="line">                                           matrix_integrator,</div><div class="line">                                           assembler);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (constraints.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(i))</div><div class="line">        system_matrix.set(i, i, 1.);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>                      mapping;</div><div class="line">    <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">    <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>                         update_flags =</div><div class="line">      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a>;</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">    MeshWorker::DoFInfo&lt;dim&gt; dof_info(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html">MeshWorker::Assembler::MGMatrixSimple&lt;SparseMatrix&lt;double&gt;</a>&gt; assembler;</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#aba020fe5832606b5a7ec4c3c54526adb">initialize</a>(mg_constrained_dofs);</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#aba020fe5832606b5a7ec4c3c54526adb">initialize</a>(mg_matrices);</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#a2509230e8e7076a818fb0e8a774dae40">initialize_interfaces</a>(mg_interface_in, mg_interface_out);</div><div class="line"></div><div class="line">    LaplaceIntegrator&lt;dim&gt; matrix_integrator;</div><div class="line">    MeshWorker::integration_loop&lt;dim, dim&gt;(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                                           dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                                           dof_info,</div><div class="line">                                           info_box,</div><div class="line">                                           matrix_integrator,</div><div class="line">                                           assembler);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.n_levels();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level); ++i)</div><div class="line">          <span class="keywordflow">if</span> (mg_constrained_dofs.is_boundary_index(level, i) ||</div><div class="line">              mg_constrained_dofs.at_refinement_edge(level, i))</div><div class="line">            mg_matrices[level].<span class="keyword">set</span>(i, i, 1.);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt; mg_transfer(mg_constrained_dofs);</div><div class="line">    mg_transfer.build(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">    coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">    <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">    coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div><div class="line"></div><div class="line">    <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line">    <a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation&lt;Smoother, Vector&lt;double&gt;</a>&gt; mg_smoother;</div><div class="line">    mg_smoother.<a class="code" href="classmg_1_1SmootherRelaxation.html#ae9e03c626c50a1b13dffe338f5f977b0">initialize</a>(mg_matrices);</div><div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(2);</div><div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#abed2837ee4e224f94c6a98405906df8f">set_symmetric</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix(mg_matrices);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_up(mg_interface_in);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_down(mg_interface_out);</div><div class="line"></div><div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">      mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);</div><div class="line">    <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_down, mg_interface_up);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt;&gt;</div><div class="line">      preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">    solution = 0;</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::refine_grid()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line">    triangulation.execute_coarsening_and_refinement();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 8; ++cycle)</div><div class="line">      {</div><div class="line">        <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">            triangulation.refine_global(1);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid();</div><div class="line"></div><div class="line">        <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">                &lt;&lt; triangulation.n_active_cells() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line">        assemble_multigrid();</div><div class="line"></div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step16</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step16;</div><div class="line"></div><div class="line">      <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(2);</div><div class="line"></div><div class="line">      LaplaceProblem&lt;2&gt; laplace_problem(1);</div><div class="line">      laplace_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_16.html">step-16</a> . <table class="tutorial"
 width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#Thetestcase">The testcase</a><a href="#Thetestcase">The
 testcase</a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Includefiles">Include files</a><a
 href="#Includefiles">Include files</a>
 <li><a href="#Theintegratoroneachcell">The integrator on each cell</a><a
 href="#Theintegratoroneachcell">The integrator on each cell</a>
 <li><a href="#ThecodeLaplaceProblemcodeclasstemplate">The
 <code>LaplaceProblem</code> class template</a><a
 href="#ThecodeLaplaceProblemcodeclasstemplate">The
 <code>LaplaceProblem</code> class template</a>
 <li><a href="#ThecodeLaplaceProblemcodeclassimplementation">The
 <code>LaplaceProblem</code> class implementation</a><a
 href="#ThecodeLaplaceProblemcodeclassimplementation">The
 <code>LaplaceProblem</code> class implementation</a>
 <ul>
 <li><a
 href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a><a
 href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a>
 <li><a
 href="#LaplaceProblemassemble_system">LaplaceProblem::assemble_system</a><a
 href="#LaplaceProblemassemble_system">LaplaceProblem::assemble_system</a>
 <li><a
 href="#LaplaceProblemassemble_multigrid">LaplaceProblem::assemble_multigrid</a><a
 href="#LaplaceProblemassemble_multigrid">LaplaceProblem::assemble_multigrid</a>
 <li><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a><a
 href="#LaplaceProblemsolve">LaplaceProblem::solve</a>
 <li><a href="#Postprocessing">Postprocessing</a><a
 href="#Postprocessing">Postprocessing</a>
 <li><a href="#LaplaceProblemrun">LaplaceProblem::run</a><a
 href="#LaplaceProblemrun">LaplaceProblem::run</a>
 </ul>
 <li><a href="#Themainfunction">The main() function</a><a
 href="#Themainfunction">The main() function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <br />
 <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This is a variant of <a class="el" href="step_16.html">step-16</a> with the only change that we are using theMeshWorker framework with the pre-made LocalIntegrator helper classes insteadof manually assembling the matrices. The details of this framework on how it is used in practice will be explainedas part of this tutorial program. <a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>The problem we solve here is the same as the one in <a class="el" href="step_16.html">step-16</a> .</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Again, the first few include files are already known, so we won't comment on them:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div></div><!-- fragment --><p>These, now, are the include necessary for the multilevel methods. The first one declares how to handle Dirichlet boundary conditions on each of the levels of the multigrid method. For the actual description of the degrees of freedom, we do not need any new include file because <a class="el" href="classDoFHandler.html">DoFHandler</a> already has all necessary methods implemented. We will only need to distribute the DoFs for the levels further down.</p>
<p>The rest of the include files deals with the mechanics of multigrid as a linear operator (solver or preconditioner).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div></div><!-- fragment --><p>Finally we include the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework. This framework through its function <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> and <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">integration_loop()</a>, automates loops over cells and assembling of data into vectors, matrices, etc. It obeys constraints automatically. Since we have to build several matrices and have to be aware of several sets of constraints, this will save us a lot of headache.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="meshworker_2dof__info_8h.html">deal.II/meshworker/dof_info.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integration__info_8h.html">deal.II/meshworker/integration_info.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="simple_8h.html">deal.II/meshworker/simple.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="output_8h.html">deal.II/meshworker/output.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="loop_8h.html">deal.II/meshworker/loop.h</a>&gt;</span></div></div><!-- fragment --><p>In order to save effort, we use the pre-implemented Laplacian found in</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="laplace_8h.html">deal.II/integrators/laplace.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="l2_8h.html">deal.II/integrators/l2.h</a>&gt;</span></div></div><!-- fragment --><p>This is C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step16</div><div class="line">{</div></div><!-- fragment --><p><a class="anchor" id="Theintegratoroneachcell"></a> </p><h3>The integrator on each cell</h3>
<p>The <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">MeshWorker::integration_loop()</a> expects a class that provides functions for integration on cells and boundary and interior faces. This is done by the following class. In the constructor, we tell the loop that cell integrals should be computed (the 'true'), but integrals should not be computed on boundary and interior faces (the two 'false'). Accordingly, we only need a cell function, but none for the faces.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>LaplaceIntegrator : <span class="keyword">public</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LaplaceIntegrator();</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html#a44cc05e3e905a8cd5af4c12d3026ea2a">cell</a>(MeshWorker::DoFInfo&lt;dim&gt; &amp;        dinfo,</div><div class="line">                    <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">LaplaceIntegrator&lt;dim&gt;::LaplaceIntegrator()</div><div class="line">  : <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::LocalIntegrator&lt;dim&gt;(true, false, false)</div><div class="line">{}</div></div><!-- fragment --><p>Next the actual integrator on each cell. We solve a Poisson problem with a coefficient one in the right half plane and one tenth in the left half plane.</p>
<p>The <a class="el" href="classMeshWorker_1_1LocalResults.html">MeshWorker::LocalResults</a> base class of <a class="el" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo</a> contains objects that can be filled in this local integrator. How many objects are created is determined inside the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework by the assembler class. Here, we test for instance that one matrix is required (<a class="el" href="classMeshWorker_1_1LocalResults.html#ac63bee72524d6f8c064b23e3ccb576af">MeshWorker::LocalResults::n_matrices()</a>). The matrices are accessed through <a class="el" href="classMeshWorker_1_1LocalResults.html#a06c5d817ce47a4c26966df1cdcebeac4">MeshWorker::LocalResults::matrix()</a>, which takes the number of the matrix as its first argument. The second argument is only used for integrals over faces when there are two matrices for each test function used. Then, a second matrix with indicator 'true' would exist with the same index.</p>
<p><a class="el" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo</a> provides one or several <a class="el" href="classFEValues.html">FEValues</a> objects, which below are used by <a class="el" href="namespaceLocalIntegrators_1_1Laplace.html#a733b581e72bfe9d27cc59501a35bcd30">LocalIntegrators::Laplace::cell_matrix()</a> or <a class="el" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">LocalIntegrators::L2::L2()</a>. Since we are assembling only a single PDE, there is also only one of these objects with index zero.</p>
<p>In addition, we note that this integrator serves to compute the matrices for the multilevel preconditioner as well as the matrix and the right hand side for the global system. Since the assembler for a system requires an additional vector, <a class="el" href="classMeshWorker_1_1LocalResults.html#a18a21989c69233694473c643d44df24f">MeshWorker::LocalResults::n_vectors()</a> is returning a nonzero value. Accordingly, we fill a right hand side vector at the end of this function. Since LocalResults can deal with several <a class="el" href="classBlockVector.html">BlockVector</a> objects, but we are again in the simplest case here, we enter the information into block zero of vector zero.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">LaplaceIntegrator&lt;dim&gt;::cell(MeshWorker::DoFInfo&lt;dim&gt; &amp;        dinfo,</div><div class="line">                             <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac63bee72524d6f8c064b23e3ccb576af">n_matrices</a>(), 1);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient = (dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;center()(0) &gt; 0.) ? .1 : 1.;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#a733b581e72bfe9d27cc59501a35bcd30">LocalIntegrators::Laplace::cell_matrix</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a06c5d817ce47a4c26966df1cdcebeac4">matrix</a>(0, <span class="keyword">false</span>).matrix,</div><div class="line">                                         info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div><div class="line">                                         coefficient);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a18a21989c69233694473c643d44df24f">n_vectors</a>() &gt; 0)</div><div class="line">    {</div><div class="line">      std::vector&lt;double&gt; rhs(info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0).n_quadrature_points, 1.);</div><div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">LocalIntegrators::L2::L2</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a13d325f993aa366ce5f837f37d96a90b">vector</a>(0).block(0),</div><div class="line">                               info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div><div class="line">                               rhs);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceProblemcodeclasstemplate"></a> </p><h3>The <code>LaplaceProblem</code> class template</h3>
<p>This main class is basically the same class as in <a class="el" href="step_6.html">step-6</a> . As far as member functions is concerned, the only addition is the <code>assemble_multigrid</code> function that assembles the matrices that correspond to the discrete operators on intermediate levels:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>LaplaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_multigrid();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> refine_grid();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div></div><!-- fragment --><p>The following members are the essential data structures for the multigrid method. The first two represent the sparsity patterns and the matrices on individual levels of the multilevel hierarchy, very much like the objects for the global mesh above. Then we have two new matrices only needed for multigrid methods with local smoothing on adaptive meshes. They convey data between the interior part of the refined region and the refinement edge, as outlined in detail in the <a class="el" href="DEALGlossary.html#mg_paper">multigrid paper</a>. The last object stores information about the boundary indices on each level and information about indices lying on a refinement edge between two different refinement levels. It thus serves a similar purpose as <a class="el" href="classAffineConstraints.html">AffineConstraints</a>, but on each level.</p>
<div class="fragment"><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a>      mg_sparsity_patterns;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_in;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_out;</div><div class="line">  <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a>                   mg_constrained_dofs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceProblemcodeclassimplementation"></a> </p><h3>The <code>LaplaceProblem</code> class implementation</h3>
<p>Just one short remark about the constructor of the <a class="el" href="classTriangulation.html">Triangulation</a>: by convention, all adaptively refined triangulations in deal.II never change by more than one level across a face between cells. For our multigrid algorithms, however, we need a slightly stricter guarantee, namely that the mesh also does not change by more than refinement level across vertices that might connect two cells. In other words, we must prevent the following situation: </p><div class="image">
<img src="limit_level_difference_at_vertices.png" alt="limit_level_difference_at_vertices.png"/>
</div>
<p> This is achieved by passing the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">Triangulation::limit_level_difference_at_vertices</a> flag to the constructor of the triangulation class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">LaplaceProblem&lt;dim&gt;::LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">  , fe(degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , degree(degree)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsetup_system"></a> </p><h4>LaplaceProblem::setup_system</h4>
<p>In addition to just distributing the degrees of freedom in the <a class="el" href="classDoFHandler.html">DoFHandler</a>, we do the same on each level. Then, we follow the same procedure as before to set up the system on the leaf mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; (by level: &quot;</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.n_levels(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level)</div><div class="line">            &lt;&lt; (level == triangulation.n_levels()</div><div class="line"></div><div class="line">- 1 ? <span class="stringliteral">&quot;)&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>);</div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">  std::set&lt;types::boundary_id&gt; dirichlet_boundary_ids = {0};</div><div class="line">  <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> homogeneous_dirichlet_bc;</div><div class="line">  <span class="keyword">const</span> std::map&lt;types::boundary_id, const Function&lt;dim&gt;&gt;</div><div class="line">    dirichlet_boundary_functions = {</div><div class="line">      {<a class="code" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>(0), &amp;homogeneous_dirichlet_bc}};</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           dirichlet_boundary_functions,</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">condense</a>(dsp);</div><div class="line">  sparsity_pattern.copy_from(dsp);</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>The multigrid constraints have to be initialized. They need to know about the boundary values as well, so we pass the <code>dirichlet_boundary</code> here as well.</p>
<div class="fragment"><div class="line">mg_constrained_dofs.clear();</div><div class="line">mg_constrained_dofs.initialize(dof_handler);</div><div class="line">mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                   dirichlet_boundary_ids);</div></div><!-- fragment --><p>Now for the things that concern the multigrid data structures. First, we resize the multilevel objects to hold matrices and sparsity patterns for every level. The coarse level is zero (this is mandatory right now but may change in a future revision). Note that these functions take a complete, inclusive range here (not a starting index and size), so the finest level is <code>n_levels-1</code> . We first have to resize the container holding the <a class="el" href="classSparseMatrix.html">SparseMatrix</a> classes, since they have to release their <a class="el" href="classSparsityPattern.html">SparsityPattern</a> before the can be destroyed upon resizing.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">  mg_interface_in.resize(0, n_levels</div><div class="line"></div><div class="line">- 1);</div><div class="line">  mg_interface_in.clear_elements();</div><div class="line">  mg_interface_out.resize(0, n_levels</div><div class="line"></div><div class="line">- 1);</div><div class="line">  mg_interface_out.clear_elements();</div><div class="line">  mg_matrices.resize(0, n_levels</div><div class="line"></div><div class="line">- 1);</div><div class="line">  mg_matrices.clear_elements();</div><div class="line">  mg_sparsity_patterns.resize(0, n_levels</div><div class="line"></div><div class="line">- 1);</div></div><!-- fragment --><p>Now, we have to provide a matrix on each level. To this end, we first use the <a class="el" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a> function to generate a preliminary compressed sparsity pattern on each level (see the <a class="el" href="group__Sparsity.html">Sparsity patterns</a> module for more information on this topic) and then copy it over to the one we really want. The next step is to initialize both kinds of level matrices with these sparsity patterns. It may be worth pointing out that the interface matrices only have entries for degrees of freedom that sit at or next to the interface between coarser and finer levels of the mesh. They are therefore even sparser than the matrices on the individual levels of our multigrid hierarchy. If we were more concerned about memory usage (and possibly the speed with which we can multiply with these matrices), we should use separate and different sparsity patterns for these two kinds of matrices.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                 dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">      <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line"></div><div class="line">      mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line"></div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">      mg_interface_in[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">      mg_interface_out[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_system"></a> </p><h4>LaplaceProblem::assemble_system</h4>
<p>The following function assembles the linear system on the finest level of the mesh. Since we want to reuse the code here for the level assembling below, we use the local integrator class LaplaceIntegrator and leave the loops to the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework. Thus, this function first sets up the objects necessary for this framework, namely</p>
<ul>
<li>a <a class="el" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox</a> object, which will provide all the required data in quadrature points on the cell. This object can be seen as an extension of <a class="el" href="classFEValues.html">FEValues</a>, providing a lot more useful information,</li>
<li>a <a class="el" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo</a> object, which on the one hand side extends the functionality of cell iterators, but also provides space for return values in its base class LocalResults,</li>
<li>an assembler, in this case for the whole system. The term 'simple' here refers to the fact that the global system does not have a block structure,</li>
<li>the local integrator, which implements the actual forms. After the loop has combined all of these into a matrix and a right hand side, there is one thing left to do: the assemblers leave matrix rows and columns of constrained degrees of freedom untouched. Therefore, we put a one on the diagonal to make the whole system well posed. The value one, or any fixed value has the advantage, that its effect on the spectrum of the matrix is easily understood. Since the corresponding eigenvectors form an invariant subspace, the value chosen does not affect the convergence of Krylov space solvers.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>                      mapping;</div><div class="line">  <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">  <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>                         update_flags =</div><div class="line">    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a>;</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">  MeshWorker::DoFInfo&lt;dim&gt; dof_info(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html">MeshWorker::Assembler::SystemSimple&lt;SparseMatrix&lt;double&gt;</a>, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt;</div><div class="line">    assembler;</div><div class="line">  assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html#abcc84b6bcef2300bcab47448c9289da7">initialize</a>(constraints);</div><div class="line">  assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html#abcc84b6bcef2300bcab47448c9289da7">initialize</a>(system_matrix, system_rhs);</div><div class="line"></div><div class="line">  LaplaceIntegrator&lt;dim&gt; matrix_integrator;</div><div class="line">  MeshWorker::integration_loop&lt;dim, dim&gt;(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                                         dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                                         dof_info,</div><div class="line">                                         info_box,</div><div class="line">                                         matrix_integrator,</div><div class="line">                                         assembler);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (constraints.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(i))</div><div class="line">      system_matrix.set(i, i, 1.);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_multigrid"></a> </p><h4>LaplaceProblem::assemble_multigrid</h4>
<p>The next function is the one that builds the linear operators (matrices) that define the multigrid method on each level of the mesh. The integration core is the same as above, but the loop below will go over all existing cells instead of just the active ones, and the results must be entered into the correct level matrices. Fortunately, <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> hides most of that from us, and thus the difference between this function and the previous lies only in the setup of the assembler and the different iterators in the loop. Also, fixing up the matrices in the end is a little more complicated.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid()</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>                      mapping;</div><div class="line">  <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">  <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>                         update_flags =</div><div class="line">    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a>;</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">  MeshWorker::DoFInfo&lt;dim&gt; dof_info(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html">MeshWorker::Assembler::MGMatrixSimple&lt;SparseMatrix&lt;double&gt;</a>&gt; assembler;</div><div class="line">  assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#aba020fe5832606b5a7ec4c3c54526adb">initialize</a>(mg_constrained_dofs);</div><div class="line">  assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#aba020fe5832606b5a7ec4c3c54526adb">initialize</a>(mg_matrices);</div><div class="line">  assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#a2509230e8e7076a818fb0e8a774dae40">initialize_interfaces</a>(mg_interface_in, mg_interface_out);</div><div class="line"></div><div class="line">  LaplaceIntegrator&lt;dim&gt; matrix_integrator;</div><div class="line">  MeshWorker::integration_loop&lt;dim, dim&gt;(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                                         dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                                         dof_info,</div><div class="line">                                         info_box,</div><div class="line">                                         matrix_integrator,</div><div class="line">                                         assembler);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.n_levels();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level); ++i)</div><div class="line">        <span class="keywordflow">if</span> (mg_constrained_dofs.is_boundary_index(level, i) ||</div><div class="line">            mg_constrained_dofs.at_refinement_edge(level, i))</div><div class="line">          mg_matrices[level].<span class="keyword">set</span>(i, i, 1.);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsolve"></a> </p><h4>LaplaceProblem::solve</h4>
<p>This is the other function that is significantly different in support of the multigrid solver (or, in fact, the preconditioner for which we use the multigrid method). Let us start out by setting up two of the components of multilevel methods: transfer operators between levels, and a solver on the coarsest level. In finite element methods, the transfer operators are derived from the finite element function spaces involved and can often be computed in a generic way independent of the problem under consideration. In that case, we can use the <a class="el" href="classMGTransferPrebuilt.html">MGTransferPrebuilt</a> class that, given the constraints of the final linear system and the <a class="el" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> object that knows about the boundary conditions on the each level and the degrees of freedom on interfaces between different refinement level can build the matrices for those transfer operations from a <a class="el" href="classDoFHandler.html">DoFHandler</a> object with level degrees of freedom. The second part of the following lines deals with the coarse grid solver. Since our coarse grid is very coarse indeed, we decide for a direct solver (a <a class="el" href="classHouseholder.html">Householder</a> decomposition of the coarsest level matrix), even if its implementation is not particularly sophisticated. If our coarse mesh had many more cells than the five we have here, something better suited would obviously be necessary here.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt; mg_transfer(mg_constrained_dofs);</div><div class="line">  mg_transfer.build(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">  coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">  <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">  coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div></div><!-- fragment --><p>The next component of a multilevel solver or preconditioner is that we need a smoother on each level. A common choice for this is to use the application of a relaxation method (such as the SOR, Jacobi or Richardson method) or a small number of iterations of a solver method (such as CG or GMRES). The <a class="el" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a> and <a class="el" href="classMGSmootherPrecondition.html">MGSmootherPrecondition</a> classes provide support for these two kinds of smoothers. Here, we opt for the application of a single SOR iteration. To this end, we define an appropriate alias and then setup a smoother object. The last step is to initialize the smoother object with our level matrices and to set some smoothing parameters. The <code>initialize()</code> function can optionally take additional arguments that will be passed to the smoother object on each level. In the current case for the SOR smoother, this could, for example, include a relaxation parameter. However, we here leave these at their default values. The call to <code>set_steps()</code> indicates that we will use two pre- and two post-smoothing steps on each level; to use a variable number of smoother steps on different levels, more options can be set in the constructor call to the <code>mg_smoother</code> object. The last step results from the fact that we use the SOR method as a smoother</p>
<ul>
<li>which is not symmetric</li>
<li>but we use the conjugate gradient iteration (which requires a symmetric preconditioner) below, we need to let the multilevel preconditioner make sure that we get a symmetric operator even for nonsymmetric smoothers:</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line"><a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation&lt;Smoother, Vector&lt;double&gt;</a>&gt; mg_smoother;</div><div class="line">mg_smoother.<a class="code" href="classmg_1_1SmootherRelaxation.html#ae9e03c626c50a1b13dffe338f5f977b0">initialize</a>(mg_matrices);</div><div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(2);</div><div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#abed2837ee4e224f94c6a98405906df8f">set_symmetric</a>(<span class="keyword">true</span>);</div></div><!-- fragment --><p>The next preparatory step is that we must wrap our level and interface matrices in an object having the required multiplication functions. We will create two objects for the interface objects going from coarse to fine and the other way around; the multigrid algorithm will later use the transpose operator for the latter operation, allowing us to initialize both up and down versions of the operator with the matrices we already built:</p>
<div class="fragment"><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix(mg_matrices);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_up(mg_interface_in);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_down(mg_interface_out);</div></div><!-- fragment --><p>Now, we are ready to set up the V-cycle operator and the multilevel preconditioner.</p>
<div class="fragment"><div class="line"><a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">  mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);</div><div class="line"><a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_down, mg_interface_up);</div><div class="line"></div><div class="line"><a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt;&gt;</div><div class="line">  preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div></div><!-- fragment --><p>With all this together, we can finally get about solving the linear system in the usual way:</p>
<div class="fragment"><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">  solution = 0;</div><div class="line"></div><div class="line">  solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Postprocessing"></a> </p><h4>Postprocessing</h4>
<p>The following two functions postprocess a solution once it is computed. In particular, the first one refines the mesh at the beginning of each cycle while the second one outputs results at the end of each such cycle. The functions are almost unchanged from those in <a class="el" href="step_6.html">step-6</a> , with the exception of one minor difference: we generate output in VTK format, to use the more modern visualization programs available today compared to those that were available when <a class="el" href="step_6.html">step-6</a> was written.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::refine_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt;(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>&gt;(),</div><div class="line">    solution,</div><div class="line">    estimated_error_per_cell);</div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.03);</div><div class="line">  triangulation.execute_coarsening_and_refinement();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemrun"></a> </p><h4>LaplaceProblem::run</h4>
<p>Like several of the functions above, this is almost exactly a copy of the corresponding function in <a class="el" href="step_6.html">step-6</a> . The only difference is the call to <code>assemble_multigrid</code> that takes care of forming the matrices on every level that we need in the multigrid method.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 8; ++cycle)</div><div class="line">    {</div><div class="line">      <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">        {</div><div class="line">          <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">          triangulation.refine_global(1);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        refine_grid();</div><div class="line"></div><div class="line">      <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">              &lt;&lt; triangulation.n_active_cells() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      setup_system();</div><div class="line"></div><div class="line">      assemble_system();</div><div class="line">      assemble_multigrid();</div><div class="line"></div><div class="line">      solve();</div><div class="line">      output_results(cycle);</div><div class="line">    }</div><div class="line">}</div><div class="line">} <span class="comment">// namespace Step16</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>This is again the same function as in <a class="el" href="step_6.html">step-6</a> :</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    <span class="keyword">using namespace </span>Step16;</div><div class="line"></div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(2);</div><div class="line"></div><div class="line">    LaplaceProblem&lt;2&gt; laplace_problem(1);</div><div class="line">    laplace_problem.run();</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>As in <a class="el" href="step_16.html">step-16</a> , the solution looks like this on the finest mesh: </p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-16.solution.png"/>
</div>
 <p>The output is formatted in a slightly different way compared to <a class="el" href="step_16.html">step-16</a> but isfunctionally the same and shows the same convergence properties:</p><pre>  DEAL::Cycle   0DEAL::   Number of active cells:
 20DEAL::   Number of degrees of freedom: 25 (by level: 8, 25)
 DEAL:cg::Starting   value 0.510691  DEAL:cg::Convergence   step 6 value
 4.59193e-14  DEAL::Cycle   1DEAL::   Number of active cells:       44DEAL::
 Number of degrees of freedom: 55 (by level: 8, 25, 45)  DEAL:cg::Starting
 value 0.440678  DEAL:cg::Convergence   step 8 value 1.99419e-13
 DEAL::Cycle   2DEAL::   Number of active cells:       86DEAL::   Number of
 degrees of freedom: 105 (by level: 8, 25, 69, 49)  DEAL:cg::Starting
 value 0.371855  DEAL:cg::Convergence   step 9 value 1.13984e-13
 DEAL::Cycle   3DEAL::   Number of active cells:       170DEAL::   Number of
 degrees of freedom: 200 (by level: 8, 25, 77, 174)  DEAL:cg::Starting
 value 0.318967  DEAL:cg::Convergence   step 9 value 2.62112e-13
 DEAL::Cycle   4DEAL::   Number of active cells:       332DEAL::   Number of
 degrees of freedom: 388 (by level: 8, 25, 86, 231, 204)  DEAL:cg::Starting
 value 0.276534  DEAL:cg::Convergence   step 10 value 1.69562e-13
 DEAL::Cycle   5DEAL::   Number of active cells:       632DEAL::   Number of
 degrees of freedom: 714 (by level: 8, 25, 89, 231, 514, 141)
 DEAL:cg::Starting   value 0.215300  DEAL:cg::Convergence   step 10 value
 6.47463e-13  DEAL::Cycle   6DEAL::   Number of active cells:
 1202DEAL::   Number of degrees of freedom: 1332 (by level: 8, 25, 89, 282,
 771, 435, 257)  DEAL:cg::Starting   value 0.175848  DEAL:cg::Convergence
 step 10 value 1.80664e-13  DEAL::Cycle   7DEAL::   Number of active cells:
 2288DEAL::   Number of degrees of freedom: 2511 (by level: 8, 25, 89, 318,
 779, 1420, 829, 30)  DEAL:cg::Starting   value 0.136724
 DEAL:cg::Convergence   step 11 value 9.73331e-14</pre><p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2003 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Guido Kanschat, University of Heidelberg, 2003</span></div><div class="line"><span class="comment"> *          Baerbel Janssen, University of Heidelberg, 2010</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University, 2010</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="meshworker_2dof__info_8h.html">deal.II/meshworker/dof_info.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integration__info_8h.html">deal.II/meshworker/integration_info.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="simple_8h.html">deal.II/meshworker/simple.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="output_8h.html">deal.II/meshworker/output.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="loop_8h.html">deal.II/meshworker/loop.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="laplace_8h.html">deal.II/integrators/laplace.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="l2_8h.html">deal.II/integrators/l2.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step16</div><div class="line">{</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceIntegrator : <span class="keyword">public</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceIntegrator();</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> cell(MeshWorker::DoFInfo&lt;dim&gt; &amp;        dinfo,</div><div class="line">                      <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceIntegrator&lt;dim&gt;::LaplaceIntegrator()</div><div class="line">    : <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::LocalIntegrator&lt;dim&gt;(true, false, false)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  LaplaceIntegrator&lt;dim&gt;::cell(MeshWorker::DoFInfo&lt;dim&gt; &amp;        dinfo,</div><div class="line">                               <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac63bee72524d6f8c064b23e3ccb576af">n_matrices</a>(), 1);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient = (dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;center()(0) &gt; 0.) ? .1 : 1.;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#a733b581e72bfe9d27cc59501a35bcd30">LocalIntegrators::Laplace::cell_matrix</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a06c5d817ce47a4c26966df1cdcebeac4">matrix</a>(0, <span class="keyword">false</span>).matrix,</div><div class="line">                                           info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div><div class="line">                                           coefficient);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a18a21989c69233694473c643d44df24f">n_vectors</a>() &gt; 0)</div><div class="line">      {</div><div class="line">        std::vector&lt;double&gt; rhs(info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0).n_quadrature_points, 1.);</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">LocalIntegrators::L2::L2</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a13d325f993aa366ce5f837f37d96a90b">vector</a>(0).block(0),</div><div class="line">                                 info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div><div class="line">                                 rhs);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_multigrid();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> refine_grid();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a>      mg_sparsity_patterns;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_in;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_out;</div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a>                   mg_constrained_dofs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceProblem&lt;dim&gt;::LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">    , fe(degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , degree(degree)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (by level: &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.n_levels(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level)</div><div class="line">              &lt;&lt; (level == triangulation.n_levels() - 1 ? <span class="stringliteral">&quot;)&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>);</div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt; dirichlet_boundary_ids = {0};</div><div class="line">    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> homogeneous_dirichlet_bc;</div><div class="line">    <span class="keyword">const</span> std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt;</div><div class="line">      dirichlet_boundary_functions = {</div><div class="line">        {<a class="code" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>(0), &amp;homogeneous_dirichlet_bc}};</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             dirichlet_boundary_functions,</div><div class="line">                                             constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">condense</a>(dsp);</div><div class="line">    sparsity_pattern.copy_from(dsp);</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    mg_constrained_dofs.clear();</div><div class="line">    mg_constrained_dofs.initialize(dof_handler);</div><div class="line">    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                       dirichlet_boundary_ids);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">    mg_interface_in.resize(0, n_levels - 1);</div><div class="line">    mg_interface_in.clear_elements();</div><div class="line">    mg_interface_out.resize(0, n_levels - 1);</div><div class="line">    mg_interface_out.clear_elements();</div><div class="line">    mg_matrices.resize(0, n_levels - 1);</div><div class="line">    mg_matrices.clear_elements();</div><div class="line">    mg_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                   dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">        <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line"></div><div class="line">        mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line"></div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">        mg_interface_in[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">        mg_interface_out[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>                      mapping;</div><div class="line">    <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">    <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>                         update_flags =</div><div class="line">      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a>;</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">    MeshWorker::DoFInfo&lt;dim&gt; dof_info(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html">MeshWorker::Assembler::SystemSimple&lt;SparseMatrix&lt;double&gt;</a>, Vector&lt;double&gt;&gt;</div><div class="line">      assembler;</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html#abcc84b6bcef2300bcab47448c9289da7">initialize</a>(constraints);</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html#abcc84b6bcef2300bcab47448c9289da7">initialize</a>(system_matrix, system_rhs);</div><div class="line"></div><div class="line">    LaplaceIntegrator&lt;dim&gt; matrix_integrator;</div><div class="line">    MeshWorker::integration_loop&lt;dim, dim&gt;(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                                           dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                                           dof_info,</div><div class="line">                                           info_box,</div><div class="line">                                           matrix_integrator,</div><div class="line">                                           assembler);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (constraints.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(i))</div><div class="line">        system_matrix.set(i, i, 1.);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>                      mapping;</div><div class="line">    <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">    <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>                         update_flags =</div><div class="line">      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a>;</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">    MeshWorker::DoFInfo&lt;dim&gt; dof_info(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html">MeshWorker::Assembler::MGMatrixSimple&lt;SparseMatrix&lt;double&gt;</a>&gt; assembler;</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#aba020fe5832606b5a7ec4c3c54526adb">initialize</a>(mg_constrained_dofs);</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#aba020fe5832606b5a7ec4c3c54526adb">initialize</a>(mg_matrices);</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#a2509230e8e7076a818fb0e8a774dae40">initialize_interfaces</a>(mg_interface_in, mg_interface_out);</div><div class="line"></div><div class="line">    LaplaceIntegrator&lt;dim&gt; matrix_integrator;</div><div class="line">    MeshWorker::integration_loop&lt;dim, dim&gt;(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                                           dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                                           dof_info,</div><div class="line">                                           info_box,</div><div class="line">                                           matrix_integrator,</div><div class="line">                                           assembler);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.n_levels();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level); ++i)</div><div class="line">          <span class="keywordflow">if</span> (mg_constrained_dofs.is_boundary_index(level, i) ||</div><div class="line">              mg_constrained_dofs.at_refinement_edge(level, i))</div><div class="line">            mg_matrices[level].<span class="keyword">set</span>(i, i, 1.);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt; mg_transfer(mg_constrained_dofs);</div><div class="line">    mg_transfer.build(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">    coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">    <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">    coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div><div class="line"></div><div class="line">    <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line">    <a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation&lt;Smoother, Vector&lt;double&gt;</a>&gt; mg_smoother;</div><div class="line">    mg_smoother.<a class="code" href="classmg_1_1SmootherRelaxation.html#ae9e03c626c50a1b13dffe338f5f977b0">initialize</a>(mg_matrices);</div><div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(2);</div><div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#abed2837ee4e224f94c6a98405906df8f">set_symmetric</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix(mg_matrices);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_up(mg_interface_in);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_down(mg_interface_out);</div><div class="line"></div><div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">      mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);</div><div class="line">    <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_down, mg_interface_up);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt;&gt;</div><div class="line">      preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">    solution = 0;</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::refine_grid()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line">    triangulation.execute_coarsening_and_refinement();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 8; ++cycle)</div><div class="line">      {</div><div class="line">        <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">            triangulation.refine_global(1);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid();</div><div class="line"></div><div class="line">        <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">                &lt;&lt; triangulation.n_active_cells() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line">        assemble_multigrid();</div><div class="line"></div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step16</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step16;</div><div class="line"></div><div class="line">      <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(2);</div><div class="line"></div><div class="line">      LaplaceProblem&lt;2&gt; laplace_problem(1);</div><div class="line">      laplace_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_16.html">step-16</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thetestcase">The testcase</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Theintegratoroneachcell">The integrator on each cell</a>
        <li><a href="#ThecodeLaplaceProblemcodeclasstemplate">The <code>LaplaceProblem</code> class template</a>
        <li><a href="#ThecodeLaplaceProblemcodeclassimplementation">The <code>LaplaceProblem</code> class implementation</a>
      <ul>
        <li><a href="#LaplaceProblemsetup_system">LaplaceProblem::setup_system</a>
        <li><a href="#LaplaceProblemassemble_system">LaplaceProblem::assemble_system</a>
        <li><a href="#LaplaceProblemassemble_multigrid">LaplaceProblem::assemble_multigrid</a>
        <li><a href="#LaplaceProblemsolve">LaplaceProblem::solve</a>
        <li><a href="#Postprocessing">Postprocessing</a>
        <li><a href="#LaplaceProblemrun">LaplaceProblem::run</a>
      </ul>
        <li><a href="#Themainfunction">The main() function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-16b/doc/intro.dox</p>
<p><br />
</p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>这是第16步的一个变体，唯一的变化是我们使用MeshWorker框架和预制的LocalIntegrator辅助类，而不是手动组装矩阵。</p>
<p>关于这个框架在实践中如何使用的细节，将作为本教程计划的一部分加以解释。</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>我们在这里解决的问题与步骤16中的问题相同。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>Again, the first few include files are already known, so we won't comment on them:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div></div><!-- fragment --><p>These, now, are the include necessary for the multilevel methods. The first one declares how to handle Dirichlet boundary conditions on each of the levels of the multigrid method. For the actual description of the degrees of freedom, we do not need any new include file because <a class="el" href="classDoFHandler.html">DoFHandler</a> already has all necessary methods implemented. We will only need to distribute the DoFs for the levels further down.</p>
<p>The rest of the include files deals with the mechanics of multigrid as a linear operator (solver or preconditioner).</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div></div><!-- fragment --><p>Finally we include the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework. This framework through its function <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> and <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">integration_loop()</a>, automates loops over cells and assembling of data into vectors, matrices, etc. It obeys constraints automatically. Since we have to build several matrices and have to be aware of several sets of constraints, this will save us a lot of headache.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="meshworker_2dof__info_8h.html">deal.II/meshworker/dof_info.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integration__info_8h.html">deal.II/meshworker/integration_info.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="simple_8h.html">deal.II/meshworker/simple.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="output_8h.html">deal.II/meshworker/output.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="loop_8h.html">deal.II/meshworker/loop.h</a>&gt;</span></div></div><!-- fragment --><p>In order to save effort, we use the pre-implemented Laplacian found in</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="laplace_8h.html">deal.II/integrators/laplace.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="l2_8h.html">deal.II/integrators/l2.h</a>&gt;</span></div></div><!-- fragment --><p>This is C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step16</div><div class="line">{</div></div><!-- fragment --><p><a class="anchor" id="Theintegratoroneachcell"></a> </p><h3>The integrator on each cell</h3>
<p>The <a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">MeshWorker::integration_loop()</a> expects a class that provides functions for integration on cells and boundary and interior faces. This is done by the following class. In the constructor, we tell the loop that cell integrals should be computed (the 'true'), but integrals should not be computed on boundary and interior faces (the two 'false'). Accordingly, we only need a cell function, but none for the faces.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>LaplaceIntegrator : <span class="keyword">public</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LaplaceIntegrator();</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html#a44cc05e3e905a8cd5af4c12d3026ea2a">cell</a>(MeshWorker::DoFInfo&lt;dim&gt; &amp;        dinfo,</div><div class="line">                    <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">LaplaceIntegrator&lt;dim&gt;::LaplaceIntegrator()</div><div class="line">  : <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::LocalIntegrator&lt;dim&gt;(true, false, false)</div><div class="line">{}</div></div><!-- fragment --><p>Next the actual integrator on each cell. We solve a Poisson problem with a coefficient one in the right half plane and one tenth in the left half plane.</p>
<p>The <a class="el" href="classMeshWorker_1_1LocalResults.html">MeshWorker::LocalResults</a> base class of <a class="el" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo</a> contains objects that can be filled in this local integrator. How many objects are created is determined inside the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework by the assembler class. Here, we test for instance that one matrix is required (<a class="el" href="classMeshWorker_1_1LocalResults.html#ac63bee72524d6f8c064b23e3ccb576af">MeshWorker::LocalResults::n_matrices()</a>). The matrices are accessed through <a class="el" href="classMeshWorker_1_1LocalResults.html#a06c5d817ce47a4c26966df1cdcebeac4">MeshWorker::LocalResults::matrix()</a>, which takes the number of the matrix as its first argument. The second argument is only used for integrals over faces when there are two matrices for each test function used. Then, a second matrix with indicator 'true' would exist with the same index.</p>
<p><a class="el" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo</a> provides one or several <a class="el" href="classFEValues.html">FEValues</a> objects, which below are used by <a class="el" href="namespaceLocalIntegrators_1_1Laplace.html#a733b581e72bfe9d27cc59501a35bcd30">LocalIntegrators::Laplace::cell_matrix()</a> or <a class="el" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">LocalIntegrators::L2::L2()</a>. Since we are assembling only a single PDE, there is also only one of these objects with index zero.</p>
<p>In addition, we note that this integrator serves to compute the matrices for the multilevel preconditioner as well as the matrix and the right hand side for the global system. Since the assembler for a system requires an additional vector, <a class="el" href="classMeshWorker_1_1LocalResults.html#a18a21989c69233694473c643d44df24f">MeshWorker::LocalResults::n_vectors()</a> is returning a nonzero value. Accordingly, we fill a right hand side vector at the end of this function. Since LocalResults can deal with several <a class="el" href="classBlockVector.html">BlockVector</a> objects, but we are again in the simplest case here, we enter the information into block zero of vector zero.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">LaplaceIntegrator&lt;dim&gt;::cell(MeshWorker::DoFInfo&lt;dim&gt; &amp;        dinfo,</div><div class="line">                             <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac63bee72524d6f8c064b23e3ccb576af">n_matrices</a>(), 1);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient = (dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;center()(0) &gt; 0.) ? .1 : 1.;</div><div class="line"></div><div class="line">  <a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#a733b581e72bfe9d27cc59501a35bcd30">LocalIntegrators::Laplace::cell_matrix</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a06c5d817ce47a4c26966df1cdcebeac4">matrix</a>(0, <span class="keyword">false</span>).matrix,</div><div class="line">                                         info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div><div class="line">                                         coefficient);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a18a21989c69233694473c643d44df24f">n_vectors</a>() &gt; 0)</div><div class="line">    {</div><div class="line">      std::vector&lt;double&gt; rhs(info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0).n_quadrature_points, 1.);</div><div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">LocalIntegrators::L2::L2</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a13d325f993aa366ce5f837f37d96a90b">vector</a>(0).block(0),</div><div class="line">                               info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div><div class="line">                               rhs);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceProblemcodeclasstemplate"></a> </p><h3>The <code>LaplaceProblem</code> class template</h3>
<p>This main class is basically the same class as in <a class="el" href="step_6.html">step-6</a>. As far as member functions is concerned, the only addition is the <code>assemble_multigrid</code> function that assembles the matrices that correspond to the discrete operators on intermediate levels:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>LaplaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_multigrid();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> refine_grid();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> system_rhs;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div></div><!-- fragment --><p>The following members are the essential data structures for the multigrid method. The first two represent the sparsity patterns and the matrices on individual levels of the multilevel hierarchy, very much like the objects for the global mesh above.</p>
<p>Then we have two new matrices only needed for multigrid methods with local smoothing on adaptive meshes. They convey data between the interior part of the refined region and the refinement edge, as outlined in detail in the <a class="el" href="DEALGlossary.html#mg_paper">multigrid paper</a>.</p>
<p>The last object stores information about the boundary indices on each level and information about indices lying on a refinement edge between two different refinement levels. It thus serves a similar purpose as <a class="el" href="classAffineConstraints.html">AffineConstraints</a>, but on each level.</p>
<div class="fragment"><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a>      mg_sparsity_patterns;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_in;</div><div class="line">  <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_out;</div><div class="line">  <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a>                   mg_constrained_dofs;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ThecodeLaplaceProblemcodeclassimplementation"></a> </p><h3>The <code>LaplaceProblem</code> class implementation</h3>
<p>Just one short remark about the constructor of the <a class="el" href="classTriangulation.html">Triangulation</a>: by convention, all adaptively refined triangulations in deal.II never change by more than one level across a face between cells. For our multigrid algorithms, however, we need a slightly stricter guarantee, namely that the mesh also does not change by more than refinement level across vertices that might connect two cells. In other words, we must prevent the following situation:</p>
<div class="image">
<img src="limit_level_difference_at_vertices.png" alt="limit_level_difference_at_vertices.png"/>
</div>
<p>This is achieved by passing the <a class="el" href="classTriangulation.html#a0633dd17e535a59162b79f338c6ff5aeaa2ab57e4f7b1633f26092ae861ea3bfc">Triangulation::limit_level_difference_at_vertices</a> flag to the constructor of the triangulation class.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">LaplaceProblem&lt;dim&gt;::LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">  : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">  , fe(degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , degree(degree)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsetup_system"></a> </p><h4>LaplaceProblem::setup_system</h4>
<p>In addition to just distributing the degrees of freedom in the <a class="el" href="classDoFHandler.html">DoFHandler</a>, we do the same on each level. Then, we follow the same procedure as before to set up the system on the leaf mesh.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">          &lt;&lt; <span class="stringliteral">&quot; (by level: &quot;</span>;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.n_levels(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level)</div><div class="line">            &lt;&lt; (level == triangulation.n_levels() - 1 ? <span class="stringliteral">&quot;)&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>);</div><div class="line">  <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">  solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">  std::set&lt;types::boundary_id&gt; dirichlet_boundary_ids = {0};</div><div class="line">  <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> homogeneous_dirichlet_bc;</div><div class="line">  <span class="keyword">const</span> std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt;</div><div class="line">    dirichlet_boundary_functions = {</div><div class="line">      {<a class="code" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>(0), &amp;homogeneous_dirichlet_bc}};</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           dirichlet_boundary_functions,</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">condense</a>(dsp);</div><div class="line">  sparsity_pattern.copy_from(dsp);</div><div class="line">  system_matrix.reinit(sparsity_pattern);</div></div><!-- fragment --><p>The multigrid constraints have to be initialized. They need to know about the boundary values as well, so we pass the <code>dirichlet_boundary</code> here as well.</p>
<div class="fragment"><div class="line">mg_constrained_dofs.clear();</div><div class="line">mg_constrained_dofs.initialize(dof_handler);</div><div class="line">mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                   dirichlet_boundary_ids);</div></div><!-- fragment --><p>Now for the things that concern the multigrid data structures. First, we resize the multilevel objects to hold matrices and sparsity patterns for every level. The coarse level is zero (this is mandatory right now but may change in a future revision). Note that these functions take a complete, inclusive range here (not a starting index and size), so the finest level is <code>n_levels-1</code>. We first have to resize the container holding the <a class="el" href="classSparseMatrix.html">SparseMatrix</a> classes, since they have to release their <a class="el" href="classSparsityPattern.html">SparsityPattern</a> before the can be destroyed upon resizing.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">mg_interface_in.resize(0, n_levels - 1);</div><div class="line">mg_interface_in.clear_elements();</div><div class="line">mg_interface_out.resize(0, n_levels - 1);</div><div class="line">mg_interface_out.clear_elements();</div><div class="line">mg_matrices.resize(0, n_levels - 1);</div><div class="line">mg_matrices.clear_elements();</div><div class="line">mg_sparsity_patterns.resize(0, n_levels - 1);</div></div><!-- fragment --><p>Now, we have to provide a matrix on each level. To this end, we first use the <a class="el" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a> function to generate a preliminary compressed sparsity pattern on each level (see the <a class="el" href="group__Sparsity.html">Sparsity patterns</a> module for more information on this topic) and then copy it over to the one we really want. The next step is to initialize both kinds of level matrices with these sparsity patterns.</p>
<p>It may be worth pointing out that the interface matrices only have entries for degrees of freedom that sit at or next to the interface between coarser and finer levels of the mesh. They are therefore even sparser than the matrices on the individual levels of our multigrid hierarchy. If we were more concerned about memory usage (and possibly the speed with which we can multiply with these matrices), we should use separate and different sparsity patterns for these two kinds of matrices.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                 dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">      <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line"></div><div class="line">      mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line"></div><div class="line">      mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">      mg_interface_in[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">      mg_interface_out[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_system"></a> </p><h4>LaplaceProblem::assemble_system</h4>
<p>The following function assembles the linear system on the finest level of the mesh. Since we want to reuse the code here for the level assembling below, we use the local integrator class LaplaceIntegrator and leave the loops to the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework. Thus, this function first sets up the objects necessary for this framework, namely</p><ul>
<li>a <a class="el" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox</a> object, which will provide all the required data in quadrature points on the cell. This object can be seen as an extension of <a class="el" href="classFEValues.html">FEValues</a>, providing a lot more useful information,</li>
<li>a <a class="el" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo</a> object, which on the one hand side extends the functionality of cell iterators, but also provides space for return values in its base class LocalResults,</li>
<li>an assembler, in this case for the whole system. The term 'simple' here refers to the fact that the global system does not have a block structure,</li>
<li>the local integrator, which implements the actual forms.</li>
</ul>
<p>After the loop has combined all of these into a matrix and a right hand side, there is one thing left to do: the assemblers leave matrix rows and columns of constrained degrees of freedom untouched. Therefore, we put a one on the diagonal to make the whole system well posed. The value one, or any fixed value has the advantage, that its effect on the spectrum of the matrix is easily understood. Since the corresponding eigenvectors form an invariant subspace, the value chosen does not affect the convergence of Krylov space solvers.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>                      mapping;</div><div class="line">  <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">  <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>                         update_flags =</div><div class="line">    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a>;</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">  MeshWorker::DoFInfo&lt;dim&gt; dof_info(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html">MeshWorker::Assembler::SystemSimple&lt;SparseMatrix&lt;double&gt;</a>, <a class="code" href="classVector.html">Vector&lt;double&gt;</a>&gt;</div><div class="line">    assembler;</div><div class="line">  assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html#abcc84b6bcef2300bcab47448c9289da7">initialize</a>(constraints);</div><div class="line">  assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html#abcc84b6bcef2300bcab47448c9289da7">initialize</a>(system_matrix, system_rhs);</div><div class="line"></div><div class="line">  LaplaceIntegrator&lt;dim&gt; matrix_integrator;</div><div class="line">  MeshWorker::integration_loop&lt;dim, dim&gt;(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                                         dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                                         dof_info,</div><div class="line">                                         info_box,</div><div class="line">                                         matrix_integrator,</div><div class="line">                                         assembler);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (constraints.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(i))</div><div class="line">      system_matrix.set(i, i, 1.);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemassemble_multigrid"></a> </p><h4>LaplaceProblem::assemble_multigrid</h4>
<p>The next function is the one that builds the linear operators (matrices) that define the multigrid method on each level of the mesh. The integration core is the same as above, but the loop below will go over all existing cells instead of just the active ones, and the results must be entered into the correct level matrices. Fortunately, <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> hides most of that from us, and thus the difference between this function and the previous lies only in the setup of the assembler and the different iterators in the loop. Also, fixing up the matrices in the end is a little more complicated.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid()</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>                      mapping;</div><div class="line">  <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">  <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>                         update_flags =</div><div class="line">    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a>;</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">  info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">  MeshWorker::DoFInfo&lt;dim&gt; dof_info(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html">MeshWorker::Assembler::MGMatrixSimple&lt;SparseMatrix&lt;double&gt;</a>&gt; assembler;</div><div class="line">  assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#aba020fe5832606b5a7ec4c3c54526adb">initialize</a>(mg_constrained_dofs);</div><div class="line">  assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#aba020fe5832606b5a7ec4c3c54526adb">initialize</a>(mg_matrices);</div><div class="line">  assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#a2509230e8e7076a818fb0e8a774dae40">initialize_interfaces</a>(mg_interface_in, mg_interface_out);</div><div class="line"></div><div class="line">  LaplaceIntegrator&lt;dim&gt; matrix_integrator;</div><div class="line">  MeshWorker::integration_loop&lt;dim, dim&gt;(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                                         dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                                         dof_info,</div><div class="line">                                         info_box,</div><div class="line">                                         matrix_integrator,</div><div class="line">                                         assembler);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.n_levels();</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level); ++i)</div><div class="line">        <span class="keywordflow">if</span> (mg_constrained_dofs.is_boundary_index(level, i) ||</div><div class="line">            mg_constrained_dofs.at_refinement_edge(level, i))</div><div class="line">          mg_matrices[level].<span class="keyword">set</span>(i, i, 1.);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemsolve"></a> </p><h4>LaplaceProblem::solve</h4>
<p>This is the other function that is significantly different in support of the multigrid solver (or, in fact, the preconditioner for which we use the multigrid method).</p>
<p>Let us start out by setting up two of the components of multilevel methods: transfer operators between levels, and a solver on the coarsest level. In finite element methods, the transfer operators are derived from the finite element function spaces involved and can often be computed in a generic way independent of the problem under consideration. In that case, we can use the <a class="el" href="classMGTransferPrebuilt.html">MGTransferPrebuilt</a> class that, given the constraints of the final linear system and the <a class="el" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a> object that knows about the boundary conditions on the each level and the degrees of freedom on interfaces between different refinement level can build the matrices for those transfer operations from a <a class="el" href="classDoFHandler.html">DoFHandler</a> object with level degrees of freedom.</p>
<p>The second part of the following lines deals with the coarse grid solver. Since our coarse grid is very coarse indeed, we decide for a direct solver (a <a class="el" href="classHouseholder.html">Householder</a> decomposition of the coarsest level matrix), even if its implementation is not particularly sophisticated. If our coarse mesh had many more cells than the five we have here, something better suited would obviously be necessary here.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt; mg_transfer(mg_constrained_dofs);</div><div class="line">  mg_transfer.build(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">  coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">  <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">  coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div></div><!-- fragment --><p>The next component of a multilevel solver or preconditioner is that we need a smoother on each level. A common choice for this is to use the application of a relaxation method (such as the SOR, Jacobi or Richardson method) or a small number of iterations of a solver method (such as CG or GMRES). The <a class="el" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation</a> and <a class="el" href="classMGSmootherPrecondition.html">MGSmootherPrecondition</a> classes provide support for these two kinds of smoothers. Here, we opt for the application of a single SOR iteration. To this end, we define an appropriate alias and then setup a smoother object.</p>
<p>The last step is to initialize the smoother object with our level matrices and to set some smoothing parameters. The <code>initialize()</code> function can optionally take additional arguments that will be passed to the smoother object on each level. In the current case for the SOR smoother, this could, for example, include a relaxation parameter. However, we here leave these at their default values. The call to <code>set_steps()</code> indicates that we will use two pre- and two post-smoothing steps on each level; to use a variable number of smoother steps on different levels, more options can be set in the constructor call to the <code>mg_smoother</code> object.</p>
<p>The last step results from the fact that we use the SOR method as a smoother - which is not symmetric - but we use the conjugate gradient iteration (which requires a symmetric preconditioner) below, we need to let the multilevel preconditioner make sure that we get a symmetric operator even for nonsymmetric smoothers:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line"><a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation&lt;Smoother, Vector&lt;double&gt;</a>&gt; mg_smoother;</div><div class="line">mg_smoother.<a class="code" href="classmg_1_1SmootherRelaxation.html#ae9e03c626c50a1b13dffe338f5f977b0">initialize</a>(mg_matrices);</div><div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(2);</div><div class="line">mg_smoother.<a class="code" href="classMGSmoother.html#abed2837ee4e224f94c6a98405906df8f">set_symmetric</a>(<span class="keyword">true</span>);</div></div><!-- fragment --><p>The next preparatory step is that we must wrap our level and interface matrices in an object having the required multiplication functions. We will create two objects for the interface objects going from coarse to fine and the other way around; the multigrid algorithm will later use the transpose operator for the latter operation, allowing us to initialize both up and down versions of the operator with the matrices we already built:</p>
<div class="fragment"><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix(mg_matrices);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_up(mg_interface_in);</div><div class="line"><a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_down(mg_interface_out);</div></div><!-- fragment --><p>Now, we are ready to set up the V-cycle operator and the multilevel preconditioner.</p>
<div class="fragment"><div class="line"><a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">  mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);</div><div class="line"><a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_down, mg_interface_up);</div><div class="line"></div><div class="line"><a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt;&gt;</div><div class="line">  preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div></div><!-- fragment --><p>With all this together, we can finally get about solving the linear system in the usual way:</p>
<div class="fragment"><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">  solution = 0;</div><div class="line"></div><div class="line">  solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Postprocessing"></a> </p><h4>Postprocessing</h4>
<p>The following two functions postprocess a solution once it is computed. In particular, the first one refines the mesh at the beginning of each cycle while the second one outputs results at the end of each such cycle. The functions are almost unchanged from those in <a class="el" href="step_6.html">step-6</a>, with the exception of one minor difference: we generate output in VTK format, to use the more modern visualization programs available today compared to those that were available when <a class="el" href="step_6.html">step-6</a> was written.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::refine_grid()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">    solution,</div><div class="line">    estimated_error_per_cell);</div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.03);</div><div class="line">  triangulation.execute_coarsening_and_refinement();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="LaplaceProblemrun"></a> </p><h4>LaplaceProblem::run</h4>
<p>Like several of the functions above, this is almost exactly a copy of the corresponding function in <a class="el" href="step_6.html">step-6</a>. The only difference is the call to <code>assemble_multigrid</code> that takes care of forming the matrices on every level that we need in the multigrid method.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 8; ++cycle)</div><div class="line">      {</div><div class="line">        <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">            triangulation.refine_global(1);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid();</div><div class="line"></div><div class="line">        <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">                &lt;&lt; triangulation.n_active_cells() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line">        assemble_multigrid();</div><div class="line"></div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step16</span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h3>The main() function</h3>
<p>This is again the same function as in <a class="el" href="step_6.html">step-6</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step16;</div><div class="line"></div><div class="line">      <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(2);</div><div class="line"></div><div class="line">      LaplaceProblem&lt;2&gt; laplace_problem(1);</div><div class="line">      laplace_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-16b/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>如同第16步，在最细的网格上，解决方案看起来是这样的。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-16.solution.png"/>
</div>
 <p>。</p>
<p>与<a class="el" href="step_16.html">step-16</a>相比，输出的格式略有不同，但在功能上是一样的，显示了相同的收敛特性。</p>
<p>DEAL::Cycle 0 DEAL:: 活动单元数：20 DEAL:: 自由度数：25（通过级别：8，25） DEAL:cg::Starting 值 0.510691 DEAL:cg::Convergence 步骤6 值 4.59193e-14 DEAL::Cycle 1 DEAL:: 活动单元数：44 DEAL:: 自由度数：55（按级别：8，25，45） DEAL:cg::Starting 值 0.440678 DEAL:cg::Convergence 步骤8值 1.99419e-13 DEAL::Cycle 2 DEAL:: 活动单元数：86 DEAL:: 自由度数：105（按级别：8，25，69，49） DEAL:cg::Starting 值 0.371855 DEAL:cg::Convergence 步骤 9 值 1.13984e-13 DEAL::Cycle 3 DEAL:: 活动单元数：170 DEAL:: 自由度数：200（按级别：8，25，77，174） DEAL:cg::Starting 值 0.318967 DEAL:cg::Convergence 步骤 9 值 2.62112e-13 DEAL::Cycle 4 DEAL:: 活动单元数：332 DEAL:: 自由度数：388（按级别：8, 25, 86, 231, 204） DEAL:cg::Starting 值 0.276534 DEAL:cg::Convergence 步骤10值 1.69562e-13 DEAL::Cycle 5 DEAL:: 活动单元数：632 DEAL:: 自由度数：714（按级别：8, 25, 89, 231, 514, 141） DEAL:cg::Starting 值 0.215300 DEAL:cg::Convergence 步骤10值 6.47463e-13 DEAL::Cycle 6 DEAL:: 活动单元数：1202 DEAL:: 自由度数：1332（按级别：8, 25, 89, 282, 771, 435, 257） DEAL:cg::Starting 值 0.175848 DEAL:cg::Convergence 第10步值 1.80664e-13 DEAL::Cycle 7 DEAL:: 活动单元数：2288 DEAL:: 自由度数：2511（按级别：8、25、89、318、779、1420、829、30） DEAL:cg::Starting 值 0.136724 DEAL:cg::Convergence 第11步值 9.73331e-14 </p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2003 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Guido Kanschat, University of Heidelberg, 2003</span></div><div class="line"><span class="comment"> *          Baerbel Janssen, University of Heidelberg, 2010</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University, 2010</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__constrained__dofs_8h.html">deal.II/multigrid/mg_constrained_dofs.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="multigrid_8h.html">deal.II/multigrid/multigrid.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__transfer_8h.html">deal.II/multigrid/mg_transfer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__tools_8h.html">deal.II/multigrid/mg_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__coarse_8h.html">deal.II/multigrid/mg_coarse.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__smoother_8h.html">deal.II/multigrid/mg_smoother.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mg__matrix_8h.html">deal.II/multigrid/mg_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="meshworker_2dof__info_8h.html">deal.II/meshworker/dof_info.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="integration__info_8h.html">deal.II/meshworker/integration_info.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="simple_8h.html">deal.II/meshworker/simple.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="output_8h.html">deal.II/meshworker/output.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="loop_8h.html">deal.II/meshworker/loop.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="laplace_8h.html">deal.II/integrators/laplace.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="l2_8h.html">deal.II/integrators/l2.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step16</div><div class="line">{</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceIntegrator : <span class="keyword">public</span> <a class="code" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceIntegrator();</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> cell(MeshWorker::DoFInfo&lt;dim&gt; &amp;        dinfo,</div><div class="line">                      <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceIntegrator&lt;dim&gt;::LaplaceIntegrator()</div><div class="line">    : <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::LocalIntegrator&lt;dim&gt;(true, false, false)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  LaplaceIntegrator&lt;dim&gt;::cell(MeshWorker::DoFInfo&lt;dim&gt; &amp;        dinfo,</div><div class="line">                               <a class="code" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt;dim&gt;</a> &amp;info)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="group__Exceptions.html#ga9442b63275c9ef3fab29bc222831c49c">AssertDimension</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#ac63bee72524d6f8c064b23e3ccb576af">n_matrices</a>(), 1);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient = (dinfo.<a class="code" href="classMeshWorker_1_1DoFInfo.html#acdb25148428f90647ca6c6166e212ffa">cell</a>-&gt;center()(0) &gt; 0.) ? .1 : 1.;</div><div class="line"></div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1Laplace.html#a733b581e72bfe9d27cc59501a35bcd30">LocalIntegrators::Laplace::cell_matrix</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a06c5d817ce47a4c26966df1cdcebeac4">matrix</a>(0, <span class="keyword">false</span>).matrix,</div><div class="line">                                           info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div><div class="line">                                           coefficient);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a18a21989c69233694473c643d44df24f">n_vectors</a>() &gt; 0)</div><div class="line">      {</div><div class="line">        std::vector&lt;double&gt; rhs(info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0).n_quadrature_points, 1.);</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a0a7d7409a5f53485a841a33fda68d916">LocalIntegrators::L2::L2</a>(dinfo.<a class="code" href="classMeshWorker_1_1LocalResults.html#a13d325f993aa366ce5f837f37d96a90b">vector</a>(0).block(0),</div><div class="line">                                 info.<a class="code" href="classMeshWorker_1_1IntegrationInfo.html#a32fa7363be71ba320bcdc94f6d677843">fe_values</a>(0),</div><div class="line">                                 rhs);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>LaplaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_multigrid();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> refine_grid();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; system_rhs;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree;</div><div class="line"></div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparsityPattern&gt;</a>      mg_sparsity_patterns;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_matrices;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_in;</div><div class="line">    <a class="code" href="classMGLevelObject.html">MGLevelObject&lt;SparseMatrix&lt;double&gt;</a>&gt; mg_interface_out;</div><div class="line">    <a class="code" href="classMGConstrainedDoFs.html">MGConstrainedDoFs</a>                   mg_constrained_dofs;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  LaplaceProblem&lt;dim&gt;::LaplaceProblem(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> degree)</div><div class="line">    : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::limit_level_difference_at_vertices)</div><div class="line">    , fe(degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , degree(degree)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">distribute_mg_dofs</a>();</div><div class="line"></div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (by level: &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; triangulation.n_levels(); ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level)</div><div class="line">              &lt;&lt; (level == triangulation.n_levels() - 1 ? <span class="stringliteral">&quot;)&quot;</span> : <span class="stringliteral">&quot;, &quot;</span>);</div><div class="line">    <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(), dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">    solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    system_rhs.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line"></div><div class="line">    std::set&lt;types::boundary_id&gt; dirichlet_boundary_ids = {0};</div><div class="line">    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a> homogeneous_dirichlet_bc;</div><div class="line">    <span class="keyword">const</span> std::map&lt;types::boundary_id, const Function&lt;dim&gt; *&gt;</div><div class="line">      dirichlet_boundary_functions = {</div><div class="line">        {<a class="code" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>(0), &amp;homogeneous_dirichlet_bc}};</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             dirichlet_boundary_functions,</div><div class="line">                                             constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">condense</a>(dsp);</div><div class="line">    sparsity_pattern.copy_from(dsp);</div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line"></div><div class="line">    mg_constrained_dofs.clear();</div><div class="line">    mg_constrained_dofs.initialize(dof_handler);</div><div class="line">    mg_constrained_dofs.make_zero_boundary_constraints(dof_handler,</div><div class="line">                                                       dirichlet_boundary_ids);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_levels = triangulation.n_levels();</div><div class="line"></div><div class="line">    mg_interface_in.resize(0, n_levels - 1);</div><div class="line">    mg_interface_in.clear_elements();</div><div class="line">    mg_interface_out.resize(0, n_levels - 1);</div><div class="line">    mg_interface_out.clear_elements();</div><div class="line">    mg_matrices.resize(0, n_levels - 1);</div><div class="line">    mg_matrices.clear_elements();</div><div class="line">    mg_sparsity_patterns.resize(0, n_levels - 1);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; n_levels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level),</div><div class="line">                                   dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level));</div><div class="line">        <a class="code" href="namespaceMGTools.html#a19ba9ee4a2b65235c8bb3fb65ea8f4e0">MGTools::make_sparsity_pattern</a>(dof_handler, dsp, level);</div><div class="line"></div><div class="line">        mg_sparsity_patterns[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].copy_from(dsp);</div><div class="line"></div><div class="line">        mg_matrices[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">        mg_interface_in[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">        mg_interface_out[<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>].reinit(mg_sparsity_patterns[level]);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>                      mapping;</div><div class="line">    <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">    <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>                         update_flags =</div><div class="line">      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a>;</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">    MeshWorker::DoFInfo&lt;dim&gt; dof_info(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html">MeshWorker::Assembler::SystemSimple&lt;SparseMatrix&lt;double&gt;</a>, Vector&lt;double&gt;&gt;</div><div class="line">      assembler;</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html#abcc84b6bcef2300bcab47448c9289da7">initialize</a>(constraints);</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html#abcc84b6bcef2300bcab47448c9289da7">initialize</a>(system_matrix, system_rhs);</div><div class="line"></div><div class="line">    LaplaceIntegrator&lt;dim&gt; matrix_integrator;</div><div class="line">    MeshWorker::integration_loop&lt;dim, dim&gt;(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>(),</div><div class="line">                                           dof_handler.<a class="code" href="classDoFHandler.html#a7b510a66ee9ea25720f64220496126ec">end</a>(),</div><div class="line">                                           dof_info,</div><div class="line">                                           info_box,</div><div class="line">                                           matrix_integrator,</div><div class="line">                                           assembler);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (constraints.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(i))</div><div class="line">        system_matrix.set(i, i, 1.);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::assemble_multigrid()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>                      mapping;</div><div class="line">    <a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt;dim&gt;</a> info_box;</div><div class="line">    <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>                         update_flags =</div><div class="line">      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a>;</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#a7572e2216a5ce6a0f30b3df417dc90c6">add_update_flags_all</a>(update_flags);</div><div class="line">    info_box.<a class="code" href="classMeshWorker_1_1IntegrationInfoBox.html#acb65243f284d15656e1bb6e2dbc2c607">initialize</a>(fe, mapping);</div><div class="line"></div><div class="line">    MeshWorker::DoFInfo&lt;dim&gt; dof_info(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html">MeshWorker::Assembler::MGMatrixSimple&lt;SparseMatrix&lt;double&gt;</a>&gt; assembler;</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#aba020fe5832606b5a7ec4c3c54526adb">initialize</a>(mg_constrained_dofs);</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#aba020fe5832606b5a7ec4c3c54526adb">initialize</a>(mg_matrices);</div><div class="line">    assembler.<a class="code" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html#a2509230e8e7076a818fb0e8a774dae40">initialize_interfaces</a>(mg_interface_in, mg_interface_out);</div><div class="line"></div><div class="line">    LaplaceIntegrator&lt;dim&gt; matrix_integrator;</div><div class="line">    MeshWorker::integration_loop&lt;dim, dim&gt;(dof_handler.<a class="code" href="classDoFHandler.html#a4f46e4221c995c41c925f8eef468b53c">begin_mg</a>(),</div><div class="line">                                           dof_handler.<a class="code" href="classDoFHandler.html#a70e36fc4bc2e6cfac62acb46c5f47db2">end_mg</a>(),</div><div class="line">                                           dof_info,</div><div class="line">                                           info_box,</div><div class="line">                                           matrix_integrator,</div><div class="line">                                           assembler);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels = triangulation.n_levels();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> level = 0; level &lt; nlevels; ++<a class="code" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(level); ++i)</div><div class="line">          <span class="keywordflow">if</span> (mg_constrained_dofs.is_boundary_index(level, i) ||</div><div class="line">              mg_constrained_dofs.at_refinement_edge(level, i))</div><div class="line">            mg_matrices[level].<span class="keyword">set</span>(i, i, 1.);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt; mg_transfer(mg_constrained_dofs);</div><div class="line">    mg_transfer.build(dof_handler);</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> coarse_matrix;</div><div class="line">    coarse_matrix.<a class="code" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a>(mg_matrices[0]);</div><div class="line">    <a class="code" href="classMGCoarseGridHouseholder.html">MGCoarseGridHouseholder&lt;double, Vector&lt;double&gt;</a>&gt; coarse_grid_solver;</div><div class="line">    coarse_grid_solver.<a class="code" href="classMGCoarseGridHouseholder.html#a07bd76dc7f6f66cb22d3e7951a558f50">initialize</a>(coarse_matrix);</div><div class="line"></div><div class="line">    <span class="keyword">using</span> Smoother = <a class="code" href="classPreconditionSOR.html">PreconditionSOR&lt;SparseMatrix&lt;double&gt;</a>&gt;;</div><div class="line">    <a class="code" href="classmg_1_1SmootherRelaxation.html">mg::SmootherRelaxation&lt;Smoother, Vector&lt;double&gt;</a>&gt; mg_smoother;</div><div class="line">    mg_smoother.<a class="code" href="classmg_1_1SmootherRelaxation.html#ae9e03c626c50a1b13dffe338f5f977b0">initialize</a>(mg_matrices);</div><div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#a9976182b6b272aac7800a8fbf18c8ab9">set_steps</a>(2);</div><div class="line">    mg_smoother.<a class="code" href="classMGSmoother.html#abed2837ee4e224f94c6a98405906df8f">set_symmetric</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_matrix(mg_matrices);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_up(mg_interface_in);</div><div class="line">    <a class="code" href="classmg_1_1Matrix.html">mg::Matrix&lt;Vector&lt;double&gt;</a>&gt; mg_interface_down(mg_interface_out);</div><div class="line"></div><div class="line">    <a class="code" href="classMultigrid.html">Multigrid&lt;Vector&lt;double&gt;</a>&gt; <a class="code" href="namespacemg.html">mg</a>(</div><div class="line">      mg_matrix, coarse_grid_solver, mg_transfer, mg_smoother, mg_smoother);</div><div class="line">    <a class="code" href="namespacemg.html">mg</a>.set_edge_matrices(mg_interface_down, mg_interface_up);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionMG.html">PreconditionMG&lt;dim, Vector&lt;double&gt;</a>, <a class="code" href="classMGTransferPrebuilt.html">MGTransferPrebuilt&lt;Vector&lt;double&gt;</a>&gt;&gt;</div><div class="line">      preconditioner(dof_handler, <a class="code" href="namespacemg.html">mg</a>, mg_transfer);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">    solution = 0;</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, system_rhs, preconditioner);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::refine_grid()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line">    triangulation.execute_coarsening_and_refinement();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> LaplaceProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">LaplaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 8; ++cycle)</div><div class="line">      {</div><div class="line">        <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">            triangulation.refine_global(1);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid();</div><div class="line"></div><div class="line">        <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">                &lt;&lt; triangulation.n_active_cells() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line">        assemble_multigrid();</div><div class="line"></div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step16</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step16;</div><div class="line"></div><div class="line">      <a class="code" href="logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a>.<a class="code" href="classLogStream.html#a8028e970ad8388596d625ed463894e98">depth_console</a>(2);</div><div class="line"></div><div class="line">      LaplaceProblem&lt;2&gt; laplace_problem(1);</div><div class="line">      laplace_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
