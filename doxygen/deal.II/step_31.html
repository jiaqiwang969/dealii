<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_31.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-31 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-31 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_22.html">step-22</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#TheBoussinesqequations">The Boussinesq equations</a>
        <li><a href="#Boundaryandinitialconditions">Boundary and initial conditions</a>
        <li><a href="#Solutionapproach">Solution approach</a>
      <ul>
        <li><a href="#Timestepping">Time stepping</a>
        <li><a href="#WeakformandspacediscretizationfortheStokespart">Weak form and space discretization for the Stokes part</a>
        <li><a href="#Stabilizationweakformandspacediscretizationforthetemperatureequation">Stabilization, weak form and space discretization for the temperature equation</a>
        <li><a href="#Linearsolvers">Linear solvers</a>
      <ul>
        <li><a href="#LinearsolversfortheStokesproblem">Linear solvers for the Stokes problem</a>
        <li><a href="#Linearsolversforthetemperatureequation">Linear solvers for the temperature equation</a>
      </ul>
      </ul>
        <li><a href="#Implementationdetails">Implementation details</a>
      <ul>
        <li><a href="#UsingdifferentDoFHandlerobjects">Using different DoFHandler objects</a>
        <li><a href="#UsingTrilinos">Using Trilinos</a>
      </ul>
        <li><a href="#Thetestcase">The testcase</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a>
      <ul>
        <li><a href="#ThecodeInverseMatrixcodeclasstemplate">The <code>InverseMatrix</code> class template</a>
        <li><a href="#Schurcomplementpreconditioner">Schur complement preconditioner</a>
      </ul>
        <li><a href="#ThecodeBoussinesqFlowProblemcodeclasstemplate">The <code>BoussinesqFlowProblem</code> class template</a>
        <li><a href="#BoussinesqFlowProblemclassimplementation">BoussinesqFlowProblem class implementation</a>
      <ul>
        <li><a href="#BoussinesqFlowProblemBoussinesqFlowProblem">BoussinesqFlowProblem::BoussinesqFlowProblem</a>
        <li><a href="#BoussinesqFlowProblemget_maximal_velocity">BoussinesqFlowProblem::get_maximal_velocity</a>
        <li><a href="#BoussinesqFlowProblemget_extrapolated_temperature_range">BoussinesqFlowProblem::get_extrapolated_temperature_range</a>
        <li><a href="#BoussinesqFlowProblemcompute_viscosity">BoussinesqFlowProblem::compute_viscosity</a>
        <li><a href="#BoussinesqFlowProblemsetup_dofs">BoussinesqFlowProblem::setup_dofs</a>
        <li><a href="#BoussinesqFlowProblemassemble_stokes_preconditioner">BoussinesqFlowProblem::assemble_stokes_preconditioner</a>
        <li><a href="#BoussinesqFlowProblembuild_stokes_preconditioner">BoussinesqFlowProblem::build_stokes_preconditioner</a>
        <li><a href="#BoussinesqFlowProblemassemble_stokes_system">BoussinesqFlowProblem::assemble_stokes_system</a>
        <li><a href="#BoussinesqFlowProblemassemble_temperature_matrix">BoussinesqFlowProblem::assemble_temperature_matrix</a>
        <li><a href="#BoussinesqFlowProblemassemble_temperature_system">BoussinesqFlowProblem::assemble_temperature_system</a>
        <li><a href="#BoussinesqFlowProblemsolve">BoussinesqFlowProblem::solve</a>
        <li><a href="#BoussinesqFlowProblemoutput_results">BoussinesqFlowProblem::output_results</a>
        <li><a href="#BoussinesqFlowProblemrefine_mesh">BoussinesqFlowProblem::refine_mesh</a>
        <li><a href="#BoussinesqFlowProblemrun">BoussinesqFlowProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Resultsin2d"> Results in 2d </a>
        <li><a href="#Resultsin3d"> Results in 3d </a>
        <li><a href="#Numericalexperimentstodetermineoptimalparameters"> Numerical experiments to determine optimal parameters </a>
      <ul>
        <li><a href="#Choosingicsubksubiandbeta"> Choosing <i>c<sub>k</sub></i> and beta </a>
      <ul>
        <li><a href="#ResultsforQsub1subelements">Results for Q<sub>1</sub> elements</a>
        <li><a href="#ResultsforQsub2subelements">Results for Q<sub>2</sub> elements</a>
        <li><a href="#Resultsfor3d">Results for 3d</a>
        <li><a href="#Conclusions">Conclusions</a>
      </ul>
      </ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Martin Kronbichler and Wolfgang Bangerth. <br />
 This material is based upon work partly supported by the National Science Foundation under Award No. EAR-0426271 and The California Institute of Technology. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation or of The California Institute of Technology. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="TheBoussinesqequations"></a></p><h3>The Boussinesq equations</h3>
<p>This program deals with an interesting physical problem: how does a fluid (i.e., a liquid or gas) behave if it experiences differences in buoyancy caused by temperature differences? It is clear that those parts of the fluid that are hotter (and therefore lighter) are going to rise up and those that are cooler (and denser) are going to sink down with gravity.</p>
<p>In cases where the fluid moves slowly enough such that inertial effects can be neglected, the equations that describe such behavior are the Boussinesq equations that read as follows: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; -\rho\; \beta \; T\; \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0, \\ \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma. \end{eqnarray*}
</p>
<p> These equations fall into the class of vector-valued problems (a toplevel overview of this topic can be found in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module). Here, \(\mathbf u\) is the velocity field, \(p\) the pressure, and \(T\) the temperature of the fluid. \(\varepsilon ({\mathbf u}) = \frac 12 [(\nabla{\mathbf u}) + (\nabla {\mathbf u})^T]\) is the symmetric gradient of the velocity. As can be seen, velocity and pressure solve a Stokes equation describing the motion of an incompressible fluid, an equation we have previously considered in <a class="el" href="step_22.html">step-22</a>; we will draw extensively on the experience we have gained in that program, in particular with regard to efficient linear Stokes solvers.</p>
<p>The forcing term of the fluid motion is the buoyancy of the fluid, expressed as the product of the density \(\rho\), the thermal expansion coefficient \(\beta\), the temperature \(T\) and the gravity vector \(\mathbf{g}\) pointing downward. (A derivation of why the right hand side looks like it looks is given in the introduction of <a class="el" href="step_32.html">step-32</a>.) While the first two equations describe how the fluid reacts to temperature differences by moving around, the third equation states how the fluid motion affects the temperature field: it is an advection diffusion equation, i.e., the temperature is attached to the fluid particles and advected along in the flow field, with an additional diffusion (heat conduction) term. In many applications, the diffusion coefficient is fairly small, and the temperature equation is in fact transport, not diffusion dominated and therefore in character more hyperbolic than elliptic; we will have to take this into account when developing a stable discretization.</p>
<p>In the equations above, the term \(\gamma\) on the right hand side denotes the heat sources and may be a spatially and temporally varying function. \(\eta\) and \(\kappa\) denote the viscosity and diffusivity coefficients, which we assume constant for this tutorial program. The more general case when \(\eta\) depends on the temperature is an important factor in physical applications: Most materials become more fluid as they get hotter (i.e., \(\eta\) decreases with \(T\)); sometimes, as in the case of rock minerals at temperatures close to their melting point, \(\eta\) may change by orders of magnitude over the typical range of temperatures.</p>
<p>We note that the Stokes equation above could be nondimensionalized by introducing the <a href="http://en.wikipedia.org/wiki/Rayleigh_number" target="_top">Rayleigh number</a> \(\mathrm{Ra}=\frac{\|\mathbf{g}\| \beta \rho}{\eta \kappa} \delta T L^3\) using a typical length scale \(L\), typical temperature difference \(\delta T\), density \(\rho\), thermal diffusivity \(\eta\), and thermal conductivity \(\kappa\). \(\mathrm{Ra}\) is a dimensionless number that describes the ratio of heat transport due to convection induced by buoyancy changes from temperature differences, and of heat transport due to thermal diffusion. A small Rayleigh number implies that buoyancy is not strong relative to viscosity and fluid motion \(\mathbf{u}\) is slow enough so that heat diffusion \(\kappa\nabla T\) is the dominant heat transport term. On the other hand, a fluid with a high Rayleigh number will show vigorous convection that dominates heat conduction.</p>
<p>For most fluids for which we are interested in computing thermal convection, the Rayleigh number is very large, often \(10^6\) or larger. From the structure of the equations, we see that this will lead to large pressure differences and large velocities. Consequently, the convection term in the convection-diffusion equation for \(T\) will also be very large and an accurate solution of this equation will require us to choose small time steps. Problems with large Rayleigh numbers are therefore hard to solve numerically for similar reasons that make solving the <a href="http://en.wikipedia.org/wiki/Navier-stokes_equations">Navier-Stokes equations</a> hard to solve when the <a href="http://en.wikipedia.org/wiki/Reynolds_number">Reynolds number \(\mathrm{Re}\)</a> is large.</p>
<p>Note that a large Rayleigh number does not necessarily involve large velocities in absolute terms. For example, the Rayleigh number in the earth mantle is larger than \(10^6\). Yet the velocities are small: the material is in fact solid rock but it is so hot and under pressure that it can flow very slowly, on the order of at most a few centimeters per year. Nevertheless, this can lead to mixing over time scales of many million years, a time scale much shorter than for the same amount of heat to be distributed by thermal conductivity and a time scale of relevance to affect the evolution of the earth's interior and surface structure.</p>
<dl class="section note"><dt>Note</dt><dd>If you are interested in using the program as the basis for your own experiments, you will also want to take a look at its continuation in <a class="el" href="step_32.html">step-32</a>. Furthermore, <a class="el" href="step_32.html">step-32</a> later was developed into the much larger open source code ASPECT (see <a href="https://aspect.geodynamics.org/">https://aspect.geodynamics.org/</a> ) that can solve realistic problems and that you may want to investigate before trying to morph <a class="el" href="step_31.html">step-31</a> into something that can solve whatever you want to solve.</dd></dl>
<p><a class="anchor" id="Boundaryandinitialconditions"></a></p><h3>Boundary and initial conditions</h3>
<p>Since the Boussinesq equations are derived under the assumption that inertia of the fluid's motion does not play a role, the flow field is at each time entirely determined by buoyancy difference at that time, not by the flow field at previous times. This is reflected by the fact that the first two equations above are the steady state Stokes equation that do not contain a time derivative. Consequently, we do not need initial conditions for either velocities or pressure. On the other hand, the temperature field does satisfy an equation with a time derivative, so we need initial conditions for \(T\).</p>
<p>As for boundary conditions: if \(\kappa&gt;0\) then the temperature satisfies a second order differential equation that requires boundary data all around the boundary for all times. These can either be a prescribed boundary temperature \(T|_{\partial\Omega}=T_b\) (Dirichlet boundary conditions), or a prescribed thermal flux \(\mathbf{n}\cdot\kappa\nabla T|_{\partial\Omega}=\phi\); in this program, we will use an insulated boundary condition, i.e., prescribe no thermal flux: \(\phi=0\).</p>
<p>Similarly, the velocity field requires us to pose boundary conditions. These may be no-slip no-flux conditions \(\mathbf{u}=0\) on \(\partial\Omega\) if the fluid sticks to the boundary, or no normal flux conditions \(\mathbf n \cdot \mathbf u = 0\) if the fluid can flow along but not across the boundary, or any number of other conditions that are physically reasonable. In this program, we will use no normal flux conditions.</p>
<p><a class="anchor" id="Solutionapproach"></a></p><h3>Solution approach</h3>
<p>Like the equations solved in <a class="el" href="step_21.html">step-21</a>, we here have a system of differential-algebraic equations (DAE): with respect to the time variable, only the temperature equation is a differential equation whereas the Stokes system for \(\mathbf{u}\) and \(p\) has no time-derivatives and is therefore of the sort of an algebraic constraint that has to hold at each time instant. The main difference to <a class="el" href="step_21.html">step-21</a> is that the algebraic constraint there was a mixed Laplace system of the form </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf u + {\mathbf K}\lambda \nabla p &amp;=&amp; 0, \\ \nabla\cdot \mathbf u &amp;=&amp; f, \end{eqnarray*}
</p>
<p> where now we have a Stokes system </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; f, \\ \nabla\cdot \mathbf u &amp;=&amp; 0, \end{eqnarray*}
</p>
<p> where \(\nabla \cdot \eta \varepsilon (\cdot)\) is an operator similar to the Laplacian \(\Delta\) applied to a vector field.</p>
<p>Given the similarity to what we have done in <a class="el" href="step_21.html">step-21</a>, it may not come as a surprise that we choose a similar approach, although we will have to make adjustments for the change in operator in the top-left corner of the differential operator.</p>
<p><a class="anchor" id="Timestepping"></a></p><h4>Time stepping</h4>
<p>The structure of the problem as a DAE allows us to use the same strategy as we have already used in <a class="el" href="step_21.html">step-21</a>, i.e., we use a time lag scheme: we first solve the temperature equation (using an extrapolated velocity field), and then insert the new temperature solution into the right hand side of the velocity equation. The way we implement this in our code looks at things from a slightly different perspective, though. We first solve the Stokes equations for velocity and pressure using the temperature field from the previous time step, which means that we get the velocity for the previous time step. In other words, we first solve the Stokes system for time step \(n - 1\) as </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2\eta \varepsilon ({\mathbf u}^{n-1})) + \nabla p^{n-1} &amp;=&amp; -\rho\; \beta \; T^{n-1} \mathbf{g}, \\ \nabla \cdot {\mathbf u}^{n-1} &amp;=&amp; 0, \end{eqnarray*}
</p>
<p> and then the temperature equation with an extrapolated velocity field to time \(n\).</p>
<p>In contrast to <a class="el" href="step_21.html">step-21</a>, we'll use a higher order time stepping scheme here, namely the <a href="http://en.wikipedia.org/wiki/Backward_differentiation_formula">Backward Differentiation Formula scheme of order 2 (BDF-2 in short)</a> that replaces the time derivative \(\frac{\partial T}{\partial t}\) by the (one-sided) difference quotient \(\frac{\frac 32 T^{n}-2T^{n-1}+\frac 12 T^{n-2}}{k}\) with \(k\) the time step size. This gives the discretized-in-time temperature equation </p><p class="formulaDsp">
\begin{eqnarray*} \frac 32 T^n - k\nabla \cdot \kappa \nabla T^n &amp;=&amp; 2 T^{n-1} - \frac 12 T^{n-2} - k(2{\mathbf u}^{n-1} - {\mathbf u}^{n-2} ) \cdot \nabla (2T^{n-1}-T^{n-2}) + k\gamma. \end{eqnarray*}
</p>
<p> Note how the temperature equation is solved semi-explicitly: diffusion is treated implicitly whereas advection is treated explicitly using an extrapolation (or forward-projection) of temperature and velocity, including the just-computed velocity \({\mathbf u}^{n-1}\). The forward-projection to the current time level \(n\) is derived from a Taylor expansion, \(T^n \approx T^{n-1} + k_n \frac{\partial T}{\partial t} \approx T^{n-1} + k_n \frac{T^{n-1}-T^{n-2}}{k_n} = 2T^{n-1}-T^{n-2}\). We need this projection for maintaining the order of accuracy of the BDF-2 scheme. In other words, the temperature fields we use in the explicit right hand side are second order approximations of the current temperature field &mdash; not quite an explicit time stepping scheme, but by character not too far away either.</p>
<p>The introduction of the temperature extrapolation limits the time step by a <a href="http://en.wikipedia.org/wiki/Courant–Friedrichs–Lewy_condition">Courant-Friedrichs-Lewy (CFL) condition</a> just like it was in <a class="el" href="step_21.html">step-21</a>. (We wouldn't have had that stability condition if we treated the advection term implicitly since the BDF-2 scheme is A-stable, at the price that we needed to build a new temperature matrix at each time step.) We will discuss the exact choice of time step in the <a href="#Results">results section</a>, but for the moment of importance is that this CFL condition means that the time step size \(k\) may change from time step to time step, and that we have to modify the above formula slightly. If \(k_n,k_{n-1}\) are the time steps sizes of the current and previous time step, then we use the approximations </p><p class="formulaDsp">
\begin{align*} \frac{\partial T}{\partial t} \approx \frac 1{k_n} \left( \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} T^{n} - \frac{k_n+k_{n-1}}{k_{n-1}}T^{n-1} + \frac{k_n^2}{k_{n-1}(k_n+k_{n-1})} T^{n-2} \right) \end{align*}
</p>
<p> and </p><p class="formulaDsp">
\begin{align*} T^n \approx T^{n-1} + k_n \frac{\partial T}{\partial t} \approx T^{n-1} + k_n \frac{T^{n-1}-T^{n-2}}{k_{n-1}} = \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2}, \end{align*}
</p>
<p> and above equation is generalized as follows: </p><p class="formulaDsp">
\begin{eqnarray*} \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} T^n - k_n\nabla \cdot \kappa \nabla T^n &amp;=&amp; \frac{k_n+k_{n-1}}{k_{n-1}} T^{n-1} - \frac{k_n^2}{k_{n-1}(k_n+k_{n-1})} T^{n-2} - k_n{\mathbf u}^{*,n} \cdot \nabla T^{*,n} + k_n\gamma, \end{eqnarray*}
</p>
<p>where \({(\cdot)}^{*,n} = \left(1+\frac{k_n}{k_{n-1}}\right)(\cdot)^{n-1} - \frac{k_n}{k_{n-1}}(\cdot)^{n-2}\) denotes the extrapolation of velocity \(\mathbf u\) and temperature \(T\) to time level \(n\), using the values at the two previous time steps. That's not an easy to read equation, but will provide us with the desired higher order accuracy. As a consistency check, it is easy to verify that it reduces to the same equation as above if \(k_n=k_{n-1}\).</p>
<p>As a final remark we note that the choice of a higher order time stepping scheme of course forces us to keep more time steps in memory; in particular, we here will need to have \(T^{n-2}\) around, a vector that we could previously discard. This seems like a nuisance that we were able to avoid previously by using only a first order time stepping scheme, but as we will see below when discussing the topic of stabilization, we will need this vector anyway and so keeping it around for time discretization is essentially for free and gives us the opportunity to use a higher order scheme.</p>
<p><a class="anchor" id="WeakformandspacediscretizationfortheStokespart"></a></p><h4>Weak form and space discretization for the Stokes part</h4>
<p>Like solving the mixed Laplace equations, solving the Stokes equations requires us to choose particular pairs of finite elements for velocities and pressure variables. Because this has already been discussed in <a class="el" href="step_22.html">step-22</a>, we only cover this topic briefly: Here, we use the stable pair \(Q_{p+1}^d \times Q_p, p\ge 1\). These are continuous elements, so we can form the weak form of the Stokes equation without problem by integrating by parts and substituting continuous functions by their discrete counterparts: </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla {\mathbf v}_h, 2\eta \varepsilon ({\mathbf u}^{n-1}_h)) - (\nabla \cdot {\mathbf v}_h, p^{n-1}_h) &amp;=&amp; -({\mathbf v}_h, \rho\; \beta \; T^{n-1}_h \mathbf{g}), \\ (q_h, \nabla \cdot {\mathbf u}^{n-1}_h) &amp;=&amp; 0, \end{eqnarray*}
</p>
<p> for all test functions \(\mathbf v_h, q_h\). The first term of the first equation is considered as the inner product between tensors, i.e. \((\nabla {\mathbf v}_h, \eta \varepsilon ({\mathbf u}^{n-1}_h))_\Omega = \int_\Omega \sum_{i,j=1}^d [\nabla {\mathbf v}_h]_{ij} \eta [\varepsilon ({\mathbf u}^{n-1}_h)]_{ij}\, dx\). Because the second tensor in this product is symmetric, the anti-symmetric component of \(\nabla {\mathbf v}_h\) plays no role and it leads to the entirely same form if we use the symmetric gradient of \(\mathbf v_h\) instead. Consequently, the formulation we consider and that we implement is </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon({\mathbf v}_h), 2\eta \varepsilon ({\mathbf u}^{n-1}_h)) - (\nabla \cdot {\mathbf v}_h, p^{n-1}_h) &amp;=&amp; -({\mathbf v}_h, \rho\; \beta \; T^{n-1}_h \mathbf{g}), \\ (q_h, \nabla \cdot {\mathbf u}^{n-1}_h) &amp;=&amp; 0. \end{eqnarray*}
</p>
<p>This is exactly the same as what we already discussed in <a class="el" href="step_22.html">step-22</a> and there is not much more to say about this here.</p>
<p><a class="anchor" id="Stabilizationweakformandspacediscretizationforthetemperatureequation"></a></p><h4>Stabilization, weak form and space discretization for the temperature equation</h4>
<p>The more interesting question is what to do with the temperature advection-diffusion equation. By default, not all discretizations of this equation are equally stable unless we either do something like upwinding, stabilization, or all of this. One way to achieve this is to use discontinuous elements (i.e., the <a class="el" href="classFE__DGQ.html">FE_DGQ</a> class that we used, for example, in the discretization of the transport equation in <a class="el" href="step_12.html">step-12</a>, or in discretizing the pressure in <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a>) and to define a flux at the interface between cells that takes into account upwinding. If we had a pure advection problem this would probably be the simplest way to go. However, here we have some diffusion as well, and the discretization of the Laplace operator with discontinuous elements is cumbersome because of the significant number of additional terms that need to be integrated on each face between cells. Discontinuous elements also have the drawback that the use of numerical fluxes introduces an additional numerical diffusion that acts everywhere, whereas we would really like to minimize the effect of numerical diffusion to a minimum and only apply it where it is necessary to stabilize the scheme.</p>
<p>A better alternative is therefore to add some nonlinear viscosity to the model. Essentially, what this does is to transform the temperature equation from the form </p><p class="formulaDsp">
\begin{eqnarray*} \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma \end{eqnarray*}
</p>
<p> to something like </p><p class="formulaDsp">
\begin{eqnarray*} \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot (\kappa+\nu(T)) \nabla T &amp;=&amp; \gamma, \end{eqnarray*}
</p>
<p> where \(\nu(T)\) is an addition viscosity (diffusion) term that only acts in the vicinity of shocks and other discontinuities. \(\nu(T)\) is chosen in such a way that if \(T\) satisfies the original equations, the additional viscosity is zero.</p>
<p>To achieve this, the literature contains a number of approaches. We will here follow one developed by Guermond and Popov that builds on a suitably defined residual and a limiting procedure for the additional viscosity. To this end, let us define a residual \(R_\alpha(T)\) as follows: </p><p class="formulaDsp">
\begin{eqnarray*} R_\alpha(T) = \left( \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T - \gamma \right) T^{\alpha-1} \end{eqnarray*}
</p>
<p> where we will later choose the stabilization exponent \(\alpha\) from within the range \([1,2]\). Note that \(R_\alpha(T)\) will be zero if \(T\) satisfies the temperature equation, since then the term in parentheses will be zero. Multiplying terms out, we get the following, entirely equivalent form: </p><p class="formulaDsp">
\begin{eqnarray*} R_\alpha(T) = \frac 1\alpha \frac{\partial (T^\alpha)}{\partial t} + \frac 1\alpha {\mathbf u} \cdot \nabla (T^\alpha) - \frac 1\alpha \nabla \cdot \kappa \nabla (T^\alpha) + \kappa(\alpha-1) T^{\alpha-2} |\nabla T|^2 - \gamma T^{\alpha-1} \end{eqnarray*}
</p>
<p>With this residual, we can now define the artificial viscosity as a piecewise constant function defined on each cell \(K\) with diameter \(h_K\) separately as follows: </p><p class="formulaDsp">
\begin{eqnarray*} \nu_\alpha(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} \min\left\{ h_K, h_K^\alpha \frac{\|R_\alpha(T)\|_{L^\infty(K)}}{c(\mathbf{u},T)} \right\} \end{eqnarray*}
</p>
<p>Here, \(\beta\) is a stabilization constant (a dimensional analysis reveals that it is unitless and therefore independent of scaling; we will discuss its choice in the <a href="#Results">results section</a>) and \(c(\mathbf{u},T)\) is a normalization constant that must have units \(\frac{m^{\alpha-1}K^\alpha}{s}\). We will choose it as \(c(\mathbf{u},T) = c_R\ \|\mathbf{u}\|_{L^\infty(\Omega)} \ \mathrm{var}(T) \ |\mathrm{diam}(\Omega)|^{\alpha-2}\), where \(\mathrm{var}(T)=\max_\Omega T - \min_\Omega T\) is the range of present temperature values (remember that buoyancy is driven by temperature variations, not the absolute temperature) and \(c_R\) is a dimensionless constant. To understand why this method works consider this: If on a particular cell \(K\) the temperature field is smooth, then we expect the residual to be small there (in fact to be on the order of \({\cal O}(h_K)\)) and the stabilization term that injects artificial diffusion will there be of size \(h_K^{\alpha+1}\) &mdash; i.e., rather small, just as we hope it to be when no additional diffusion is necessary. On the other hand, if we are on or close to a discontinuity of the temperature field, then the residual will be large; the minimum operation in the definition of \(\nu_\alpha(T)\) will then ensure that the stabilization has size \(h_K\) &mdash; the optimal amount of artificial viscosity to ensure stability of the scheme.</p>
<p>Whether or not this scheme really works is a good question. Computations by Guermond and Popov have shown that this form of stabilization actually performs much better than most of the other stabilization schemes that are around (for example streamline diffusion, to name only the simplest one). Furthermore, for \(\alpha\in [1,2)\) they can even prove that it produces better convergence orders for the linear transport equation than for example streamline diffusion. For \(\alpha=2\), no theoretical results are currently available, but numerical tests indicate that the results are considerably better than for \(\alpha=1\).</p>
<p>A more practical question is how to introduce this artificial diffusion into the equations we would like to solve. Note that the numerical viscosity \(\nu(T)\) is temperature-dependent, so the equation we want to solve is nonlinear in \(T\) &mdash; not what one desires from a simple method to stabilize an equation, and even less so if we realize that \(\nu(T)\) is nondifferentiable in \(T\). However, there is no reason to despair: we still have to discretize in time and we can treat the term explicitly.</p>
<p>In the definition of the stabilization parameter, we approximate the time derivative by \(\frac{\partial T}{\partial t} \approx \frac{T^{n-1}-T^{n-2}}{k^{n-1}}\). This approximation makes only use of available time data and this is the reason why we need to store data of two previous time steps (which enabled us to use the BDF-2 scheme without additional storage cost). We could now simply evaluate the rest of the terms at \(t_{n-1}\), but then the discrete residual would be nothing else than a backward Euler approximation, which is only first order accurate. So, in case of smooth solutions, the residual would be still of the order \(h\), despite the second order time accuracy in the outer BDF-2 scheme and the spatial FE discretization. This is certainly not what we want to have (in fact, we desired to have small residuals in regions where the solution behaves nicely), so a bit more care is needed. The key to this problem is to observe that the first derivative as we constructed it is actually centered at \(t_{n-\frac{3}{2}}\). We get the desired second order accurate residual calculation if we evaluate all spatial terms at \(t_{n-\frac{3}{2}}\) by using the approximation \(\frac 12 T^{n-1}+\frac 12 T^{n-2}\), which means that we calculate the nonlinear viscosity as a function of this intermediate temperature, \(\nu_\alpha = \nu_\alpha\left(\frac 12 T^{n-1}+\frac 12 T^{n-2}\right)\). Note that this evaluation of the residual is nothing else than a Crank-Nicholson scheme, so we can be sure that now everything is alright. One might wonder whether it is a problem that the numerical viscosity now is not evaluated at time \(n\) (as opposed to the rest of the equation). However, this offset is uncritical: For smooth solutions, \(\nu_\alpha\) will vary continuously, so the error in time offset is \(k\) times smaller than the nonlinear viscosity itself, i.e., it is a small higher order contribution that is left out. That's fine because the term itself is already at the level of discretization error in smooth regions.</p>
<p>Using the BDF-2 scheme introduced above, this yields for the simpler case of uniform time steps of size \(k\): </p><p class="formulaDsp">
\begin{eqnarray*} \frac 32 T^n - k\nabla \cdot \kappa \nabla T^n &amp;=&amp; 2 T^{n-1} - \frac 12 T^{n-2} \\ &amp;&amp; + k\nabla \cdot \left[ \nu_\alpha\left(\frac 12 T^{n-1}+\frac 12 T^{n-2}\right) \ \nabla (2T^{n-1}-T^{n-2}) \right] \\ &amp;&amp; - k(2{\mathbf u}^{n-1}-{\mathbf u}^{n-2}) \cdot \nabla (2T^{n-1}-T^{n-2}) \\ &amp;&amp; + k\gamma. \end{eqnarray*}
</p>
<p> On the left side of this equation remains the term from the time derivative and the original (physical) diffusion which we treat implicitly (this is actually a nice term: the matrices that result from the left hand side are the mass matrix and a multiple of the Laplace matrix &mdash; both are positive definite and if the time step size \(k\) is small, the sum is simple to invert). On the right hand side, the terms in the first line result from the time derivative; in the second line is the artificial diffusion at time \(t_{n-\frac 32}\); the third line contains the advection term, and the fourth the sources. Note that the artificial diffusion operates on the extrapolated temperature at the current time in the same way as we have discussed the advection works in the section on time stepping.</p>
<p>The form for nonuniform time steps that we will have to use in reality is a bit more complicated (which is why we showed the simpler form above first) and reads: </p><p class="formulaDsp">
\begin{eqnarray*} \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} T^n - k_n\nabla \cdot \kappa \nabla T^n &amp;=&amp; \frac{k_n+k_{n-1}}{k_{n-1}} T^{n-1} - \frac{k_n^2}{k_{n-1}(k_n+k_{n-1})} T^{n-2} \\ &amp;&amp; + k_n\nabla \cdot \left[ \nu_\alpha\left(\frac 12 T^{n-1}+\frac 12 T^{n-2}\right) \ \nabla \left[ \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2} \right] \right] \\ &amp;&amp; - k_n \left[ \left(1+\frac{k_n}{k_{n-1}}\right){\mathbf u}^{n-1} - \frac{k_n}{k_{n-1}}{\mathbf u}^{n-2} \right] \cdot \nabla \left[ \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2} \right] \\ &amp;&amp; + k_n\gamma. \end{eqnarray*}
</p>
<p>After settling all these issues, the weak form follows naturally from the strong form shown in the last equation, and we immediately arrive at the weak form of the discretized equations: </p><p class="formulaDsp">
\begin{eqnarray*} \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} (\tau_h,T_h^n) + k_n (\nabla \tau_h, \kappa \nabla T_h^n) &amp;=&amp; \biggl(\tau_h, \frac{k_n+k_{n-1}}{k_{n-1}} T_h^{n-1} - \frac{k_n^2}{k_{n-1}(k_n+k_{n-1})} T_h^{n-2} \\ &amp;&amp;\qquad - k_n \left[ \left(1+\frac{k_n}{k_{n-1}}\right){\mathbf u}^{n-1} - \frac{k_n}{k_{n-1}}{\mathbf u}^{n-2} \right] \cdot \nabla \left[ \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2} \right] + k_n\gamma \biggr) \\ &amp;&amp; - k_n \left(\nabla \tau_h, \nu_\alpha\left(\frac 12 T_h^{n-1}+\frac 12 T_h^{n-2}\right) \ \nabla \left[ \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2} \right] \right) \end{eqnarray*}
</p>
<p> for all discrete test functions \(\tau_h\). Here, the diffusion term has been integrated by parts, and we have used that we will impose no thermal flux, \(\mathbf{n}\cdot\kappa\nabla T|_{\partial\Omega}=0\).</p>
<p>This then results in a matrix equation of form </p><p class="formulaDsp">
\begin{eqnarray*} \left( \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} M+k_n A_T\right) T_h^n = F(U_h^{n-1}, U_h^{n-2},T_h^{n-1},T_h^{n-2}), \end{eqnarray*}
</p>
<p> which given the structure of matrix on the left (the sum of two positive definite matrices) is easily solved using the Conjugate Gradient method.</p>
<p><a class="anchor" id="Linearsolvers"></a></p><h4>Linear solvers</h4>
<p>As explained above, our approach to solving the joint system for velocities/pressure on the one hand and temperature on the other is to use an operator splitting where we first solve the Stokes system for the velocities and pressures using the old temperature field, and then solve for the new temperature field using the just computed velocity field. (A more extensive discussion of operator splitting methods can be found in <a class="el" href="step_58.html">step-58</a>.)</p>
<p><a class="anchor" id="LinearsolversfortheStokesproblem"></a></p><h5>Linear solvers for the Stokes problem</h5>
<p>Solving the linear equations coming from the Stokes system has been discussed in great detail in <a class="el" href="step_22.html">step-22</a>. In particular, in the results section of that program, we have discussed a number of alternative linear solver strategies that turned out to be more efficient than the original approach. The best alternative identified there we to use a GMRES solver preconditioned by a block matrix involving the Schur complement. Specifically, the Stokes operator leads to a block structured matrix </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \end{eqnarray*}
</p>
<p> and as discussed there a good preconditioner is </p><p class="formulaDsp">
\begin{eqnarray*} P = \left(\begin{array}{cc} A &amp; 0 \\ B &amp; -S \end{array}\right), \qquad \text{or equivalently} \qquad P^{-1} = \left(\begin{array}{cc} A^{-1} &amp; 0 \\ S^{-1} B A^{-1} &amp; -S^{-1} \end{array}\right) \end{eqnarray*}
</p>
<p> where \(S\) is the Schur complement of the Stokes operator \(S=B^TA^{-1}B\). Of course, this preconditioner is not useful because we can't form the various inverses of matrices, but we can use the following as a preconditioner: </p><p class="formulaDsp">
\begin{eqnarray*} \tilde P^{-1} = \left(\begin{array}{cc} \tilde A^{-1} &amp; 0 \\ \tilde S^{-1} B \tilde A^{-1} &amp; -\tilde S^{-1} \end{array}\right) \end{eqnarray*}
</p>
<p> where \(\tilde A^{-1},\tilde S^{-1}\) are approximations to the inverse matrices. In particular, it turned out that \(S\) is spectrally equivalent to the mass matrix and consequently replacing \(\tilde S^{-1}\) by a CG solver applied to the mass matrix on the pressure space was a good choice. In a small deviation from <a class="el" href="step_22.html">step-22</a>, we here have a coefficient \(\eta\) in the momentum equation, and by the same derivation as there we should arrive at the conclusion that it is the weighted mass matrix with entries \(\tilde S_{ij}=(\eta^{-1}\varphi_i,\varphi_j)\) that we should be using.</p>
<p>It was more complicated to come up with a good replacement \(\tilde A^{-1}\), which corresponds to the discretized symmetric Laplacian of the vector-valued velocity field, i.e. \(A_{ij} = (\varepsilon {\mathbf v}_i, 2\eta \varepsilon ({\mathbf v}_j))\). In <a class="el" href="step_22.html">step-22</a> we used a sparse LU decomposition (using the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class) of \(A\) for \(\tilde A^{-1}\) &mdash; the perfect preconditioner &mdash; in 2d, but for 3d memory and compute time is not usually sufficient to actually compute this decomposition; consequently, we only use an incomplete LU decomposition (ILU, using the <a class="el" href="classSparseILU.html">SparseILU</a> class) in 3d.</p>
<p>For this program, we would like to go a bit further. To this end, note that the symmetrized bilinear form on vector fields, \((\varepsilon {\mathbf v}_i, 2 \eta \varepsilon ({\mathbf v}_j))\) is not too far away from the nonsymmetrized version, \((\nabla {\mathbf v}_i, \eta \nabla {\mathbf v}_j) = \sum_{k,l=1}^d (\partial_k ({\mathbf v}_i)_l, \eta \partial_k ({\mathbf v}_j)_l) \) (note that the factor 2 has disappeared in this form). The latter, however, has the advantage that the <code>dim</code> vector components of the test functions are not coupled (well, almost, see below), i.e., the resulting matrix is block-diagonal: one block for each vector component, and each of these blocks is equal to the Laplace matrix for this vector component. So assuming we order degrees of freedom in such a way that first all \(x\)-components of the velocity are numbered, then the \(y\)-components, and then the \(z\)-components, then the matrix \(\hat A\) that is associated with this slightly different bilinear form has the form </p><p class="formulaDsp">
\begin{eqnarray*} \hat A = \left(\begin{array}{ccc} A_s &amp; 0 &amp; 0 \\ 0 &amp; A_s &amp; 0 \\ 0 &amp; 0 &amp; A_s \end{array}\right) \end{eqnarray*}
</p>
<p> where \(A_s\) is a Laplace matrix of size equal to the number of shape functions associated with each component of the vector-valued velocity. With this matrix, one could be tempted to define our preconditioner for the velocity matrix \(A\) as follows: </p><p class="formulaDsp">
\begin{eqnarray*} \tilde A^{-1} = \left(\begin{array}{ccc} \tilde A_s^{-1} &amp; 0 &amp; 0 \\ 0 &amp; \tilde A_s^{-1} &amp; 0 \\ 0 &amp; 0 &amp; \tilde A_s^{-1} \end{array}\right), \end{eqnarray*}
</p>
<p> where \(\tilde A_s^{-1}\) is a preconditioner for the Laplace matrix &mdash; something where we know very well how to build good preconditioners!</p>
<p>In reality, the story is not quite as simple: To make the matrix \(\tilde A\) definite, we need to make the individual blocks \(\tilde A_s\) definite by applying boundary conditions. One can try to do so by applying Dirichlet boundary conditions all around the boundary, and then the so-defined preconditioner \(\tilde A^{-1}\) turns out to be a good preconditioner for \(A\) if the latter matrix results from a Stokes problem where we also have Dirichlet boundary conditions on the velocity components all around the domain, i.e., if we enforce \(\mathbf{u} = 0\).</p>
<p>Unfortunately, this "if" is an "if and only if": in the program below we will want to use no-flux boundary conditions of the form \(\mathbf u \cdot \mathbf n = 0\) (i.e., flow parallel to the boundary is allowed, but no flux through the boundary). In this case, it turns out that the block diagonal matrix defined above is not a good preconditioner because it neglects the coupling of components at the boundary. A better way to do things is therefore if we build the matrix \(\hat A\) as the vector Laplace matrix \(\hat A_{ij} = (\nabla {\mathbf v}_i, \eta \nabla {\mathbf v}_j)\) and then apply the same boundary condition as we applied to \(A\). If this is a Dirichlet boundary condition all around the domain, the \(\hat A\) will decouple to three diagonal blocks as above, and if the boundary conditions are of the form \(\mathbf u \cdot \mathbf n = 0\) then this will introduce a coupling of degrees of freedom at the boundary but only there. This, in fact, turns out to be a much better preconditioner than the one introduced above, and has almost all the benefits of what we hoped to get.</p>
<p>To sum this whole story up, we can observe: </p><ul>
<li>
<p class="startli">Compared to building a preconditioner from the original matrix \(A\) resulting from the symmetric gradient as we did in <a class="el" href="step_22.html">step-22</a>, we have to expect that the preconditioner based on the Laplace bilinear form performs worse since it does not take into account the coupling between vector components.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">On the other hand, preconditioners for the Laplace matrix are typically more mature and perform better than ones for vector problems. For example, at the time of this writing, Algebraic Multigrid (AMG) algorithms are very well developed for scalar problems, but not so for vector problems.</p>
<p class="endli"></p>
</li>
<li>
In building this preconditioner, we will have to build up the matrix \(\hat A\) and its preconditioner. While this means that we have to store an additional matrix we didn't need before, the preconditioner \(\tilde A_s^{-1}\) is likely going to need much less memory than storing a preconditioner for the coupled matrix \(A\). This is because the matrix \(A_s\) has only a third of the entries per row for all rows corresponding to interior degrees of freedom, and contains coupling between vector components only on those parts of the boundary where the boundary conditions introduce such a coupling. Storing the matrix is therefore comparatively cheap, and we can expect that computing and storing the preconditioner \(\tilde A_s\) will also be much cheaper compared to doing so for the fully coupled matrix. </li>
</ul>
<p><a class="anchor" id="Linearsolversforthetemperatureequation"></a></p><h5>Linear solvers for the temperature equation</h5>
<p>This is the easy part: The matrix for the temperature equation has the form \(\alpha M + \beta A\), where \(M,A\) are mass and stiffness matrices on the temperature space, and \(\alpha,\beta\) are constants related the time stepping scheme and the current and previous time step. This being the sum of a symmetric positive definite and a symmetric positive semidefinite matrix, the result is also symmetric positive definite. Furthermore, \(\frac\beta\alpha\) is a number proportional to the time step, and so becomes small whenever the mesh is fine, damping the effect of the then ill-conditioned stiffness matrix.</p>
<p>As a consequence, inverting this matrix with the Conjugate Gradient algorithm, using a simple preconditioner, is trivial and very cheap compared to inverting the Stokes matrix.</p>
<p><a class="anchor" id="Implementationdetails"></a></p><h3>Implementation details</h3>
<p><a class="anchor" id="UsingdifferentDoFHandlerobjects"></a></p><h4>Using different <a class="el" href="classDoFHandler.html">DoFHandler</a> objects</h4>
<p>One of the things worth explaining up front about the program below is the use of two different <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. If one looks at the structure of the equations above and the scheme for their solution, one realizes that there is little commonality that keeps the Stokes part and the temperature part together. In all previous tutorial programs in which we have discussed <a class="el" href="group__vector__valued.html">vector-valued problems</a> we have always only used a single finite element with several vector components, and a single <a class="el" href="classDoFHandler.html">DoFHandler</a> object. Sometimes, we have substructured the resulting matrix into blocks to facilitate particular solver schemes; this was, for example, the case in the <a class="el" href="step_22.html">step-22</a> program for the Stokes equations upon which the current program is based.</p>
<p>We could of course do the same here. The linear system that we would get would look like this: </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{ccc} A &amp; B^T &amp; 0 \\ B &amp; 0 &amp;0 \\ C &amp; 0 &amp; K \end{array}\right) \left(\begin{array}{ccc} U^{n-1} \\ P^{n-1} \\ T^n \end{array}\right) = \left(\begin{array}{ccc} F_U(T^{n-1}) \\ 0 \\ F_T(U^{n-1},U^{n-2},T^{n-1},T^{n-2}) \end{array}\right). \end{eqnarray*}
</p>
<p> The problem with this is: We never use the whole matrix at the same time. In fact, it never really exists at the same time: As explained above, \(K\) and \(F_T\) depend on the already computed solution \(U^n\), in the first case through the time step (that depends on \(U^n\) because it has to satisfy a CFL condition). So we can only assemble it once we've already solved the top left \(2\times 2\) block Stokes system, and once we've moved on to the temperature equation we don't need the Stokes part any more; the fact that we build an object for a matrix that never exists as a whole in memory at any given time led us to jumping through some hoops in <a class="el" href="step_21.html">step-21</a>, so let's not repeat this sort of error. Furthermore, we don't actually build the matrix \(C\): Because by the time we get to the temperature equation we already know \(U^n\), and because we have to assemble the right hand side \(F_T\) at this time anyway, we simply move the term \(CU^n\) to the right hand side and assemble it along with all the other terms there. What this means is that there does not remain a part of the matrix where temperature variables and Stokes variables couple, and so a global enumeration of all degrees of freedom is no longer important: It is enough if we have an enumeration of all Stokes degrees of freedom, and of all temperature degrees of freedom independently.</p>
<p>In essence, there is consequently not much use in putting <em>everything</em> into a block matrix (though there are of course the same good reasons to do so for the \(2\times 2\) Stokes part), or, for that matter, in putting everything into the same <a class="el" href="classDoFHandler.html">DoFHandler</a> object.</p>
<p>But are there <em>downsides</em> to doing so? These exist, though they may not be obvious at first. The main problem is that if we need to create one global finite element that contains velocity, pressure, and temperature shape functions, and use this to initialize the <a class="el" href="classDoFHandler.html">DoFHandler</a>. But we also use this finite element object to initialize all <a class="el" href="classFEValues.html">FEValues</a> or <a class="el" href="classFEFaceValues.html">FEFaceValues</a> objects that we use. This may not appear to be that big a deal, but imagine what happens when, for example, we evaluate the residual \( R_\alpha(T) = \left( \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T - \gamma \right) T^{\alpha-1} \) that we need to compute the artificial viscosity \(\nu_\alpha(T)|_K\). For this, we need the Laplacian of the temperature, which we compute using the tensor of second derivatives (Hessians) of the shape functions (we have to give the <code>update_hessians</code> flag to the <a class="el" href="classFEValues.html">FEValues</a> object for this). Now, if we have a finite that contains the shape functions for velocities, pressures, and temperatures, that means that we have to compute the Hessians of <em>all</em> shape functions, including the many higher order shape functions for the velocities. That's a lot of computations that we don't need, and indeed if one were to do that (as we had in an early version of the program), assembling the right hand side took about a quarter of the overall compute time.</p>
<p>So what we will do is to use two different finite element objects, one for the Stokes components and one for the temperatures. With this come two different DoFHandlers, two sparsity patterns and two matrices for the Stokes and temperature parts, etc. And whenever we have to assemble something that contains both temperature and Stokes shape functions (in particular the right hand sides of Stokes and temperature equations), then we use two <a class="el" href="classFEValues.html">FEValues</a> objects initialized with two cell iterators that we walk in parallel through the two <a class="el" href="classDoFHandler.html">DoFHandler</a> objects associated with the same <a class="el" href="classTriangulation.html">Triangulation</a> object; for these two <a class="el" href="classFEValues.html">FEValues</a> objects, we use of course the same quadrature objects so that we can iterate over the same set of quadrature points, but each <a class="el" href="classFEValues.html">FEValues</a> object will get update flags only according to what it actually needs to compute. In particular, when we compute the residual as above, we only ask for the values of the Stokes shape functions, but also the Hessians of the temperature shape functions &mdash; much cheaper indeed, and as it turns out: assembling the right hand side of the temperature equation is now a component of the program that is hardly measurable.</p>
<p>With these changes, timing the program yields that only the following operations are relevant for the overall run time: </p><ul>
<li>
Solving the Stokes system: 72% of the run time. </li>
<li>
Assembling the Stokes preconditioner and computing the algebraic multigrid hierarchy using the Trilinos ML package: 11% of the run time. </li>
<li>
The function <code>BoussinesqFlowProblem::setup_dofs</code>: 7% of overall run time. </li>
<li>
Assembling the Stokes and temperature right hand side vectors as well as assembling the matrices: 7%. </li>
</ul>
<p>In essence this means that all bottlenecks apart from the algebraic multigrid have been removed.</p>
<p><a class="anchor" id="UsingTrilinos"></a></p><h4>Using Trilinos</h4>
<p>In much the same way as we used PETSc to support our linear algebra needs in <a class="el" href="step_17.html">step-17</a> and <a class="el" href="step_18.html">step-18</a>, we use interfaces to the <a href="http://trilinos.org">Trilinos</a> library (see the deal.II README file for installation instructions) in this program. Trilinos is a very large collection of everything that has to do with linear and nonlinear algebra, as well as all sorts of tools around that (and looks like it will grow in many other directions in the future as well).</p>
<p>The main reason for using Trilinos, similar to our exploring PETSc, is that it is a very powerful library that provides a lot more tools than deal.II's own linear algebra library. That includes, in particular, the ability to work in parallel on a cluster, using MPI, and a wider variety of preconditioners. In the latter class, one of the most interesting capabilities is the existence of the Trilinos ML package that implements an Algebraic <a class="el" href="classMultigrid.html">Multigrid</a> (AMG) method. We will use this preconditioner to precondition the second order operator part of the momentum equation. The ability to solve problems in parallel will be explored in <a class="el" href="step_32.html">step-32</a>, using the same problem as discussed here.</p>
<p>PETSc, which we have used in <a class="el" href="step_17.html">step-17</a> and <a class="el" href="step_18.html">step-18</a>, is certainly a powerful library, providing a large number of functions that deal with matrices, vectors, and iterative solvers and preconditioners, along with lots of other stuff, most of which runs quite well in parallel. It is, however, a few years old already than Trilinos, written in C, and generally not quite as easy to use as some other libraries. As a consequence, deal.II has also acquired interfaces to Trilinos, which shares a lot of the same functionality with PETSc. It is, however, a project that is several years younger, is written in C++ and by people who generally have put a significant emphasis on software design.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>The case we want to solve here is as follows: we solve the Boussinesq equations described above with \(\kappa=10^{-6}, \eta=1, \rho=1, \beta=10\), i.e., a relatively slow moving fluid that has virtually no thermal diffusive conductivity and transports heat mainly through convection. On the boundary, we will require no-normal flux for the velocity ( \(\mathrm{n}\cdot\mathrm{u}=0\)) and for the temperature ( \(\mathrm{n}\cdot\nabla T=0\)). This is one of the cases discussed in the introduction of <a class="el" href="step_22.html">step-22</a> and fixes one component of the velocity while allowing flow to be parallel to the boundary. There remain <code>dim-1</code> components to be fixed, namely the tangential components of the normal stress; for these, we choose homogeneous conditions which means that we do not have to anything special. Initial conditions are only necessary for the temperature field, and we choose it to be constant zero.</p>
<p>The evolution of the problem is then entirely driven by the right hand side \(\gamma(\mathrm{x},t)\) of the temperature equation, i.e., by heat sources and sinks. Here, we choose a setup invented in advance of a Christmas lecture: real candles are of course prohibited in U.S. class rooms, but virtual ones are allowed. We therefore choose three spherical heat sources unequally spaced close to the bottom of the domain, imitating three candles. The fluid located at these sources, initially at rest, is then heated up and as the temperature rises gains buoyancy, rising up; more fluid is dragged up and through the sources, leading to three hot plumes that rise up until they are captured by the recirculation of fluid that sinks down on the outside, replacing the air that rises due to heating.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first step, as always, is to include the functionality of these well-known deal.II library files and some C++ header files.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div></div><!-- fragment --><p>Then we need to include some header files that provide vector, matrix, and preconditioner classes that implement interfaces to the respective Trilinos classes. In particular, we will need interfaces to the matrix and vector classes based on Trilinos as well as Trilinos preconditioners:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, here are a few C++ headers that haven't been included yet by one of the aforelisted header files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div></div><!-- fragment --><p>At the end of this top-matter, we import all deal.II names into the global namespace:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step31</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Again, the next stage in the program is the definition of the equation data, that is, the various boundary conditions, the right hand sides and the initial condition (remember that we're about to solve a time-dependent system). The basic strategy for this definition is the same as in <a class="el" href="step_22.html">step-22</a>. Regarding the details, though, there are some differences.</p>
<p>The first thing is that we don't set any inhomogeneous boundary conditions on the velocity, since as is explained in the introduction we will use no-flux conditions \(\mathbf{n}\cdot\mathbf{u}=0\). So what is left are <code>dim-1</code> conditions for the tangential part of the normal component of the stress tensor, \(\textbf{n} \cdot [p \textbf{1} - \eta\varepsilon(\textbf{u})]\); we assume homogeneous values for these components, i.e., a natural boundary condition that requires no specific action (it appears as a zero term in the right hand side of the weak form).</p>
<p>For the temperature \(T\), we assume no thermal energy flux, i.e., \(\mathbf{n} \cdot \kappa \nabla T=0\). This, again, is a boundary condition that does not require us to do anything in particular.</p>
<p>Secondly, we have to set initial conditions for the temperature (no initial conditions are required for the velocity and pressure, since the Stokes equations for the quasi-stationary case we consider here have no time derivatives of the velocity or pressure). Here, we choose a very simple test case, where the initial temperature is zero, and all dynamics are driven by the temperature right hand side.</p>
<p>Thirdly, we need to define the right hand side of the temperature equation. We choose it to be constant within three circles (or spheres in 3d) somewhere at the bottom of the domain, as explained in the introduction, and zero outside.</p>
<p>Finally, or maybe firstly, at the top of this namespace, we define the various material constants we need ( \(\eta,\kappa\), density \(\rho\) and the thermal expansion coefficient \(\beta\)):</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>EquationData</div><div class="line">{</div><div class="line">  constexpr <span class="keywordtype">double</span> eta     = 1;</div><div class="line">  constexpr <span class="keywordtype">double</span> kappa   = 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6;</div><div class="line">  constexpr <span class="keywordtype">double</span> beta    = 10;</div><div class="line">  constexpr <span class="keywordtype">double</span> density = 1;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TemperatureInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TemperatureInitialValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">        value(c) = TemperatureInitialValues&lt;dim&gt;::value(p, c);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TemperatureRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TemperatureRightHandSide()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0,</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Invalid operation for a scalar function.&quot;</span>));</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((dim == 2) || (dim == 3), <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">      <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> source_centers[3] = {</div><div class="line">        (dim == 2 ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(.3, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.3, .5, .1)),</div><div class="line">        (dim == 2 ? <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.45, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.45, .5, .1)),</div><div class="line">        (dim == 2 ? <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.75, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.75, .5, .1))};</div><div class="line">      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> source_radius = (dim == 2 ? 1. / 32 : 1. / 8);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> ((source_centers[0].distance(p) &lt; source_radius) ||</div><div class="line">                  (source_centers[1].<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(p) &lt; source_radius) ||</div><div class="line">                  (source_centers[2].distance(p) &lt; source_radius) ?</div><div class="line">                1 :</div><div class="line">                0);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">        value(c) = TemperatureRightHandSide&lt;dim&gt;::value(p, c);</div><div class="line">    }</div><div class="line">  };</div><div class="line">} <span class="comment">// namespace EquationData</span></div></div><!-- fragment --><p><a class="anchor" id="Linearsolversandpreconditioners"></a> </p><h3>Linear solvers and preconditioners</h3>
<p>This section introduces some objects that are used for the solution of the linear equations of the Stokes system that we need to solve in each time step. Many of the ideas used here are the same as in <a class="el" href="step_20.html">step-20</a>, where Schur complement based preconditioners and solvers have been introduced, with the actual interface taken from <a class="el" href="step_22.html">step-22</a> (in particular the discussion in the "Results" section of <a class="el" href="step_22.html">step-22</a>, in which we introduce alternatives to the direct Schur complement approach). Note, however, that here we don't use the Schur complement to solve the Stokes equations, though an approximate Schur complement (the mass matrix on the pressure space) appears in the preconditioner.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>LinearSolvers</div><div class="line">{</div></div><!-- fragment --><p><a class="anchor" id="ThecodeInverseMatrixcodeclasstemplate"></a> </p><h4>The <code>InverseMatrix</code> class template</h4>
<p>This class is an interface to calculate the action of an "inverted" matrix on a vector (using the <code>vmult</code> operation) in the same way as the corresponding class in <a class="el" href="step_22.html">step-22</a>: when the product of an object of this class is requested, we solve a linear equation system with that matrix using the CG method, accelerated by a preconditioner of (templated) class <code>PreconditionerType</code>.</p>
<p>In a minor deviation from the implementation of the same class in <a class="el" href="step_22.html">step-22</a>, we make the <code>vmult</code> function take any kind of vector type (it will yield compiler errors, however, if the matrix does not allow a matrix-vector product with this kind of vector).</p>
<p>Secondly, we catch any exceptions that the solver may have thrown. The reason is as follows: When debugging a program like this one occasionally makes a mistake of passing an indefinite or nonsymmetric matrix or preconditioner to the current class. The solver will, in that case, not converge and throw a run-time exception. If not caught here it will propagate up the call stack and may end up in <code>main()</code> where we output an error message that will say that the CG solver failed. The question then becomes: Which CG solver? The one that inverted the mass matrix? The one that inverted the top left block with the Laplace operator? Or a CG solver in one of the several other nested places where we use linear solvers in the current code? No indication about this is present in a run-time exception because it doesn't store the stack of calls through which we got to the place where the exception was generated.</p>
<p>So rather than letting the exception propagate freely up to <code>main()</code> we realize that there is little that an outer function can do if the inner solver fails and rather convert the run-time exception into an assertion that fails and triggers a call to <code><a class="el" href="namespacedeal__II__exceptions_1_1internals.html#a600f8f191a6ce368afda0074dd7ea1dc">abort()</a></code>, allowing us to trace back in a debugger how we got to the current place.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVectorType.html">VectorType</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">  <span class="keyword">const</span> PreconditionerType &amp;           preconditioner;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">  <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">  <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">  : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">  , preconditioner(preconditioner)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line"><span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">  <a class="code" href="classVectorType.html">VectorType</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>        solver_control(src.size(), 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-7 * src.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;VectorType&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">  dst = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, preconditioner);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(e.what()));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Schurcomplementpreconditioner"></a> </p><h4>Schur complement preconditioner</h4>
<p>This is the implementation of the Schur complement preconditioner as described in detail in the introduction. As opposed to <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_22.html">step-22</a>, we solve the block system all-at-once using GMRES, and use the Schur complement of the block structured matrix to build a good preconditioner instead.</p>
<p>Let's have a look at the ideal preconditioner matrix \(P=\left(\begin{array}{cc} A &amp; 0 \\ B &amp; -S \end{array}\right)\) described in the introduction. If we apply this matrix in the solution of a linear system, convergence of an iterative GMRES solver will be governed by the matrix </p><p class="formulaDsp">
\begin{eqnarray*} P^{-1}\left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) = \left(\begin{array}{cc} I &amp; A^{-1} B^T \\ 0 &amp; I \end{array}\right), \end{eqnarray*}
</p>
<p> which indeed is very simple. A GMRES solver based on exact matrices would converge in one iteration, since all eigenvalues are equal (any Krylov method takes at most as many iterations as there are distinct eigenvalues). Such a preconditioner for the blocked Stokes system has been proposed by Silvester and Wathen ("Fast iterative solution of stabilised Stokes
 systems part II.  Using general block preconditioners", SIAM J. Numer. Anal., 31 (1994), pp. 1352-1367).</p>
<p>Replacing \(P\) by \(\tilde{P}\) keeps that spirit alive: the product \(P^{-1} A\) will still be close to a matrix with eigenvalues 1 with a distribution that does not depend on the problem size. This lets us hope to be able to get a number of GMRES iterations that is problem-size independent.</p>
<p>The deal.II users who have already gone through the <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_22.html">step-22</a> tutorials can certainly imagine how we're going to implement this. We replace the exact inverse matrices in \(P^{-1}\) by some approximate inverses built from the InverseMatrix class, and the inverse Schur complement will be approximated by the pressure mass matrix \(M_p\) (weighted by \(\eta^{-1}\) as mentioned in the introduction). As pointed out in the results section of <a class="el" href="step_22.html">step-22</a>, we can replace the exact inverse of \(A\) by just the application of a preconditioner, in this case on a vector Laplace matrix as was explained in the introduction. This does increase the number of (outer) GMRES iterations, but is still significantly cheaper than an exact inverse, which would require between 20 and 35 CG iterations for <em>each</em> outer solver step (using the AMG preconditioner).</p>
<p>Having the above explanations in mind, we define a preconditioner class with a <code>vmult</code> functionality, which is all we need for the interaction with the usual solver functions further below in the program code.</p>
<p>First the declarations. These are similar to the definition of the Schur complement in <a class="el" href="step_20.html">step-20</a>, with the difference that we need some more preconditioners in the constructor and that the matrices we use here are built upon Trilinos:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line"><span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BlockSchurPreconditioner(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                        PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">    <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">    stokes_matrix;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;<span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                         PreconditionerTypeMp&gt;&gt;</div><div class="line">                             m_inverse;</div><div class="line">  <span class="keyword">const</span> PreconditionerTypeA &amp;a_preconditioner;</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp;</div><div class="line">};</div></div><!-- fragment --><p>When using a <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> or a <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>, the <a class="el" href="classVector.html">Vector</a> is initialized using an <a class="el" href="classIndexSet.html">IndexSet</a>. <a class="el" href="classIndexSet.html">IndexSet</a> is used not only to resize the <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> but it also associates an index in the <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> with a degree of freedom (see <a class="el" href="step_40.html">step-40</a> for a more detailed explanation). The function <a class="el" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set()</a> creates an <a class="el" href="classIndexSet.html">IndexSet</a> where every valid index is part of the set. Note that this program can only be run sequentially and will throw an exception if used in parallel.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::</div><div class="line">  BlockSchurPreconditioner(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                        PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">    <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner)</div><div class="line">  : stokes_matrix(&amp;S)</div><div class="line">  , m_inverse(&amp;Mpinv)</div><div class="line">  , a_preconditioner(Apreconditioner)</div><div class="line">  , tmp(<a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(stokes_matrix-&gt;block(1, 1).m()))</div><div class="line">{}</div></div><!-- fragment --><p>Next is the <code>vmult</code> function. We implement the action of \(P^{-1}\) as described above in three successive steps. In formulas, we want to compute \(Y=P^{-1}X\) where \(X,Y\) are both vectors with two block components.</p>
<p>The first step multiplies the velocity part of the vector by a preconditioner of the matrix \(A\), i.e., we compute \(Y_0={\tilde A}^{-1}X_0\). The resulting velocity vector is then multiplied by \(B\) and subtracted from the pressure, i.e., we want to compute \(X_1-BY_0\). This second step only acts on the pressure vector and is accomplished by the residual function of our matrix classes, except that the sign is wrong. Consequently, we change the sign in the temporary pressure vector and finally multiply by the inverse pressure mass matrix to get the final pressure vector, completing our work on the Stokes preconditioner:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::vmult(</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    a_preconditioner.vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">    stokes_matrix-&gt;block(1, 0).residual(tmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">    tmp *= -1;</div><div class="line">    m_inverse-&gt;vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace LinearSolvers</span></div></div><!-- fragment --><p><a class="anchor" id="ThecodeBoussinesqFlowProblemcodeclasstemplate"></a> </p><h3>The <code>BoussinesqFlowProblem</code> class template</h3>
<p>The definition of the class that defines the top-level logic of solving the time-dependent Boussinesq problem is mainly based on the <a class="el" href="step_22.html">step-22</a> tutorial program. The main differences are that now we also have to solve for the temperature equation, which forces us to have a second <a class="el" href="classDoFHandler.html">DoFHandler</a> object for the temperature variable as well as matrices, right hand sides, and solution vectors for the current and previous time steps. As mentioned in the introduction, all linear algebra objects are going to use wrappers of the corresponding Trilinos functionality.</p>
<p>The member functions of this class are reminiscent of <a class="el" href="step_21.html">step-21</a>, where we also used a staggered scheme that first solve the flow equations (here the Stokes equations, in <a class="el" href="step_21.html">step-21</a> Darcy flow) and then update the advected quantity (here the temperature, there the saturation). The functions that are new are mainly concerned with determining the time step, as well as the proper size of the artificial viscosity stabilization.</p>
<p>The last three variables indicate whether the various matrices or preconditioners need to be rebuilt the next time the corresponding build functions are called. This allows us to move the corresponding <code>if</code> into the respective function and thereby keeping our main <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function clean and easy to read.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoussinesqFlowProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoussinesqFlowProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>   setup_dofs();</div><div class="line">  <span class="keywordtype">void</span>   assemble_stokes_preconditioner();</div><div class="line">  <span class="keywordtype">void</span>   build_stokes_preconditioner();</div><div class="line">  <span class="keywordtype">void</span>   assemble_stokes_system();</div><div class="line">  <span class="keywordtype">void</span>   assemble_temperature_system(<span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity);</div><div class="line">  <span class="keywordtype">void</span>   assemble_temperature_matrix();</div><div class="line">  <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div><div class="line">  std::pair&lt;double, double&gt; get_extrapolated_temperature_range() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span>                      solve();</div><div class="line">  <span class="keywordtype">void</span>                      output_results() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span>                      refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> compute_viscosity(</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        gamma_values,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_u_infty,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_T_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <span class="keywordtype">double</span>             global_Omega_diameter;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        stokes_degree;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             stokes_fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           stokes_dof_handler;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> stokes_constraints;</div><div class="line"></div><div class="line">  std::vector&lt;IndexSet&gt;               stokes_partitioning;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_matrix;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_preconditioner_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_stokes_solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_rhs;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        temperature_degree;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 temperature_fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           temperature_dof_handler;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> temperature_constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> temperature_mass_matrix;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> temperature_stiffness_matrix;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> temperature_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_temperature_solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_temperature_solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_rhs;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>       time_step;</div><div class="line">  <span class="keywordtype">double</span>       old_time_step;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">  std::shared_ptr&lt;TrilinosWrappers::PreconditionAMG&gt; Amg_preconditioner;</div><div class="line">  std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt;  Mp_preconditioner;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> rebuild_stokes_matrix;</div><div class="line">  <span class="keywordtype">bool</span> rebuild_temperature_matrices;</div><div class="line">  <span class="keywordtype">bool</span> rebuild_stokes_preconditioner;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemclassimplementation"></a> </p><h3>BoussinesqFlowProblem class implementation</h3>
<p><a class="anchor" id="BoussinesqFlowProblemBoussinesqFlowProblem"></a> </p><h4>BoussinesqFlowProblem::BoussinesqFlowProblem</h4>
<p>The constructor of this class is an extension of the constructor in <a class="el" href="step_22.html">step-22</a>. We need to add the various variables that concern the temperature. As discussed in the introduction, we are going to use \(Q_2\times Q_1\) (Taylor-Hood) elements again for the Stokes part, and \(Q_2\) elements for the temperature. However, by using variables that store the polynomial degree of the Stokes and temperature finite elements, it is easy to consistently modify the degree of the elements as well as all quadrature formulas used on them downstream. Moreover, we initialize the time stepping as well as the options for matrix assembly and preconditioning:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::BoussinesqFlowProblem()</div><div class="line">  : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">  , global_Omega_diameter(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">  , stokes_degree(1)</div><div class="line">  , stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree), 1)</div><div class="line">  , stokes_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  temperature_degree(2)</div><div class="line">  , temperature_fe(temperature_degree)</div><div class="line">  , temperature_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  time_step(0)</div><div class="line">  , old_time_step(0)</div><div class="line">  , timestep_number(0)</div><div class="line">  , rebuild_stokes_matrix(true)</div><div class="line">  , rebuild_temperature_matrices(true)</div><div class="line">  , rebuild_stokes_preconditioner(true)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemget_maximal_velocity"></a> </p><h4>BoussinesqFlowProblem::get_maximal_velocity</h4>
<p>Starting the real functionality of this class is a helper function that determines the maximum ( \(L_\infty\)) velocity in the domain (at the quadrature points, in fact). How it works should be relatively obvious to all who have gotten to this point of the tutorial. Note that since we are only interested in the velocity, rather than using <code>stokes_fe_values.get_function_values</code> to get the values of the entire Stokes solution (velocities and pressures) we use <code>stokes_fe_values[velocities].get_function_values</code> to extract only the velocities part. This has the additional benefit that we get it as a <a class="el" href="classTensor.html">Tensor&lt;1,dim&gt;</a>, rather than some components in a <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>, allowing us to process it right away using the <code><a class="el" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm()</a></code> function to get the magnitude of the velocity.</p>
<p>The only point worth thinking about a bit is how to choose the quadrature points we use here. Since the goal of this function is to find the maximal velocity over a domain by looking at quadrature points on each cell. So we should ask how we should best choose these quadrature points on each cell. To this end, recall that if we had a single \(Q_1\) field (rather than the vector-valued field of higher order) then the maximum would be attained at a vertex of the mesh. In other words, we should use the <a class="el" href="classQTrapezoid.html">QTrapezoid</a> class that has quadrature points only at the vertices of cells.</p>
<p>For higher order shape functions, the situation is more complicated: the maxima and minima may be attained at points between the support points of shape functions (for the usual \(Q_p\) elements the support points are the equidistant Lagrange interpolation points); furthermore, since we are looking for the maximum magnitude of a vector-valued quantity, we can even less say with certainty where the set of potential maximal points are. Nevertheless, intuitively if not provably, the Lagrange interpolation points appear to be a better choice than the Gauss points.</p>
<p>There are now different methods to produce a quadrature formula with quadrature points equal to the interpolation points of the finite element. One option would be to use the <a class="el" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">FiniteElement::get_unit_support_points()</a> function, reduce the output to a unique set of points to avoid duplicate function evaluations, and create a <a class="el" href="classQuadrature.html">Quadrature</a> object using these points. Another option, chosen here, is to use the <a class="el" href="classQTrapezoid.html">QTrapezoid</a> class and combine it with the <a class="el" href="classQIterated.html">QIterated</a> class that repeats the <a class="el" href="classQTrapezoid.html">QTrapezoid</a> formula on a number of sub-cells in each coordinate direction. To cover all support points, we need to iterate it <code>stokes_degree+1</code> times since this is the polynomial degree of the Stokes element in use:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(), stokes_degree + 1);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(stokes_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points);</div><div class="line">  <span class="keywordtype">double</span>                      max_velocity = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(stokes_solution,</div><div class="line">                                                velocity_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity, velocity_values[q].<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> max_velocity;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemget_extrapolated_temperature_range"></a> </p><h4>BoussinesqFlowProblem::get_extrapolated_temperature_range</h4>
<p>Next a function that determines the minimum and maximum temperature at quadrature points inside \(\Omega\) when extrapolated from the two previous time steps to the current one. We need this information in the computation of the artificial viscosity parameter \(\nu\) as discussed in the introduction.</p>
<p>The formula for the extrapolated temperature is \(\left(1+\frac{k_n}{k_{n-1}} \right)T^{n-1} + \frac{k_n}{k_{n-1}} T^{n-2}\). The way to compute it is to loop over all quadrature points and update the maximum and minimum value if the current value is bigger/smaller than the previous one. We initialize the variables that store the max and min before the loop over all quadrature points by the smallest and the largest number representable as a double. Then we know for a fact that it is larger/smaller than the minimum/maximum and that the loop over all quadrature points is ultimately going to update the initial value with the correct one.</p>
<p>The only other complication worth mentioning here is that in the first time step, \(T^{k-2}\) is not yet available of course. In that case, we can only use \(T^{k-1}\) which we have from the initial temperature. As quadrature points, we use the same choice as in the previous function though with the difference that now the number of repetitions is determined by the polynomial degree of the temperature field.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;double, double&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::get_extrapolated_temperature_range()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                          temperature_degree);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(temperature_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">             max_temperature = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                        old_temperature_values);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_temperature_solution,</div><div class="line">                                        old_old_temperature_values);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> temperature =</div><div class="line">                (1. + time_step / old_time_step) * old_temperature_values[q] -</div><div class="line">                time_step / old_time_step * old_old_temperature_values[q];</div><div class="line"></div><div class="line">              min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_temperature, temperature);</div><div class="line">              max_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_temperature, temperature);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> std::make_pair(min_temperature, max_temperature);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">             max_temperature = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                        old_temperature_values);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> temperature = old_temperature_values[q];</div><div class="line"></div><div class="line">              min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_temperature, temperature);</div><div class="line">              max_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_temperature, temperature);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> std::make_pair(min_temperature, max_temperature);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemcompute_viscosity"></a> </p><h4>BoussinesqFlowProblem::compute_viscosity</h4>
<p>The last of the tool functions computes the artificial viscosity parameter \(\nu|_K\) on a cell \(K\) as a function of the extrapolated temperature, its gradient and Hessian (second derivatives), the velocity, the right hand side \(\gamma\) all on the quadrature points of the current cell, and various other parameters as described in detail in the introduction.</p>
<p>There are some universal constants worth mentioning here. First, we need to fix \(\beta\); we choose \(\beta=0.017\cdot dim\), a choice discussed in detail in the results section of this tutorial program. The second is the exponent \(\alpha\); \(\alpha=1\) appears to work fine for the current program, even though some additional benefit might be expected from choosing \(\alpha = 2\). Finally, there is one thing that requires special casing: In the first time step, the velocity equals zero, and the formula for \(\nu|_K\) is not defined. In that case, we return \(\nu|_K=5\cdot 10^3 \cdot h_K\), a choice admittedly more motivated by heuristics than anything else (it is in the same order of magnitude, however, as the value returned for most cells on the second time step).</p>
<p>The rest of the function should be mostly obvious based on the material discussed in the introduction:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::compute_viscosity(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        gamma_values,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_u_infty,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_T_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  constexpr <span class="keywordtype">double</span> beta  = 0.017 * dim;</div><div class="line">  constexpr <span class="keywordtype">double</span> alpha = 1.0;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (global_u_infty == 0)</div><div class="line">    <span class="keywordflow">return</span> 5e-3 * cell_diameter;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_temperature.size();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_residual = 0;</div><div class="line">  <span class="keywordtype">double</span> max_velocity = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u =</div><div class="line">        (old_velocity_values[q] + old_old_velocity_values[q]) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> dT_dt =</div><div class="line">        (old_temperature[q] - old_old_temperature[q]) / old_time_step;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_T =</div><div class="line">        u * (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> kappa_Delta_T =</div><div class="line">        EquationData::kappa *</div><div class="line">        (old_temperature_laplacians[q] + old_old_temperature_laplacians[q]) /</div><div class="line">        2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> residual =</div><div class="line">        <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>((dT_dt + u_grad_T - kappa_Delta_T - gamma_values[q]) *</div><div class="line">                 std::pow((old_temperature[q] + old_old_temperature[q]) / 2,</div><div class="line">                          alpha - 1.));</div><div class="line"></div><div class="line">      max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div><div class="line">      max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u * u), max_velocity);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> c_R            = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2., (4. - 2 * alpha) / dim);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> global_scaling = c_R * global_u_infty * global_T_variation *</div><div class="line">                                <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(global_Omega_diameter, alpha - 2.);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (</div><div class="line">    beta * max_velocity *</div><div class="line">    <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(cell_diameter,</div><div class="line">             std::pow(cell_diameter, alpha) * max_residual / global_scaling));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemsetup_dofs"></a> </p><h4>BoussinesqFlowProblem::setup_dofs</h4>
<p>This is the function that sets up the <a class="el" href="classDoFHandler.html">DoFHandler</a> objects we have here (one for the Stokes part and one for the temperature part) as well as set to the right sizes the various objects required for the linear algebra in this program. Its basic operations are similar to what we do in <a class="el" href="step_22.html">step-22</a>.</p>
<p>The body of the function first enumerates all degrees of freedom for the Stokes and temperature systems. For the Stokes part, degrees of freedom are then sorted to ensure that velocities precede pressure DoFs so that we can partition the Stokes matrix into a \(2\times 2\) matrix. As a difference to <a class="el" href="step_22.html">step-22</a>, we do not perform any additional DoF renumbering. In that program, it paid off since our solver was heavily dependent on ILU's, whereas we use AMG here which is not sensitive to the DoF numbering. The IC preconditioner for the inversion of the pressure mass matrix would of course take advantage of a Cuthill-McKee like renumbering, but its costs are low compared to the velocity portion, so the additional work does not pay off.</p>
<p>We then proceed with the generation of the hanging node constraints that arise from adaptive grid refinement for both <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. For the velocity, we impose no-flux boundary conditions \(\mathbf{u}\cdot \mathbf{n}=0\) by adding constraints to the object that already stores the hanging node constraints matrix. The second parameter in the function describes the first of the velocity components in the total dof vector, which is zero here. The variable <code>no_normal_flux_boundaries</code> denotes the boundary indicators for which to set the no flux boundary conditions; here, this is boundary indicator zero.</p>
<p>After having done so, we count the number of degrees of freedom in the various blocks:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; stokes_sub_blocks(dim + 1, 0);</div><div class="line">  stokes_sub_blocks[dim] = 1;</div><div class="line"></div><div class="line">  {</div><div class="line">    stokes_dof_handler.distribute_dofs(stokes_fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">    stokes_constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(stokes_dof_handler,</div><div class="line">                                            stokes_constraints);</div><div class="line">    std::set&lt;types::boundary_id&gt; no_normal_flux_boundaries;</div><div class="line">    no_normal_flux_boundaries.insert(0);</div><div class="line">    <a class="code" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a>(stokes_dof_handler,</div><div class="line">                                                    0,</div><div class="line">                                                    no_normal_flux_boundaries,</div><div class="line">                                                    stokes_constraints);</div><div class="line">    stokes_constraints.close();</div><div class="line">  }</div><div class="line">  {</div><div class="line">    temperature_dof_handler.distribute_dofs(temperature_fe);</div><div class="line"></div><div class="line">    temperature_constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(temperature_dof_handler,</div><div class="line">                                            temperature_constraints);</div><div class="line">    temperature_constraints.close();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; stokes_dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = stokes_dofs_per_block[0],</div><div class="line">                     n_p = stokes_dofs_per_block[1],</div><div class="line">                     n_T = temperature_dof_handler.n_dofs();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_T &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">            &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_T &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div></div><!-- fragment --><p>The next step is to create the sparsity pattern for the Stokes and temperature system matrices as well as the preconditioner matrix from which we build the Stokes preconditioner. As in <a class="el" href="step_22.html">step-22</a>, we choose to create the pattern by using the blocked version of <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>.</p>
<p>So, we first release the memory stored in the matrices, then set up an object of type <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> consisting of \(2\times 2\) blocks (for the Stokes system matrix and preconditioner) or <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> (for the temperature part). We then fill these objects with the nonzero pattern, taking into account that for the Stokes system matrix, there are no entries in the pressure-pressure block (but all velocity vector components couple with each other and with the pressure). Similarly, in the Stokes preconditioner matrix, only the diagonal blocks are nonzero, since we use the vector Laplacian as discussed in the introduction. This operator only couples each vector component of the Laplacian with itself, but not with the other vector components. (Application of the constraints resulting from the no-flux boundary conditions will couple vector components at the boundary again, however.)</p>
<p>When generating the sparsity pattern, we directly apply the constraints from hanging nodes and no-flux boundary conditions. This approach was already used in <a class="el" href="step_27.html">step-27</a>, but is different from the one in early tutorial programs where we first built the original sparsity pattern and only then added the entries resulting from constraints. The reason for doing so is that later during assembly we are going to distribute the constraints immediately when transferring local to global dofs. Consequently, there will be no data written at positions of constrained degrees of freedom, so we can let the <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> function omit these entries by setting the last Boolean flag to <code>false</code>. Once the sparsity pattern is ready, we can use it to initialize the Trilinos matrices. Since the Trilinos matrices store the sparsity pattern internally, there is no need to keep the sparsity pattern around after the initialization of the matrix.</p>
<div class="fragment"><div class="line">stokes_partitioning.resize(2);</div><div class="line">stokes_partitioning[0] = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_u);</div><div class="line">stokes_partitioning[1] = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_p);</div><div class="line">{</div><div class="line">  stokes_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">  dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">  dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">  dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">  dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">  dsp.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">    stokes_dof_handler, coupling, dsp, stokes_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  stokes_matrix.reinit(dsp);</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  Amg_preconditioner.reset();</div><div class="line">  Mp_preconditioner.reset();</div><div class="line">  stokes_preconditioner_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">  dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">  dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">  dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">  dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">  dsp.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (c == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">    stokes_dof_handler, coupling, dsp, stokes_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  stokes_preconditioner_matrix.reinit(dsp);</div><div class="line">}</div></div><!-- fragment --><p>The creation of the temperature matrix (or, rather, matrices, since we provide a temperature mass matrix and a temperature stiffness matrix, that will be added together for time discretization) follows the generation of the Stokes matrix &ndash; except that it is much easier here since we do not need to take care of any blocks or coupling between components. Note how we initialize the three temperature matrices: We only use the sparsity pattern for reinitialization of the first matrix, whereas we use the previously generated matrix for the two remaining reinits. The reason for doing so is that reinitialization from an already generated matrix allows Trilinos to reuse the sparsity pattern instead of generating a new one for each copy. This saves both some time and memory.</p>
<div class="fragment"><div class="line">{</div><div class="line">  temperature_mass_matrix.clear();</div><div class="line">  temperature_stiffness_matrix.clear();</div><div class="line">  temperature_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_T, n_T);</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(temperature_dof_handler,</div><div class="line">                                  dsp,</div><div class="line">                                  temperature_constraints,</div><div class="line">                                  <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  temperature_matrix.reinit(dsp);</div><div class="line">  temperature_mass_matrix.reinit(temperature_matrix);</div><div class="line">  temperature_stiffness_matrix.reinit(temperature_matrix);</div><div class="line">}</div></div><!-- fragment --><p>Lastly, we set the vectors for the Stokes solutions \(\mathbf u^{n-1}\) and \(\mathbf u^{n-2}\), as well as for the temperatures \(T^{n}\), \(T^{n-1}\) and \(T^{n-2}\) (required for time stepping) and all the system right hand sides to their correct sizes and block structure:</p>
<div class="fragment"><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> temperature_partitioning = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_T);</div><div class="line">  stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line">  stokes_rhs.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_old_temperature_solution.reinit(temperature_partitioning,</div><div class="line">                                      MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  temperature_rhs.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemassemble_stokes_preconditioner"></a> </p><h4>BoussinesqFlowProblem::assemble_stokes_preconditioner</h4>
<p>This function assembles the matrix we use for preconditioning the Stokes system. What we need are a vector Laplace matrix on the velocity components and a mass matrix weighted by \(\eta^{-1}\) on the pressure component. We start by generating a quadrature object of appropriate order, the <a class="el" href="classFEValues.html">FEValues</a> object that can give values and gradients at the quadrature points (together with quadrature weights). Next we create data structures for the cell matrix and the relation between local and global DoFs. The vectors <code>grad_phi_u</code> and <code>phi_p</code> are going to hold the values of the basis functions in order to faster build up the local matrices, as was already done in <a class="el" href="step_22.html">step-22</a>. Before we start the loop over all active cells, we have to specify which components are pressure and which are velocity.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_preconditioner()</div><div class="line">{</div><div class="line">  stokes_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(stokes_degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(stokes_fe,</div><div class="line">                                 quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt;&gt; grad_phi_u(dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt;         phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      stokes_fe_values.reinit(cell);</div><div class="line">      local_matrix = 0;</div></div><!-- fragment --><p>The creation of the local matrix is rather simple. There are only a Laplace term (on the velocity) and a mass matrix weighted by \(\eta^{-1}\) to be generated, so the creation of the local matrix is done in two lines. Once the local matrix is ready (loop over rows and columns in the local matrix on each quadrature point), we get the local DoF indices and write the local information into the global matrix. We do this as in <a class="el" href="step_27.html">step-27</a>, i.e., we directly apply the constraints from hanging nodes locally. By doing so, we don't have to do that afterwards, and we don't also write into entries of the matrix that will actually be set to zero again later when eliminating constraints.</p>
<div class="fragment"><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              grad_phi_u[k] = stokes_fe_values[velocities].gradient(k, q);</div><div class="line">              phi_p[k]      = stokes_fe_values[pressure].value(k, q);</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              local_matrix(i, j) +=</div><div class="line">                (EquationData::eta *</div><div class="line">                   <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[i], grad_phi_u[j]) +</div><div class="line">                 (1. / EquationData::eta) * phi_p[i] * phi_p[j]) *</div><div class="line">                stokes_fe_values.JxW(q);</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      stokes_constraints.distribute_local_to_global(</div><div class="line">        local_matrix, local_dof_indices, stokes_preconditioner_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblembuild_stokes_preconditioner"></a> </p><h4>BoussinesqFlowProblem::build_stokes_preconditioner</h4>
<p>This function generates the inner preconditioners that are going to be used for the Schur complement block preconditioner. Since the preconditioners need only to be regenerated when the matrices change, this function does not have to do anything in case the matrices have not changed (i.e., the flag <code>rebuild_stokes_preconditioner</code> has the value <code>false</code>). Otherwise its first task is to call <code>assemble_stokes_preconditioner</code> to generate the preconditioner matrices.</p>
<p>Next, we set up the preconditioner for the velocity-velocity matrix \(A\). As explained in the introduction, we are going to use an AMG preconditioner based on a vector Laplace matrix \(\hat{A}\) (which is spectrally close to the Stokes matrix \(A\)). Usually, the <a class="el" href="classTrilinosWrappers_1_1PreconditionAMG.html">TrilinosWrappers::PreconditionAMG</a> class can be seen as a good black-box preconditioner which does not need any special knowledge. In this case, however, we have to be careful: since we build an AMG for a vector problem, we have to tell the preconditioner setup which dofs belong to which vector component. We do this using the function <a class="el" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>, a function that generates a set of <code>dim</code> vectors, where each one has ones in the respective component of the vector problem and zeros elsewhere. Hence, these are the constant modes on each component, which explains the name of the variable.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::build_stokes_preconditioner()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_preconditioner == <span class="keyword">false</span>)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding Stokes preconditioner...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  assemble_stokes_preconditioner();</div><div class="line"></div><div class="line">  Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionAMG&gt;();</div><div class="line"></div><div class="line">  std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocity_components(0);</div><div class="line">  <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(stokes_dof_handler,</div><div class="line">                                   stokes_fe.component_mask(</div><div class="line">                                     velocity_components),</div><div class="line">                                   constant_modes);</div><div class="line">  <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> amg_data;</div><div class="line">  amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a> = constant_modes;</div></div><!-- fragment --><p>Next, we set some more options of the AMG preconditioner. In particular, we need to tell the AMG setup that we use quadratic basis functions for the velocity matrix (this implies more nonzero elements in the matrix, so that a more robust algorithm needs to be chosen internally). Moreover, we want to be able to control how the coarsening structure is build up. The way the Trilinos smoothed aggregation AMG does this is to look which matrix entries are of similar size as the diagonal entry in order to algebraically build a coarse-grid structure. By setting the parameter <code>aggregation_threshold</code> to 0.02, we specify that all entries that are more than two percent of size of some diagonal pivots in that row should form one coarse grid point. This parameter is rather ad hoc, and some fine-tuning of it can influence the performance of the preconditioner. As a rule of thumb, larger values of <code>aggregation_threshold</code> will decrease the number of iterations, but increase the costs per iteration. A look at the Trilinos documentation will provide more information on these parameters. With this data set, we then initialize the preconditioner with the matrix we want it to apply to.</p>
<p>Finally, we also initialize the preconditioner for the inversion of the pressure mass matrix. This matrix is symmetric and well-behaved, so we can chose a simple preconditioner. We stick with an incomplete Cholesky (IC) factorization preconditioner, which is designed for symmetric matrices. We could have also chosen an SSOR preconditioner with relaxation factor around 1.2, but IC is cheaper for our example. We wrap the preconditioners into a <code>std::shared_ptr</code> pointer, which makes it easier to recreate the preconditioner next time around since we do not have to care about destroying the previously used object.</p>
<div class="fragment"><div class="line">  amg_data.elliptic              = <span class="keyword">true</span>;</div><div class="line">  amg_data.higher_order_elements = <span class="keyword">true</span>;</div><div class="line">  amg_data.smoother_sweeps       = 2;</div><div class="line">  amg_data.aggregation_threshold = 0.02;</div><div class="line">  Amg_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(0, 0),</div><div class="line">                                 amg_data);</div><div class="line"></div><div class="line">  Mp_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">  Mp_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(1, 1));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  rebuild_stokes_preconditioner = <span class="keyword">false</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemassemble_stokes_system"></a> </p><h4>BoussinesqFlowProblem::assemble_stokes_system</h4>
<p>The time lag scheme we use for advancing the coupled Stokes-temperature system forces us to split up the assembly (and the solution of linear systems) into two step. The first one is to create the Stokes system matrix and right hand side, and the second is to create matrix and right hand sides for the temperature dofs, which depends on the result of the linear system for the velocity.</p>
<p>This function is called at the beginning of each time step. In the first time step or if the mesh has changed, indicated by the <code>rebuild_stokes_matrix</code>, we need to assemble the Stokes matrix; on the other hand, if the mesh hasn't changed and the matrix is already available, this is not necessary and all we need to do is assemble the right hand side vector which changes in each time step.</p>
<p>Regarding the technical details of implementation, not much has changed from <a class="el" href="step_22.html">step-22</a>. We reset matrix and vector, create a quadrature formula on the cells, and then create the respective <a class="el" href="classFEValues.html">FEValues</a> object. For the update flags, we require basis function derivatives only in case of a full assembly, since they are not needed for the right hand side; as always, choosing the minimal set of flags depending on what is currently needed makes the call to <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit</a> further down in the program more efficient.</p>
<p>There is one thing that needs to be commented &ndash; since we have a separate finite element and <a class="el" href="classDoFHandler.html">DoFHandler</a> for the temperature, we need to generate a second <a class="el" href="classFEValues.html">FEValues</a> object for the proper evaluation of the temperature solution. This isn't too complicated to realize here: just use the temperature structures and set an update flag for the basis function values which we need for evaluation of the temperature solution. The only important part to remember here is that the same quadrature formula is used for both <a class="el" href="classFEValues.html">FEValues</a> objects to ensure that we get matching information when we loop over the quadrature points of the two objects.</p>
<p>The declarations proceed with some shortcuts for array sizes, the creation of the local matrix and right hand side as well as the vector for the indices of the local dofs compared to the global system.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_system()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">    stokes_matrix = 0;</div><div class="line"></div><div class="line">  stokes_rhs = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(stokes_degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(</div><div class="line">    stokes_fe,</div><div class="line">    quadrature_formula,</div><div class="line">    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">      (rebuild_stokes_matrix == <span class="keyword">true</span> ? <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> : <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(0)));</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values(temperature_fe,</div><div class="line">                                      quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div></div><!-- fragment --><p>Next we need a vector that will contain the values of the temperature solution at the previous time level at the quadrature points to assemble the source term in the right hand side of the momentum equation. Let's call this vector <code>old_solution_values</code>.</p>
<p>The set of vectors we create next hold the evaluations of the basis functions as well as their gradients and symmetrized gradients that will be used for creating the matrices. Putting these into their own arrays rather than asking the <a class="el" href="classFEValues.html">FEValues</a> object for this information each time it is needed is an optimization to accelerate the assembly process, see <a class="el" href="step_22.html">step-22</a> for details.</p>
<p>The last two declarations are used to extract the individual blocks (velocity, pressure, temperature) from the total FE system.</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt;          phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; grads_phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;                  div_phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;                  phi_p(dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div></div><!-- fragment --><p>Now start the loop over all cells in the problem. We are working on two different DoFHandlers for this assembly routine, so we must have two different cell iterators for the two objects in use. This might seem a bit peculiar, since both the Stokes system and the temperature system use the same grid, but that's the only way to keep degrees of freedom in sync. The first statements within the loop are again all very familiar, doing the update of the finite element data as specified by the update flags, zeroing out the local arrays and getting the values of the old solution at the quadrature points. Then we are ready to loop over the quadrature points on the cell.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>       cell             = stokes_dof_handler.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> endc             = stokes_dof_handler.end();</div><div class="line"><span class="keyword">auto</span>       temperature_cell = temperature_dof_handler.begin_active();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell != endc; ++cell, ++temperature_cell)</div><div class="line">  {</div><div class="line">    stokes_fe_values.reinit(cell);</div><div class="line">    temperature_fe_values.reinit(temperature_cell);</div><div class="line"></div><div class="line">    local_matrix = 0;</div><div class="line">    local_rhs    = 0;</div><div class="line"></div><div class="line">    temperature_fe_values.get_function_values(old_temperature_solution,</div><div class="line">                                              old_temperature_values);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> old_temperature = old_temperature_values[q];</div></div><!-- fragment --><p>Next we extract the values and gradients of basis functions relevant to the terms in the inner products. As shown in <a class="el" href="step_22.html">step-22</a> this helps accelerate assembly.</p>
<p>Once this is done, we start the loop over the rows and columns of the local matrix and feed the matrix with the relevant products. The right hand side is filled with the forcing term driven by temperature in direction of gravity (which is vertical in our example). Note that the right hand side term is always generated, whereas the matrix contributions are only updated when it is requested by the <code>rebuild_matrices</code> flag.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">    {</div><div class="line">      phi_u[k] = stokes_fe_values[velocities].value(k, q);</div><div class="line">      <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">        {</div><div class="line">          grads_phi_u[k] =</div><div class="line">            stokes_fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">          div_phi_u[k] =</div><div class="line">            stokes_fe_values[velocities].divergence(k, q);</div><div class="line">          phi_p[k] = stokes_fe_values[pressure].value(k, q);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        local_matrix(i, j) +=</div><div class="line">          (EquationData::eta * 2 * (grads_phi_u[i] * grads_phi_u[j]) -</div><div class="line">           div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div><div class="line">          stokes_fe_values.JxW(q);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> gravity =</div><div class="line">    -((dim == 2) ? (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 1)) : (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0, 1)));</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    local_rhs(i) += (-EquationData::density * EquationData::beta *</div><div class="line">                     gravity * phi_u[i] * old_temperature) *</div><div class="line">                    stokes_fe_values.JxW(q);</div><div class="line">}</div></div><!-- fragment --><p>The last step in the loop over all cells is to enter the local contributions into the global matrix and vector structures to the positions specified in <code>local_dof_indices</code>. Again, we let the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class do the insertion of the cell matrix elements to the global matrix, which already condenses the hanging node constraints.</p>
<div class="fragment"><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">        stokes_constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                                      local_rhs,</div><div class="line">                                                      local_dof_indices,</div><div class="line">                                                      stokes_matrix,</div><div class="line">                                                      stokes_rhs);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        stokes_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                      local_dof_indices,</div><div class="line">                                                      stokes_rhs);</div><div class="line">    }</div><div class="line"></div><div class="line">  rebuild_stokes_matrix = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemassemble_temperature_matrix"></a> </p><h4>BoussinesqFlowProblem::assemble_temperature_matrix</h4>
<p>This function assembles the matrix in the temperature equation. The temperature matrix consists of two parts, a mass matrix and the time step size times a stiffness matrix given by a Laplace term times the amount of diffusion. Since the matrix depends on the time step size (which varies from one step to another), the temperature matrix needs to be updated every time step. We could simply regenerate the matrices in every time step, but this is not really efficient since mass and Laplace matrix do only change when we change the mesh. Hence, we do this more efficiently by generating two separate matrices in this function, one for the mass matrix and one for the stiffness (diffusion) matrix. We will then sum up the matrix plus the stiffness matrix times the time step size once we know the actual time step.</p>
<p>So the details for this first step are very simple. In case we need to rebuild the matrix (i.e., the mesh has changed), we zero the data structures, get a quadrature formula and a <a class="el" href="classFEValues.html">FEValues</a> object, and create local matrices, local dof indices and evaluation structures for the basis functions.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_matrix()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_temperature_matrices == <span class="keyword">false</span>)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  temperature_mass_matrix      = 0;</div><div class="line">  temperature_stiffness_matrix = 0;</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(temperature_degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values(temperature_fe,</div><div class="line">                                      quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = temperature_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_stiffness_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;         phi_T(dofs_per_cell);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T(dofs_per_cell);</div></div><!-- fragment --><p>Now, let's start the loop over all cells in the triangulation. We need to zero out the local matrices, update the finite element evaluations, and then loop over the rows and columns of the matrices on each quadrature point, where we then create the mass matrix and the stiffness matrix (Laplace terms times the diffusion <code>EquationData::kappa</code>. Finally, we let the constraints object insert these values into the global matrix, and directly condense the constraints into the matrix.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      local_mass_matrix      = 0;</div><div class="line">      local_stiffness_matrix = 0;</div><div class="line"></div><div class="line">      temperature_fe_values.reinit(cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);</div><div class="line">              phi_T[k]      = temperature_fe_values.shape_value(k, q);</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                local_mass_matrix(i, j) +=</div><div class="line">                  (phi_T[i] * phi_T[j] * temperature_fe_values.JxW(q));</div><div class="line">                local_stiffness_matrix(i, j) +=</div><div class="line">                  (EquationData::kappa * grad_phi_T[i] * grad_phi_T[j] *</div><div class="line">                   temperature_fe_values.JxW(q));</div><div class="line">              }</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      temperature_constraints.distribute_local_to_global(</div><div class="line">        local_mass_matrix, local_dof_indices, temperature_mass_matrix);</div><div class="line">      temperature_constraints.distribute_local_to_global(</div><div class="line">        local_stiffness_matrix,</div><div class="line">        local_dof_indices,</div><div class="line">        temperature_stiffness_matrix);</div><div class="line">    }</div><div class="line"></div><div class="line">  rebuild_temperature_matrices = <span class="keyword">false</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemassemble_temperature_system"></a> </p><h4>BoussinesqFlowProblem::assemble_temperature_system</h4>
<p>This function does the second part of the assembly work on the temperature matrix, the actual addition of pressure mass and stiffness matrix (where the time step size comes into play), as well as the creation of the velocity-dependent right hand side. The declarations for the right hand side assembly in this function are pretty much the same as the ones used in the other assembly routines, except that we restrict ourselves to vectors this time. We are going to calculate residuals on the temperature system, which means that we have to evaluate second derivatives, specified by the update flag <code>update_hessians</code>.</p>
<p>The temperature equation is coupled to the Stokes system by means of the fluid velocity. These two parts of the solution are associated with different DoFHandlers, so we again need to create a second <a class="el" href="classFEValues.html">FEValues</a> object for the evaluation of the velocity at the quadrature points.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_system(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (use_bdf2_scheme == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">      temperature_matrix *=</div><div class="line">        (2 * time_step + old_time_step) / (time_step + old_time_step);</div><div class="line">      temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">      temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">    }</div><div class="line"></div><div class="line">  temperature_rhs = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(temperature_degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     temperature_fe_values(temperature_fe,</div><div class="line">                                      quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(stokes_fe,</div><div class="line">                                 quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = temperature_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div></div><!-- fragment --><p>Next comes the declaration of vectors to hold the old and older solution values (as a notation for time levels \(n-1\) and \(n-2\), respectively) and gradients at quadrature points of the current cell. We also declare an object to hold the temperature right hand side values (<code>gamma_values</code>), and we again use shortcuts for the temperature basis functions. Eventually, we need to find the temperature extrema and the diameter of the computational domain which will be used for the definition of the stabilization parameter (we got the maximal velocity as an input to this function).</p>
<div class="fragment"><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_velocity_values(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_velocity_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_temperature_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_old_temperature_values(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_temperature_grads(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_temperature_grads(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_temperature_laplacians(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_old_temperature_laplacians(n_q_points);</div><div class="line"></div><div class="line">EquationData::TemperatureRightHandSide&lt;dim&gt; temperature_right_hand_side;</div><div class="line">std::vector&lt;double&gt;                         gamma_values(n_q_points);</div><div class="line"></div><div class="line">std::vector&lt;double&gt;         phi_T(dofs_per_cell);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T(dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range =</div><div class="line">  get_extrapolated_temperature_range();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div></div><!-- fragment --><p>Now, let's start the loop over all cells in the triangulation. Again, we need two cell iterators that walk in parallel through the cells of the two involved <a class="el" href="classDoFHandler.html">DoFHandler</a> objects for the Stokes and temperature part. Within the loop, we first set the local rhs to zero, and then get the values and derivatives of the old solution functions at the quadrature points, since they are going to be needed for the definition of the stabilization parameters and as coefficients in the equation, respectively. Note that since the temperature has its own <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="classFEValues.html">FEValues</a> object we get the entire solution at the quadrature point (which is the scalar temperature field only anyway) whereas for the Stokes part we restrict ourselves to extracting the velocity part (and ignoring the pressure part) by using <code>stokes_fe_values[velocities].get_function_values</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>       cell        = temperature_dof_handler.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> endc        = temperature_dof_handler.end();</div><div class="line"><span class="keyword">auto</span>       stokes_cell = stokes_dof_handler.begin_active();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell != endc; ++cell, ++stokes_cell)</div><div class="line">  {</div><div class="line">    local_rhs = 0;</div><div class="line"></div><div class="line">    temperature_fe_values.reinit(cell);</div><div class="line">    stokes_fe_values.reinit(stokes_cell);</div><div class="line"></div><div class="line">    temperature_fe_values.get_function_values(old_temperature_solution,</div><div class="line">                                              old_temperature_values);</div><div class="line">    temperature_fe_values.get_function_values(old_old_temperature_solution,</div><div class="line">                                              old_old_temperature_values);</div><div class="line"></div><div class="line">    temperature_fe_values.get_function_gradients(old_temperature_solution,</div><div class="line">                                                 old_temperature_grads);</div><div class="line">    temperature_fe_values.get_function_gradients(</div><div class="line">      old_old_temperature_solution, old_old_temperature_grads);</div><div class="line"></div><div class="line">    temperature_fe_values.get_function_laplacians(</div><div class="line">      old_temperature_solution, old_temperature_laplacians);</div><div class="line">    temperature_fe_values.get_function_laplacians(</div><div class="line">      old_old_temperature_solution, old_old_temperature_laplacians);</div><div class="line"></div><div class="line">    temperature_right_hand_side.value_list(</div><div class="line">      temperature_fe_values.get_quadrature_points(), gamma_values);</div><div class="line"></div><div class="line">    stokes_fe_values[velocities].get_function_values(stokes_solution,</div><div class="line">                                                     old_velocity_values);</div><div class="line">    stokes_fe_values[velocities].get_function_values(</div><div class="line">      old_stokes_solution, old_old_velocity_values);</div></div><!-- fragment --><p>Next, we calculate the artificial viscosity for stabilization according to the discussion in the introduction using the dedicated function. With that at hand, we can get into the loop over quadrature points and local rhs vector components. The terms here are quite lengthy, but their definition follows the time-discrete system developed in the introduction of this program. The BDF-2 scheme needs one more term from the old time step (and involves more complicated factors) than the backward Euler scheme that is used for the first time step. When all this is done, we distribute the local vector into the global one (including hanging node constraints).</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div><div class="line">        compute_viscosity(old_temperature_values,</div><div class="line">                          old_old_temperature_values,</div><div class="line">                          old_temperature_grads,</div><div class="line">                          old_old_temperature_grads,</div><div class="line">                          old_temperature_laplacians,</div><div class="line">                          old_old_temperature_laplacians,</div><div class="line">                          old_velocity_values,</div><div class="line">                          old_old_velocity_values,</div><div class="line">                          gamma_values,</div><div class="line">                          maximal_velocity,</div><div class="line">                          global_T_range.second - global_T_range.first,</div><div class="line">                          cell-&gt;diameter());</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);</div><div class="line">              phi_T[k]      = temperature_fe_values.shape_value(k, q);</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> T_term_for_rhs =</div><div class="line">            (use_bdf2_scheme ?</div><div class="line">               (old_temperature_values[q] * (1 + time_step / old_time_step) -</div><div class="line">                old_old_temperature_values[q] * (time_step * time_step) /</div><div class="line">                  (old_time_step * (time_step + old_time_step))) :</div><div class="line">               old_temperature_values[q]);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ext_grad_T =</div><div class="line">            (use_bdf2_scheme ?</div><div class="line">               (old_temperature_grads[q] * (1 + time_step / old_time_step) -</div><div class="line">                old_old_temperature_grads[q] * time_step / old_time_step) :</div><div class="line">               old_temperature_grads[q]);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> extrapolated_u =</div><div class="line">            (use_bdf2_scheme ?</div><div class="line">               (old_velocity_values[q] * (1 + time_step / old_time_step) -</div><div class="line">                old_old_velocity_values[q] * time_step / old_time_step) :</div><div class="line">               old_velocity_values[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            local_rhs(i) +=</div><div class="line">              (T_term_for_rhs * phi_T[i] -</div><div class="line">               time_step * extrapolated_u * ext_grad_T * phi_T[i] -</div><div class="line">               time_step * nu * ext_grad_T * grad_phi_T[i] +</div><div class="line">               time_step * gamma_values[q] * phi_T[i]) *</div><div class="line">              temperature_fe_values.JxW(q);</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      temperature_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                         local_dof_indices,</div><div class="line">                                                         temperature_rhs);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemsolve"></a> </p><h4>BoussinesqFlowProblem::solve</h4>
<p>This function solves the linear systems of equations. Following the introduction, we start with the Stokes system, where we need to generate our block Schur preconditioner. Since all the relevant actions are implemented in the class <code>BlockSchurPreconditioner</code>, all we have to do is to initialize the class appropriately. What we need to pass down is an <code>InverseMatrix</code> object for the pressure mass matrix, which we set up using the respective class together with the IC preconditioner we already generated, and the AMG preconditioner for the velocity-velocity matrix. Note that both <code>Mp_preconditioner</code> and <code>Amg_preconditioner</code> are only pointers, so we use <code>*</code> to pass down the actual preconditioner objects.</p>
<p>Once the preconditioner is ready, we create a GMRES solver for the block system. Since we are working with Trilinos data structures, we have to set the respective template argument in the solver. GMRES needs to internally store temporary vectors for each iteration (see the discussion in the results section of <a class="el" href="step_22.html">step-22</a>) &ndash; the more vectors it can use, the better it will generally perform. To keep memory demands in check, we set the number of vectors to 100. This means that up to 100 solver iterations, every temporary vector can be stored. If the solver needs to iterate more often to get the specified tolerance, it will work on a reduced set of vectors by restarting at every 100 iterations.</p>
<p>With this all set up, we solve the system and distribute the constraints in the Stokes system, i.e., hanging nodes and no-flux boundary condition, in order to have the appropriate solution values even at constrained dofs. Finally, we write the number of iterations to the screen.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> LinearSolvers::InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                       <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a>&gt;</div><div class="line">      mp_inverse(stokes_preconditioner_matrix.block(1, 1),</div><div class="line">                 *Mp_preconditioner);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">      <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">TrilinosWrappers::PreconditionAMG</a>,</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a>&gt;</div><div class="line">      preconditioner(stokes_matrix, mp_inverse, *Amg_preconditioner);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(stokes_matrix.m(),</div><div class="line">                                 1e-6 * stokes_rhs.l2_norm());</div><div class="line"></div><div class="line">    <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> gmres(</div><div class="line">      solver_control,</div><div class="line">      <a class="code" href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(100));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; stokes_solution.size(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (stokes_constraints.is_constrained(i))</div><div class="line">        stokes_solution(i) = 0;</div><div class="line"></div><div class="line">    gmres.solve(stokes_matrix, stokes_solution, stokes_rhs, preconditioner);</div><div class="line"></div><div class="line">    stokes_constraints.distribute(stokes_solution);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; GMRES iterations for Stokes subsystem.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div></div><!-- fragment --><p>Once we know the Stokes solution, we can determine the new time step from the maximal velocity. We have to do this to satisfy the CFL condition since convection terms are treated explicitly in the temperature equation, as discussed in the introduction. The exact form of the formula used here for the time step is discussed in the results section of this program.</p>
<p>There is a snatch here. The formula contains a division by the maximum value of the velocity. However, at the start of the computation, we have a constant temperature field (we start with a constant temperature, and it will be nonconstant only after the first time step during which the source acts). Constant temperature means that no buoyancy acts, and so the velocity is zero. Dividing by it will not likely lead to anything good.</p>
<p>To avoid the resulting infinite time step, we ask whether the maximal velocity is very small (in particular smaller than the values we encounter during any of the following time steps) and if so rather than dividing by zero we just divide by a small value, resulting in a large but finite time step.</p>
<div class="fragment"><div class="line">old_time_step                 = time_step;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity = get_maximal_velocity();</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (maximal_velocity &gt;= 0.01)</div><div class="line">  time_step = 1. / (1.7 * dim * <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim)) / temperature_degree *</div><div class="line">              <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) /</div><div class="line">              maximal_velocity;</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  time_step = 1. / (1.7 * dim * <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim)) / temperature_degree *</div><div class="line">              <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / .01;</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">temperature_solution = old_temperature_solution;</div></div><!-- fragment --><p>Next we set up the temperature system and the right hand side using the function <code>assemble_temperature_system()</code>. Knowing the matrix and right hand side of the temperature equation, we set up a preconditioner and a solver. The temperature matrix is a mass matrix (with eigenvalues around one) plus a Laplace matrix (with eigenvalues between zero and \(ch^{-2}\)) times a small number proportional to the time step \(k_n\). Hence, the resulting symmetric and positive definite matrix has eigenvalues in the range \([1,1+k_nh^{-2}]\) (up to constants). This matrix is only moderately ill conditioned even for small mesh sizes and we get a reasonably good preconditioner by simple means, for example with an incomplete Cholesky decomposition preconditioner (IC) as we also use for preconditioning the pressure mass matrix solver. As a solver, we choose the conjugate gradient method CG. As before, we tell the solver to use Trilinos vectors via the template argument <code><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a></code>. Finally, we solve, distribute the hanging node constraints and write out the number of iterations.</p>
<div class="fragment"><div class="line">assemble_temperature_system(maximal_velocity);</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(temperature_matrix.m(),</div><div class="line">                               1e-8 * temperature_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a> preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html#a95eff1f8abcf2ba67815b6a96a66d375">initialize</a>(temperature_matrix);</div><div class="line"></div><div class="line">  cg.solve(temperature_matrix,</div><div class="line">           temperature_solution,</div><div class="line">           temperature_rhs,</div><div class="line">           preconditioner);</div><div class="line"></div><div class="line">  temperature_constraints.distribute(temperature_solution);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations for temperature.&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p>At the end of this function, we step through the vector and read out the maximum and minimum temperature value, which we also want to output. This will come in handy when determining the correct constant in the choice of time step as discuss in the results section of this program.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">double</span> min_temperature = temperature_solution(0),</div><div class="line">           max_temperature = temperature_solution(0);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; temperature_solution.size(); ++i)</div><div class="line">      {</div><div class="line">        min_temperature =</div><div class="line">          std::min&lt;double&gt;(min_temperature, temperature_solution(i));</div><div class="line">        max_temperature =</div><div class="line">          std::max&lt;double&gt;(max_temperature, temperature_solution(i));</div><div class="line">      }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Temperature range: &quot;</span> &lt;&lt; min_temperature &lt;&lt; <span class="charliteral">&#39; &#39;</span></div><div class="line">              &lt;&lt; max_temperature &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemoutput_results"></a> </p><h4>BoussinesqFlowProblem::output_results</h4>
<p>This function writes the solution to a VTK output file for visualization, which is done every tenth time step. This is usually quite a simple task, since the deal.II library provides functions that do almost all the job for us. There is one new function compared to previous examples: We want to visualize both the Stokes solution and the temperature as one data set, but we have done all the calculations based on two different <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. Luckily, the <a class="el" href="classDataOut.html">DataOut</a> class is prepared to deal with it. All we have to do is to not attach one single <a class="el" href="classDoFHandler.html">DoFHandler</a> at the beginning and then use that for all added vector, but specify the <a class="el" href="classDoFHandler.html">DoFHandler</a> to each vector separately. The rest is done as in <a class="el" href="step_22.html">step-22</a>. We create solution names (that are going to appear in the visualization program for the individual components). The first <code>dim</code> components are the vector velocity, and then we have pressure for the Stokes part, whereas temperature is scalar. This information is read out using the <a class="el" href="namespaceDataComponentInterpretation.html">DataComponentInterpretation</a> helper class. Next, we actually attach the data vectors with their <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, build patches according to the degree of freedom, which are (sub-) elements that describe the data for visualization programs. Finally, we open a file (that includes the time step number) and write the vtk data into it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (timestep_number % 10 != 0)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  std::vector&lt;std::string&gt; stokes_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  stokes_names.emplace_back(<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    stokes_component_interpretation(</div><div class="line">      dim + 1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    stokes_component_interpretation[i] =</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(stokes_dof_handler,</div><div class="line">                           stokes_solution,</div><div class="line">                           stokes_names,</div><div class="line">                           stokes_component_interpretation);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(temperature_dof_handler,</div><div class="line">                           temperature_solution,</div><div class="line">                           <span class="stringliteral">&quot;T&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(stokes_degree, temperature_degree));</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                       <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 4) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemrefine_mesh"></a> </p><h4>BoussinesqFlowProblem::refine_mesh</h4>
<p>This function takes care of the adaptive mesh refinement. The three tasks this function performs is to first find out which cells to refine/coarsen, then to actually do the refinement and eventually transfer the solution vectors between the two different grids. The first task is simply achieved by using the well-established Kelly error estimator on the temperature (it is the temperature we're mainly interested in for this program, and we need to be accurate in regions of high temperature gradients, also to not have too much numerical diffusion). The second task is to actually do the remeshing. That involves only basic functions as well, such as the <code>refine_and_coarsen_fixed_fraction</code> that refines those cells with the largest estimated error that together make up 80 per cent of the error, and coarsens those cells with the smallest error that make up for a combined 10 per cent of the error.</p>
<p>If implemented like this, we would get a program that will not make much progress: Remember that we expect temperature fields that are nearly discontinuous (the diffusivity \(\kappa\) is very small after all) and consequently we can expect that a freely adapted mesh will refine further and further into the areas of large gradients. This decrease in mesh size will then be accompanied by a decrease in time step, requiring an exceedingly large number of time steps to solve to a given final time. It will also lead to meshes that are much better at resolving discontinuities after several mesh refinement cycles than in the beginning.</p>
<p>In particular to prevent the decrease in time step size and the correspondingly large number of time steps, we limit the maximal refinement depth of the mesh. To this end, after the refinement indicator has been applied to the cells, we simply loop over all cells on the finest level and unselect them from refinement if they would result in too high a mesh level.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(temperature_dof_handler,</div><div class="line">                                     <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(temperature_degree + 1),</div><div class="line">                                     {},</div><div class="line">                                     temperature_solution,</div><div class="line">                                     estimated_error_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.8,</div><div class="line">                                                    0.1);</div><div class="line">  <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &gt; max_grid_level)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell :</div><div class="line">         triangulation.<a class="code" href="group__CPP11.html#gac10cd3fe6ef8360e2599d3cff58e13e8">active_cell_iterators_on_level</a>(max_grid_level))</div><div class="line">      cell-&gt;clear_refine_flag();</div></div><!-- fragment --><p>As part of mesh refinement we need to transfer the solution vectors from the old mesh to the new one. To this end we use the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class and we have to prepare the solution vectors that should be transferred to the new grid (we will lose the old grid once we have done the refinement so the transfer has to happen concurrently with refinement). What we definitely need are the current and the old temperature (BDF-2 time stepping requires two old solutions). Since the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> objects only support to transfer one object per dof handler, we need to collect the two temperature solutions in one data structure. Moreover, we choose to transfer the Stokes solution, too, since we need the velocity at two previous time steps, of which only one is calculated on the fly.</p>
<p>Consequently, we initialize two <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> objects for the Stokes and temperature <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, by attaching them to the old dof handlers. With this at place, we can prepare the triangulation and the data vectors for refinement (in this order).</p>
<div class="fragment"><div class="line">std::vector&lt;TrilinosWrappers::MPI::Vector&gt; x_temperature(2);</div><div class="line">x_temperature[0]                            = temperature_solution;</div><div class="line">x_temperature[1]                            = old_temperature_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> x_stokes = stokes_solution;</div><div class="line"></div><div class="line"><a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a> temperature_trans(</div><div class="line">  temperature_dof_handler);</div><div class="line"><a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::BlockVector&gt;</a> stokes_trans(</div><div class="line">  stokes_dof_handler);</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);</div><div class="line">stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);</div></div><!-- fragment --><p>Now everything is ready, so do the refinement and recreate the dof structure on the new grid, and initialize the matrix structures and the new vectors in the <code>setup_dofs</code> function. Next, we actually perform the interpolation of the solutions between the grids. We create another copy of temporary vectors for temperature (now corresponding to the new grid), and let the interpolate function do the job. Then, the resulting array of vectors is written into the respective vector member variables.</p>
<p>Remember that the set of constraints will be updated for the new triangulation in the setup_dofs() call.</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">setup_dofs();</div><div class="line"></div><div class="line">std::vector&lt;TrilinosWrappers::MPI::Vector&gt; tmp(2);</div><div class="line">tmp[0].reinit(temperature_solution);</div><div class="line">tmp[1].reinit(temperature_solution);</div><div class="line">temperature_trans.interpolate(x_temperature, tmp);</div><div class="line"></div><div class="line">temperature_solution     = tmp[0];</div><div class="line">old_temperature_solution = tmp[1];</div></div><!-- fragment --><p>After the solution has been transferred we then enforce the constraints on the transferred solution.</p>
<div class="fragment"><div class="line">temperature_constraints.distribute(temperature_solution);</div><div class="line">temperature_constraints.distribute(old_temperature_solution);</div></div><!-- fragment --><p>For the Stokes vector, everything is just the same &ndash; except that we do not need another temporary vector since we just interpolate a single vector. In the end, we have to tell the program that the matrices and preconditioners need to be regenerated, since the mesh has changed.</p>
<div class="fragment"><div class="line">  stokes_trans.interpolate(x_stokes, stokes_solution);</div><div class="line"></div><div class="line">  stokes_constraints.distribute(stokes_solution);</div><div class="line"></div><div class="line">  rebuild_stokes_matrix         = <span class="keyword">true</span>;</div><div class="line">  rebuild_temperature_matrices  = <span class="keyword">true</span>;</div><div class="line">  rebuild_stokes_preconditioner = <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemrun"></a> </p><h4>BoussinesqFlowProblem::run</h4>
<p>This function performs all the essential steps in the Boussinesq program. It starts by setting up a grid (depending on the spatial dimension, we choose some different level of initial refinement and additional adaptive refinement steps, and then create a cube in <code>dim</code> dimensions and set up the dofs for the first time. Since we want to start the time stepping already with an adaptively refined grid, we perform some pre-refinement steps, consisting of all assembly, solution and refinement, but without actually advancing in time. Rather, we use the vilified <code>goto</code> statement to jump out of the time loop right after mesh refinement to start all over again on the new mesh beginning at the <code>start_time_iteration</code> label. (The use of the <code>goto</code> is discussed in <a class="el" href="step_26.html">step-26</a>.)</p>
<p>Before we start, we project the initial values to the grid and obtain the first data for the <code>old_temperature_solution</code> vector. Then, we initialize time step number and time step and start the time loop.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">BoussinesqFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement     = (dim == 2 ? 4 : 2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_pre_refinement_steps = (dim == 2 ? 4 : 3);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">  global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(triangulation);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(initial_refinement);</div><div class="line"></div><div class="line">  setup_dofs();</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"></div><div class="line">start_time_iteration:</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(temperature_dof_handler,</div><div class="line">                       temperature_constraints,</div><div class="line">                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(temperature_degree + 2),</div><div class="line">                       EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">                       old_temperature_solution);</div><div class="line"></div><div class="line">  timestep_number = 0;</div><div class="line">  time_step = old_time_step = 0;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> time = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time</div><div class="line">                &lt;&lt; std::endl;</div></div><!-- fragment --><p>The first steps in the time loop are all obvious &ndash; we assemble the Stokes system, the preconditioner, the temperature matrix (matrices and preconditioner do actually only change in case we've remeshed before), and then do the solve. Before going on with the next time step, we have to check whether we should first finish the pre-refinement steps or if we should remesh (every fifth time step), refining up to a level that is consistent with initial refinement and pre-refinement steps. Last in the loop is to advance the solutions, i.e., to copy the solutions to the next "older" time level.</p>
<div class="fragment"><div class="line">  assemble_stokes_system();</div><div class="line">  build_stokes_preconditioner();</div><div class="line">  assemble_temperature_matrix();</div><div class="line"></div><div class="line">  solve();</div><div class="line"></div><div class="line">  output_results();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">      (pre_refinement_step &lt; n_pre_refinement_steps))</div><div class="line">    {</div><div class="line">      refine_mesh(initial_refinement + n_pre_refinement_steps);</div><div class="line">      ++pre_refinement_step;</div><div class="line">      <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp; (timestep_number % 5 == 0))</div><div class="line">    refine_mesh(initial_refinement + n_pre_refinement_steps);</div><div class="line"></div><div class="line">  time += time_step;</div><div class="line">  ++timestep_number;</div><div class="line"></div><div class="line">  old_stokes_solution          = stokes_solution;</div><div class="line">  old_old_temperature_solution = old_temperature_solution;</div><div class="line">  old_temperature_solution     = temperature_solution;</div><div class="line">}</div></div><!-- fragment --><p>Do all the above until we arrive at time 100.</p>
<div class="fragment"><div class="line">    <span class="keywordflow">while</span> (time &lt;= 100);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step31</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>The main function looks almost the same as in all other programs.</p>
<p>There is one difference we have to be careful about. This program uses Trilinos and, typically, Trilinos is configured so that it can run in parallel using MPI. This doesn't mean that it <em>has</em> to run in parallel, and in fact this program (unlike <a class="el" href="step_32.html">step-32</a>) makes no attempt at all to do anything in parallel using MPI. Nevertheless, Trilinos wants the MPI system to be initialized. We do that be creating an object of type <a class="el" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> that initializes MPI (if available) using the arguments given to main() (i.e., <code>argc</code> and <code>argv</code>) and de-initializes it again when the object goes out of scope.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step31;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div></div><!-- fragment --><p>This program can only be run in serial. Otherwise, throw an exception.</p>
<div class="fragment"><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-31&quot;</span>));</div><div class="line"></div><div class="line">      BoussinesqFlowProblem&lt;2&gt; flow_problem;</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Resultsin2d"></a></p><h3>Results in 2d </h3>
<p>When you run the program in 2d, the output will look something like this: <code> </p><pre>
Number of active cells: 256 (on 5 levels)
Number of degrees of freedom: 3556 (2178+289+1089)</pre><p></code></p>
<p><code></p><pre>Timestep 0:  t=0
   Assembling...
   Rebuilding Stokes preconditioner...
   Solving...
   0 GMRES iterations for Stokes subsystem.
   Time step: 0.919118
   9 CG iterations for temperature.
   Temperature range: -0.16687 1.30011</pre><p></code></p>
<p><code></p><pre>Number of active cells: 280 (on 6 levels)
Number of degrees of freedom: 4062 (2490+327+1245)</pre><p></code></p>
<p><code></p><pre>Timestep 0:  t=0
   Assembling...
   Rebuilding Stokes preconditioner...
   Solving...
   0 GMRES iterations for Stokes subsystem.
   Time step: 0.459559
   9 CG iterations for temperature.
   Temperature range: -0.0982971 0.598503</pre><p></code></p>
<p><code></p><pre>Number of active cells: 520 (on 7 levels)
Number of degrees of freedom: 7432 (4562+589+2281)</pre><p></code></p>
<p><code></p><pre>Timestep 0:  t=0
   Assembling...
   Rebuilding Stokes preconditioner...
   Solving...
   0 GMRES iterations for Stokes subsystem.
   Time step: 0.229779
   9 CG iterations for temperature.
   Temperature range: -0.0551098 0.294493</pre><p></code></p>
<p><code></p><pre>Number of active cells: 1072 (on 8 levels)
Number of degrees of freedom: 15294 (9398+1197+4699)</pre><p></code></p>
<p><code></p><pre>Timestep 0:  t=0
   Assembling...
   Rebuilding Stokes preconditioner...
   Solving...
   0 GMRES iterations for Stokes subsystem.
   Time step: 0.11489
   9 CG iterations for temperature.
   Temperature range: -0.0273524 0.156861</pre><p></code></p>
<p><code></p><pre>Number of active cells: 2116 (on 9 levels)
Number of degrees of freedom: 30114 (18518+2337+9259)</pre><p></code></p>
<p><code></p><pre>Timestep 0:  t=0
   Assembling...
   Rebuilding Stokes preconditioner...
   Solving...
   0 GMRES iterations for Stokes subsystem.
   Time step: 0.0574449
   9 CG iterations for temperature.
   Temperature range: -0.014993 0.0738328</pre><p></code></p>
<p><code></p><pre>Timestep 1:  t=0.0574449
   Assembling...
   Solving...
   56 GMRES iterations for Stokes subsystem.
   Time step: 0.0574449
   9 CG iterations for temperature.
   Temperature range: -0.0273934 0.14488</pre><p></code></p>
<p><code></p><pre>...
</pre><p> </code></p>
<p>In the beginning we refine the mesh several times adaptively and always return to time step zero to restart on the newly refined mesh. Only then do we start the actual time iteration.</p>
<p>The program runs for a while. The temperature field for time steps 0, 500, 1000, 1500, 2000, 3000, 4000, and 5000 looks like this (note that the color scale used for the temperature is not always the same):</p>
<table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.00.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.01.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.02.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.03.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.04.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.05.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.06.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.07.png"/>
</div>
   </td></tr>
</table>
<p>The visualizations shown here were generated using a version of the example which did not enforce the constraints after transferring the mesh.</p>
<p>As can be seen, we have three heat sources that heat fluid and therefore produce a buoyancy effect that lets hots pockets of fluid rise up and swirl around. By a chimney effect, the three streams are pressed together by fluid that comes from the outside and wants to join the updraft party. Note that because the fluid is initially at rest, those parts of the fluid that were initially over the sources receive a longer heating time than that fluid that is later dragged over the source by the fully developed flow field. It is therefore hotter, a fact that can be seen in the red tips of the three plumes. Note also the relatively fine features of the flow field, a result of the sophisticated transport stabilization of the temperature equation we have chosen.</p>
<p>In addition to the pictures above, the following ones show the adaptive mesh and the flow field at the same time steps:</p>
<table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.00.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.01.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.02.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.03.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.04.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.05.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.06.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.07.png"/>
</div>
   </td></tr>
</table>
<p><a class="anchor" id="Resultsin3d"></a></p><h3>Results in 3d </h3>
<p>The same thing can of course be done in 3d by changing the template parameter to the BoussinesqFlowProblem object in <code>main()</code> from 2 to 3, so that the output now looks like follows:</p>
<p><code> </p><pre>
Number of active cells: 64 (on 3 levels)
Number of degrees of freedom: 3041 (2187+125+729)</pre><p></code></p>
<p><code></p><pre>Timestep 0:  t=0
   Assembling...
   Rebuilding Stokes preconditioner...
   Solving...
   0 GMRES iterations for Stokes subsystem.
   Time step: 2.45098
   9 CG iterations for temperature.
   Temperature range: -0.675683 4.94725</pre><p></code></p>
<p><code></p><pre>Number of active cells: 288 (on 4 levels)
Number of degrees of freedom: 12379 (8943+455+2981)</pre><p></code></p>
<p><code></p><pre>Timestep 0:  t=0
   Assembling...
   Rebuilding Stokes preconditioner...
   Solving...
   0 GMRES iterations for Stokes subsystem.
   Time step: 1.22549
   9 CG iterations for temperature.
   Temperature range: -0.527701 2.25764</pre><p></code></p>
<p><code></p><pre>Number of active cells: 1296 (on 5 levels)
Number of degrees of freedom: 51497 (37305+1757+12435)</pre><p></code></p>
<p><code></p><pre>Timestep 0:  t=0
   Assembling...
   Rebuilding Stokes preconditioner...
   Solving...
   0 GMRES iterations for Stokes subsystem.
   Time step: 0.612745
   10 CG iterations for temperature.
   Temperature range: -0.496942 0.847395</pre><p></code></p>
<p><code></p><pre>Number of active cells: 5048 (on 6 levels)
Number of degrees of freedom: 192425 (139569+6333+46523)</pre><p></code></p>
<p><code></p><pre>Timestep 0:  t=0
   Assembling...
   Rebuilding Stokes preconditioner...
   Solving...
   0 GMRES iterations for Stokes subsystem.
   Time step: 0.306373
   10 CG iterations for temperature.
   Temperature range: -0.267683 0.497739</pre><p></code></p>
<p><code></p><pre>Timestep 1:  t=0.306373
   Assembling...
   Solving...
   27 GMRES iterations for Stokes subsystem.
   Time step: 0.306373
   10 CG iterations for temperature.
   Temperature range: -0.461787 0.958679</pre><p></code></p>
<p><code></p><pre>...
</pre><p> </code></p>
<p>Visualizing the temperature isocontours at time steps 0, 50, 100, 150, 200, 300, 400, 500, 600, 700, and 800 yields the following plots:</p>
<table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.00.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.01.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.02.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.03.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.04.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.05.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.06.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.07.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.08.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.09.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.10.png"/>
</div>
  </td><td></td></tr>
</table>
<p>That the first picture looks like three hedgehogs stems from the fact that our scheme essentially projects the source times the first time step size onto the mesh to obtain the temperature field in the first time step. Since the source function is discontinuous, we need to expect over- and undershoots from this project. This is in fact what happens (it's easier to check this in 2d) and leads to the crumpled appearance of the isosurfaces. The visualizations shown here were generated using a version of the example which did not enforce the constraints after transferring the mesh.</p>
<p><a class="anchor" id="Numericalexperimentstodetermineoptimalparameters"></a></p><h3>Numerical experiments to determine optimal parameters </h3>
<p>The program as is has three parameters that we don't have much of a theoretical handle on how to choose in an optimal way. These are: </p><ul>
<li>
The time step must satisfy a CFL condition \(k\le \min_K \frac{c_kh_K}{\|\mathbf{u}\|_{L^\infty(K)}}\). Here, \(c_k\) is dimensionless, but what is the right value? </li>
<li>
In the computation of the artificial viscosity, <p class="formulaDsp">
\begin{eqnarray*} \nu_\alpha(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} \min\left\{ h_K, h_K^\alpha \frac{\|R_\alpha(T)\|_{L^\infty(K)}}{c(\mathbf{u},T)} \right\}, \end{eqnarray*}
</p>
 with \(c(\mathbf{u},T) = c_R\ \|\mathbf{u}\|_{L^\infty(\Omega)} \ \mathrm{var}(T) \ |\mathrm{diam}(\Omega)|^{\alpha-2}\). Here, the choice of the dimensionless numbers \(\beta,c_R\) is of interest. </li>
</ul>
<p>In all of these cases, we will have to expect that the correct choice of each value depends on that of the others, and most likely also on the space dimension and polynomial degree of the finite element used for the temperature. Below we'll discuss a few numerical experiments to choose constants \(c_k\) and \(\beta\).</p>
<p>Below, we will not discuss the choice of \(c_R\). In the program, we set it to \(c_R=2^{\frac{4-2\alpha}{d}}\). The reason for this value is a bit complicated and has more to do with the history of the program than reasoning: while the correct formula for the global scaling parameter \(c(\mathbf{u},T)\) is shown above, the program (including the version shipped with deal.II 6.2) initially had a bug in that we computed \(c(\mathbf{u},T) = \|\mathbf{u}\|_{L^\infty(\Omega)} \ \mathrm{var}(T) \ \frac{1}{|\mathrm{diam}(\Omega)|^{\alpha-2}}\) instead, where we had set the scaling parameter to one. Since we only computed on the unit square/cube where \(\mathrm{diam}(\Omega)=2^{1/d}\), this was entirely equivalent to using the correct formula with \(c_R=\left(2^{1/d}\right)^{4-2\alpha}=2^{\frac{4-2\alpha}{d}}\). Since this value for \(c_R\) appears to work just fine for the current program, we corrected the formula in the program and set \(c_R\) to a value that reproduces exactly the results we had before. We will, however, revisit this issue again in <a class="el" href="step_32.html">step-32</a>.</p>
<p>Now, however, back to the discussion of what values of \(c_k\) and \(\beta\) to choose:</p>
<p><a class="anchor" id="Choosingicsubksubiandbeta"></a></p><h4>Choosing <em>c<sub>k</sub></em> and beta </h4>
<p>These two constants are definitely linked in some way. The reason is easy to see: In the case of a pure advection problem, \(\frac{\partial T}{\partial t} + \mathbf{u}\cdot\nabla T = \gamma\), any explicit scheme has to satisfy a CFL condition of the form \(k\le \min_K \frac{c_k^a h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\). On the other hand, for a pure diffusion problem, \(\frac{\partial T}{\partial t} + \nu \Delta T = \gamma\), explicit schemes need to satisfy a condition \(k\le \min_K \frac{c_k^d h_K^2}{\nu}\). So given the form of \(\nu\) above, an advection diffusion problem like the one we have to solve here will result in a condition of the form \( k\le \min_K \min \left\{ \frac{c_k^a h_K}{\|\mathbf{u}\|_{L^\infty(K)}}, \frac{c_k^d h_K^2}{\beta \|\mathbf{u}\|_{L^\infty(K)} h_K}\right\} = \min_K \left( \min \left\{ c_k^a, \frac{c_k^d}{\beta}\right\} \frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}} \right) \). It follows that we have to face the fact that we might want to choose \(\beta\) larger to improve the stability of the numerical scheme (by increasing the amount of artificial diffusion), but we have to pay a price in the form of smaller, and consequently more time steps. In practice, one would therefore like to choose \(\beta\) as small as possible to keep the transport problem sufficiently stabilized while at the same time trying to choose the time step as large as possible to reduce the overall amount of work.</p>
<p>The find the right balance, the only way is to do a few computational experiments. Here's what we did: We modified the program slightly to allow less mesh refinement (so we don't always have to wait that long) and to choose \( \nu(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} h_K \) to eliminate the effect of the constant \(c_R\) (we know that solutions are stable by using this version of \(\nu(T)\) as an artificial viscosity, but that we can improve things &ndash; i.e. make the solution sharper &ndash; by using the more complicated formula for this artificial viscosity). We then run the program for different values \(c_k,\beta\) and observe maximal and minimal temperatures in the domain. What we expect to see is this: If we choose the time step too big (i.e. choose a \(c_k\) bigger than theoretically allowed) then we will get exponential growth of the temperature. If we choose \(\beta\) too small, then the transport stabilization becomes insufficient and the solution will show significant oscillations but not exponential growth.</p>
<p><a class="anchor" id="ResultsforQsub1subelements"></a></p><h5>Results for Q<sub>1</sub> elements</h5>
<p>Here is what we get for \(\beta=0.01, \beta=0.1\), and \(\beta=0.5\), different choices of \(c_k\), and bilinear elements (<code>temperature_degree=1</code>) in 2d:</p>
<table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q1.beta=0.01.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q1.beta=0.03.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q1.beta=0.1.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q1.beta=0.5.png"/>
</div>
   </td></tr>
</table>
<p>The way to interpret these graphs goes like this: for \(\beta=0.01\) and \(c_k=\frac 12,\frac 14\), we see exponential growth or at least large variations, but if we choose \(k=\frac 18\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) or smaller, then the scheme is stable though a bit wobbly. For more artificial diffusion, we can choose \(k=\frac 14\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) or smaller for \(\beta=0.03\), \(k=\frac 13\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) or smaller for \(\beta=0.1\), and again need \(k=\frac 1{15}\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) for \(\beta=0.5\) (this time because much diffusion requires a small time step).</p>
<p>So how to choose? If we were simply interested in a large time step, then we would go with \(\beta=0.1\) and \(k=\frac 13\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\). On the other hand, we're also interested in accuracy and here it may be of interest to actually investigate what these curves show. To this end note that we start with a zero temperature and that our sources are positive &mdash; so we would intuitively expect that the temperature can never drop below zero. But it does, a consequence of Gibb's phenomenon when using continuous elements to approximate a discontinuous solution. We can therefore see that choosing \(\beta\) too small is bad: too little artificial diffusion leads to over- and undershoots that aren't diffused away. On the other hand, for large \(\beta\), the minimum temperature drops below zero at the beginning but then quickly diffuses back to zero.</p>
<p>On the other hand, let's also look at the maximum temperature. Watching the movie of the solution, we see that initially the fluid is at rest. The source keeps heating the same volume of fluid whose temperature increases linearly at the beginning until its buoyancy is able to move it upwards. The hottest part of the fluid is therefore transported away from the solution and fluid taking its place is heated for only a short time before being moved out of the source region, therefore remaining cooler than the initial bubble. If \(\kappa=0\) (in the program it is nonzero but very small) then the hottest part of the fluid should be advected along with the flow with its temperature constant. That's what we can see in the graphs with the smallest \(\beta\): Once the maximum temperature is reached, it hardly changes any more. On the other hand, the larger the artificial diffusion, the more the hot spot is diffused. Note that for this criterion, the time step size does not play a significant role.</p>
<p>So to sum up, likely the best choice would appear to be \(\beta=0.03\) and \(k=\frac 14\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\). The curve is a bit wobbly, but overall pictures looks pretty reasonable with the exception of some over and undershoots close to the start time due to Gibb's phenomenon.</p>
<p><a class="anchor" id="ResultsforQsub2subelements"></a></p><h5>Results for Q<sub>2</sub> elements</h5>
<p>One can repeat the same sequence of experiments for higher order elements as well. Here are the graphs for bi-quadratic shape functions (<code>temperature_degree=2</code>) for the temperature, while we retain the \(Q_2/Q_1\) stable Taylor-Hood element for the Stokes system:</p>
<table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q2.beta=0.01.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q2.beta=0.03.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q2.beta=0.1.png"/>
</div>
   </td></tr>
</table>
<p>Again, small values of \(\beta\) lead to less diffusion but we have to choose the time step very small to keep things under control. Too large values of \(\beta\) make for more diffusion, but again require small time steps. The best value would appear to be \(\beta=0.03\), as for the \(Q_1\) element, and then we have to choose \(k=\frac 18\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) &mdash; exactly half the size for the \(Q_1\) element, a fact that may not be surprising if we state the CFL condition as the requirement that the time step be small enough so that the distance transport advects in each time step is no longer than one <em>grid point</em> away (which for \(Q_1\) elements is \(h_K\), but for \(Q_2\) elements is \(h_K/2\)). It turns out that \(\beta\) needs to be slightly larger for obtaining stable results also late in the simulation at times larger than 60, so we actually choose it as \(\beta = 0.034\) in the code.</p>
<p><a class="anchor" id="Resultsfor3d"></a></p><h5>Results for 3d</h5>
<p>One can repeat these experiments in 3d and find the optimal time step for each value of \(\beta\) and find the best value of \(\beta\). What one finds is that for the same \(\beta\) already used in 2d, the time steps needs to be a bit smaller, by around a factor of 1.2 or so. This is easily explained: the time step restriction is \(k=\min_K \frac{ch_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) where \(h_K\) is the <em>diameter</em> of the cell. However, what is really needed is the distance between mesh points, which is \(\frac{h_K}{\sqrt{d}}\). So a more appropriate form would be \(k=\min_K \frac{ch_K}{\|\mathbf{u}\|_{L^\infty(K)}\sqrt{d}}\).</p>
<p>The second find is that one needs to choose \(\beta\) slightly bigger (about \(\beta=0.05\) or so). This then again reduces the time step we can take.</p>
<p><a class="anchor" id="Conclusions"></a></p><h5>Conclusions</h5>
<p>Concluding, from the simple computations above, \(\beta=0.034\) appears to be a good choice for the stabilization parameter in 2d, and \(\beta=0.05\) in 3d. In a dimension independent way, we can model this as \(\beta=0.017d\). If one does longer computations (several thousand time steps) on finer meshes, one realizes that the time step size is not quite small enough and that for stability one will have to reduce the above values a bit more (by about a factor of \(\frac 78\)).</p>
<p>As a consequence, a formula that reconciles 2d, 3d, and variable polynomial degree and takes all factors in account reads as follows: </p><p class="formulaDsp">
\begin{eqnarray*} k = \frac 1{2 \cdot 1.7} \frac 1{\sqrt{d}} \frac 2d \frac 1{q_T} \frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}} = \frac 1{1.7 d\sqrt{d}} \frac 1{q_T} \frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}. \end{eqnarray*}
</p>
<p> In the first form (in the center of the equation), \(\frac 1{2 \cdot 1.7}\) is a universal constant, \(\frac 1{\sqrt{d}}\) is the factor that accounts for the difference between cell diameter and grid point separation, \(\frac 2d\) accounts for the increase in \(\beta\) with space dimension, \(\frac 1{q_T}\) accounts for the distance between grid points for higher order elements, and \(\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) for the local speed of transport relative to the cell size. This is the formula that we use in the program.</p>
<p>As for the question of whether to use \(Q_1\) or \(Q_2\) elements for the temperature, the following considerations may be useful: First, solving the temperature equation is hardly a factor in the overall scheme since almost the entire compute time goes into solving the Stokes system in each time step. Higher order elements for the temperature equation are therefore not a significant drawback. On the other hand, if one compares the size of the over- and undershoots the solution produces due to the discontinuous source description, one notices that for the choice of \(\beta\) and \(k\) as above, the \(Q_1\) solution dips down to around \(-0.47\), whereas the \(Q_2\) solution only goes to \(-0.13\) (remember that the exact solution should never become negative at all. This means that the \(Q_2\) solution is significantly more accurate; the program therefore uses these higher order elements, despite the penalty we pay in terms of smaller time steps.</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>There are various ways to extend the current program. Of particular interest is, of course, to make it faster and/or increase the resolution of the program, in particular in 3d. This is the topic of the <a class="el" href="step_32.html">step-32</a> tutorial program which will implement strategies to solve this problem in parallel on a cluster. It is also the basis of the much larger open source code ASPECT (see <a href="https://aspect.geodynamics.org/">https://aspect.geodynamics.org/</a> ) that can solve realistic problems and that constitutes the further development of <a class="el" href="step_32.html">step-32</a>.</p>
<p>Another direction would be to make the fluid flow more realistic. The program was initially written to simulate various cases simulating the convection of material in the earth's mantle, i.e. the zone between the outer earth core and the solid earth crust: there, material is heated from below and cooled from above, leading to thermal convection. The physics of this fluid are much more complicated than shown in this program, however: The viscosity of mantle material is strongly dependent on the temperature, i.e. \(\eta=\eta(T)\), with the dependency frequently modeled as a viscosity that is reduced exponentially with rising temperature. Secondly, much of the dynamics of the mantle is determined by chemical reactions, primarily phase changes of the various crystals that make up the mantle; the buoyancy term on the right hand side of the Stokes equations then depends not only on the temperature, but also on the chemical composition at a given location which is advected by the flow field but also changes as a function of pressure and temperature. We will investigate some of these effects in later tutorial programs as well.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2007 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Martin Kronbichler, Uppsala University,</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University 2007, 2008</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step31</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>EquationData</div><div class="line">  {</div><div class="line">    constexpr <span class="keywordtype">double</span> eta     = 1;</div><div class="line">    constexpr <span class="keywordtype">double</span> kappa   = 1e-6;</div><div class="line">    constexpr <span class="keywordtype">double</span> beta    = 10;</div><div class="line">    constexpr <span class="keywordtype">double</span> density = 1;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>TemperatureInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      TemperatureInitialValues()</div><div class="line">        : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                Vector&lt;double&gt; &amp;  value)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">          value(c) = TemperatureInitialValues&lt;dim&gt;::value(p, c);</div><div class="line">      }</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>TemperatureRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      TemperatureRightHandSide()</div><div class="line">        : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        (void)component;</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0,</div><div class="line">               <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Invalid operation for a scalar function.&quot;</span>));</div><div class="line"></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((dim == 2) || (dim == 3), <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> source_centers[3] = {</div><div class="line">          (dim == 2 ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(.3, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.3, .5, .1)),</div><div class="line">          (dim == 2 ? <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.45, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.45, .5, .1)),</div><div class="line">          (dim == 2 ? <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.75, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.75, .5, .1))};</div><div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> source_radius = (dim == 2 ? 1. / 32 : 1. / 8);</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> ((source_centers[0].distance(p) &lt; source_radius) ||</div><div class="line">                    (source_centers[1].<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(p) &lt; source_radius) ||</div><div class="line">                    (source_centers[2].distance(p) &lt; source_radius) ?</div><div class="line">                  1 :</div><div class="line">                  0);</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                Vector&lt;double&gt; &amp;  value)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">          value(c) = TemperatureRightHandSide&lt;dim&gt;::value(p, c);</div><div class="line">      }</div><div class="line">    };</div><div class="line">  } <span class="comment">// namespace EquationData</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>LinearSolvers</div><div class="line">  {</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                    <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">      <span class="keywordtype">void</span> vmult(<a class="code" href="classVectorType.html">VectorType</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">      <span class="keyword">const</span> PreconditionerType &amp;           preconditioner;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">      <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">      <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">      : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">      , preconditioner(preconditioner)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">    <span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">      <a class="code" href="classVectorType.html">VectorType</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>        solver_control(src.size(), 1e-7 * src.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;VectorType&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">      dst = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">try</span></div><div class="line">        {</div><div class="line">          cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, preconditioner);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">catch</span> (std::exception &amp;e)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(e.what()));</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    <span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      BlockSchurPreconditioner(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">        <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                            PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">        <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner);</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#aff5a880cfa288ecdd2a83a876abacf0d">vmult</a>(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">        stokes_matrix;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;<span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                             PreconditionerTypeMp&gt;&gt;</div><div class="line">                                 m_inverse;</div><div class="line">      <span class="keyword">const</span> PreconditionerTypeA &amp;a_preconditioner;</div><div class="line"></div><div class="line">      <span class="keyword">mutable</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::</div><div class="line">      BlockSchurPreconditioner(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">        <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                            PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">        <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner)</div><div class="line">      : stokes_matrix(&amp;S)</div><div class="line">      , m_inverse(&amp;Mpinv)</div><div class="line">      , a_preconditioner(Apreconditioner)</div><div class="line">      , tmp(<a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(stokes_matrix-&gt;block(1, 1).m()))</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::vmult(</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      a_preconditioner.vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">      stokes_matrix-&gt;block(1, 0).residual(tmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">      tmp *= -1;</div><div class="line">      m_inverse-&gt;vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div><div class="line">    }</div><div class="line">  } <span class="comment">// namespace LinearSolvers</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoussinesqFlowProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoussinesqFlowProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span>   setup_dofs();</div><div class="line">    <span class="keywordtype">void</span>   assemble_stokes_preconditioner();</div><div class="line">    <span class="keywordtype">void</span>   build_stokes_preconditioner();</div><div class="line">    <span class="keywordtype">void</span>   assemble_stokes_system();</div><div class="line">    <span class="keywordtype">void</span>   assemble_temperature_system(<span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity);</div><div class="line">    <span class="keywordtype">void</span>   assemble_temperature_matrix();</div><div class="line">    <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div><div class="line">    std::pair&lt;double, double&gt; get_extrapolated_temperature_range() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span>                      solve();</div><div class="line">    <span class="keywordtype">void</span>                      output_results() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span>                      refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> compute_viscosity(</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        gamma_values,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_u_infty,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_T_variation,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <span class="keywordtype">double</span>             global_Omega_diameter;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        stokes_degree;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             stokes_fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           stokes_dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> stokes_constraints;</div><div class="line"></div><div class="line">    std::vector&lt;IndexSet&gt;               stokes_partitioning;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_matrix;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_preconditioner_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_stokes_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_rhs;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        temperature_degree;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 temperature_fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           temperature_dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> temperature_constraints;</div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix temperature_mass_matrix;</div><div class="line">    TrilinosWrappers::SparseMatrix temperature_stiffness_matrix;</div><div class="line">    TrilinosWrappers::SparseMatrix temperature_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_rhs;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time_step;</div><div class="line">    <span class="keywordtype">double</span>       old_time_step;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionAMG&gt; Amg_preconditioner;</div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt;  Mp_preconditioner;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> rebuild_stokes_matrix;</div><div class="line">    <span class="keywordtype">bool</span> rebuild_temperature_matrices;</div><div class="line">    <span class="keywordtype">bool</span> rebuild_stokes_preconditioner;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::BoussinesqFlowProblem()</div><div class="line">    : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">    , global_Omega_diameter(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">    , stokes_degree(1)</div><div class="line">    , stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree), 1)</div><div class="line">    , stokes_dof_handler(triangulation)</div><div class="line">    ,</div><div class="line"></div><div class="line">    temperature_degree(2)</div><div class="line">    , temperature_fe(temperature_degree)</div><div class="line">    , temperature_dof_handler(triangulation)</div><div class="line">    ,</div><div class="line"></div><div class="line">    time_step(0)</div><div class="line">    , old_time_step(0)</div><div class="line">    , timestep_number(0)</div><div class="line">    , rebuild_stokes_matrix(true)</div><div class="line">    , rebuild_temperature_matrices(true)</div><div class="line">    , rebuild_stokes_preconditioner(true)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(), stokes_degree + 1);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(stokes_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points);</div><div class="line">    <span class="keywordtype">double</span>                      max_velocity = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(stokes_solution,</div><div class="line">                                                  velocity_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity, velocity_values[q].<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> max_velocity;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::pair&lt;double, double&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::get_extrapolated_temperature_range()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                            temperature_degree);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(temperature_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">               max_temperature = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                          old_temperature_values);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_temperature_solution,</div><div class="line">                                          old_old_temperature_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> temperature =</div><div class="line">                  (1. + time_step / old_time_step) * old_temperature_values[q] -</div><div class="line">                  time_step / old_time_step * old_old_temperature_values[q];</div><div class="line"></div><div class="line">                min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_temperature, temperature);</div><div class="line">                max_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_temperature, temperature);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> std::make_pair(min_temperature, max_temperature);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">               max_temperature = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                          old_temperature_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> temperature = old_temperature_values[q];</div><div class="line"></div><div class="line">                min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_temperature, temperature);</div><div class="line">                max_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_temperature, temperature);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> std::make_pair(min_temperature, max_temperature);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::compute_viscosity(</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        gamma_values,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_u_infty,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_T_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    constexpr <span class="keywordtype">double</span> beta  = 0.017 * dim;</div><div class="line">    constexpr <span class="keywordtype">double</span> alpha = 1.0;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (global_u_infty == 0)</div><div class="line">      <span class="keywordflow">return</span> 5e-3 * cell_diameter;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_temperature.size();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_residual = 0;</div><div class="line">    <span class="keywordtype">double</span> max_velocity = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u =</div><div class="line">          (old_velocity_values[q] + old_old_velocity_values[q]) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> dT_dt =</div><div class="line">          (old_temperature[q] - old_old_temperature[q]) / old_time_step;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_T =</div><div class="line">          u * (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> kappa_Delta_T =</div><div class="line">          EquationData::kappa *</div><div class="line">          (old_temperature_laplacians[q] + old_old_temperature_laplacians[q]) /</div><div class="line">          2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> residual =</div><div class="line">          <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>((dT_dt + u_grad_T - kappa_Delta_T - gamma_values[q]) *</div><div class="line">                   std::pow((old_temperature[q] + old_old_temperature[q]) / 2,</div><div class="line">                            alpha - 1.));</div><div class="line"></div><div class="line">        max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div><div class="line">        max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u * u), max_velocity);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> c_R            = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2., (4. - 2 * alpha) / dim);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> global_scaling = c_R * global_u_infty * global_T_variation *</div><div class="line">                                  <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(global_Omega_diameter, alpha - 2.);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (</div><div class="line">      beta * max_velocity *</div><div class="line">      <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(cell_diameter,</div><div class="line">               std::pow(cell_diameter, alpha) * max_residual / global_scaling));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_dofs()</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; stokes_sub_blocks(dim + 1, 0);</div><div class="line">    stokes_sub_blocks[dim] = 1;</div><div class="line"></div><div class="line">    {</div><div class="line">      stokes_dof_handler.distribute_dofs(stokes_fe);</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">      stokes_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(stokes_dof_handler,</div><div class="line">                                              stokes_constraints);</div><div class="line">      std::set&lt;types::boundary_id&gt; no_normal_flux_boundaries;</div><div class="line">      no_normal_flux_boundaries.insert(0);</div><div class="line">      <a class="code" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a>(stokes_dof_handler,</div><div class="line">                                                      0,</div><div class="line">                                                      no_normal_flux_boundaries,</div><div class="line">                                                      stokes_constraints);</div><div class="line">      stokes_constraints.close();</div><div class="line">    }</div><div class="line">    {</div><div class="line">      temperature_dof_handler.distribute_dofs(temperature_fe);</div><div class="line"></div><div class="line">      temperature_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(temperature_dof_handler,</div><div class="line">                                              temperature_constraints);</div><div class="line">      temperature_constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; stokes_dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = stokes_dofs_per_block[0],</div><div class="line">                       n_p = stokes_dofs_per_block[1],</div><div class="line">                       n_T = temperature_dof_handler.n_dofs();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_T &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">              &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_T &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    stokes_partitioning.resize(2);</div><div class="line">    stokes_partitioning[0] = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_u);</div><div class="line">    stokes_partitioning[1] = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_p);</div><div class="line">    {</div><div class="line">      stokes_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">      dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">      dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">      dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">      dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">      dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        stokes_dof_handler, coupling, dsp, stokes_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      stokes_matrix.reinit(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      Amg_preconditioner.reset();</div><div class="line">      Mp_preconditioner.reset();</div><div class="line">      stokes_preconditioner_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">      dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">      dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">      dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">      dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">      dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (c == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        stokes_dof_handler, coupling, dsp, stokes_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      stokes_preconditioner_matrix.reinit(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      temperature_mass_matrix.clear();</div><div class="line">      temperature_stiffness_matrix.clear();</div><div class="line">      temperature_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_T, n_T);</div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(temperature_dof_handler,</div><div class="line">                                      dsp,</div><div class="line">                                      temperature_constraints,</div><div class="line">                                      <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      temperature_matrix.reinit(dsp);</div><div class="line">      temperature_mass_matrix.reinit(temperature_matrix);</div><div class="line">      temperature_stiffness_matrix.reinit(temperature_matrix);</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> temperature_partitioning = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_T);</div><div class="line">    stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line">    stokes_rhs.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_old_temperature_solution.reinit(temperature_partitioning,</div><div class="line">                                        MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    temperature_rhs.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_preconditioner()</div><div class="line">  {</div><div class="line">    stokes_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(stokes_degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(stokes_fe,</div><div class="line">                                   quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; grad_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;         phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        stokes_fe_values.reinit(cell);</div><div class="line">        local_matrix = 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                grad_phi_u[k] = stokes_fe_values[velocities].gradient(k, q);</div><div class="line">                phi_p[k]      = stokes_fe_values[pressure].value(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                local_matrix(i, j) +=</div><div class="line">                  (EquationData::eta *</div><div class="line">                     <a class="code" href="symmetric__tensor_8h.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[i], grad_phi_u[j]) +</div><div class="line">                   (1. / EquationData::eta) * phi_p[i] * phi_p[j]) *</div><div class="line">                  stokes_fe_values.JxW(q);</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        stokes_constraints.distribute_local_to_global(</div><div class="line">          local_matrix, local_dof_indices, stokes_preconditioner_matrix);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::build_stokes_preconditioner()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_preconditioner == <span class="keyword">false</span>)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding Stokes preconditioner...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    assemble_stokes_preconditioner();</div><div class="line"></div><div class="line">    Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionAMG&gt;();</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocity_components(0);</div><div class="line">    <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(stokes_dof_handler,</div><div class="line">                                     stokes_fe.component_mask(</div><div class="line">                                       velocity_components),</div><div class="line">                                     constant_modes);</div><div class="line">    <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> amg_data;</div><div class="line">    amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a> = constant_modes;</div><div class="line"></div><div class="line">    amg_data.elliptic              = <span class="keyword">true</span>;</div><div class="line">    amg_data.higher_order_elements = <span class="keyword">true</span>;</div><div class="line">    amg_data.smoother_sweeps       = 2;</div><div class="line">    amg_data.aggregation_threshold = 0.02;</div><div class="line">    Amg_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(0, 0),</div><div class="line">                                   amg_data);</div><div class="line"></div><div class="line">    Mp_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">    Mp_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(1, 1));</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    rebuild_stokes_preconditioner = <span class="keyword">false</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_system()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">      stokes_matrix = 0;</div><div class="line"></div><div class="line">    stokes_rhs = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(stokes_degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(</div><div class="line">      stokes_fe,</div><div class="line">      quadrature_formula,</div><div class="line">      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">        (rebuild_stokes_matrix == <span class="keyword">true</span> ? <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> : <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(0)));</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values(temperature_fe,</div><div class="line">                                        quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;          phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; grads_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  div_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell             = stokes_dof_handler.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc             = stokes_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       temperature_cell = temperature_dof_handler.begin_active();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++temperature_cell)</div><div class="line">      {</div><div class="line">        stokes_fe_values.reinit(cell);</div><div class="line">        temperature_fe_values.reinit(temperature_cell);</div><div class="line"></div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs    = 0;</div><div class="line"></div><div class="line">        temperature_fe_values.get_function_values(old_temperature_solution,</div><div class="line">                                                  old_temperature_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> old_temperature = old_temperature_values[q];</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                phi_u[k] = stokes_fe_values[velocities].value(k, q);</div><div class="line">                <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">                  {</div><div class="line">                    grads_phi_u[k] =</div><div class="line">                      stokes_fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">                    div_phi_u[k] =</div><div class="line">                      stokes_fe_values[velocities].divergence(k, q);</div><div class="line">                    phi_p[k] = stokes_fe_values[pressure].value(k, q);</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  local_matrix(i, j) +=</div><div class="line">                    (EquationData::eta * 2 * (grads_phi_u[i] * grads_phi_u[j]) -</div><div class="line">                     div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div><div class="line">                    stokes_fe_values.JxW(q);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> gravity =</div><div class="line">              -((dim == 2) ? (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 1)) : (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0, 1)));</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              local_rhs(i) += (-EquationData::density * EquationData::beta *</div><div class="line">                               gravity * phi_u[i] * old_temperature) *</div><div class="line">                              stokes_fe_values.JxW(q);</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">          stokes_constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                                        local_rhs,</div><div class="line">                                                        local_dof_indices,</div><div class="line">                                                        stokes_matrix,</div><div class="line">                                                        stokes_rhs);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          stokes_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                        local_dof_indices,</div><div class="line">                                                        stokes_rhs);</div><div class="line">      }</div><div class="line"></div><div class="line">    rebuild_stokes_matrix = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_matrix()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (rebuild_temperature_matrices == <span class="keyword">false</span>)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    temperature_mass_matrix      = 0;</div><div class="line">    temperature_stiffness_matrix = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(temperature_degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values(temperature_fe,</div><div class="line">                                        quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = temperature_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_stiffness_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         phi_T(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        local_mass_matrix      = 0;</div><div class="line">        local_stiffness_matrix = 0;</div><div class="line"></div><div class="line">        temperature_fe_values.reinit(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);</div><div class="line">                phi_T[k]      = temperature_fe_values.shape_value(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  local_mass_matrix(i, j) +=</div><div class="line">                    (phi_T[i] * phi_T[j] * temperature_fe_values.JxW(q));</div><div class="line">                  local_stiffness_matrix(i, j) +=</div><div class="line">                    (EquationData::kappa * grad_phi_T[i] * grad_phi_T[j] *</div><div class="line">                     temperature_fe_values.JxW(q));</div><div class="line">                }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        temperature_constraints.distribute_local_to_global(</div><div class="line">          local_mass_matrix, local_dof_indices, temperature_mass_matrix);</div><div class="line">        temperature_constraints.distribute_local_to_global(</div><div class="line">          local_stiffness_matrix,</div><div class="line">          local_dof_indices,</div><div class="line">          temperature_stiffness_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    rebuild_temperature_matrices = <span class="keyword">false</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_system(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (use_bdf2_scheme == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line">        temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">        temperature_matrix *=</div><div class="line">          (2 * time_step + old_time_step) / (time_step + old_time_step);</div><div class="line">        temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">        temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    temperature_rhs = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(temperature_degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     temperature_fe_values(temperature_fe,</div><div class="line">                                        quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(stokes_fe,</div><div class="line">                                   quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = temperature_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    Vector&lt;double&gt; local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_velocity_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_velocity_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_temperature_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_old_temperature_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_temperature_grads(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_temperature_grads(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_temperature_laplacians(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_old_temperature_laplacians(n_q_points);</div><div class="line"></div><div class="line">    EquationData::TemperatureRightHandSide&lt;dim&gt; temperature_right_hand_side;</div><div class="line">    std::vector&lt;double&gt;                         gamma_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         phi_T(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range =</div><div class="line">      get_extrapolated_temperature_range();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell        = temperature_dof_handler.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc        = temperature_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       stokes_cell = stokes_dof_handler.begin_active();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++stokes_cell)</div><div class="line">      {</div><div class="line">        local_rhs = 0;</div><div class="line"></div><div class="line">        temperature_fe_values.reinit(cell);</div><div class="line">        stokes_fe_values.reinit(stokes_cell);</div><div class="line"></div><div class="line">        temperature_fe_values.get_function_values(old_temperature_solution,</div><div class="line">                                                  old_temperature_values);</div><div class="line">        temperature_fe_values.get_function_values(old_old_temperature_solution,</div><div class="line">                                                  old_old_temperature_values);</div><div class="line"></div><div class="line">        temperature_fe_values.get_function_gradients(old_temperature_solution,</div><div class="line">                                                     old_temperature_grads);</div><div class="line">        temperature_fe_values.get_function_gradients(</div><div class="line">          old_old_temperature_solution, old_old_temperature_grads);</div><div class="line"></div><div class="line">        temperature_fe_values.get_function_laplacians(</div><div class="line">          old_temperature_solution, old_temperature_laplacians);</div><div class="line">        temperature_fe_values.get_function_laplacians(</div><div class="line">          old_old_temperature_solution, old_old_temperature_laplacians);</div><div class="line"></div><div class="line">        temperature_right_hand_side.value_list(</div><div class="line">          temperature_fe_values.get_quadrature_points(), gamma_values);</div><div class="line"></div><div class="line">        stokes_fe_values[velocities].get_function_values(stokes_solution,</div><div class="line">                                                         old_velocity_values);</div><div class="line">        stokes_fe_values[velocities].get_function_values(</div><div class="line">          old_stokes_solution, old_old_velocity_values);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div><div class="line">          compute_viscosity(old_temperature_values,</div><div class="line">                            old_old_temperature_values,</div><div class="line">                            old_temperature_grads,</div><div class="line">                            old_old_temperature_grads,</div><div class="line">                            old_temperature_laplacians,</div><div class="line">                            old_old_temperature_laplacians,</div><div class="line">                            old_velocity_values,</div><div class="line">                            old_old_velocity_values,</div><div class="line">                            gamma_values,</div><div class="line">                            maximal_velocity,</div><div class="line">                            global_T_range.second - global_T_range.first,</div><div class="line">                            cell-&gt;diameter());</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);</div><div class="line">                phi_T[k]      = temperature_fe_values.shape_value(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> T_term_for_rhs =</div><div class="line">              (use_bdf2_scheme ?</div><div class="line">                 (old_temperature_values[q] * (1 + time_step / old_time_step) -</div><div class="line">                  old_old_temperature_values[q] * (time_step * time_step) /</div><div class="line">                    (old_time_step * (time_step + old_time_step))) :</div><div class="line">                 old_temperature_values[q]);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ext_grad_T =</div><div class="line">              (use_bdf2_scheme ?</div><div class="line">                 (old_temperature_grads[q] * (1 + time_step / old_time_step) -</div><div class="line">                  old_old_temperature_grads[q] * time_step / old_time_step) :</div><div class="line">                 old_temperature_grads[q]);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> extrapolated_u =</div><div class="line">              (use_bdf2_scheme ?</div><div class="line">                 (old_velocity_values[q] * (1 + time_step / old_time_step) -</div><div class="line">                  old_old_velocity_values[q] * time_step / old_time_step) :</div><div class="line">                 old_velocity_values[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              local_rhs(i) +=</div><div class="line">                (T_term_for_rhs * phi_T[i] -</div><div class="line">                 time_step * extrapolated_u * ext_grad_T * phi_T[i] -</div><div class="line">                 time_step * nu * ext_grad_T * grad_phi_T[i] +</div><div class="line">                 time_step * gamma_values[q] * phi_T[i]) *</div><div class="line">                temperature_fe_values.JxW(q);</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        temperature_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                           local_dof_indices,</div><div class="line">                                                           temperature_rhs);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> LinearSolvers::InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                         <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a>&gt;</div><div class="line">        mp_inverse(stokes_preconditioner_matrix.block(1, 1),</div><div class="line">                   *Mp_preconditioner);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">        <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">TrilinosWrappers::PreconditionAMG</a>,</div><div class="line">        <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a>&gt;</div><div class="line">        preconditioner(stokes_matrix, mp_inverse, *Amg_preconditioner);</div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(stokes_matrix.m(),</div><div class="line">                                   1e-6 * stokes_rhs.l2_norm());</div><div class="line"></div><div class="line">      <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> gmres(</div><div class="line">        solver_control,</div><div class="line">        <a class="code" href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(100));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; stokes_solution.size(); ++i)</div><div class="line">        <span class="keywordflow">if</span> (stokes_constraints.is_constrained(i))</div><div class="line">          stokes_solution(i) = 0;</div><div class="line"></div><div class="line">      gmres.solve(stokes_matrix, stokes_solution, stokes_rhs, preconditioner);</div><div class="line"></div><div class="line">      stokes_constraints.distribute(stokes_solution);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; GMRES iterations for Stokes subsystem.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    old_time_step                 = time_step;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity = get_maximal_velocity();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (maximal_velocity &gt;= 0.01)</div><div class="line">      time_step = 1. / (1.7 * dim * <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim)) / temperature_degree *</div><div class="line">                  <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) /</div><div class="line">                  maximal_velocity;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      time_step = 1. / (1.7 * dim * <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim)) / temperature_degree *</div><div class="line">                  <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / .01;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    temperature_solution = old_temperature_solution;</div><div class="line"></div><div class="line">    assemble_temperature_system(maximal_velocity);</div><div class="line">    {</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(temperature_matrix.m(),</div><div class="line">                                   1e-8 * temperature_rhs.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a> preconditioner;</div><div class="line">      preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html#a95eff1f8abcf2ba67815b6a96a66d375">initialize</a>(temperature_matrix);</div><div class="line"></div><div class="line">      cg.solve(temperature_matrix,</div><div class="line">               temperature_solution,</div><div class="line">               temperature_rhs,</div><div class="line">               preconditioner);</div><div class="line"></div><div class="line">      temperature_constraints.distribute(temperature_solution);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; CG iterations for temperature.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> min_temperature = temperature_solution(0),</div><div class="line">             max_temperature = temperature_solution(0);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; temperature_solution.size(); ++i)</div><div class="line">        {</div><div class="line">          min_temperature =</div><div class="line">            std::min&lt;double&gt;(min_temperature, temperature_solution(i));</div><div class="line">          max_temperature =</div><div class="line">            std::max&lt;double&gt;(max_temperature, temperature_solution(i));</div><div class="line">        }</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Temperature range: &quot;</span> &lt;&lt; min_temperature &lt;&lt; <span class="charliteral">&#39; &#39;</span></div><div class="line">                &lt;&lt; max_temperature &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (timestep_number % 10 != 0)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; stokes_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    stokes_names.emplace_back(<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      stokes_component_interpretation(</div><div class="line">        dim + 1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">      stokes_component_interpretation[i] =</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(stokes_dof_handler,</div><div class="line">                             stokes_solution,</div><div class="line">                             stokes_names,</div><div class="line">                             stokes_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(temperature_dof_handler,</div><div class="line">                             temperature_solution,</div><div class="line">                             <span class="stringliteral">&quot;T&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(stokes_degree, temperature_degree));</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                         <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 4) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(temperature_dof_handler,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(temperature_degree + 1),</div><div class="line">                                       {},</div><div class="line">                                       temperature_solution,</div><div class="line">                                       estimated_error_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a>(triangulation,</div><div class="line">                                                      estimated_error_per_cell,</div><div class="line">                                                      0.8,</div><div class="line">                                                      0.1);</div><div class="line">    <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &gt; max_grid_level)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell :</div><div class="line">           triangulation.<a class="code" href="group__CPP11.html#gac10cd3fe6ef8360e2599d3cff58e13e8">active_cell_iterators_on_level</a>(max_grid_level))</div><div class="line">        cell-&gt;clear_refine_flag();</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::Vector&gt; x_temperature(2);</div><div class="line">    x_temperature[0]                            = temperature_solution;</div><div class="line">    x_temperature[1]                            = old_temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> x_stokes = stokes_solution;</div><div class="line"></div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a> temperature_trans(</div><div class="line">      temperature_dof_handler);</div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::BlockVector&gt;</a> stokes_trans(</div><div class="line">      stokes_dof_handler);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">    temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);</div><div class="line">    stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::Vector&gt; tmp(2);</div><div class="line">    tmp[0].reinit(temperature_solution);</div><div class="line">    tmp[1].reinit(temperature_solution);</div><div class="line">    temperature_trans.interpolate(x_temperature, tmp);</div><div class="line"></div><div class="line">    temperature_solution     = tmp[0];</div><div class="line">    old_temperature_solution = tmp[1];</div><div class="line"></div><div class="line">    temperature_constraints.distribute(temperature_solution);</div><div class="line">    temperature_constraints.distribute(old_temperature_solution);</div><div class="line"></div><div class="line">    stokes_trans.interpolate(x_stokes, stokes_solution);</div><div class="line"></div><div class="line">    stokes_constraints.distribute(stokes_solution);</div><div class="line"></div><div class="line">    rebuild_stokes_matrix         = <span class="keyword">true</span>;</div><div class="line">    rebuild_temperature_matrices  = <span class="keyword">true</span>;</div><div class="line">    rebuild_stokes_preconditioner = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">BoussinesqFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement     = (dim == 2 ? 4 : 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_pre_refinement_steps = (dim == 2 ? 4 : 3);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">    global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(triangulation);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(initial_refinement);</div><div class="line"></div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"></div><div class="line">  start_time_iteration:</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(temperature_dof_handler,</div><div class="line">                         temperature_constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(temperature_degree + 2),</div><div class="line">                         EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">                         old_temperature_solution);</div><div class="line"></div><div class="line">    timestep_number = 0;</div><div class="line">    time_step = old_time_step = 0;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> time = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_stokes_system();</div><div class="line">        build_stokes_preconditioner();</div><div class="line">        assemble_temperature_matrix();</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">            (pre_refinement_step &lt; n_pre_refinement_steps))</div><div class="line">          {</div><div class="line">            refine_mesh(initial_refinement + n_pre_refinement_steps);</div><div class="line">            ++pre_refinement_step;</div><div class="line">            <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp; (timestep_number % 5 == 0))</div><div class="line">          refine_mesh(initial_refinement + n_pre_refinement_steps);</div><div class="line"></div><div class="line">        time += time_step;</div><div class="line">        ++timestep_number;</div><div class="line"></div><div class="line">        old_stokes_solution          = stokes_solution;</div><div class="line">        old_old_temperature_solution = old_temperature_solution;</div><div class="line">        old_temperature_solution     = temperature_solution;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (time &lt;= 100);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step31</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step31;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-31&quot;</span>));</div><div class="line"></div><div class="line">      BoussinesqFlowProblem&lt;2&gt; flow_problem;</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_22.html">step-22</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#TheBoussinesqequations">The Boussinesq equations</a><a href="#TheBoussinesqequations">The Boussinesq equations</a>
        <li><a href="#Boundaryandinitialconditions">Boundary and initial conditions</a><a href="#Boundaryandinitialconditions">Boundary and initial conditions</a>
        <li><a href="#Solutionapproach">Solution approach</a><a href="#Solutionapproach">Solution approach</a>
      <ul>
        <li><a href="#Timestepping">Time stepping</a><a href="#Timestepping">Time stepping</a>
        <li><a href="#WeakformandspacediscretizationfortheStokespart">Weak form and space discretization for the Stokes part</a><a href="#WeakformandspacediscretizationfortheStokespart">Weak form and space discretization for the Stokes part</a>
        <li><a href="#Stabilizationweakformandspacediscretizationforthetemperatureequation">Stabilization, weak form and space discretization for the temperature equation</a><a href="#Stabilizationweakformandspacediscretizationforthetemperatureequation">Stabilization, weak form and space discretization for the temperature equation</a>
        <li><a href="#Linearsolvers">Linear solvers</a><a href="#Linearsolvers">Linear solvers</a>
      <ul>
        <li><a href="#LinearsolversfortheStokesproblem">Linear solvers for the Stokes problem</a><a href="#LinearsolversfortheStokesproblem">Linear solvers for the Stokes problem</a>
        <li><a href="#Linearsolversforthetemperatureequation">Linear solvers for the temperature equation</a><a href="#Linearsolversforthetemperatureequation">Linear solvers for the temperature equation</a>
      </ul>
      </ul>
        <li><a href="#Implementationdetails">Implementation details</a><a href="#Implementationdetails">Implementation details</a>
      <ul>
        <li><a href="#UsingdifferentDoFHandlerobjects">Using different DoFHandler objects</a><a href="#UsingdifferentDoFHandlerobjects">Using different DoFHandler objects</a>
        <li><a href="#UsingTrilinos">Using Trilinos</a><a href="#UsingTrilinos">Using Trilinos</a>
      </ul>
        <li><a href="#Thetestcase">The testcase</a><a href="#Thetestcase">The testcase</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#Equationdata">Equation data</a><a href="#Equationdata">Equation data</a>
        <li><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a>
      <ul>
        <li><a href="#ThecodeInverseMatrixcodeclasstemplate">The <code>InverseMatrix</code> class template</a><a href="#ThecodeInverseMatrixcodeclasstemplate">The <code>InverseMatrix</code> class template</a>
        <li><a href="#Schurcomplementpreconditioner">Schur complement preconditioner</a><a href="#Schurcomplementpreconditioner">Schur complement preconditioner</a>
      </ul>
        <li><a href="#ThecodeBoussinesqFlowProblemcodeclasstemplate">The <code>BoussinesqFlowProblem</code> class template</a><a href="#ThecodeBoussinesqFlowProblemcodeclasstemplate">The <code>BoussinesqFlowProblem</code> class template</a>
        <li><a href="#BoussinesqFlowProblemclassimplementation">BoussinesqFlowProblem class implementation</a><a href="#BoussinesqFlowProblemclassimplementation">BoussinesqFlowProblem class implementation</a>
      <ul>
        <li><a href="#BoussinesqFlowProblemBoussinesqFlowProblem">BoussinesqFlowProblem::BoussinesqFlowProblem</a><a href="#BoussinesqFlowProblemBoussinesqFlowProblem">BoussinesqFlowProblem::BoussinesqFlowProblem</a>
        <li><a href="#BoussinesqFlowProblemget_maximal_velocity">BoussinesqFlowProblem::get_maximal_velocity</a><a href="#BoussinesqFlowProblemget_maximal_velocity">BoussinesqFlowProblem::get_maximal_velocity</a>
        <li><a href="#BoussinesqFlowProblemget_extrapolated_temperature_range">BoussinesqFlowProblem::get_extrapolated_temperature_range</a><a href="#BoussinesqFlowProblemget_extrapolated_temperature_range">BoussinesqFlowProblem::get_extrapolated_temperature_range</a>
        <li><a href="#BoussinesqFlowProblemcompute_viscosity">BoussinesqFlowProblem::compute_viscosity</a><a href="#BoussinesqFlowProblemcompute_viscosity">BoussinesqFlowProblem::compute_viscosity</a>
        <li><a href="#BoussinesqFlowProblemsetup_dofs">BoussinesqFlowProblem::setup_dofs</a><a href="#BoussinesqFlowProblemsetup_dofs">BoussinesqFlowProblem::setup_dofs</a>
        <li><a href="#BoussinesqFlowProblemassemble_stokes_preconditioner">BoussinesqFlowProblem::assemble_stokes_preconditioner</a><a href="#BoussinesqFlowProblemassemble_stokes_preconditioner">BoussinesqFlowProblem::assemble_stokes_preconditioner</a>
        <li><a href="#BoussinesqFlowProblembuild_stokes_preconditioner">BoussinesqFlowProblem::build_stokes_preconditioner</a><a href="#BoussinesqFlowProblembuild_stokes_preconditioner">BoussinesqFlowProblem::build_stokes_preconditioner</a>
        <li><a href="#BoussinesqFlowProblemassemble_stokes_system">BoussinesqFlowProblem::assemble_stokes_system</a><a href="#BoussinesqFlowProblemassemble_stokes_system">BoussinesqFlowProblem::assemble_stokes_system</a>
        <li><a href="#BoussinesqFlowProblemassemble_temperature_matrix">BoussinesqFlowProblem::assemble_temperature_matrix</a><a href="#BoussinesqFlowProblemassemble_temperature_matrix">BoussinesqFlowProblem::assemble_temperature_matrix</a>
        <li><a href="#BoussinesqFlowProblemassemble_temperature_system">BoussinesqFlowProblem::assemble_temperature_system</a><a href="#BoussinesqFlowProblemassemble_temperature_system">BoussinesqFlowProblem::assemble_temperature_system</a>
        <li><a href="#BoussinesqFlowProblemsolve">BoussinesqFlowProblem::solve</a><a href="#BoussinesqFlowProblemsolve">BoussinesqFlowProblem::solve</a>
        <li><a href="#BoussinesqFlowProblemoutput_results">BoussinesqFlowProblem::output_results</a><a href="#BoussinesqFlowProblemoutput_results">BoussinesqFlowProblem::output_results</a>
        <li><a href="#BoussinesqFlowProblemrefine_mesh">BoussinesqFlowProblem::refine_mesh</a><a href="#BoussinesqFlowProblemrefine_mesh">BoussinesqFlowProblem::refine_mesh</a>
        <li><a href="#BoussinesqFlowProblemrun">BoussinesqFlowProblem::run</a><a href="#BoussinesqFlowProblemrun">BoussinesqFlowProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Resultsin2d"> Results in 2d </a><a href="#Resultsin2d"> Results in 2d </a>
        <li><a href="#Resultsin3d"> Results in 3d </a><a href="#Resultsin3d"> Results in 3d </a>
        <li><a href="#Numericalexperimentstodetermineoptimalparameters"> Numerical experiments to determine optimal parameters </a><a href="#Numericalexperimentstodetermineoptimalparameters"> Numerical experiments to determine optimal parameters </a>
      <ul>
        <li><a href="#Choosingicsubksubiandbeta"> Choosing <i>c<sub>k</sub></i><a href="#Choosingicsubksubiandbeta"> Choosing <i>c<sub>k</sub></i> and beta </a><i>c<sub>k</sub></i> and beta </a>
      <ul>
        <li><a href="#ResultsforQsub1subelements">Results for Q<sub>1</sub> elements</a><a href="#ResultsforQsub1subelements">Results for Q<sub>1</sub> elements</a>
        <li><a href="#ResultsforQsub2subelements">Results for Q<sub>2</sub> elements</a><a href="#ResultsforQsub2subelements">Results for Q<sub>2</sub> elements</a>
        <li><a href="#Resultsfor3d">Results for 3d</a><a href="#Resultsfor3d">Results for 3d</a>
        <li><a href="#Conclusions">Conclusions</a><a href="#Conclusions">Conclusions</a>
      </ul>
      </ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
 <em>This program was contributed by Martin Kronbichler and Wolfgang Bangerth. <br />
 This material is based upon work partly supported by the National Science Foundation under Award No. EAR-0426271 and The California Institute of Technology. Any opinions, findings, and conclusions or recommendations expressed in this publication are those of the author and do not necessarily reflect the views of the National Science Foundation or of The California Institute of Technology. </em></p>
<p><a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="TheBoussinesqequations"></a></p><h3>The Boussinesq equations</h3>
<p>This program deals with an interesting physical problem: how does afluid (i.e., a liquid or gas) behave if it experiences differences inbuoyancy caused by temperature differences? It is clear that thoseparts of the fluid that are hotter (and therefore lighter) are goingto rise up and those that are cooler (and denser) are going to sinkdown with gravity. In cases where the fluid moves slowly enough such that inertial effectscan be neglected, the equations that describe such behavior are theBoussinesq equations that read as follows: </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; -\rho\; \beta \; T\; \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0, \\ \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma. \end{eqnarray*}
</p>
<p> These equations fall into the class of vector-valued problems (atoplevel overview of this topic can be found in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module).Here, \(\mathbf u\) is the velocity field, \(p\) the pressure, and \(T\) the temperature of the fluid. \(\varepsilon ({\mathbf u}) = \frac 12 [(\nabla{\mathbf u}) + (\nabla {\mathbf u})^T]\) is the symmetricgradient of the velocity. As can be seen, velocity and pressuresolve a Stokes equation describing the motion of an incompressiblefluid, an equation we have previously considered in <a class="el" href="step_22.html">step-22</a> ; wewill draw extensively on the experience we have gained in that program, inparticular with regard to efficient linear Stokes solvers. The forcing term of the fluid motion is the buoyancy of thefluid, expressed as the product of the density \(\rho\) , the thermal expansioncoefficient \(\beta\) ,the temperature \(T\) and the gravity vector \(\mathbf{g}\) pointingdownward. (A derivation of why the right hand side looks like it looksis given in the introduction of <a class="el" href="step_32.html">step-32</a> .)While the first two equations describe how the fluid reacts totemperature differences by moving around, the third equation stateshow the fluid motion affects the temperature field: it is an advectiondiffusion equation, i.e., the temperature is attached to the fluidparticles and advected along in the flow field, with an additionaldiffusion (heat conduction) term. In many applications, the diffusioncoefficient is fairly small, and the temperature equation is in facttransport, not diffusion dominated and therefore in character more hyperbolicthan elliptic; we will have to take this into account when developing a stablediscretization. In the equations above, the term \(\gamma\) on the right hand side denotes theheat sources and may be a spatially and temporally varying function. \(\eta\) and \(\kappa\) denote the viscosity and diffusivity coefficients, which we assumeconstant for this tutorial program. The more general case when \(\eta\) depends onthe temperature is an important factor in physical applications: Most materialsbecome more fluid as they get hotter (i.e., \(\eta\) decreases with \(T\) );sometimes, as in the case of rock minerals at temperatures close to theirmelting point, \(\eta\) may change by orders of magnitude over the typical rangeof temperatures. We note that the Stokes equation above could be nondimensionalized byintroducing the <a href="http://en.wikipedia.org/wiki/Rayleigh_number" target="_top">Rayleigh number</a> \(\mathrm{Ra}=\frac{\|\mathbf{g}\| \beta \rho}{\eta \kappa} \delta T L^3\) using atypical length scale \(L\) , typical temperature difference \(\delta T\) , density \(\rho\) , thermal diffusivity \(\eta\) , and thermal conductivity \(\kappa\) . \(\mathrm{Ra}\) is a dimensionless number that describes the ratio of heattransport due to convection induced by buoyancy changes fromtemperature differences, and of heat transport due to thermaldiffusion. A small Rayleigh number implies that buoyancy is not strongrelative to viscosity and fluid motion \(\mathbf{u}\) is slow enough sothat heat diffusion \(\kappa\nabla T\) is the dominant heat transportterm. On the other hand, a fluid with a high Rayleigh number will showvigorous convection that dominates heat conduction. For most fluids for which we are interested in computing thermalconvection, the Rayleigh number is very large, often \(10^6\) orlarger. From the structure of the equations, we see that this willlead to large pressure differences and large velocities. Consequently,the convection term in the convection-diffusion equation for \(T\) willalso be very large and an accurate solution of this equation willrequire us to choose small time steps. Problems with large Rayleighnumbers are therefore hard to solve numerically for similar reasonsthat make solving the <a href="http://en.wikipedia.org/wiki/Navier-stokes_equations">Navier-Stokes equations</a> hard to solve when the <a href="http://en.wikipedia.org/wiki/Reynolds_number">Reynolds number \(\mathrm{Re}\)</a> is large. Note that a large Rayleigh number does not necessarily involve largevelocities in absolute terms. For example, the Rayleigh number in theearth mantle is larger than \(10^6\) . Yet thevelocities are small: the material is in fact solid rock but it is sohot and under pressure that it can flow very slowly, on the order ofat most a few centimeters per year. Nevertheless, this can lead tomixing over time scales of many million years, a time scale muchshorter than for the same amount of heat to be distributed by thermalconductivity and a time scale of relevance to affect the evolution of theearth's interior and surface structure. </p><dl class="section note"><dt>Note</dt><dd>If you are interested in using the program as the basis for your ownexperiments, you will also want to take a look at its continuation in <a class="el" href="step_32.html">step-32</a> . Furthermore, <a class="el" href="step_32.html">step-32</a> later was developed into the much larger opensource code ASPECT (see <a href="https://aspect.geodynamics.org/">https://aspect.geodynamics.org/</a> ) that can solve realisticproblems and that you may want to investigate before trying to morph <a class="el" href="step_31.html">step-31</a> into something that can solve whatever you want to solve.</dd></dl>
<p><a class="anchor" id="Boundaryandinitialconditions"></a></p><h3>Boundary and initial conditions</h3>
<p>Since the Boussinesq equations are derived under the assumption that inertiaof the fluid's motion does not play a role, the flow field is at each timeentirely determined by buoyancy difference at that time, not by the flow fieldat previous times. This is reflected by the fact that the first two equationsabove are the steady state Stokes equation that do not contain a timederivative. Consequently, we do not need initial conditions for eithervelocities or pressure. On the other hand, the temperature field does satisfyan equation with a time derivative, so we need initial conditions for \(T\) . As for boundary conditions: if \(\kappa&gt;0\) then the temperaturesatisfies a second order differential equation that requiresboundary data all around the boundary for all times. These can either be aprescribed boundary temperature \(T|_{\partial\Omega}=T_b\) (Dirichlet boundaryconditions), or a prescribed thermal flux \(\mathbf{n}\cdot\kappa\nabla T|_{\partial\Omega}=\phi\) ; in this program, we will use an insulated boundarycondition, i.e., prescribe no thermal flux: \(\phi=0\) . Similarly, the velocity field requires us to pose boundary conditions. Thesemay be no-slip no-flux conditions \(\mathbf{u}=0\) on \(\partial\Omega\) if the fluidsticks to the boundary, or no normal flux conditions \(\mathbf n \cdot \mathbf u = 0\) if the fluid can flow along but not across the boundary, or any numberof other conditions that are physically reasonable. In this program, we willuse no normal flux conditions.</p>
<p><a class="anchor" id="Solutionapproach"></a></p><h3>Solution approach</h3>
<p>Like the equations solved in <a class="el" href="step_21.html">step-21</a> , we here have asystem of differential-algebraic equations (DAE): with respect to the timevariable, only the temperature equation is a differential equationwhereas the Stokes system for \(\mathbf{u}\) and \(p\) has notime-derivatives and is therefore of the sort of an algebraicconstraint that has to hold at each time instant. The main differenceto <a class="el" href="step_21.html">step-21</a> is that the algebraic constraint there was amixed Laplace system of the form </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf u + {\mathbf K}\lambda \nabla p &amp;=&amp; 0, \\ \nabla\cdot \mathbf u &amp;=&amp; f, \end{eqnarray*}
</p>
<p> where now we have a Stokes system </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; f, \\ \nabla\cdot \mathbf u &amp;=&amp; 0, \end{eqnarray*}
</p>
<p> where \(\nabla \cdot \eta \varepsilon (\cdot)\) is an operator similar to theLaplacian \(\Delta\) applied to a vector field. Given the similarity to what we have done in <a class="el" href="step_21.html">step-21</a> ,it may not come as a surprise that we choose a similar approach,although we will have to make adjustments for the change in operatorin the top-left corner of the differential operator.</p>
<p><a class="anchor" id="Timestepping"></a></p><h4>Time stepping</h4>
<p>The structure of the problem as a DAE allows us to use the same strategy aswe have already used in <a class="el" href="step_21.html">step-21</a> , i.e., we use a time lagscheme: we first solve the temperature equation (using an extrapolatedvelocity field), and then insert the new temperature solution into the righthand side of the velocity equation. The way we implement this in our codelooks at things from a slightly different perspective, though. We firstsolve the Stokes equations for velocity and pressure using the temperaturefield from the previous time step, which means that we get the velocity forthe previous time step. In other words, we first solve the Stokes system fortime step \(n - 1\) as </p><p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2\eta \varepsilon ({\mathbf u}^{n-1})) + \nabla p^{n-1} &amp;=&amp; -\rho\; \beta \; T^{n-1} \mathbf{g}, \\ \nabla \cdot {\mathbf u}^{n-1} &amp;=&amp; 0, \end{eqnarray*}
</p>
<p> and then the temperature equation with an extrapolated velocity field totime \(n\) . In contrast to <a class="el" href="step_21.html">step-21</a> , we'll use a higher order timestepping scheme here, namely the <a href="http://en.wikipedia.org/wiki/Backward_differentiation_formula">Backward Differentiation Formula scheme of order 2 (BDF-2 in short)</a> that replacesthe time derivative \(\frac{\partial T}{\partial t}\) by the (one-sided)difference quotient \(\frac{\frac 32 T^{n}-2T^{n-1}+\frac 12 T^{n-2}}{k}\) with \(k\) the time step size. This gives the discretized-in-timetemperature equation </p><p class="formulaDsp">
\begin{eqnarray*} \frac 32 T^n - k\nabla \cdot \kappa \nabla T^n &amp;=&amp; 2 T^{n-1} - \frac 12 T^{n-2} - k(2{\mathbf u}^{n-1} - {\mathbf u}^{n-2} ) \cdot \nabla (2T^{n-1}-T^{n-2}) + k\gamma. \end{eqnarray*}
</p>
<p> Note how the temperature equation is solved semi-explicitly: diffusion istreated implicitly whereas advection is treated explicitly using anextrapolation (or forward-projection) of temperature and velocity, includingthe just-computed velocity \({\mathbf u}^{n-1}\) . The forward-projection tothe current time level \(n\) is derived from a Taylor expansion, \(T^n \approx T^{n-1} + k_n \frac{\partial T}{\partial t} \approx T^{n-1} + k_n \frac{T^{n-1}-T^{n-2}}{k_n} = 2T^{n-1}-T^{n-2}\) . We need this projection formaintaining the order of accuracy of the BDF-2 scheme. In other words, thetemperature fields we use in the explicit right hand side are second orderapproximations of the current temperature field &mdash; not quite anexplicit time stepping scheme, but by character not too far away either. The introduction of the temperature extrapolation limits the time step by a<a href="http://en.wikipedia.org/wiki/Courant–Friedrichs–Lewy_condition">Courant-Friedrichs-Lewy (CFL) condition</a> just like it was in <a class="el" href="step_21.html">step_21 </a>step-21"  ". (We wouldn't have had that stability condition if we treated theadvection term implicitly since the BDF-2 scheme is A-stable, at the pricethat we needed to build a new temperature matrix at each time step.) We willdiscuss the exact choice of time step in the <a href="#Results">results section</a>, but for the moment of importance is that this CFL conditionmeans that the time step size \(k\) may change from time step to timestep, and that we have to modify the above formula slightly. If \(k_n,k_{n-1}\) are the time steps sizes of the current and previous timestep, then we use the approximations </p><p class="formulaDsp">
\begin{align*} \frac{\partial T}{\partial t} \approx \frac 1{k_n} \left( \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} T^{n} - \frac{k_n+k_{n-1}}{k_{n-1}}T^{n-1} + \frac{k_n^2}{k_{n-1}(k_n+k_{n-1})} T^{n-2} \right) \end{align*}
</p>
<p> and </p><p class="formulaDsp">
\begin{align*} T^n \approx T^{n-1} + k_n \frac{\partial T}{\partial t} \approx T^{n-1} + k_n \frac{T^{n-1}-T^{n-2}}{k_{n-1}} = \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2}, \end{align*}
</p>
<p> and above equation is generalized as follows: </p><p class="formulaDsp">
\begin{eqnarray*} \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} T^n - k_n\nabla \cdot \kappa \nabla T^n &amp;=&amp; \frac{k_n+k_{n-1}}{k_{n-1}} T^{n-1} - \frac{k_n^2}{k_{n-1}(k_n+k_{n-1})} T^{n-2} - k_n{\mathbf u}^{*,n} \cdot \nabla T^{*,n} + k_n\gamma, \end{eqnarray*}
</p>
<p>where \({(\cdot)}^{*,n} = \left(1+\frac{k_n}{k_{n-1}}\right)(\cdot)^{n-1} - \frac{k_n}{k_{n-1}}(\cdot)^{n-2}\) denotes the extrapolation of velocity \(\mathbf u\) and temperature \(T\) to time level \(n\) , using the valuesat the two previous time steps. That's not an easy to read equation, butwill provide us with the desired higher order accuracy. As a consistencycheck, it is easy to verify that it reduces to the same equation as above if \(k_n=k_{n-1}\) . As a final remark we note that the choice of a higher order timestepping scheme of course forces us to keep more time steps in memory;in particular, we here will need to have \(T^{n-2}\) around, a vectorthat we could previously discard. This seems like a nuisance that wewere able to avoid previously by using only a first order timestepping scheme, but as we will see below when discussing the topic ofstabilization, we will need this vector anyway and so keeping itaround for time discretization is essentially for free and gives usthe opportunity to use a higher order scheme.</p>
<p><a class="anchor" id="WeakformandspacediscretizationfortheStokespart"></a></p><h4>Weak form and space discretization for the Stokes part</h4>
<p>Like solving the mixed Laplace equations, solving the Stokes equationsrequires us to choose particular pairs of finite elements forvelocities and pressure variables. Because this has already been discussed in <a class="el" href="step_22.html">step-22</a> , we only cover this topic briefly:Here, we use thestable pair \(Q_{p+1}^d \times Q_p, p\ge 1\) . These are continuouselements, so we can form the weak form of the Stokes equation withoutproblem by integrating by parts and substituting continuous functionsby their discrete counterparts: </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla {\mathbf v}_h, 2\eta \varepsilon ({\mathbf u}^{n-1}_h)) - (\nabla \cdot {\mathbf v}_h, p^{n-1}_h) &amp;=&amp; -({\mathbf v}_h, \rho\; \beta \; T^{n-1}_h \mathbf{g}), \\ (q_h, \nabla \cdot {\mathbf u}^{n-1}_h) &amp;=&amp; 0, \end{eqnarray*}
</p>
<p> for all test functions \(\mathbf v_h, q_h\) . The first term of the firstequation is considered as the inner product between tensors, i.e. \((\nabla {\mathbf v}_h, \eta \varepsilon ({\mathbf u}^{n-1}_h))_\Omega = \int_\Omega \sum_{i,j=1}^d [\nabla {\mathbf v}_h]_{ij} \eta [\varepsilon ({\mathbf u}^{n-1}_h)]_{ij}\, dx\) .Because the second tensor in this product is symmetric, theanti-symmetric component of \(\nabla {\mathbf v}_h\) plays no role andit leads to the entirely same form if we use the symmetric gradient of \(\mathbf v_h\) instead. Consequently, the formulation we consider andthat we implement is </p><p class="formulaDsp">
\begin{eqnarray*} (\varepsilon({\mathbf v}_h), 2\eta \varepsilon ({\mathbf u}^{n-1}_h)) - (\nabla \cdot {\mathbf v}_h, p^{n-1}_h) &amp;=&amp; -({\mathbf v}_h, \rho\; \beta \; T^{n-1}_h \mathbf{g}), \\ (q_h, \nabla \cdot {\mathbf u}^{n-1}_h) &amp;=&amp; 0. \end{eqnarray*}
</p>
<p>This is exactly the same as what we already discussed in <a class="el" href="step_22.html">step-22</a> and there is not much more to say about this here.</p>
<p><a class="anchor" id="Stabilizationweakformandspacediscretizationforthetemperatureequation"></a></p><h4>Stabilization, weak form and space discretization for the temperature equation</h4>
<p>The more interesting question is what to do with the temperatureadvection-diffusion equation. By default, not all discretizations ofthis equation are equally stable unless we either do something likeupwinding, stabilization, or all of this. One way to achieve this isto use discontinuous elements (i.e., the <a class="el" href="classFE__DGQ.html">FE_DGQ</a> class that we used, forexample, in the discretization of the transport equation in <a class="el" href="step_12.html">step-12</a> , or in discretizing the pressure in <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_21.html">step-21</a> ) and to define aflux at the interface between cells that takes into accountupwinding. If we had a pure advection problem this would probably bethe simplest way to go. However, here we have some diffusion as well,and the discretization of the Laplace operator with discontinuouselements is cumbersome because of the significant number of additionalterms that need to be integrated on each face betweencells. Discontinuous elements also have the drawback that the use ofnumerical fluxes introduces an additional numerical diffusion thatacts everywhere, whereas we would really like to minimize the effectof numerical diffusion to a minimum and only apply it where it isnecessary to stabilize the scheme. A better alternative is therefore to add some nonlinear viscosity tothe model. Essentially, what this does is to transform the temperatureequation from the form </p><p class="formulaDsp">
\begin{eqnarray*} \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma \end{eqnarray*}
</p>
<p> to something like </p><p class="formulaDsp">
\begin{eqnarray*} \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot (\kappa+\nu(T)) \nabla T &amp;=&amp; \gamma, \end{eqnarray*}
</p>
<p> where \(\nu(T)\) is an addition viscosity (diffusion) term that onlyacts in the vicinity of shocks and other discontinuities. \(\nu(T)\) ischosen in such a way that if \(T\) satisfies the original equations, theadditional viscosity is zero. To achieve this, the literature contains a number of approaches. Wewill here follow one developed by Guermond and Popov that builds on asuitably defined residual and a limiting procedure for the additionalviscosity. To this end, let us define a residual \(R_\alpha(T)\) as follows: </p><p class="formulaDsp">
\begin{eqnarray*} R_\alpha(T) = \left( \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T - \gamma \right) T^{\alpha-1} \end{eqnarray*}
</p>
<p> where we will later choose the stabilization exponent \(\alpha\) fromwithin the range \([1,2]\) . Note that \(R_\alpha(T)\) will be zero if \(T\) satisfies the temperature equation, since then the term in parentheseswill be zero. Multiplying terms out, we get the following, entirelyequivalent form: </p><p class="formulaDsp">
\begin{eqnarray*} R_\alpha(T) = \frac 1\alpha \frac{\partial (T^\alpha)}{\partial t} + \frac 1\alpha {\mathbf u} \cdot \nabla (T^\alpha) - \frac 1\alpha \nabla \cdot \kappa \nabla (T^\alpha) + \kappa(\alpha-1) T^{\alpha-2} |\nabla T|^2 - \gamma T^{\alpha-1} \end{eqnarray*}
</p>
<p>With this residual, we can now define the artificial viscosity asa piecewise constant function defined on each cell \(K\) with diameter \(h_K\) separately asfollows: </p><p class="formulaDsp">
\begin{eqnarray*} \nu_\alpha(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} \min\left\{ h_K, h_K^\alpha \frac{\|R_\alpha(T)\|_{L^\infty(K)}}{c(\mathbf{u},T)} \right\} \end{eqnarray*}
</p>
<p>Here, \(\beta\) is a stabilization constant (a dimensional analysisreveals that it is unitless and therefore independent of scaling; we willdiscuss its choice in the <a href="#Results">results section</a>) and \(c(\mathbf{u},T)\) is a normalization constant that must have units \(\frac{m^{\alpha-1}K^\alpha}{s}\) . We will choose it as \(c(\mathbf{u},T) = c_R\ \|\mathbf{u}\|_{L^\infty(\Omega)} \ \mathrm{var}(T) \ |\mathrm{diam}(\Omega)|^{\alpha-2}\) ,where \(\mathrm{var}(T)=\max_\Omega T - \min_\Omega T\) is the range of presenttemperature values (remember that buoyancy is driven by temperaturevariations, not the absolute temperature) and \(c_R\) is a dimensionlessconstant. To understand why this method works consider this: If on a particularcell \(K\) the temperature field is smooth, then we expect the residualto be small there (in fact to be on the order of \({\cal O}(h_K)\) ) andthe stabilization term that injects artificial diffusion will there beof size \(h_K^{\alpha+1}\) &mdash; i.e., rather small, just as we hope it tobe when no additional diffusion is necessary. On the other hand, if weare on or close to a discontinuity of the temperature field, then theresidual will be large; the minimum operation in the definition of \(\nu_\alpha(T)\) will then ensure that the stabilization has size \(h_K\) &mdash; the optimal amount of artificial viscosity to ensure stability ofthe scheme. Whether or not this scheme really works is a good question.Computations by Guermond and Popov have shown that this form ofstabilization actually performs much better than most of the otherstabilization schemes that are around (for example streamlinediffusion, to name only the simplest one). Furthermore, for \(\alpha\in [1,2)\) they can even prove that it produces better convergence ordersfor the linear transport equation than for example streamlinediffusion. For \(\alpha=2\) , no theoretical results are currentlyavailable, but numerical tests indicate that the resultsare considerably better than for \(\alpha=1\) . A more practical question is how to introduce this artificialdiffusion into the equations we would like to solve. Note that thenumerical viscosity \(\nu(T)\) is temperature-dependent, so the equationwe want to solve is nonlinear in \(T\) &mdash; not what one desires from asimple method to stabilize an equation, and even less so if we realizethat \(\nu(T)\) is nondifferentiable in \(T\) . However, there is noreason to despair: we still have to discretize in time and we cantreat the term explicitly. In the definition of the stabilization parameter, we approximate the timederivative by \(\frac{\partial T}{\partial t} \approx \frac{T^{n-1}-T^{n-2}}{k^{n-1}}\) . This approximation makes only useof available time data and this is the reason why we need to store data of twoprevious time steps (which enabled us to use the BDF-2 scheme withoutadditional storage cost). We could now simply evaluate the rest of theterms at \(t_{n-1}\) , but then the discrete residual would be nothing else thana backward Euler approximation, which is only first order accurate. So, incase of smooth solutions, the residual would be still of the order \(h\) ,despite the second order time accuracy in the outer BDF-2 scheme and thespatial FE discretization. This is certainly not what we want to have(in fact, we desired to have small residuals in regions where the solutionbehaves nicely), so a bit more care is needed. The key to this problemis to observe that the first derivative as we constructed it is actuallycentered at \(t_{n-\frac{3}{2}}\) . We get the desired second order accurateresidual calculation if we evaluate all spatial terms at \(t_{n-\frac{3}{2}}\) by using the approximation \(\frac 12 T^{n-1}+\frac 12 T^{n-2}\) , which meansthat we calculate the nonlinear viscosity as a function of thisintermediate temperature, \(\nu_\alpha = \nu_\alpha\left(\frac 12 T^{n-1}+\frac 12 T^{n-2}\right)\) . Note that thisevaluation of the residual is nothing else than a Crank-Nicholson scheme,so we can be sure that now everything is alright. One might wonder whetherit is a problem that the numerical viscosity now is not evaluated attime \(n\) (as opposed to the rest of the equation). However, this offsetis uncritical: For smooth solutions, \(\nu_\alpha\) will vary continuously,so the error in time offset is \(k\) times smaller than the nonlinearviscosity itself, i.e., it is a small higher order contribution that isleft out. That's fine because the term itself is already at the level ofdiscretization error in smooth regions. Using the BDF-2 scheme introduced above,this yields for the simpler case of uniform time steps of size \(k\) : </p><p class="formulaDsp">
\begin{eqnarray*} \frac 32 T^n - k\nabla \cdot \kappa \nabla T^n &amp;=&amp; 2 T^{n-1} - \frac 12 T^{n-2} \\ &amp;&amp; + k\nabla \cdot \left[ \nu_\alpha\left(\frac 12 T^{n-1}+\frac 12 T^{n-2}\right) \ \nabla (2T^{n-1}-T^{n-2}) \right] \\ &amp;&amp; - k(2{\mathbf u}^{n-1}-{\mathbf u}^{n-2}) \cdot \nabla (2T^{n-1}-T^{n-2}) \\ &amp;&amp; + k\gamma. \end{eqnarray*}
</p>
<p> On the left side of this equation remains the term from the timederivative and the original (physical) diffusion which we treatimplicitly (this is actually a nice term: the matrices that resultfrom the left hand side are the mass matrix and a multiple of theLaplace matrix &mdash; both are positive definite and if the time stepsize \(k\) is small, the sum is simple to invert). On the right handside, the terms in the first line result from the time derivative; inthe second line is the artificial diffusion at time \(t_{n-\frac 32}\) ; the third line contains theadvection term, and the fourth the sources. Note that theartificial diffusion operates on the extrapolatedtemperature at the current time in the same way as we have discussedthe advection works in the section on time stepping. The form for nonuniform time steps that we will have to use inreality is a bit more complicated (which is why we showed the simplerform above first) and reads: </p><p class="formulaDsp">
\begin{eqnarray*} \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} T^n - k_n\nabla \cdot \kappa \nabla T^n &amp;=&amp; \frac{k_n+k_{n-1}}{k_{n-1}} T^{n-1} - \frac{k_n^2}{k_{n-1}(k_n+k_{n-1})} T^{n-2} \\ &amp;&amp; + k_n\nabla \cdot \left[ \nu_\alpha\left(\frac 12 T^{n-1}+\frac 12 T^{n-2}\right) \ \nabla \left[ \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2} \right] \right] \\ &amp;&amp; - k_n \left[ \left(1+\frac{k_n}{k_{n-1}}\right){\mathbf u}^{n-1} - \frac{k_n}{k_{n-1}}{\mathbf u}^{n-2} \right] \cdot \nabla \left[ \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2} \right] \\ &amp;&amp; + k_n\gamma. \end{eqnarray*}
</p>
<p>After settling all these issues, the weak form follows naturally fromthe strong form shown in the last equation, and we immediately arriveat the weak form of the discretized equations: </p><p class="formulaDsp">
\begin{eqnarray*} \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} (\tau_h,T_h^n) + k_n (\nabla \tau_h, \kappa \nabla T_h^n) &amp;=&amp; \biggl(\tau_h, \frac{k_n+k_{n-1}}{k_{n-1}} T_h^{n-1} - \frac{k_n^2}{k_{n-1}(k_n+k_{n-1})} T_h^{n-2} \\ &amp;&amp;\qquad - k_n \left[ \left(1+\frac{k_n}{k_{n-1}}\right){\mathbf u}^{n-1} - \frac{k_n}{k_{n-1}}{\mathbf u}^{n-2} \right] \cdot \nabla \left[ \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2} \right] + k_n\gamma \biggr) \\ &amp;&amp; - k_n \left(\nabla \tau_h, \nu_\alpha\left(\frac 12 T_h^{n-1}+\frac 12 T_h^{n-2}\right) \ \nabla \left[ \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2} \right] \right) \end{eqnarray*}
</p>
<p> for all discrete test functions \(\tau_h\) . Here, the diffusion term has beenintegrated by parts, and we have used that we will impose no thermal flux, \(\mathbf{n}\cdot\kappa\nabla T|_{\partial\Omega}=0\) . This then results in amatrix equation of form </p><p class="formulaDsp">
\begin{eqnarray*} \left( \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} M+k_n A_T\right) T_h^n = F(U_h^{n-1}, U_h^{n-2},T_h^{n-1},T_h^{n-2}), \end{eqnarray*}
</p>
<p> which given the structure of matrix on the left (the sum of twopositive definite matrices) is easily solved using the ConjugateGradient method.</p>
<p><a class="anchor" id="Linearsolvers"></a></p><h4>Linear solvers</h4>
<p>As explained above, our approach to solving the joint system forvelocities/pressure on the one hand and temperature on the other is to use anoperator splitting where we first solve the Stokes system for the velocitiesand pressures using the old temperature field, and then solve for the newtemperature field using the just computed velocity field. (A moreextensive discussion of operator splitting methods can be found in <a class="el" href="step_58.html">step-58</a> .)</p>
<p><a class="anchor" id="LinearsolversfortheStokesproblem"></a></p><h5>Linear solvers for the Stokes problem</h5>
<p>Solving the linear equations coming from the Stokes system has beendiscussed in great detail in <a class="el" href="step_22.html">step-22</a> . In particular, inthe results section of that program, we have discussed a number ofalternative linear solver strategies that turned out to be moreefficient than the original approach. The best alternativeidentified there we to use a GMRES solver preconditioned by a blockmatrix involving the Schur complement. Specifically, the Stokesoperator leads to a block structured matrix </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \end{eqnarray*}
</p>
<p> and as discussed there a good preconditioner is </p><p class="formulaDsp">
\begin{eqnarray*} P = \left(\begin{array}{cc} A &amp; 0 \\ B &amp; -S \end{array}\right), \qquad \text{or equivalently} \qquad P^{-1} = \left(\begin{array}{cc} A^{-1} &amp; 0 \\ S^{-1} B A^{-1} &amp; -S^{-1} \end{array}\right) \end{eqnarray*}
</p>
<p> where \(S\) is the Schur complement of the Stokes operator \(S=B^TA^{-1}B\) . Of course, this preconditioner is not useful because wecan't form the various inverses of matrices, but we can use thefollowing as a preconditioner: </p><p class="formulaDsp">
\begin{eqnarray*} \tilde P^{-1} = \left(\begin{array}{cc} \tilde A^{-1} &amp; 0 \\ \tilde S^{-1} B \tilde A^{-1} &amp; -\tilde S^{-1} \end{array}\right) \end{eqnarray*}
</p>
<p> where \(\tilde A^{-1},\tilde S^{-1}\) are approximations to the inversematrices. In particular, it turned out that \(S\) is spectrallyequivalent to the mass matrix and consequently replacing \(\tilde S^{-1}\) by a CG solver applied to the mass matrix on the pressurespace was a good choice. In a small deviation from <a class="el" href="step_22.html">step-22</a> , wehere have a coefficient \(\eta\) in the momentum equation, and by the samederivation as there we should arrive at the conclusion that it is the weightedmass matrix with entries \(\tilde S_{ij}=(\eta^{-1}\varphi_i,\varphi_j)\) thatwe should be using. It was more complicated to come up with a good replacement \(\tilde A^{-1}\) , which corresponds to the discretized symmetric Laplacian ofthe vector-valued velocity field, i.e. \(A_{ij} = (\varepsilon {\mathbf v}_i, 2\eta \varepsilon ({\mathbf v}_j))\) .In <a class="el" href="step_22.html">step-22</a> we used a sparse LU decomposition (using theSparseDirectUMFPACK class) of \(A\) for \(\tilde A^{-1}\) &mdash; theperfect preconditioner &mdash; in 2d, but for 3d memory and computetime is not usually sufficient to actually compute this decomposition;consequently, we only use an incomplete LU decomposition (ILU, usingthe <a class="el" href="classSparseILU.html">SparseILU</a> class) in 3d. For this program, we would like to go a bit further. To this end, notethat the symmetrized bilinear form on vector fields, \((\varepsilon {\mathbf v}_i, 2 \eta \varepsilon ({\mathbf v}_j))\) is not too far away from the nonsymmetrized version, \((\nabla {\mathbf v}_i, \eta \nabla {\mathbf v}_j) = \sum_{k,l=1}^d (\partial_k ({\mathbf v}_i)_l, \eta \partial_k ({\mathbf v}_j)_l) \) (note that the factor 2 has disappeared in this form). The latter,however, has the advantage that the <code>dim</code> vector componentsof the test functions are not coupled (well, almost, see below),i.e., the resulting matrix is block-diagonal: one block for each vectorcomponent, and each of these blocks is equal to the Laplace matrix forthis vector component. So assuming we order degrees of freedom in sucha way that first all \(x\) -components of the velocity are numbered, thenthe \(y\) -components, and then the \(z\) -components, then the matrix \(\hat A\) that is associated with this slightly different bilinear form hasthe form </p><p class="formulaDsp">
\begin{eqnarray*} \hat A = \left(\begin{array}{ccc} A_s &amp; 0 &amp; 0 \\ 0 &amp; A_s &amp; 0 \\ 0 &amp; 0 &amp; A_s \end{array}\right) \end{eqnarray*}
</p>
<p> where \(A_s\) is a Laplace matrix of size equal to the number of shape functionsassociated with each component of the vector-valued velocity. With thismatrix, one could be tempted to define our preconditioner for thevelocity matrix \(A\) as follows: </p><p class="formulaDsp">
\begin{eqnarray*} \tilde A^{-1} = \left(\begin{array}{ccc} \tilde A_s^{-1} &amp; 0 &amp; 0 \\ 0 &amp; \tilde A_s^{-1} &amp; 0 \\ 0 &amp; 0 &amp; \tilde A_s^{-1} \end{array}\right), \end{eqnarray*}
</p>
<p> where \(\tilde A_s^{-1}\) is a preconditioner for the Laplace matrix &mdash;something where we know very well how to build good preconditioners! In reality, the story is not quite as simple: To make the matrix \(\tilde A\) definite, we need to make the individual blocks \(\tilde A_s\) definite by applying boundary conditions. One can try to do so byapplying Dirichlet boundary conditions all around the boundary, andthen the so-defined preconditioner \(\tilde A^{-1}\) turns out to be agood preconditioner for \(A\) if the latter matrix results from a Stokesproblem where we also have Dirichlet boundary conditions on thevelocity components all around the domain, i.e., if we enforce \(\mathbf{u} = 0\) . Unfortunately, this "if" is an "if and only if": in the program belowwe will want to use no-flux boundary conditions of the form \(\mathbf u \cdot \mathbf n = 0\) (i.e., flow parallel to the boundary is allowed,but no flux through the boundary). In this case, it turns out that theblock diagonal matrix defined above is not a good preconditionerbecause it neglects the coupling of components at the boundary. Abetter way to do things is therefore if we build the matrix \(\hat A\) as the vector Laplace matrix \(\hat A_{ij} = (\nabla {\mathbf v}_i, \eta \nabla {\mathbf v}_j)\) and then apply the same boundary conditionas we applied to \(A\) . If this is a Dirichlet boundary condition allaround the domain, the \(\hat A\) will decouple to three diagonal blocksas above, and if the boundary conditions are of the form \(\mathbf u \cdot \mathbf n = 0\) then this will introduce a coupling of degrees offreedom at the boundary but only there. This, in fact, turns out to bea much better preconditioner than the one introduced above, and hasalmost all the benefits of what we hoped to get.</p>
<p>To sum this whole story up, we can observe: </p><ul>
<li>
Compared to building a preconditioner from the original matrix \(A\) resulting from the symmetric gradient as we did in <a class="el" href="step_22.html">step-22</a> , we have to expect that the preconditioner based on the Laplace bilinear form performs worse since it does not take into account the coupling between vector components. </li>
<li>
On the other hand, preconditioners for the Laplace matrix are typically more mature and perform better than ones for vector problems. For example, at the time of this writing, Algebraic Multigrid (AMG) algorithms are very well developed for scalar problems, but not so for vector problems. </li>
<li>
In building this preconditioner, we will have to build up the matrix \(\hat A\) and its preconditioner. While this means that we have to store an additional matrix we didn't need before, the preconditioner \(\tilde A_s^{-1}\) is likely going to need much less memory than storing a preconditioner for the coupled matrix \(A\) . This is because the matrix \(A_s\) has only a third of the entries per row for all rows corresponding to interior degrees of freedom, and contains coupling between vector components only on those parts of the boundary where the boundary conditions introduce such a coupling. Storing the matrix is therefore comparatively cheap, and we can expect that computing and storing the preconditioner \(\tilde A_s\) will also be much cheaper compared to doing so for the fully coupled matrix. </li>
</ul>
<p><a class="anchor" id="Linearsolversforthetemperatureequation"></a></p><h5>Linear solvers for the temperature equation</h5>
<p>This is the easy part: The matrix for the temperature equation has the form \(\alpha M + \beta A\) , where \(M,A\) are mass and stiffness matrices on thetemperature space, and \(\alpha,\beta\) are constants related the time steppingscheme and the current and previous time step. This being the sum of asymmetric positive definite and a symmetric positive semidefinite matrix, theresult is also symmetric positive definite. Furthermore, \(\frac\beta\alpha\) isa number proportional to the time step, and so becomes small whenever the meshis fine, damping the effect of the then ill-conditioned stiffness matrix. As a consequence, inverting this matrix with the Conjugate Gradient algorithm,using a simple preconditioner, is trivial and very cheap compared to invertingthe Stokes matrix.</p>
<p><a class="anchor" id="Implementationdetails"></a></p><h3>Implementation details</h3>
<p><a class="anchor" id="UsingdifferentDoFHandlerobjects"></a></p><h4>Using different <a class="el" href="classDoFHandler.html">DoFHandler</a> objects</h4>
<p>One of the things worth explaining up front about the program below is the useof two different <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. If one looks at the structure of theequations above and the scheme for their solution, one realizes that there islittle commonality that keeps the Stokes part and the temperature parttogether. In all previous tutorial programs in which we have discussed <a class="el" href="group__vector__valued.html">vector-valued problems</a> we have always only used a singlefinite element with several vector components, and a single <a class="el" href="classDoFHandler.html">DoFHandler</a> object.Sometimes, we have substructured the resulting matrix into blocks tofacilitate particular solver schemes; this was, for example, the case in the <a class="el" href="step_22.html">step-22</a> program for the Stokes equations upon which the currentprogram is based. We could of course do the same here. The linear system that we would get wouldlook like this: </p><p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{ccc} A &amp; B^T &amp; 0 \\ B &amp; 0 &amp;0 \\ C &amp; 0 &amp; K \end{array}\right) \left(\begin{array}{ccc} U^{n-1} \\ P^{n-1} \\ T^n \end{array}\right) = \left(\begin{array}{ccc} F_U(T^{n-1}) \\ 0 \\ F_T(U^{n-1},U^{n-2},T^{n-1},T^{n-2}) \end{array}\right). \end{eqnarray*}
</p>
<p> The problem with this is: We never use the whole matrix at the same time. Infact, it never really exists at the same time: As explained above, \(K\) and \(F_T\) depend on the already computed solution \(U^n\) , in the first case throughthe time step (that depends on \(U^n\) because it has to satisfy a CFLcondition). So we can only assemble it once we've already solved the top left \(2\times 2\) block Stokes system, and once we've moved on to the temperatureequation we don't need the Stokes part any more; the fact that webuild an object for a matrix that never exists as a whole in memory atany given time led us to jumping through some hoops in <a class="el" href="step_21.html">step-21</a> , solet's not repeat this sort of error. Furthermore, we don'tactually build the matrix \(C\) : Because by the time we get to the temperatureequation we already know \(U^n\) , and because we have to assemble the right handside \(F_T\) at this time anyway, we simply move the term \(CU^n\) to the righthand side and assemble it along with all the other terms there. What thismeans is that there does not remain a part of the matrix where temperaturevariables and Stokes variables couple, and so a global enumeration of alldegrees of freedom is no longer important: It is enough if we have anenumeration of all Stokes degrees of freedom, and of all temperature degreesof freedom independently. In essence, there is consequently not much use in putting <em>everything</em>into a block matrix (though there are of course the same good reasons to do sofor the \(2\times 2\) Stokes part), or, for that matter, in putting everythinginto the same <a class="el" href="classDoFHandler.html">DoFHandler</a> object. But are there <em>downsides</em> to doing so? These exist, though they may notbe obvious at first. The main problem is that if we need to create one globalfinite element that contains velocity, pressure, and temperature shapefunctions, and use this to initialize the <a class="el" href="classDoFHandler.html">DoFHandler</a>. But we also use thisfinite element object to initialize all <a class="el" href="classFEValues.html">FEValues</a> or <a class="el" href="classFEFaceValues.html">FEFaceValues</a> objects thatwe use. This may not appear to be that big a deal, but imagine what happenswhen, for example, we evaluate the residual \( R_\alpha(T) = \left( \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T - \gamma \right) T^{\alpha-1} \) that we need to compute the artificial viscosity \(\nu_\alpha(T)|_K\) . Forthis, we need the Laplacian of the temperature, which we compute using thetensor of second derivatives (Hessians) of the shape functions (we have togive the <code>update_hessians</code> flag to the <a class="el" href="classFEValues.html">FEValues</a> object forthis). Now, if we have a finite that contains the shape functions forvelocities, pressures, and temperatures, that means that we have to computethe Hessians of <em>all</em> shape functions, including the many higher ordershape functions for the velocities. That's a lot of computations that we don'tneed, and indeed if one were to do that (as we had in an early version of theprogram), assembling the right hand side took about a quarter of the overallcompute time. So what we will do is to use two different finite element objects, one for theStokes components and one for the temperatures. With this come two differentDoFHandlers, two sparsity patterns and two matrices for the Stokes andtemperature parts, etc. And whenever we have to assemble something thatcontains both temperature and Stokes shape functions (in particular the righthand sides of Stokes and temperature equations), then we use two FEValuesobjects initialized with two cell iterators that we walk in parallel throughthe two <a class="el" href="classDoFHandler.html">DoFHandler</a> objects associated with the same <a class="el" href="classTriangulation.html">Triangulation</a> object; forthese two <a class="el" href="classFEValues.html">FEValues</a> objects, we use of course the same quadrature objects sothat we can iterate over the same set of quadrature points, but each FEValuesobject will get update flags only according to what it actually needs tocompute. In particular, when we compute the residual as above, we only ask forthe values of the Stokes shape functions, but also the Hessians of thetemperature shape functions &mdash; much cheaper indeed, and as it turns out:assembling the right hand side of the temperature equation is now a componentof the program that is hardly measurable. With these changes, timing the program yields that only the followingoperations are relevant for the overall run time: </p><ul>
<li>
Solving the Stokes system: 72% of the run time. </li>
<li>
Assembling the Stokes preconditioner and computing the algebraic multigrid hierarchy using the Trilinos ML package: 11% of the run time. </li>
<li>
The function <code>BoussinesqFlowProblem::setup_dofs</code> : 7% of overall run time. </li>
<li>
Assembling the Stokes and temperature right hand side vectors as well as assembling the matrices: 7%. </li>
</ul>
<p>In essence this means that all bottlenecks apart from the algebraicmultigrid have been removed.</p>
<p><a class="anchor" id="UsingTrilinos"></a></p><h4>Using Trilinos</h4>
<p>In much the same way as we used PETSc to support our linear algebra needs in <a class="el" href="step_17.html">step-17</a> and <a class="el" href="step_18.html">step-18</a> , we use interfaces to the <a href="http://trilinos.org">Trilinos</a> library (see thedeal.II README file for installation instructions) in this program. Trilinosis a very large collection ofeverything that has to do with linear and nonlinear algebra, as well as allsorts of tools around that (and looks like it will grow in many otherdirections in the future as well). The main reason for using Trilinos, similar to our exploring PETSc, is that itis a very powerful library that provides a lot more tools than deal.II's ownlinear algebra library. That includes, in particular, the ability to work inparallel on a cluster, using MPI, and a wider variety of preconditioners. Inthe latter class, one of the most interesting capabilities is the existence ofthe Trilinos ML package that implements an Algebraic <a class="el" href="classMultigrid.html">Multigrid</a> (AMG)method. We will use this preconditioner to precondition the second orderoperator part of the momentum equation. The ability to solve problems inparallel will be explored in <a class="el" href="step_32.html">step-32</a> , using the same problem asdiscussed here. PETSc, which we have used in <a class="el" href="step_17.html">step-17</a> and <a class="el" href="step_18.html">step-18</a> , is certainly a powerfullibrary, providing a large number of functions that deal with matrices,vectors, and iterative solvers and preconditioners, along with lots of otherstuff, most of which runs quite well in parallel. It is, however, a few yearsold already than Trilinos, written in C, and generally not quite as easy touse as some other libraries. As a consequence, deal.II has also acquiredinterfaces to Trilinos, which shares a lot of the same functionality withPETSc. It is, however, a project that is several years younger, is written inC++ and by people who generally have put a significant emphasis on softwaredesign.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p>The case we want to solve here is as follows: we solve the Boussinesqequations described above with \(\kappa=10^{-6}, \eta=1, \rho=1, \beta=10\) ,i.e., a relatively slow moving fluid that has virtually no thermal diffusiveconductivity and transports heat mainly through convection. On theboundary, we will require no-normal flux for the velocity( \(\mathrm{n}\cdot\mathrm{u}=0\) ) and for the temperature( \(\mathrm{n}\cdot\nabla T=0\) ). This is one of the cases discussed in theintroduction of <a class="el" href="step_22.html">step-22</a> and fixes one component of the velocitywhile allowing flow to be parallel to the boundary. There remain <code>dim-1</code> components to be fixed, namely the tangential components ofthe normal stress; for these, we choose homogeneous conditions which means thatwe do not have to anything special. Initial conditions are only necessary forthe temperature field, and we choose it to be constant zero. The evolution of the problem is then entirely driven by the right hand side \(\gamma(\mathrm{x},t)\) of the temperature equation, i.e., by heat sources andsinks. Here, we choose a setup invented in advance of a Christmas lecture:real candles are of course prohibited in U.S. class rooms, but virtual onesare allowed. We therefore choose three spherical heat sources unequally spacedclose to the bottom of the domain, imitating three candles. The fluid locatedat these sources, initially at rest, is then heated up and as the temperaturerises gains buoyancy, rising up; more fluid is dragged up and through thesources, leading to three hot plumes that rise up until they are captured bythe recirculation of fluid that sinks down on the outside, replacing the airthat rises due to heating.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>The first step, as always, is to include the functionality of these well-known deal.II library files and some C++ header files.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div></div><!-- fragment --><p>Then we need to include some header files that provide vector, matrix, and preconditioner classes that implement interfaces to the respective Trilinos classes. In particular, we will need interfaces to the matrix and vector classes based on Trilinos as well as Trilinos preconditioners:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, here are a few C++ headers that haven't been included yet by one of the aforelisted header files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div></div><!-- fragment --><p>At the end of this top-matter, we import all deal.II names into the global namespace:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step31</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>Again, the next stage in the program is the definition of the equation data, that is, the various boundary conditions, the right hand sides and the initial condition (remember that we're about to solve a time-dependent system). The basic strategy for this definition is the same as in <a class="el" href="step_22.html">step-22</a> . Regarding the details, though, there are some differences.</p>
<p>The first thing is that we don't set any inhomogeneous boundary conditions on the velocity, since as is explained in the introduction we will use no-flux conditions \(\mathbf{n}\cdot\mathbf{u}=0\) . So what is left are <code>dim-1</code> conditions for the tangential part of the normal component of the stress tensor, \(\textbf{n} \cdot [p \textbf{1} - \eta\varepsilon(\textbf{u})]\) ; we assume homogeneous values for these components, i.e., a natural boundary condition that requires no specific action (it appears as a zero term in the right hand side of the weak form). For the temperature \(T\) , we assume no thermal energy flux, i.e., \(\mathbf{n} \cdot \kappa \nabla T=0\) . This, again, is a boundary condition that does not require us to do anything in particular. Secondly, we have to set initial conditions for the temperature (no initial conditions are required for the velocity and pressure, since the Stokes equations for the quasi-stationary case we consider here have no time derivatives of the velocity or pressure). Here, we choose a very simple test case, where the initial temperature is zero, and all dynamics are driven by the temperature right hand side. Thirdly, we need to define the right hand side of the temperature equation. We choose it to be constant within three circles (or spheres in 3d) somewhere at the bottom of the domain, as explained in the introduction, and zero outside. Finally, or maybe firstly, at the top of this namespace, we define the various material constants we need ( \(\eta,\kappa\) , density \(\rho\) and the thermal expansion coefficient \(\beta\) ):</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>EquationData</div><div class="line">{</div><div class="line">  constexpr <span class="keywordtype">double</span> eta     = 1;</div><div class="line">  constexpr <span class="keywordtype">double</span> kappa   = 1e-6;</div><div class="line">  constexpr <span class="keywordtype">double</span> beta    = 10;</div><div class="line">  constexpr <span class="keywordtype">double</span> density = 1;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TemperatureInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TemperatureInitialValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;  <span class="comment">/*p*/</span> ,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span>  = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">        value(c) = TemperatureInitialValues&lt;dim&gt;::value(p, c);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TemperatureRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TemperatureRightHandSide()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0,</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Invalid operation for a scalar function.&quot;</span>));</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((dim == 2) || (dim == 3), <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">      <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> source_centers[3] = {</div><div class="line">        (dim == 2 ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(.3, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.3, .5, .1)),</div><div class="line">        (dim == 2 ? <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.45, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.45, .5, .1)),</div><div class="line">        (dim == 2 ? <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.75, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.75, .5, .1))};</div><div class="line">      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> source_radius = (dim == 2 ? 1. / 32 : 1. / 8);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> ((source_centers[0].distance(p) &lt; source_radius) ||</div><div class="line">                  (source_centers[1].<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(p) &lt; source_radius) ||</div><div class="line">                  (source_centers[2].distance(p) &lt; source_radius) ?</div><div class="line">                1 :</div><div class="line">                0);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">        value(c) = TemperatureRightHandSide&lt;dim&gt;::value(p, c);</div><div class="line">    }</div><div class="line">  };</div><div class="line">} <span class="comment">// namespace EquationData</span></div></div><!-- fragment --><p><a class="anchor" id="Linearsolversandpreconditioners"></a> </p><h3>Linear solvers and preconditioners</h3>
<p>This section introduces some objects that are used for the solution of the linear equations of the Stokes system that we need to solve in each time step. Many of the ideas used here are the same as in <a class="el" href="step_20.html">step-20</a> , where Schur complement based preconditioners and solvers have been introduced, with the actual interface taken from <a class="el" href="step_22.html">step-22</a> (in particular the discussion in the "Results" section of <a class="el" href="step_22.html">step-22</a> , in which we introduce alternatives to the direct Schur complement approach). Note, however, that here we don't use the Schur complement to solve the Stokes equations, though an approximate Schur complement (the mass matrix on the pressure space) appears in the preconditioner.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>LinearSolvers</div><div class="line">{</div></div><!-- fragment --><p><a class="anchor" id="ThecodeInverseMatrixcodeclasstemplate"></a> </p><h4>The <code>InverseMatrix</code> class template</h4>
<p>This class is an interface to calculate the action of an "inverted" matrix on a vector (using the <code>vmult</code> operation) in the same way as the corresponding class in <a class="el" href="step_22.html">step-22</a> : when the product of an object of this class is requested, we solve a linear equation system with that matrix using the CG method, accelerated by a preconditioner of (templated) class <code>PreconditionerType</code> . In a minor deviation from the implementation of the same class in <a class="el" href="step_22.html">step-22</a> , we make the <code>vmult</code> function take any kind of vector type (it will yield compiler errors, however, if the matrix does not allow a matrix-vector product with this kind of vector). Secondly, we catch any exceptions that the solver may have thrown. The reason is as follows: When debugging a program like this one occasionally makes a mistake of passing an indefinite or nonsymmetric matrix or preconditioner to the current class. The solver will, in that case, not converge and throw a run-time exception. If not caught here it will propagate up the call stack and may end up in <code>main()</code> where we output an error message that will say that the CG solver failed. The question then becomes: Which CG solver? The one that inverted the mass matrix? The one that inverted the top left block with the Laplace operator? Or a CG solver in one of the several other nested places where we use linear solvers in the current code? No indication about this is present in a run-time exception because it doesn't store the stack of calls through which we got to the place where the exception was generated. So rather than letting the exception propagate freely up to <code>main()</code> we realize that there is little that an outer function can do if the inner solver fails and rather convert the run-time exception into an assertion that fails and triggers a call to <code><a class="el" href="namespacedeal__II__exceptions_1_1internals.html#a600f8f191a6ce368afda0074dd7ea1dc">abort()</a></code> , allowing us to trace back in a debugger how we got to the current place.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVectorType.html">VectorType</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">  <span class="keyword">const</span> PreconditionerType &amp;           preconditioner;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">  <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">  <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">  : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">  , preconditioner(preconditioner)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line"><span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">  <a class="code" href="classVectorType.html">VectorType</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>        solver_control(src.size(), 1e-7 src.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;VectorType&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">  dst = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, preconditioner);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;e)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(e.what()));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Schurcomplementpreconditioner"></a> </p><h4>Schur complement preconditioner</h4>
<p>This is the implementation of the Schur complement preconditioner as described in detail in the introduction. As opposed to <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_22.html">step-22</a> , we solve the block system all-at-once using GMRES, and use the Schur complement of the block structured matrix to build a good preconditioner instead. Let's have a look at the ideal preconditioner matrix \(P=\left(\begin{array}{cc} A &amp; 0 \\ B &amp; -S \end{array}\right)\) described in the introduction. If we apply this matrix in the solution of a linear system, convergence of an iterative GMRES solver will be governed by the matrix </p><p class="formulaDsp">
\begin{eqnarray*} P^{-1}\left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) = \left(\begin{array}{cc} I &amp; A^{-1} B^T \\ 0 &amp; I \end{array}\right), \end{eqnarray*}
</p>
<p> which indeed is very simple. A GMRES solver based on exact matrices would converge in one iteration, since all eigenvalues are equal (any Krylov method takes at most as many iterations as there are distinct eigenvalues). Such a preconditioner for the blocked Stokes system has been proposed by Silvester and Wathen ("Fast iterative solution of stabilised Stokes systems part II.  Using general block preconditioners", SIAM J. Numer. Anal., 31 (1994), pp. 1352-1367). Replacing \(P\) by \(\tilde{P}\) keeps that spirit alive: the product \(P^{-1} A\) will still be close to a matrix with eigenvalues 1 with a distribution that does not depend on the problem size. This lets us hope to be able to get a number of GMRES iterations that is problem-size independent. The deal.II users who have already gone through the <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_22.html">step-22</a> tutorials can certainly imagine how we're going to implement this. We replace the exact inverse matrices in \(P^{-1}\) by some approximate inverses built from the InverseMatrix class, and the inverse Schur complement will be approximated by the pressure mass matrix \(M_p\) (weighted by \(\eta^{-1}\) as mentioned in the introduction). As pointed out in the results section of <a class="el" href="step_22.html">step-22</a> , we can replace the exact inverse of \(A\) by just the application of a preconditioner, in this case on a vector Laplace matrix as was explained in the introduction. This does increase the number of (outer) GMRES iterations, but is still significantly cheaper than an exact inverse, which would require between 20 and 35 CG iterations for <em> each </em> outer solver step (using the AMG preconditioner). Having the above explanations in mind, we define a preconditioner class with a <code>vmult</code> functionality, which is all we need for the interaction with the usual solver functions further below in the program code. First the declarations. These are similar to the definition of the Schur complement in <a class="el" href="step_20.html">step-20</a> , with the difference that we need some more preconditioners in the constructor and that the matrices we use here are built upon Trilinos:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line"><span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BlockSchurPreconditioner(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                        PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">    <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">    stokes_matrix;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;<span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                         PreconditionerTypeMp&gt;&gt;</div><div class="line">                             m_inverse;</div><div class="line">  <span class="keyword">const</span> PreconditionerTypeA &amp;a_preconditioner;</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp;</div><div class="line">};</div></div><!-- fragment --><p>When using a <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> or a <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>, the <a class="el" href="classVector.html">Vector</a> is initialized using an <a class="el" href="classIndexSet.html">IndexSet</a>. <a class="el" href="classIndexSet.html">IndexSet</a> is used not only to resize the <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> but it also associates an index in the <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> with a degree of freedom (see <a class="el" href="step_40.html">step-40</a> for a more detailed explanation). The function <a class="el" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set()</a> creates an <a class="el" href="classIndexSet.html">IndexSet</a> where every valid index is part of the set. Note that this program can only be run sequentially and will throw an exception if used in parallel.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::</div><div class="line">  BlockSchurPreconditioner(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                        PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">    <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner)</div><div class="line">  : stokes_matrix(&amp;S)</div><div class="line">  , m_inverse(&amp;Mpinv)</div><div class="line">  , a_preconditioner(Apreconditioner)</div><div class="line">  , tmp(<a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(stokes_matrix-&gt;block(1, 1).m()))</div><div class="line">{}</div></div><!-- fragment --><p>Next is the <code>vmult</code> function. We implement the action of \(P^{-1}\) as described above in three successive steps. In formulas, we want to compute \(Y=P^{-1}X\) where \(X,Y\) are both vectors with two block components. The first step multiplies the velocity part of the vector by a preconditioner of the matrix \(A\) , i.e., we compute \(Y_0={\tilde A}^{-1}X_0\) . The resulting velocity vector is then multiplied by \(B\) and subtracted from the pressure, i.e., we want to compute \(X_1-BY_0\) . This second step only acts on the pressure vector and is accomplished by the residual function of our matrix classes, except that the sign is wrong. Consequently, we change the sign in the temporary pressure vector and finally multiply by the inverse pressure mass matrix to get the final pressure vector, completing our work on the Stokes preconditioner:</p>
<div class="fragment"><div class="line">     <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">     <span class="keywordtype">void</span></div><div class="line">     BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::vmult(</div><div class="line">       <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">       <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       a_preconditioner.vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">       stokes_matrix-&gt;block(1, 0).residual(tmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">       tmp=</div><div class="line">  </div><div class="line">-1;</div><div class="line">       m_inverse-&gt;vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div><div class="line">     }</div><div class="line">   } <span class="comment">// namespace LinearSolvers</span></div></div><!-- fragment --><p><a class="anchor" id="ThecodeBoussinesqFlowProblemcodeclasstemplate"></a> </p><h3>The <code>BoussinesqFlowProblem</code> class template</h3>
<p>The definition of the class that defines the top-level logic of solving the time-dependent Boussinesq problem is mainly based on the <a class="el" href="step_22.html">step-22</a> tutorial program. The main differences are that now we also have to solve for the temperature equation, which forces us to have a second <a class="el" href="classDoFHandler.html">DoFHandler</a> object for the temperature variable as well as matrices, right hand sides, and solution vectors for the current and previous time steps. As mentioned in the introduction, all linear algebra objects are going to use wrappers of the corresponding Trilinos functionality. The member functions of this class are reminiscent of <a class="el" href="step_21.html">step-21</a> , where we also used a staggered scheme that first solve the flow equations (here the Stokes equations, in <a class="el" href="step_21.html">step-21</a> Darcy flow) and then update the advected quantity (here the temperature, there the saturation). The functions that are new are mainly concerned with determining the time step, as well as the proper size of the artificial viscosity stabilization. The last three variables indicate whether the various matrices or preconditioners need to be rebuilt the next time the corresponding build functions are called. This allows us to move the corresponding <code>if</code> into the respective function and thereby keeping our main <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function clean and easy to read.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoussinesqFlowProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoussinesqFlowProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>   setup_dofs();</div><div class="line">  <span class="keywordtype">void</span>   assemble_stokes_preconditioner();</div><div class="line">  <span class="keywordtype">void</span>   build_stokes_preconditioner();</div><div class="line">  <span class="keywordtype">void</span>   assemble_stokes_system();</div><div class="line">  <span class="keywordtype">void</span>   assemble_temperature_system(<span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity);</div><div class="line">  <span class="keywordtype">void</span>   assemble_temperature_matrix();</div><div class="line">  <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div><div class="line">  std::pair&lt;double, double&gt; get_extrapolated_temperature_range() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span>                      solve();</div><div class="line">  <span class="keywordtype">void</span>                      output_results() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span>                      refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> compute_viscosity(</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        gamma_values,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_u_infty,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_T_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <span class="keywordtype">double</span>             global_Omega_diameter;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        stokes_degree;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             stokes_fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           stokes_dof_handler;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> stokes_constraints;</div><div class="line"></div><div class="line">  std::vector&lt;IndexSet&gt;               stokes_partitioning;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_matrix;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_preconditioner_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_stokes_solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_rhs;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        temperature_degree;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 temperature_fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           temperature_dof_handler;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> temperature_constraints;</div><div class="line"></div><div class="line">  TrilinosWrappers::SparseMatrix temperature_mass_matrix;</div><div class="line">  TrilinosWrappers::SparseMatrix temperature_stiffness_matrix;</div><div class="line">  TrilinosWrappers::SparseMatrix temperature_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_temperature_solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_temperature_solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_rhs;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>       time_step;</div><div class="line">  <span class="keywordtype">double</span>       old_time_step;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">  std::shared_ptr&lt;TrilinosWrappers::PreconditionAMG&gt; Amg_preconditioner;</div><div class="line">  std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt;  Mp_preconditioner;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> rebuild_stokes_matrix;</div><div class="line">  <span class="keywordtype">bool</span> rebuild_temperature_matrices;</div><div class="line">  <span class="keywordtype">bool</span> rebuild_stokes_preconditioner;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemclassimplementation"></a> </p><h3>BoussinesqFlowProblem class implementation</h3>
<pre class="fragment">&lt;a name="BoussinesqFlowProblemBoussinesqFlowProblem"&gt;&lt;/a&gt;  &lt;h4&gt;BoussinesqFlowProblem::BoussinesqFlowProblem&lt;/h4&gt;   
The constructor of this class is an extension of the constructor in   @ref step_22 "step-22"  . We need to add the various variables that concern the temperature. As discussed in the introduction, we are going to use \form#1094   (Taylor-Hood) elements again for the Stokes part, and \form#150   elements for the temperature. However, by using variables that store the polynomial degree of the Stokes and temperature finite elements, it is easy to consistently modify the degree of the elements as well as all quadrature formulas used on them downstream. Moreover, we initialize the time stepping as well as the options for matrix assembly and preconditioning:
</pre><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::BoussinesqFlowProblem()</div><div class="line">  : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">  , global_Omega_diameter(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">  , stokes_degree(1)</div><div class="line">  , stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree), 1)</div><div class="line">  , stokes_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  temperature_degree(2)</div><div class="line">  , temperature_fe(temperature_degree)</div><div class="line">  , temperature_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  time_step(0)</div><div class="line">  , old_time_step(0)</div><div class="line">  , timestep_number(0)</div><div class="line">  , rebuild_stokes_matrix(true)</div><div class="line">  , rebuild_temperature_matrices(true)</div><div class="line">  , rebuild_stokes_preconditioner(true)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemget_maximal_velocity"></a> </p><h4>BoussinesqFlowProblem::get_maximal_velocity</h4>
<p>Starting the real functionality of this class is a helper function that determines the maximum ( \(L_\infty\) ) velocity in the domain (at the quadrature points, in fact). How it works should be relatively obvious to all who have gotten to this point of the tutorial. Note that since we are only interested in the velocity, rather than using <code>stokes_fe_values.get_function_values</code> to get the values of the entire Stokes solution (velocities and pressures) we use <code>stokes_fe_values[velocities].get_function_values</code> to extract only the velocities part. This has the additional benefit that we get it as a <a class="el" href="classTensor.html">Tensor&lt;1,dim&gt;</a>, rather than some components in a <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>, allowing us to process it right away using the <code><a class="el" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm()</a></code> function to get the magnitude of the velocity. The only point worth thinking about a bit is how to choose the quadrature points we use here. Since the goal of this function is to find the maximal velocity over a domain by looking at quadrature points on each cell. So we should ask how we should best choose these quadrature points on each cell. To this end, recall that if we had a single \(Q_1\) field (rather than the vector-valued field of higher order) then the maximum would be attained at a vertex of the mesh. In other words, we should use the <a class="el" href="classQTrapezoid.html">QTrapezoid</a> class that has quadrature points only at the vertices of cells. For higher order shape functions, the situation is more complicated: the maxima and minima may be attained at points between the support points of shape functions (for the usual \(Q_p\) elements the support points are the equidistant Lagrange interpolation points); furthermore, since we are looking for the maximum magnitude of a vector-valued quantity, we can even less say with certainty where the set of potential maximal points are. Nevertheless, intuitively if not provably, the Lagrange interpolation points appear to be a better choice than the Gauss points. There are now different methods to produce a quadrature formula with quadrature points equal to the interpolation points of the finite element. One option would be to use the <a class="el" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">FiniteElement::get_unit_support_points()</a> function, reduce the output to a unique set of points to avoid duplicate function evaluations, and create a <a class="el" href="classQuadrature.html">Quadrature</a> object using these points. Another option, chosen here, is to use the <a class="el" href="classQTrapezoid.html">QTrapezoid</a> class and combine it with the <a class="el" href="classQIterated.html">QIterated</a> class that repeats the <a class="el" href="classQTrapezoid.html">QTrapezoid</a> formula on a number of sub-cells in each coordinate direction. To cover all support points, we need to iterate it <code>stokes_degree+1</code> times since this is the polynomial degree of the Stokes element in use:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(), stokes_degree + 1);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(stokes_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points);</div><div class="line">  <span class="keywordtype">double</span>                      max_velocity = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(stokes_solution,</div><div class="line">                                                velocity_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity, velocity_values[q].<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> max_velocity;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemget_extrapolated_temperature_range"></a> </p><h4>BoussinesqFlowProblem::get_extrapolated_temperature_range</h4>
<p>Next a function that determines the minimum and maximum temperature at quadrature points inside \(\Omega\) when extrapolated from the two previous time steps to the current one. We need this information in the computation of the artificial viscosity parameter \(\nu\) as discussed in the introduction. The formula for the extrapolated temperature is \(\left(1+\frac{k_n}{k_{n-1}} \right)T^{n-1} + \frac{k_n}{k_{n-1}} T^{n-2}\) . The way to compute it is to loop over all quadrature points and update the maximum and minimum value if the current value is bigger/smaller than the previous one. We initialize the variables that store the max and min before the loop over all quadrature points by the smallest and the largest number representable as a double. Then we know for a fact that it is larger/smaller than the minimum/maximum and that the loop over all quadrature points is ultimately going to update the initial value with the correct one. The only other complication worth mentioning here is that in the first time step, \(T^{k-2}\) is not yet available of course. In that case, we can only use \(T^{k-1}\) which we have from the initial temperature. As quadrature points, we use the same choice as in the previous function though with the difference that now the number of repetitions is determined by the polynomial degree of the temperature field.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   std::pair&lt;double, double&gt;</div><div class="line">   BoussinesqFlowProblem&lt;dim&gt;::get_extrapolated_temperature_range()<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                             temperature_degree);</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line">  </div><div class="line">     <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(temperature_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">     std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">     std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div><div class="line">  </div><div class="line">     <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">       {</div><div class="line">         <span class="keywordtype">double</span> min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">                max_temperature =</div><div class="line">  </div><div class="line">-<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line">  </div><div class="line">         <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">           {</div><div class="line">             fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">             fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                           old_temperature_values);</div><div class="line">             fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_temperature_solution,</div><div class="line">                                           old_old_temperature_values);</div><div class="line">  </div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">               {</div><div class="line">                 <span class="keyword">const</span> <span class="keywordtype">double</span> temperature =</div><div class="line">                   (1. + time_step / old_time_step) old_temperature_values[q]</div><div class="line">  </div><div class="line">-</div><div class="line">                   time_step / old_time_step old_old_temperature_values[q];</div><div class="line">  </div><div class="line">                 min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_temperature, temperature);</div><div class="line">                 max_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_temperature, temperature);</div><div class="line">               }</div><div class="line">           }</div><div class="line">  </div><div class="line">         <span class="keywordflow">return</span> std::make_pair(min_temperature, max_temperature);</div><div class="line">       }</div><div class="line">     <span class="keywordflow">else</span></div><div class="line">       {</div><div class="line">         <span class="keywordtype">double</span> min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">                max_temperature =</div><div class="line">  </div><div class="line">-<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line">  </div><div class="line">         <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">           {</div><div class="line">             fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">             fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                           old_temperature_values);</div><div class="line">  </div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">               {</div><div class="line">                 <span class="keyword">const</span> <span class="keywordtype">double</span> temperature = old_temperature_values[q];</div><div class="line">  </div><div class="line">                 min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_temperature, temperature);</div><div class="line">                 max_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_temperature, temperature);</div><div class="line">               }</div><div class="line">           }</div><div class="line">  </div><div class="line">         <span class="keywordflow">return</span> std::make_pair(min_temperature, max_temperature);</div><div class="line">       }</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemcompute_viscosity"></a> </p><h4>BoussinesqFlowProblem::compute_viscosity</h4>
<p>The last of the tool functions computes the artificial viscosity parameter \(\nu|_K\) on a cell \(K\) as a function of the extrapolated temperature, its gradient and Hessian (second derivatives), the velocity, the right hand side \(\gamma\) all on the quadrature points of the current cell, and various other parameters as described in detail in the introduction. There are some universal constants worth mentioning here. First, we need to fix \(\beta\) ; we choose \(\beta=0.017\cdot dim\) , a choice discussed in detail in the results section of this tutorial program. The second is the exponent \(\alpha\) ; \(\alpha=1\) appears to work fine for the current program, even though some additional benefit might be expected from choosing \(\alpha = 2\) . Finally, there is one thing that requires special casing: In the first time step, the velocity equals zero, and the formula for \(\nu|_K\) is not defined. In that case, we return \(\nu|_K=5\cdot 10^3 \cdot h_K\) , a choice admittedly more motivated by heuristics than anything else (it is in the same order of magnitude, however, as the value returned for most cells on the second time step). The rest of the function should be mostly obvious based on the material discussed in the introduction:</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::compute_viscosity(</div><div class="line">     <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div><div class="line">     <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div><div class="line">     <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div><div class="line">     <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div><div class="line">     <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div><div class="line">     <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div><div class="line">     <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div><div class="line">     <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div><div class="line">     <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        gamma_values,</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_u_infty,</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_T_variation,</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword">   </span>{</div><div class="line">     constexpr <span class="keywordtype">double</span> beta  = 0.017 dim;</div><div class="line">     constexpr <span class="keywordtype">double</span> alpha = 1.0;</div><div class="line">  </div><div class="line">     <span class="keywordflow">if</span> (global_u_infty == 0)</div><div class="line">       <span class="keywordflow">return</span> 5e-3 cell_diameter;</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_temperature.size();</div><div class="line">  </div><div class="line">     <span class="keywordtype">double</span> max_residual = 0;</div><div class="line">     <span class="keywordtype">double</span> max_velocity = 0;</div><div class="line">  </div><div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">       {</div><div class="line">         <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u =</div><div class="line">           (old_velocity_values[q] + old_old_velocity_values[q]) / 2;</div><div class="line">  </div><div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span> dT_dt =</div><div class="line">           (old_temperature[q]</div><div class="line">  </div><div class="line">- old_old_temperature[q]) / old_time_step;</div><div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_T =</div><div class="line">           u (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2;</div><div class="line">  </div><div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span> kappa_Delta_T =</div><div class="line">           EquationData::kappa</div><div class="line">           (old_temperature_laplacians[q] + old_old_temperature_laplacians[q]) /</div><div class="line">           2;</div><div class="line">  </div><div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span> residual =</div><div class="line">           <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>((dT_dt + u_grad_T</div><div class="line">  </div><div class="line">- kappa_Delta_T</div><div class="line">  </div><div class="line">- gamma_values[q])</div><div class="line">                    std::pow((old_temperature[q] + old_old_temperature[q]) / 2,</div><div class="line">                             alpha</div><div class="line">  </div><div class="line">- 1.));</div><div class="line">  </div><div class="line">         max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div><div class="line">         max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u u), max_velocity);</div><div class="line">       }</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> c_R            = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2., (4.</div><div class="line">  </div><div class="line">- 2 alpha) / dim);</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">double</span> global_scaling = c_R global_u_infty global_T_variation</div><div class="line">                                   <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(global_Omega_diameter, alpha</div><div class="line">  </div><div class="line">- 2.);</div><div class="line">  </div><div class="line">     <span class="keywordflow">return</span> (</div><div class="line">       beta max_velocity</div><div class="line">       <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(cell_diameter,</div><div class="line">                std::pow(cell_diameter, alpha) max_residual / global_scaling));</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemsetup_dofs"></a> </p><h4>BoussinesqFlowProblem::setup_dofs</h4>
<p>This is the function that sets up the <a class="el" href="classDoFHandler.html">DoFHandler</a> objects we have here (one for the Stokes part and one for the temperature part) as well as set to the right sizes the various objects required for the linear algebra in this program. Its basic operations are similar to what we do in <a class="el" href="step_22.html">step-22</a> . The body of the function first enumerates all degrees of freedom for the Stokes and temperature systems. For the Stokes part, degrees of freedom are then sorted to ensure that velocities precede pressure DoFs so that we can partition the Stokes matrix into a \(2\times 2\) matrix. As a difference to <a class="el" href="step_22.html">step-22</a> , we do not perform any additional DoF renumbering. In that program, it paid off since our solver was heavily dependent on ILU's, whereas we use AMG here which is not sensitive to the DoF numbering. The IC preconditioner for the inversion of the pressure mass matrix would of course take advantage of a Cuthill-McKee like renumbering, but its costs are low compared to the velocity portion, so the additional work does not pay off. We then proceed with the generation of the hanging node constraints that arise from adaptive grid refinement for both <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. For the velocity, we impose no-flux boundary conditions \(\mathbf{u}\cdot \mathbf{n}=0\) by adding constraints to the object that already stores the hanging node constraints matrix. The second parameter in the function describes the first of the velocity components in the total dof vector, which is zero here. The variable <code>no_normal_flux_boundaries</code> denotes the boundary indicators for which to set the no flux boundary conditions; here, this is boundary indicator zero. After having done so, we count the number of degrees of freedom in the various blocks:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; stokes_sub_blocks(dim + 1, 0);</div><div class="line">  stokes_sub_blocks[dim] = 1;</div><div class="line"></div><div class="line">  {</div><div class="line">    stokes_dof_handler.distribute_dofs(stokes_fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">    stokes_constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(stokes_dof_handler,</div><div class="line">                                            stokes_constraints);</div><div class="line">    std::set&lt;types::boundary_id&gt; no_normal_flux_boundaries;</div><div class="line">    no_normal_flux_boundaries.insert(0);</div><div class="line">    <a class="code" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a>(stokes_dof_handler,</div><div class="line">                                                    0,</div><div class="line">                                                    no_normal_flux_boundaries,</div><div class="line">                                                    stokes_constraints);</div><div class="line">    stokes_constraints.close();</div><div class="line">  }</div><div class="line">  {</div><div class="line">    temperature_dof_handler.distribute_dofs(temperature_fe);</div><div class="line"></div><div class="line">    temperature_constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(temperature_dof_handler,</div><div class="line">                                            temperature_constraints);</div><div class="line">    temperature_constraints.close();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; stokes_dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = stokes_dofs_per_block[0],</div><div class="line">                     n_p = stokes_dofs_per_block[1],</div><div class="line">                     n_T = temperature_dof_handler.n_dofs();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_T &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">            &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_T &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div></div><!-- fragment --><p>The next step is to create the sparsity pattern for the Stokes and temperature system matrices as well as the preconditioner matrix from which we build the Stokes preconditioner. As in <a class="el" href="step_22.html">step-22</a> , we choose to create the pattern by using the blocked version of <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>. So, we first release the memory stored in the matrices, then set up an object of type <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> consisting of \(2\times 2\) blocks (for the Stokes system matrix and preconditioner) or <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> (for the temperature part). We then fill these objects with the nonzero pattern, taking into account that for the Stokes system matrix, there are no entries in the pressure-pressure block (but all velocity vector components couple with each other and with the pressure). Similarly, in the Stokes preconditioner matrix, only the diagonal blocks are nonzero, since we use the vector Laplacian as discussed in the introduction. This operator only couples each vector component of the Laplacian with itself, but not with the other vector components. (Application of the constraints resulting from the no-flux boundary conditions will couple vector components at the boundary again, however.) When generating the sparsity pattern, we directly apply the constraints from hanging nodes and no-flux boundary conditions. This approach was already used in <a class="el" href="step_27.html">step-27</a> , but is different from the one in early tutorial programs where we first built the original sparsity pattern and only then added the entries resulting from constraints. The reason for doing so is that later during assembly we are going to distribute the constraints immediately when transferring local to global dofs. Consequently, there will be no data written at positions of constrained degrees of freedom, so we can let the <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> function omit these entries by setting the last Boolean flag to <code>false</code> . Once the sparsity pattern is ready, we can use it to initialize the Trilinos matrices. Since the Trilinos matrices store the sparsity pattern internally, there is no need to keep the sparsity pattern around after the initialization of the matrix.</p>
<div class="fragment"><div class="line">stokes_partitioning.resize(2);</div><div class="line">stokes_partitioning[0] = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_u);</div><div class="line">stokes_partitioning[1] = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_p);</div><div class="line">{</div><div class="line">  stokes_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">  dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">  dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">  dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">  dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">  dsp.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">    stokes_dof_handler, coupling, dsp, stokes_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  stokes_matrix.reinit(dsp);</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  Amg_preconditioner.reset();</div><div class="line">  Mp_preconditioner.reset();</div><div class="line">  stokes_preconditioner_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">  dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">  dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">  dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">  dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">  dsp.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (c == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">    stokes_dof_handler, coupling, dsp, stokes_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  stokes_preconditioner_matrix.reinit(dsp);</div><div class="line">}</div></div><!-- fragment --><p>The creation of the temperature matrix (or, rather, matrices, since we provide a temperature mass matrix and a temperature stiffness matrix, that will be added together for time discretization) follows the generation of the Stokes matrix &ndash; except that it is much easier here since we do not need to take care of any blocks or coupling between components. Note how we initialize the three temperature matrices: We only use the sparsity pattern for reinitialization of the first matrix, whereas we use the previously generated matrix for the two remaining reinits. The reason for doing so is that reinitialization from an already generated matrix allows Trilinos to reuse the sparsity pattern instead of generating a new one for each copy. This saves both some time and memory.</p>
<div class="fragment"><div class="line">{</div><div class="line">  temperature_mass_matrix.clear();</div><div class="line">  temperature_stiffness_matrix.clear();</div><div class="line">  temperature_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_T, n_T);</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(temperature_dof_handler,</div><div class="line">                                  dsp,</div><div class="line">                                  temperature_constraints,</div><div class="line">                                  <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  temperature_matrix.reinit(dsp);</div><div class="line">  temperature_mass_matrix.reinit(temperature_matrix);</div><div class="line">  temperature_stiffness_matrix.reinit(temperature_matrix);</div><div class="line">}</div></div><!-- fragment --><p>Lastly, we set the vectors for the Stokes solutions \(\mathbf u^{n-1}\) and \(\mathbf u^{n-2}\) , as well as for the temperatures \(T^{n}\) , \(T^{n-1}\) and \(T^{n-2}\) (required for time stepping) and all the system right hand sides to their correct sizes and block structure:</p>
<div class="fragment"><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> temperature_partitioning = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_T);</div><div class="line">  stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line">  stokes_rhs.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_old_temperature_solution.reinit(temperature_partitioning,</div><div class="line">                                      MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  temperature_rhs.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemassemble_stokes_preconditioner"></a> </p><h4>BoussinesqFlowProblem::assemble_stokes_preconditioner</h4>
<p>This function assembles the matrix we use for preconditioning the Stokes system. What we need are a vector Laplace matrix on the velocity components and a mass matrix weighted by \(\eta^{-1}\) on the pressure component. We start by generating a quadrature object of appropriate order, the <a class="el" href="classFEValues.html">FEValues</a> object that can give values and gradients at the quadrature points (together with quadrature weights). Next we create data structures for the cell matrix and the relation between local and global DoFs. The vectors <code>grad_phi_u</code> and <code>phi_p</code> are going to hold the values of the basis functions in order to faster build up the local matrices, as was already done in <a class="el" href="step_22.html">step-22</a> . Before we start the loop over all active cells, we have to specify which components are pressure and which are velocity.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_preconditioner()</div><div class="line">{</div><div class="line">  stokes_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(stokes_degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(stokes_fe,</div><div class="line">                                 quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt;&gt; grad_phi_u(dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt;         phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      stokes_fe_values.reinit(cell);</div><div class="line">      local_matrix = 0;</div></div><!-- fragment --><p>The creation of the local matrix is rather simple. There are only a Laplace term (on the velocity) and a mass matrix weighted by \(\eta^{-1}\) to be generated, so the creation of the local matrix is done in two lines. Once the local matrix is ready (loop over rows and columns in the local matrix on each quadrature point), we get the local DoF indices and write the local information into the global matrix. We do this as in <a class="el" href="step_27.html">step-27</a> , i.e., we directly apply the constraints from hanging nodes locally. By doing so, we don't have to do that afterwards, and we don't also write into entries of the matrix that will actually be set to zero again later when eliminating constraints.</p>
<div class="fragment"><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              grad_phi_u[k] = stokes_fe_values[velocities].gradient(k, q);</div><div class="line">              phi_p[k]      = stokes_fe_values[pressure].value(k, q);</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              local_matrix(i, j) +=</div><div class="line">                (EquationData::eta</div><div class="line">                   <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[i], grad_phi_u[j]) +</div><div class="line">                 (1. / EquationData::eta) phi_p[i] phi_p[j])</div><div class="line">                stokes_fe_values.JxW(q);</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      stokes_constraints.distribute_local_to_global(</div><div class="line">        local_matrix, local_dof_indices, stokes_preconditioner_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblembuild_stokes_preconditioner"></a> </p><h4>BoussinesqFlowProblem::build_stokes_preconditioner</h4>
<p>This function generates the inner preconditioners that are going to be used for the Schur complement block preconditioner. Since the preconditioners need only to be regenerated when the matrices change, this function does not have to do anything in case the matrices have not changed (i.e., the flag <code>rebuild_stokes_preconditioner</code> has the value <code>false</code> ). Otherwise its first task is to call <code>assemble_stokes_preconditioner</code> to generate the preconditioner matrices. Next, we set up the preconditioner for the velocity-velocity matrix \(A\) . As explained in the introduction, we are going to use an AMG preconditioner based on a vector Laplace matrix \(\hat{A}\) (which is spectrally close to the Stokes matrix \(A\) ). Usually, the <a class="el" href="classTrilinosWrappers_1_1PreconditionAMG.html">TrilinosWrappers::PreconditionAMG</a> class can be seen as a good black-box preconditioner which does not need any special knowledge. In this case, however, we have to be careful: since we build an AMG for a vector problem, we have to tell the preconditioner setup which dofs belong to which vector component. We do this using the function <a class="el" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>, a function that generates a set of <code>dim</code> vectors, where each one has ones in the respective component of the vector problem and zeros elsewhere. Hence, these are the constant modes on each component, which explains the name of the variable.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::build_stokes_preconditioner()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_preconditioner == <span class="keyword">false</span>)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding Stokes preconditioner...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  assemble_stokes_preconditioner();</div><div class="line"></div><div class="line">  Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionAMG&gt;();</div><div class="line"></div><div class="line">  std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocity_components(0);</div><div class="line">  <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(stokes_dof_handler,</div><div class="line">                                   stokes_fe.component_mask(</div><div class="line">                                     velocity_components),</div><div class="line">                                   constant_modes);</div><div class="line">  <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> amg_data;</div><div class="line">  amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a> = constant_modes;</div></div><!-- fragment --><p>Next, we set some more options of the AMG preconditioner. In particular, we need to tell the AMG setup that we use quadratic basis functions for the velocity matrix (this implies more nonzero elements in the matrix, so that a more robust algorithm needs to be chosen internally). Moreover, we want to be able to control how the coarsening structure is build up. The way the Trilinos smoothed aggregation AMG does this is to look which matrix entries are of similar size as the diagonal entry in order to algebraically build a coarse-grid structure. By setting the parameter <code>aggregation_threshold</code> to 0.02, we specify that all entries that are more than two percent of size of some diagonal pivots in that row should form one coarse grid point. This parameter is rather ad hoc, and some fine-tuning of it can influence the performance of the preconditioner. As a rule of thumb, larger values of <code>aggregation_threshold</code> will decrease the number of iterations, but increase the costs per iteration. A look at the Trilinos documentation will provide more information on these parameters. With this data set, we then initialize the preconditioner with the matrix we want it to apply to. Finally, we also initialize the preconditioner for the inversion of the pressure mass matrix. This matrix is symmetric and well-behaved, so we can chose a simple preconditioner. We stick with an incomplete Cholesky (IC) factorization preconditioner, which is designed for symmetric matrices. We could have also chosen an SSOR preconditioner with relaxation factor around 1.2, but IC is cheaper for our example. We wrap the preconditioners into a <code>std::shared_ptr</code> pointer, which makes it easier to recreate the preconditioner next time around since we do not have to care about destroying the previously used object.</p>
<div class="fragment"><div class="line">  amg_data.elliptic              = <span class="keyword">true</span>;</div><div class="line">  amg_data.higher_order_elements = <span class="keyword">true</span>;</div><div class="line">  amg_data.smoother_sweeps       = 2;</div><div class="line">  amg_data.aggregation_threshold = 0.02;</div><div class="line">  Amg_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(0, 0),</div><div class="line">                                 amg_data);</div><div class="line"></div><div class="line">  Mp_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">  Mp_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(1, 1));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  rebuild_stokes_preconditioner = <span class="keyword">false</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemassemble_stokes_system"></a> </p><h4>BoussinesqFlowProblem::assemble_stokes_system</h4>
<p>The time lag scheme we use for advancing the coupled Stokes-temperature system forces us to split up the assembly (and the solution of linear systems) into two step. The first one is to create the Stokes system matrix and right hand side, and the second is to create matrix and right hand sides for the temperature dofs, which depends on the result of the linear system for the velocity. This function is called at the beginning of each time step. In the first time step or if the mesh has changed, indicated by the <code>rebuild_stokes_matrix</code> , we need to assemble the Stokes matrix; on the other hand, if the mesh hasn't changed and the matrix is already available, this is not necessary and all we need to do is assemble the right hand side vector which changes in each time step. Regarding the technical details of implementation, not much has changed from <a class="el" href="step_22.html">step-22</a> . We reset matrix and vector, create a quadrature formula on the cells, and then create the respective <a class="el" href="classFEValues.html">FEValues</a> object. For the update flags, we require basis function derivatives only in case of a full assembly, since they are not needed for the right hand side; as always, choosing the minimal set of flags depending on what is currently needed makes the call to <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit</a> further down in the program more efficient. There is one thing that needs to be commented &ndash; since we have a separate finite element and <a class="el" href="classDoFHandler.html">DoFHandler</a> for the temperature, we need to generate a second <a class="el" href="classFEValues.html">FEValues</a> object for the proper evaluation of the temperature solution. This isn't too complicated to realize here: just use the temperature structures and set an update flag for the basis function values which we need for evaluation of the temperature solution. The only important part to remember here is that the same quadrature formula is used for both <a class="el" href="classFEValues.html">FEValues</a> objects to ensure that we get matching information when we loop over the quadrature points of the two objects. The declarations proceed with some shortcuts for array sizes, the creation of the local matrix and right hand side as well as the vector for the indices of the local dofs compared to the global system.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_system()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">    stokes_matrix = 0;</div><div class="line"></div><div class="line">  stokes_rhs = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(stokes_degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(</div><div class="line">    stokes_fe,</div><div class="line">    quadrature_formula,</div><div class="line">    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">      (rebuild_stokes_matrix == <span class="keyword">true</span> ? <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> : <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(0)));</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values(temperature_fe,</div><div class="line">                                      quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div></div><!-- fragment --><p>Next we need a vector that will contain the values of the temperature solution at the previous time level at the quadrature points to assemble the source term in the right hand side of the momentum equation. Let's call this vector <code>old_solution_values</code> . The set of vectors we create next hold the evaluations of the basis functions as well as their gradients and symmetrized gradients that will be used for creating the matrices. Putting these into their own arrays rather than asking the <a class="el" href="classFEValues.html">FEValues</a> object for this information each time it is needed is an optimization to accelerate the assembly process, see <a class="el" href="step_22.html">step-22</a> for details. The last two declarations are used to extract the individual blocks (velocity, pressure, temperature) from the total FE system.</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt;          phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; grads_phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;                  div_phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;                  phi_p(dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div></div><!-- fragment --><p>Now start the loop over all cells in the problem. We are working on two different DoFHandlers for this assembly routine, so we must have two different cell iterators for the two objects in use. This might seem a bit peculiar, since both the Stokes system and the temperature system use the same grid, but that's the only way to keep degrees of freedom in sync. The first statements within the loop are again all very familiar, doing the update of the finite element data as specified by the update flags, zeroing out the local arrays and getting the values of the old solution at the quadrature points. Then we are ready to loop over the quadrature points on the cell.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>       cell             = stokes_dof_handler.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> endc             = stokes_dof_handler.end();</div><div class="line"><span class="keyword">auto</span>       temperature_cell = temperature_dof_handler.begin_active();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell != endc; ++cell, ++temperature_cell)</div><div class="line">  {</div><div class="line">    stokes_fe_values.reinit(cell);</div><div class="line">    temperature_fe_values.reinit(temperature_cell);</div><div class="line"></div><div class="line">    local_matrix = 0;</div><div class="line">    local_rhs    = 0;</div><div class="line"></div><div class="line">    temperature_fe_values.get_function_values(old_temperature_solution,</div><div class="line">                                              old_temperature_values);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> old_temperature = old_temperature_values[q];</div></div><!-- fragment --><p>Next we extract the values and gradients of basis functions relevant to the terms in the inner products. As shown in <a class="el" href="step_22.html">step-22</a> this helps accelerate assembly. Once this is done, we start the loop over the rows and columns of the local matrix and feed the matrix with the relevant products. The right hand side is filled with the forcing term driven by temperature in direction of gravity (which is vertical in our example). Note that the right hand side term is always generated, whereas the matrix contributions are only updated when it is requested by the <code>rebuild_matrices</code> flag.</p>
<div class="fragment"><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">               {</div><div class="line">                 phi_u[k] = stokes_fe_values[velocities].value(k, q);</div><div class="line">                 <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">                   {</div><div class="line">                     grads_phi_u[k] =</div><div class="line">                       stokes_fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">                     div_phi_u[k] =</div><div class="line">                       stokes_fe_values[velocities].divergence(k, q);</div><div class="line">                     phi_p[k] = stokes_fe_values[pressure].value(k, q);</div><div class="line">                   }</div><div class="line">               }</div><div class="line">  </div><div class="line">             <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">               <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                   local_matrix(i, j) +=</div><div class="line">                     (EquationData::eta 2 (grads_phi_u[i] grads_phi_u[j])</div><div class="line">  </div><div class="line">-</div><div class="line">                      div_phi_u[i] phi_p[j]</div><div class="line">  </div><div class="line">- phi_p[i] div_phi_u[j])</div><div class="line">                     stokes_fe_values.JxW(q);</div><div class="line">  </div><div class="line">             <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> gravity =</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-((dim == 2) ? (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 1)) : (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0, 1)));</div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">               local_rhs(i) += (-EquationData::density EquationData::beta</div><div class="line">                                gravity phi_u[i] old_temperature)</div><div class="line">                               stokes_fe_values.JxW(q);</div><div class="line">           }</div></div><!-- fragment --><p>The last step in the loop over all cells is to enter the local contributions into the global matrix and vector structures to the positions specified in <code>local_dof_indices</code> . Again, we let the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class do the insertion of the cell matrix elements to the global matrix, which already condenses the hanging node constraints.</p>
<div class="fragment"><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">        stokes_constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                                      local_rhs,</div><div class="line">                                                      local_dof_indices,</div><div class="line">                                                      stokes_matrix,</div><div class="line">                                                      stokes_rhs);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        stokes_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                      local_dof_indices,</div><div class="line">                                                      stokes_rhs);</div><div class="line">    }</div><div class="line"></div><div class="line">  rebuild_stokes_matrix = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemassemble_temperature_matrix"></a> </p><h4>BoussinesqFlowProblem::assemble_temperature_matrix</h4>
<p>This function assembles the matrix in the temperature equation. The temperature matrix consists of two parts, a mass matrix and the time step size times a stiffness matrix given by a Laplace term times the amount of diffusion. Since the matrix depends on the time step size (which varies from one step to another), the temperature matrix needs to be updated every time step. We could simply regenerate the matrices in every time step, but this is not really efficient since mass and Laplace matrix do only change when we change the mesh. Hence, we do this more efficiently by generating two separate matrices in this function, one for the mass matrix and one for the stiffness (diffusion) matrix. We will then sum up the matrix plus the stiffness matrix times the time step size once we know the actual time step. So the details for this first step are very simple. In case we need to rebuild the matrix (i.e., the mesh has changed), we zero the data structures, get a quadrature formula and a <a class="el" href="classFEValues.html">FEValues</a> object, and create local matrices, local dof indices and evaluation structures for the basis functions.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_matrix()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_temperature_matrices == <span class="keyword">false</span>)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  temperature_mass_matrix      = 0;</div><div class="line">  temperature_stiffness_matrix = 0;</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(temperature_degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values(temperature_fe,</div><div class="line">                                      quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = temperature_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_stiffness_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;         phi_T(dofs_per_cell);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T(dofs_per_cell);</div></div><!-- fragment --><p>Now, let's start the loop over all cells in the triangulation. We need to zero out the local matrices, update the finite element evaluations, and then loop over the rows and columns of the matrices on each quadrature point, where we then create the mass matrix and the stiffness matrix (Laplace terms times the diffusion <code>EquationData::kappa</code> . Finally, we let the constraints object insert these values into the global matrix, and directly condense the constraints into the matrix.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      local_mass_matrix      = 0;</div><div class="line">      local_stiffness_matrix = 0;</div><div class="line"></div><div class="line">      temperature_fe_values.reinit(cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);</div><div class="line">              phi_T[k]      = temperature_fe_values.shape_value(k, q);</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                local_mass_matrix(i, j) +=</div><div class="line">                  (phi_T[i] phi_T[j] temperature_fe_values.JxW(q));</div><div class="line">                local_stiffness_matrix(i, j) +=</div><div class="line">                  (EquationData::kappa grad_phi_T[i] grad_phi_T[j]</div><div class="line">                   temperature_fe_values.JxW(q));</div><div class="line">              }</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      temperature_constraints.distribute_local_to_global(</div><div class="line">        local_mass_matrix, local_dof_indices, temperature_mass_matrix);</div><div class="line">      temperature_constraints.distribute_local_to_global(</div><div class="line">        local_stiffness_matrix,</div><div class="line">        local_dof_indices,</div><div class="line">        temperature_stiffness_matrix);</div><div class="line">    }</div><div class="line"></div><div class="line">  rebuild_temperature_matrices = <span class="keyword">false</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemassemble_temperature_system"></a> </p><h4>BoussinesqFlowProblem::assemble_temperature_system</h4>
<p>This function does the second part of the assembly work on the temperature matrix, the actual addition of pressure mass and stiffness matrix (where the time step size comes into play), as well as the creation of the velocity-dependent right hand side. The declarations for the right hand side assembly in this function are pretty much the same as the ones used in the other assembly routines, except that we restrict ourselves to vectors this time. We are going to calculate residuals on the temperature system, which means that we have to evaluate second derivatives, specified by the update flag <code>update_hessians</code> . The temperature equation is coupled to the Stokes system by means of the fluid velocity. These two parts of the solution are associated with different DoFHandlers, so we again need to create a second <a class="el" href="classFEValues.html">FEValues</a> object for the evaluation of the velocity at the quadrature points.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_system(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (use_bdf2_scheme == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">      temperature_matrix=</div><div class="line">        (2 time_step + old_time_step) / (time_step + old_time_step);</div><div class="line">      temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">      temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">    }</div><div class="line"></div><div class="line">  temperature_rhs = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(temperature_degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     temperature_fe_values(temperature_fe,</div><div class="line">                                      quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(stokes_fe,</div><div class="line">                                 quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = temperature_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div></div><!-- fragment --><p>Next comes the declaration of vectors to hold the old and older solution values (as a notation for time levels \(n-1\) and \(n-2\) , respectively) and gradients at quadrature points of the current cell. We also declare an object to hold the temperature right hand side values ( <code>gamma_values</code> ), and we again use shortcuts for the temperature basis functions. Eventually, we need to find the temperature extrema and the diameter of the computational domain which will be used for the definition of the stabilization parameter (we got the maximal velocity as an input to this function).</p>
<div class="fragment"><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_velocity_values(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_velocity_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_temperature_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_old_temperature_values(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_temperature_grads(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_temperature_grads(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_temperature_laplacians(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_old_temperature_laplacians(n_q_points);</div><div class="line"></div><div class="line">EquationData::TemperatureRightHandSide&lt;dim&gt; temperature_right_hand_side;</div><div class="line">std::vector&lt;double&gt;                         gamma_values(n_q_points);</div><div class="line"></div><div class="line">std::vector&lt;double&gt;         phi_T(dofs_per_cell);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T(dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range =</div><div class="line">  get_extrapolated_temperature_range();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div></div><!-- fragment --><p>Now, let's start the loop over all cells in the triangulation. Again, we need two cell iterators that walk in parallel through the cells of the two involved <a class="el" href="classDoFHandler.html">DoFHandler</a> objects for the Stokes and temperature part. Within the loop, we first set the local rhs to zero, and then get the values and derivatives of the old solution functions at the quadrature points, since they are going to be needed for the definition of the stabilization parameters and as coefficients in the equation, respectively. Note that since the temperature has its own <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="classFEValues.html">FEValues</a> object we get the entire solution at the quadrature point (which is the scalar temperature field only anyway) whereas for the Stokes part we restrict ourselves to extracting the velocity part (and ignoring the pressure part) by using <code>stokes_fe_values[velocities].get_function_values</code> .</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>       cell        = temperature_dof_handler.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> endc        = temperature_dof_handler.end();</div><div class="line"><span class="keyword">auto</span>       stokes_cell = stokes_dof_handler.begin_active();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell != endc; ++cell, ++stokes_cell)</div><div class="line">  {</div><div class="line">    local_rhs = 0;</div><div class="line"></div><div class="line">    temperature_fe_values.reinit(cell);</div><div class="line">    stokes_fe_values.reinit(stokes_cell);</div><div class="line"></div><div class="line">    temperature_fe_values.get_function_values(old_temperature_solution,</div><div class="line">                                              old_temperature_values);</div><div class="line">    temperature_fe_values.get_function_values(old_old_temperature_solution,</div><div class="line">                                              old_old_temperature_values);</div><div class="line"></div><div class="line">    temperature_fe_values.get_function_gradients(old_temperature_solution,</div><div class="line">                                                 old_temperature_grads);</div><div class="line">    temperature_fe_values.get_function_gradients(</div><div class="line">      old_old_temperature_solution, old_old_temperature_grads);</div><div class="line"></div><div class="line">    temperature_fe_values.get_function_laplacians(</div><div class="line">      old_temperature_solution, old_temperature_laplacians);</div><div class="line">    temperature_fe_values.get_function_laplacians(</div><div class="line">      old_old_temperature_solution, old_old_temperature_laplacians);</div><div class="line"></div><div class="line">    temperature_right_hand_side.value_list(</div><div class="line">      temperature_fe_values.get_quadrature_points(), gamma_values);</div><div class="line"></div><div class="line">    stokes_fe_values[velocities].get_function_values(stokes_solution,</div><div class="line">                                                     old_velocity_values);</div><div class="line">    stokes_fe_values[velocities].get_function_values(</div><div class="line">      old_stokes_solution, old_old_velocity_values);</div></div><!-- fragment --><p>Next, we calculate the artificial viscosity for stabilization according to the discussion in the introduction using the dedicated function. With that at hand, we can get into the loop over quadrature points and local rhs vector components. The terms here are quite lengthy, but their definition follows the time-discrete system developed in the introduction of this program. The BDF-2 scheme needs one more term from the old time step (and involves more complicated factors) than the backward Euler scheme that is used for the first time step. When all this is done, we distribute the local vector into the global one (including hanging node constraints).</p>
<div class="fragment"><div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div><div class="line">           compute_viscosity(old_temperature_values,</div><div class="line">                             old_old_temperature_values,</div><div class="line">                             old_temperature_grads,</div><div class="line">                             old_old_temperature_grads,</div><div class="line">                             old_temperature_laplacians,</div><div class="line">                             old_old_temperature_laplacians,</div><div class="line">                             old_velocity_values,</div><div class="line">                             old_old_velocity_values,</div><div class="line">                             gamma_values,</div><div class="line">                             maximal_velocity,</div><div class="line">                             global_T_range.second</div><div class="line">  </div><div class="line">- global_T_range.first,</div><div class="line">                             cell-&gt;diameter());</div><div class="line">  </div><div class="line">         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">           {</div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">               {</div><div class="line">                 grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);</div><div class="line">                 phi_T[k]      = temperature_fe_values.shape_value(k, q);</div><div class="line">               }</div><div class="line">  </div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">double</span> T_term_for_rhs =</div><div class="line">               (use_bdf2_scheme ?</div><div class="line">                  (old_temperature_values[q] (1 + time_step / old_time_step)</div><div class="line">  </div><div class="line">-</div><div class="line">                   old_old_temperature_values[q] (time_step time_step) /</div><div class="line">                     (old_time_step (time_step + old_time_step))) :</div><div class="line">                  old_temperature_values[q]);</div><div class="line">  </div><div class="line">             <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ext_grad_T =</div><div class="line">               (use_bdf2_scheme ?</div><div class="line">                  (old_temperature_grads[q] (1 + time_step / old_time_step)</div><div class="line">  </div><div class="line">-</div><div class="line">                   old_old_temperature_grads[q] time_step / old_time_step) :</div><div class="line">                  old_temperature_grads[q]);</div><div class="line">  </div><div class="line">             <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> extrapolated_u =</div><div class="line">               (use_bdf2_scheme ?</div><div class="line">                  (old_velocity_values[q] (1 + time_step / old_time_step)</div><div class="line">  </div><div class="line">-</div><div class="line">                   old_old_velocity_values[q] time_step / old_time_step) :</div><div class="line">                  old_velocity_values[q]);</div><div class="line">  </div><div class="line">             <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">               local_rhs(i) +=</div><div class="line">                 (T_term_for_rhs phi_T[i]</div><div class="line">  </div><div class="line">-</div><div class="line">                  time_step extrapolated_u ext_grad_T phi_T[i]</div><div class="line">  </div><div class="line">-</div><div class="line">                  time_step nu ext_grad_T grad_phi_T[i] +</div><div class="line">                  time_step gamma_values[q] phi_T[i])</div><div class="line">                 temperature_fe_values.JxW(q);</div><div class="line">           }</div><div class="line">  </div><div class="line">         cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">         temperature_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                            local_dof_indices,</div><div class="line">                                                            temperature_rhs);</div><div class="line">       }</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemsolve"></a> </p><h4>BoussinesqFlowProblem::solve</h4>
<p>This function solves the linear systems of equations. Following the introduction, we start with the Stokes system, where we need to generate our block Schur preconditioner. Since all the relevant actions are implemented in the class <code>BlockSchurPreconditioner</code> , all we have to do is to initialize the class appropriately. What we need to pass down is an <code>InverseMatrix</code> object for the pressure mass matrix, which we set up using the respective class together with the IC preconditioner we already generated, and the AMG preconditioner for the velocity-velocity matrix. Note that both <code>Mp_preconditioner</code> and <code>Amg_preconditioner</code> are only pointers, so we use <code>*</code> to pass down the actual preconditioner objects. Once the preconditioner is ready, we create a GMRES solver for the block system. Since we are working with Trilinos data structures, we have to set the respective template argument in the solver. GMRES needs to internally store temporary vectors for each iteration (see the discussion in the results section of <a class="el" href="step_22.html">step-22</a> ) &ndash; the more vectors it can use, the better it will generally perform. To keep memory demands in check, we set the number of vectors to 100. This means that up to 100 solver iterations, every temporary vector can be stored. If the solver needs to iterate more often to get the specified tolerance, it will work on a reduced set of vectors by restarting at every 100 iterations. With this all set up, we solve the system and distribute the constraints in the Stokes system, i.e., hanging nodes and no-flux boundary condition, in order to have the appropriate solution values even at constrained dofs. Finally, we write the number of iterations to the screen.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> LinearSolvers::InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                       <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a>&gt;</div><div class="line">      mp_inverse(stokes_preconditioner_matrix.block(1, 1),</div><div class="line">                Mp_preconditioner);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">      <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">TrilinosWrappers::PreconditionAMG</a>,</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a>&gt;</div><div class="line">      preconditioner(stokes_matrix, mp_inverse,Amg_preconditioner);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(stokes_matrix.m(),</div><div class="line">                                 1e-6 stokes_rhs.l2_norm());</div><div class="line"></div><div class="line">    <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> gmres(</div><div class="line">      solver_control,</div><div class="line">      <a class="code" href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(100));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; stokes_solution.size(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (stokes_constraints.is_constrained(i))</div><div class="line">        stokes_solution(i) = 0;</div><div class="line"></div><div class="line">    gmres.solve(stokes_matrix, stokes_solution, stokes_rhs, preconditioner);</div><div class="line"></div><div class="line">    stokes_constraints.distribute(stokes_solution);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; GMRES iterations for Stokes subsystem.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div></div><!-- fragment --><p>Once we know the Stokes solution, we can determine the new time step from the maximal velocity. We have to do this to satisfy the CFL condition since convection terms are treated explicitly in the temperature equation, as discussed in the introduction. The exact form of the formula used here for the time step is discussed in the results section of this program. There is a snatch here. The formula contains a division by the maximum value of the velocity. However, at the start of the computation, we have a constant temperature field (we start with a constant temperature, and it will be nonconstant only after the first time step during which the source acts). Constant temperature means that no buoyancy acts, and so the velocity is zero. Dividing by it will not likely lead to anything good. To avoid the resulting infinite time step, we ask whether the maximal velocity is very small (in particular smaller than the values we encounter during any of the following time steps) and if so rather than dividing by zero we just divide by a small value, resulting in a large but finite time step.</p>
<div class="fragment"><div class="line">old_time_step                 = time_step;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity = get_maximal_velocity();</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (maximal_velocity &gt;= 0.01)</div><div class="line">  time_step = 1. / (1.7 dim <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. dim)) / temperature_degree</div><div class="line">              <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) /</div><div class="line">              maximal_velocity;</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  time_step = 1. / (1.7 dim <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. dim)) / temperature_degree</div><div class="line">              <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / .01;</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">temperature_solution = old_temperature_solution;</div></div><!-- fragment --><p>Next we set up the temperature system and the right hand side using the function <code>assemble_temperature_system()</code> . Knowing the matrix and right hand side of the temperature equation, we set up a preconditioner and a solver. The temperature matrix is a mass matrix (with eigenvalues around one) plus a Laplace matrix (with eigenvalues between zero and \(ch^{-2}\) ) times a small number proportional to the time step \(k_n\) . Hence, the resulting symmetric and positive definite matrix has eigenvalues in the range \([1,1+k_nh^{-2}]\) (up to constants). This matrix is only moderately ill conditioned even for small mesh sizes and we get a reasonably good preconditioner by simple means, for example with an incomplete Cholesky decomposition preconditioner (IC) as we also use for preconditioning the pressure mass matrix solver. As a solver, we choose the conjugate gradient method CG. As before, we tell the solver to use Trilinos vectors via the template argument <code><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a></code> . Finally, we solve, distribute the hanging node constraints and write out the number of iterations.</p>
<div class="fragment"><div class="line">assemble_temperature_system(maximal_velocity);</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(temperature_matrix.m(),</div><div class="line">                               1e-8 temperature_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a> preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html#a95eff1f8abcf2ba67815b6a96a66d375">initialize</a>(temperature_matrix);</div><div class="line"></div><div class="line">  cg.solve(temperature_matrix,</div><div class="line">           temperature_solution,</div><div class="line">           temperature_rhs,</div><div class="line">           preconditioner);</div><div class="line"></div><div class="line">  temperature_constraints.distribute(temperature_solution);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations for temperature.&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p>At the end of this function, we step through the vector and read out the maximum and minimum temperature value, which we also want to output. This will come in handy when determining the correct constant in the choice of time step as discuss in the results section of this program.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">double</span> min_temperature = temperature_solution(0),</div><div class="line">           max_temperature = temperature_solution(0);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; temperature_solution.size(); ++i)</div><div class="line">      {</div><div class="line">        min_temperature =</div><div class="line">          std::min&lt;double&gt;(min_temperature, temperature_solution(i));</div><div class="line">        max_temperature =</div><div class="line">          std::max&lt;double&gt;(max_temperature, temperature_solution(i));</div><div class="line">      }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Temperature range: &quot;</span> &lt;&lt; min_temperature &lt;&lt; <span class="charliteral">&#39; &#39;</span></div><div class="line">              &lt;&lt; max_temperature &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemoutput_results"></a> </p><h4>BoussinesqFlowProblem::output_results</h4>
<p>This function writes the solution to a VTK output file for visualization, which is done every tenth time step. This is usually quite a simple task, since the deal.II library provides functions that do almost all the job for us. There is one new function compared to previous examples: We want to visualize both the Stokes solution and the temperature as one data set, but we have done all the calculations based on two different <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. Luckily, the <a class="el" href="classDataOut.html">DataOut</a> class is prepared to deal with it. All we have to do is to not attach one single <a class="el" href="classDoFHandler.html">DoFHandler</a> at the beginning and then use that for all added vector, but specify the <a class="el" href="classDoFHandler.html">DoFHandler</a> to each vector separately. The rest is done as in <a class="el" href="step_22.html">step-22</a> . We create solution names (that are going to appear in the visualization program for the individual components). The first <code>dim</code> components are the vector velocity, and then we have pressure for the Stokes part, whereas temperature is scalar. This information is read out using the <a class="el" href="namespaceDataComponentInterpretation.html">DataComponentInterpretation</a> helper class. Next, we actually attach the data vectors with their <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, build patches according to the degree of freedom, which are (sub-) elements that describe the data for visualization programs. Finally, we open a file (that includes the time step number) and write the vtk data into it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (timestep_number % 10 != 0)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  std::vector&lt;std::string&gt; stokes_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  stokes_names.emplace_back(<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    stokes_component_interpretation(</div><div class="line">      dim + 1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    stokes_component_interpretation[i] =</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(stokes_dof_handler,</div><div class="line">                           stokes_solution,</div><div class="line">                           stokes_names,</div><div class="line">                           stokes_component_interpretation);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(temperature_dof_handler,</div><div class="line">                           temperature_solution,</div><div class="line">                           <span class="stringliteral">&quot;T&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(stokes_degree, temperature_degree));</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                       <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 4) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemrefine_mesh"></a> </p><h4>BoussinesqFlowProblem::refine_mesh</h4>
<p>This function takes care of the adaptive mesh refinement. The three tasks this function performs is to first find out which cells to refine/coarsen, then to actually do the refinement and eventually transfer the solution vectors between the two different grids. The first task is simply achieved by using the well-established Kelly error estimator on the temperature (it is the temperature we're mainly interested in for this program, and we need to be accurate in regions of high temperature gradients, also to not have too much numerical diffusion). The second task is to actually do the remeshing. That involves only basic functions as well, such as the <code>refine_and_coarsen_fixed_fraction</code> that refines those cells with the largest estimated error that together make up 80 per cent of the error, and coarsens those cells with the smallest error that make up for a combined 10 per cent of the error. If implemented like this, we would get a program that will not make much progress: Remember that we expect temperature fields that are nearly discontinuous (the diffusivity \(\kappa\) is very small after all) and consequently we can expect that a freely adapted mesh will refine further and further into the areas of large gradients. This decrease in mesh size will then be accompanied by a decrease in time step, requiring an exceedingly large number of time steps to solve to a given final time. It will also lead to meshes that are much better at resolving discontinuities after several mesh refinement cycles than in the beginning. In particular to prevent the decrease in time step size and the correspondingly large number of time steps, we limit the maximal refinement depth of the mesh. To this end, after the refinement indicator has been applied to the cells, we simply loop over all cells on the finest level and unselect them from refinement if they would result in too high a mesh level.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span></div><div class="line">   BoussinesqFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">   {</div><div class="line">     <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  </div><div class="line">     <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(temperature_dof_handler,</div><div class="line">                                        <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt;(temperature_degree + 1),</div><div class="line">                                        {},</div><div class="line">                                        temperature_solution,</div><div class="line">                                        estimated_error_per_cell);</div><div class="line">  </div><div class="line">     <a class="code" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a>(triangulation,</div><div class="line">                                                       estimated_error_per_cell,</div><div class="line">                                                       0.8,</div><div class="line">                                                       0.1);</div><div class="line">     <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &gt; max_grid_level)</div><div class="line">       <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell :</div><div class="line">            triangulation.<a class="code" href="group__CPP11.html#gac10cd3fe6ef8360e2599d3cff58e13e8">active_cell_iterators_on_level</a>(max_grid_level))</div><div class="line">         cell-&gt;clear_refine_flag();</div></div><!-- fragment --><p>As part of mesh refinement we need to transfer the solution vectors from the old mesh to the new one. To this end we use the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class and we have to prepare the solution vectors that should be transferred to the new grid (we will lose the old grid once we have done the refinement so the transfer has to happen concurrently with refinement). What we definitely need are the current and the old temperature (BDF-2 time stepping requires two old solutions). Since the <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> objects only support to transfer one object per dof handler, we need to collect the two temperature solutions in one data structure. Moreover, we choose to transfer the Stokes solution, too, since we need the velocity at two previous time steps, of which only one is calculated on the fly. Consequently, we initialize two <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> objects for the Stokes and temperature <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, by attaching them to the old dof handlers. With this at place, we can prepare the triangulation and the data vectors for refinement (in this order).</p>
<div class="fragment"><div class="line">std::vector&lt;TrilinosWrappers::MPI::Vector&gt; x_temperature(2);</div><div class="line">x_temperature[0]                            = temperature_solution;</div><div class="line">x_temperature[1]                            = old_temperature_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> x_stokes = stokes_solution;</div><div class="line"></div><div class="line"><a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a> temperature_trans(</div><div class="line">  temperature_dof_handler);</div><div class="line"><a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::BlockVector&gt;</a> stokes_trans(</div><div class="line">  stokes_dof_handler);</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);</div><div class="line">stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);</div></div><!-- fragment --><p>Now everything is ready, so do the refinement and recreate the dof structure on the new grid, and initialize the matrix structures and the new vectors in the <code>setup_dofs</code> function. Next, we actually perform the interpolation of the solutions between the grids. We create another copy of temporary vectors for temperature (now corresponding to the new grid), and let the interpolate function do the job. Then, the resulting array of vectors is written into the respective vector member variables. Remember that the set of constraints will be updated for the new triangulation in the setup_dofs() call.</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">setup_dofs();</div><div class="line"></div><div class="line">std::vector&lt;TrilinosWrappers::MPI::Vector&gt; tmp(2);</div><div class="line">tmp[0].reinit(temperature_solution);</div><div class="line">tmp[1].reinit(temperature_solution);</div><div class="line">temperature_trans.interpolate(x_temperature, tmp);</div><div class="line"></div><div class="line">temperature_solution     = tmp[0];</div><div class="line">old_temperature_solution = tmp[1];</div></div><!-- fragment --><p>After the solution has been transferred we then enforce the constraints on the transferred solution.</p>
<div class="fragment"><div class="line">temperature_constraints.distribute(temperature_solution);</div><div class="line">temperature_constraints.distribute(old_temperature_solution);</div></div><!-- fragment --><p>For the Stokes vector, everything is just the same &ndash; except that we do not need another temporary vector since we just interpolate a single vector. In the end, we have to tell the program that the matrices and preconditioners need to be regenerated, since the mesh has changed.</p>
<div class="fragment"><div class="line">  stokes_trans.interpolate(x_stokes, stokes_solution);</div><div class="line"></div><div class="line">  stokes_constraints.distribute(stokes_solution);</div><div class="line"></div><div class="line">  rebuild_stokes_matrix         = <span class="keyword">true</span>;</div><div class="line">  rebuild_temperature_matrices  = <span class="keyword">true</span>;</div><div class="line">  rebuild_stokes_preconditioner = <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemrun"></a> </p><h4>BoussinesqFlowProblem::run</h4>
<p>This function performs all the essential steps in the Boussinesq program. It starts by setting up a grid (depending on the spatial dimension, we choose some different level of initial refinement and additional adaptive refinement steps, and then create a cube in <code>dim</code> dimensions and set up the dofs for the first time. Since we want to start the time stepping already with an adaptively refined grid, we perform some pre-refinement steps, consisting of all assembly, solution and refinement, but without actually advancing in time. Rather, we use the vilified <code>goto</code> statement to jump out of the time loop right after mesh refinement to start all over again on the new mesh beginning at the <code>start_time_iteration</code> label. (The use of the <code>goto</code> is discussed in <a class="el" href="step_26.html">step-26</a> .) Before we start, we project the initial values to the grid and obtain the first data for the <code>old_temperature_solution</code> vector. Then, we initialize time step number and time step and start the time loop.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">BoussinesqFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement     = (dim == 2 ? 4 : 2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_pre_refinement_steps = (dim == 2 ? 4 : 3);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">  global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(triangulation);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(initial_refinement);</div><div class="line"></div><div class="line">  setup_dofs();</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"></div><div class="line">start_time_iteration:</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(temperature_dof_handler,</div><div class="line">                       temperature_constraints,</div><div class="line">                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(temperature_degree + 2),</div><div class="line">                       EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">                       old_temperature_solution);</div><div class="line"></div><div class="line">  timestep_number = 0;</div><div class="line">  time_step = old_time_step = 0;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> time = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time</div><div class="line">                &lt;&lt; std::endl;</div></div><!-- fragment --><p>The first steps in the time loop are all obvious &ndash; we assemble the Stokes system, the preconditioner, the temperature matrix (matrices and preconditioner do actually only change in case we've remeshed before), and then do the solve. Before going on with the next time step, we have to check whether we should first finish the pre-refinement steps or if we should remesh (every fifth time step), refining up to a level that is consistent with initial refinement and pre-refinement steps. Last in the loop is to advance the solutions, i.e., to copy the solutions to the next "older" time level.</p>
<div class="fragment"><div class="line">  assemble_stokes_system();</div><div class="line">  build_stokes_preconditioner();</div><div class="line">  assemble_temperature_matrix();</div><div class="line"></div><div class="line">  solve();</div><div class="line"></div><div class="line">  output_results();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">      (pre_refinement_step &lt; n_pre_refinement_steps))</div><div class="line">    {</div><div class="line">      refine_mesh(initial_refinement + n_pre_refinement_steps);</div><div class="line">      ++pre_refinement_step;</div><div class="line">      <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp; (timestep_number % 5 == 0))</div><div class="line">    refine_mesh(initial_refinement + n_pre_refinement_steps);</div><div class="line"></div><div class="line">  time += time_step;</div><div class="line">  ++timestep_number;</div><div class="line"></div><div class="line">  old_stokes_solution          = stokes_solution;</div><div class="line">  old_old_temperature_solution = old_temperature_solution;</div><div class="line">  old_temperature_solution     = temperature_solution;</div><div class="line">}</div></div><!-- fragment --><p>Do all the above until we arrive at time 100.</p>
<div class="fragment"><div class="line">    <span class="keywordflow">while</span> (time &lt;= 100);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step31</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<p>The main function looks almost the same as in all other programs.</p>
<p>There is one difference we have to be careful about. This program uses Trilinos and, typically, Trilinos is configured so that it can run in parallel using MPI. This doesn't mean that it <em>has</em> to run in parallel, and in fact this program (unlike <a class="el" href="step_32.html">step-32</a> ) makes no attempt at all to do anything in parallel using MPI. Nevertheless, Trilinos wants the MPI system to be initialized. We do that be creating an object of type <a class="el" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> that initializes MPI (if available) using the arguments given to main() (i.e., <code>argc</code> and <code>argv</code> ) and de-initializes it again when the object goes out of scope.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, charargv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step31;</div><div class="line"> </div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div></div><!-- fragment --><p>This program can only be run in serial. Otherwise, throw an exception.</p>
<div class="fragment"><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-31&quot;</span>));</div><div class="line"> </div><div class="line">      BoussinesqFlowProblem&lt;2&gt; flow_problem;</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"> </div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Resultsin2d"></a></p><h3>Results in 2d </h3>
<p>When you run the program in 2d, the output will look something likethis:<code></p><pre>Number of active cells: 256 (on 5 levels)Number of degrees of freedom: 3556 (2178+289+1089)
  Timestep 0:  t=0   Assembling...   Rebuilding Stokes preconditioner...   Solving...   0 GMRES iterations for Stokes subsystem.   Time step: 0.919118   9 CG iterations for temperature.   Temperature range:</pre><p></code></p>
<p><code></p><pre><ul>
<li>.16687 1.30011
  Number of active cells: 280 (on 6 levels)Number of degrees of freedom: 4062 (2490+327+1245)
  Timestep 0:  t=0   Assembling...   Rebuilding Stokes preconditioner...   Solving...   0 GMRES iterations for Stokes subsystem.   Time step: 0.459559   9 CG iterations for temperature.   Temperature range:</li>
</ul>
</pre><p></code></p>
<p><code></p><pre><ul>
<li>.0982971 0.598503
  Number of active cells: 520 (on 7 levels)Number of degrees of freedom: 7432 (4562+589+2281)
  Timestep 0:  t=0   Assembling...   Rebuilding Stokes preconditioner...   Solving...   0 GMRES iterations for Stokes subsystem.   Time step: 0.229779   9 CG iterations for temperature.   Temperature range:</li>
</ul>
</pre><p></code></p>
<p><code></p><pre><ul>
<li>.0551098 0.294493
  Number of active cells: 1072 (on 8 levels)Number of degrees of freedom: 15294 (9398+1197+4699)
  Timestep 0:  t=0   Assembling...   Rebuilding Stokes preconditioner...   Solving...   0 GMRES iterations for Stokes subsystem.   Time step: 0.11489   9 CG iterations for temperature.   Temperature range:</li>
</ul>
</pre><p></code></p>
<p><code></p><pre><ul>
<li>.0273524 0.156861
  Number of active cells: 2116 (on 9 levels)Number of degrees of freedom: 30114 (18518+2337+9259)
  Timestep 0:  t=0   Assembling...   Rebuilding Stokes preconditioner...   Solving...   0 GMRES iterations for Stokes subsystem.   Time step: 0.0574449   9 CG iterations for temperature.   Temperature range:</li>
</ul>
</pre><p></code></p>
<p><code></p><pre><ul>
<li>.014993 0.0738328
  Timestep 1:  t=0.0574449   Assembling...   Solving...   56 GMRES iterations for Stokes subsystem.   Time step: 0.0574449   9 CG iterations for temperature.   Temperature range:</li>
</ul>
</pre><p></code></p>
<p><code></p><pre><ul>
<li>.0273934 0.14488
  ...
  In the beginning we refine the mesh several times adaptively andalways return to time step zero to restart on the newly refinedmesh. Only then do we start the actual time iteration.
  The program runs for a while. The temperature field for time steps 0,500, 1000, 1500, 2000, 3000, 4000, and 5000 looks like this (note thatthe color scale used for the temperature is not always the same):
    <table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.00.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.01.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.02.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.03.png"/>
</div>

    
  
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.04.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.05.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.06.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.07.png"/>
</div>

    
  
</td></tr>
</table>
The visualizations shown here were generated using a version of the examplewhich did not enforce the constraints after transferring the mesh.
  As can be seen, we have three heat sources that heat fluid andtherefore produce a buoyancy effect that lets hots pockets of fluidrise up and swirl around. By a chimney effect, the three streams arepressed together by fluid that comes from the outside and wants tojoin the updraft party. Note that because the fluid is initially atrest, those parts of the fluid that were initially over the sourcesreceive a longer heating time than that fluid that is later draggedover the source by the fully developed flow field. It is thereforehotter, a fact that can be seen in the red tips of the threeplumes. Note also the relatively fine features of the flow field, aresult of the sophisticated transport stabilization of the temperatureequation we have chosen.
  In addition to the pictures above, the following ones show theadaptive mesh and the flow field at the same time steps:
    <table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.00.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.01.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.02.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.03.png"/>
</div>

    
  
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.04.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.05.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.06.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.07.png"/>
</div>

    
  
</td></tr>
</table>
</li>
</ul>
</pre><p></code></p>
<p><code></p><pre>  <a class="anchor" id="Resultsin3d"></a><h3>Results in 3d </h3>
</pre><p></code></p>
<p><code></p><pre></pre><p></code></p>
<p><code></p><pre>  The same thing can of course be done in 3d by changing the templateparameter to the BoussinesqFlowProblem object in   <code>main()</code>  from 2 to 3, so that the output now looks like follows:
  <code><pre>Number of active cells: 64 (on 3 levels)Number of degrees of freedom: 3041 (2187+125+729)
  Timestep 0:  t=0   Assembling...   Rebuilding Stokes preconditioner...   Solving...   0 GMRES iterations for Stokes subsystem.   Time step: 2.45098   9 CG iterations for temperature.   Temperature range:</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre><ul>
<li>.675683 4.94725
  Number of active cells: 288 (on 4 levels)Number of degrees of freedom: 12379 (8943+455+2981)
  Timestep 0:  t=0   Assembling...   Rebuilding Stokes preconditioner...   Solving...   0 GMRES iterations for Stokes subsystem.   Time step: 1.22549   9 CG iterations for temperature.   Temperature range:</li>
</ul>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre><ul>
<li>.527701 2.25764
  Number of active cells: 1296 (on 5 levels)Number of degrees of freedom: 51497 (37305+1757+12435)
  Timestep 0:  t=0   Assembling...   Rebuilding Stokes preconditioner...   Solving...   0 GMRES iterations for Stokes subsystem.   Time step: 0.612745   10 CG iterations for temperature.   Temperature range:</li>
</ul>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre><ul>
<li>.496942 0.847395
  Number of active cells: 5048 (on 6 levels)Number of degrees of freedom: 192425 (139569+6333+46523)
  Timestep 0:  t=0   Assembling...   Rebuilding Stokes preconditioner...   Solving...   0 GMRES iterations for Stokes subsystem.   Time step: 0.306373   10 CG iterations for temperature.   Temperature range:</li>
</ul>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre><ul>
<li>.267683 0.497739
  Timestep 1:  t=0.306373   Assembling...   Solving...   27 GMRES iterations for Stokes subsystem.   Time step: 0.306373   10 CG iterations for temperature.   Temperature range:</li>
</ul>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre><ul>
<li>.461787 0.958679
  ...
  Visualizing the temperature isocontours at time steps 0,50, 100, 150, 200, 300, 400, 500, 600, 700, and 800 yields thefollowing plots:
    <table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.00.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.01.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.02.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.03.png"/>
</div>

    
  
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.04.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.05.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.06.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.07.png"/>
</div>

    
  
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.08.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.09.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.10.png"/>
</div>

    
    </td><td></td></tr>
</table>
That the first picture looks like three hedgehogs stems from the fact that ourscheme essentially projects the source times the first time step size onto themesh to obtain the temperature field in the first time step. Since the sourcefunction is discontinuous, we need to expect over- and undershoots from thisproject. This is in fact what happens (it's easier to check this in 2d) andleads to the crumpled appearance of the isosurfaces.  The visualizations shownhere were generated using a version of the example which did not enforce theconstraints after transferring the mesh.</li>
</ul>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>  <a class="anchor" id="Numericalexperimentstodetermineoptimalparameters"></a><h3>Numerical experiments to determine optimal parameters </h3>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>  The program as is has three parameters that we don't have much of atheoretical handle on how to choose in an optimal way. These are:  <ul>
<li>
The time step must satisfy a CFL condition \(k\le \min_K \frac{c_kh_K}{\|\mathbf{u}\|_{L^\infty(K)}}\)  . Here, \(c_k\)   is      dimensionless, but what is the right value?    </li>
<li>
In the computation of the artificial viscosity, <p class="formulaDsp">
\begin{eqnarray*} \nu_\alpha(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} \min\left\{ h_K, h_K^\alpha \frac{\|R_\alpha(T)\|_{L^\infty(K)}}{c(\mathbf{u},T)} \right\}, \end{eqnarray*}
</p>

        with \(c(\mathbf{u},T) = c_R\ \|\mathbf{u}\|_{L^\infty(\Omega)} \ \mathrm{var}(T) \ |\mathrm{diam}(\Omega)|^{\alpha-2}\)  .      Here, the choice of the dimensionless numbers \(\beta,c_R\)   is of      interest.  </li>
</ul>
In all of these cases, we will have to expect that the correct choice of eachvalue depends on that of the others, and most likely also on the spacedimension and polynomial degree of the finite element used for thetemperature. Below we'll discuss a few numerical experiments to chooseconstants \(c_k\)   and \(\beta\)  .
  Below, we will not discuss the choice of \(c_R\)  . In the program, we setit to \(c_R=2^{\frac{4-2\alpha}{d}}\)  . The reason for this value is abit complicated and has more to do with the history of the programthan reasoning: while the correct formula for the global scalingparameter \(c(\mathbf{u},T)\)   is shown above, the program (including theversion shipped with deal.II 6.2) initially had a bug in that wecomputed \(c(\mathbf{u},T) = \|\mathbf{u}\|_{L^\infty(\Omega)} \ \mathrm{var}(T) \ \frac{1}{|\mathrm{diam}(\Omega)|^{\alpha-2}}\)   instead, wherewe had set the scaling parameter to one. Since we only computed on theunit square/cube where \(\mathrm{diam}(\Omega)=2^{1/d}\)  , this wasentirely equivalent to using the correct formula with \(c_R=\left(2^{1/d}\right)^{4-2\alpha}=2^{\frac{4-2\alpha}{d}}\)  . Sincethis value for \(c_R\)   appears to work just fine for the currentprogram, we corrected the formula in the program and set \(c_R\)   to avalue that reproduces exactly the results we had before. We will,however, revisit this issue again in   <a class="el" href="step_32.html">step-32</a>  .
  Now, however, back to the discussion of what values of \(c_k\)   and \(\beta\)   to choose:</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>  <a class="anchor" id="Choosingicsubksubiandbeta"></a><h4>Choosing <em>c<sub>k</sub></em><em>c<sub>k</sub></em> and beta </h4>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>  These two constants are definitely linked in some way. The reason is easy tosee: In the case of a pure advection problem, \(\frac{\partial T}{\partial t} + \mathbf{u}\cdot\nabla T = \gamma\)  , anyexplicit scheme has to satisfy a CFL condition of the form \(k\le \min_K \frac{c_k^a h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\)  . On the other hand,for a pure diffusion problem, \(\frac{\partial T}{\partial t} + \nu \Delta T = \gamma\)  ,explicit schemes need to satisfy a condition \(k\le \min_K \frac{c_k^d h_K^2}{\nu}\)  . So given the form of \(\nu\)   above, anadvection diffusion problem like the one we have to solve here will result ina condition of the form \( k\le \min_K \min \left\{ \frac{c_k^a h_K}{\|\mathbf{u}\|_{L^\infty(K)}}, \frac{c_k^d h_K^2}{\beta \|\mathbf{u}\|_{L^\infty(K)} h_K}\right\} = \min_K \left( \min \left\{ c_k^a, \frac{c_k^d}{\beta}\right\} \frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}} \right) \)  .It follows that we have to face the fact that we might want to choose \(\beta\)  larger to improve the stability of the numerical scheme (by increasing theamount of artificial diffusion), but we have to pay a price in the form ofsmaller, and consequently more time steps. In practice, one would thereforelike to choose \(\beta\)   as small as possible to keep the transport problemsufficiently stabilized while at the same time trying to choose the time stepas large as possible to reduce the overall amount of work.
  The find the right balance, the only way is to do a few computationalexperiments. Here's what we did: We modified the program slightly to allowless mesh refinement (so we don't always have to wait that long) and to choose \( \nu(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} h_K \)   to eliminate the effect of the constant \(c_R\)   (we know thatsolutions are stable by using this version of \(\nu(T)\)   as an artificialviscosity, but that we can improve things</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre><ul>
<li>i.e. make the solutionsharper</li>
<li>by using the more complicated formula for this artificialviscosity). We then run the programfor different values \(c_k,\beta\)   and observe maximal and minimal temperaturesin the domain. What we expect to see is this: If we choose the time step toobig (i.e. choose a \(c_k\)   bigger than theoretically allowed) then we will getexponential growth of the temperature. If we choose \(\beta\)   too small, thenthe transport stabilization becomes insufficient and the solution will showsignificant oscillations but not exponential growth.</li>
</ul>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>  <a class="anchor" id="ResultsforQsub1subelements"></a><h5>Results for Q<sub>1</sub> elements</h5>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>  Here is what we get for \(\beta=0.01, \beta=0.1\)  , and \(\beta=0.5\)  , different choices of \(c_k\)  , andbilinear elements (  <code>temperature_degree=1</code>  ) in 2d:
    <table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q1.beta=0.01.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q1.beta=0.03.png"/>
</div>

    
  
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q1.beta=0.1.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q1.beta=0.5.png"/>
</div>

    
  
</td></tr>
</table>
The way to interpret these graphs goes like this: for \(\beta=0.01\)   and \(c_k=\frac 12,\frac 14\)  , we see exponential growth or at least largevariations, but if we choose \(k=\frac 18\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\)  or smaller, then the scheme isstable though a bit wobbly. For more artificial diffusion, we can choose \(k=\frac 14\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\)  or smaller for \(\beta=0.03\)  , \(k=\frac 13\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\)  or smaller for \(\beta=0.1\)  , and again need \(k=\frac 1{15}\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\)  for \(\beta=0.5\)   (this time because much diffusion requires a small timestep).
  So how to choose? If we were simply interested in a large time step, then wewould go with \(\beta=0.1\)   and \(k=\frac 13\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\)  .On the other hand, we're also interested in accuracy and here it may be ofinterest to actually investigate what these curves show. To this end note thatwe start with a zero temperature and that our sources are positive &mdash; sowe would intuitively expect that the temperature can never drop belowzero. But it does, a consequence of Gibb's phenomenon when using continuouselements to approximate a discontinuous solution. We can therefore see thatchoosing \(\beta\)   too small is bad: too little artificial diffusion leads toover- and undershoots that aren't diffused away. On the other hand, for large \(\beta\)  , the minimum temperature drops below zero at the beginning but thenquickly diffuses back to zero.
  On the other hand, let's also look at the maximum temperature. Watching themovie of the solution, we see that initially the fluid is at rest. The sourcekeeps heating the same volume of fluid whose temperature increases linearly atthe beginning until its buoyancy is able to move it upwards. The hottest partof the fluid is therefore transported away from the solution and fluid takingits place is heated for only a short time before being moved out of the sourceregion, therefore remaining cooler than the initial bubble. If \(\kappa=0\)  (in the program it is nonzero but very small) then the hottest part of thefluid should be advected along with the flow with its temperatureconstant. That's what we can see in the graphs with the smallest \(\beta\)  : Oncethe maximum temperature is reached, it hardly changes any more. On the otherhand, the larger the artificial diffusion, the more the hot spot isdiffused. Note that for this criterion, the time step size does not play asignificant role.
  So to sum up, likely the best choice would appear to be \(\beta=0.03\)  and \(k=\frac 14\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\)  . The curve isa bit wobbly, but overall pictures looks pretty reasonable with theexception of some over and undershoots close to the start time due toGibb's phenomenon.</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>  <a class="anchor" id="ResultsforQsub2subelements"></a><h5>Results for Q<sub>2</sub> elements</h5>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>  One can repeat the same sequence of experiments for higher orderelements as well. Here are the graphs for bi-quadratic shape functions(  <code>temperature_degree=2</code>  ) for the temperature, while weretain the \(Q_2/Q_1\)   stable Taylor-Hood element for the Stokes system:
    <table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q2.beta=0.01.png"/>
</div>

    
    </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q2.beta=0.03.png"/>
</div>

    
  
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q2.beta=0.1.png"/>
</div>

    
  
</td></tr>
</table>
Again, small values of \(\beta\)   lead to less diffusion but we have tochoose the time step very small to keep things under control. Toolarge values of \(\beta\)   make for more diffusion, but again requiresmall time steps. The best value would appear to be \(\beta=0.03\)  , asfor the \(Q_1\)   element, and then we have to choose \(k=\frac 18\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\)   &mdash; exactlyhalf the size for the \(Q_1\)   element, a fact that may not be surprisingif we state the CFL condition as the requirement that the time step besmall enough so that the distance transport advects in each time stepis no longer than one <em>grid point</em> away (which for \(Q_1\)   elementsis \(h_K\)  , but for \(Q_2\)   elements is \(h_K/2\)  ). It turns out that \(\beta\)  needs to be slightly larger for obtaining stable results also late inthe simulation at times larger than 60, so we actually choose it as \(\beta = 0.034\)   in the code.</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>  <a class="anchor" id="Resultsfor3d"></a><h5>Results for 3d</h5>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>  One can repeat these experiments in 3d and find the optimal time stepfor each value of \(\beta\)   and find the best value of \(\beta\)  . What onefinds is that for the same \(\beta\)   already used in 2d, the time stepsneeds to be a bit smaller, by around a factor of 1.2 or so. This iseasily explained: the time step restriction is \(k=\min_K \frac{ch_K}{\|\mathbf{u}\|_{L^\infty(K)}}\)   where \(h_K\)   isthe <em>diameter</em> of the cell. However, what is really needed is thedistance between mesh points, which is \(\frac{h_K}{\sqrt{d}}\)  . So amore appropriate form would be \(k=\min_K \frac{ch_K}{\|\mathbf{u}\|_{L^\infty(K)}\sqrt{d}}\)  .
  The second find is that one needs to choose \(\beta\)   slightly bigger(about \(\beta=0.05\)   or so). This then again reduces the time step wecan take.</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>  <a class="anchor" id="Conclusions"></a><h5>Conclusions</h5>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>  Concluding, from the simple computations above, \(\beta=0.034\)   appears to be agood choice for the stabilization parameter in 2d, and \(\beta=0.05\)   in 3d. Ina dimension independent way, we can model this as \(\beta=0.017d\)  . If one doeslonger computations (several thousand time steps) on finer meshes, onerealizes that the time step size is not quite small enough and that forstability one will have to reduce the above values a bit more (by about afactor of \(\frac 78\)  ).
  As a consequence, a formula that reconciles 2d, 3d, and variable polynomialdegree and takes all factors in account reads as follows: <p class="formulaDsp">
\begin{eqnarray*} k = \frac 1{2 \cdot 1.7} \frac 1{\sqrt{d}} \frac 2d \frac 1{q_T} \frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}} = \frac 1{1.7 d\sqrt{d}} \frac 1{q_T} \frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}. \end{eqnarray*}
</p>

  In the first form (in the center of the equation), \(\frac 1{2 \cdot 1.7}\)   is a universal constant, \(\frac 1{\sqrt{d}}\)  is the factor that accounts for the difference between cell diameterand grid point separation, \(\frac 2d\)   accounts for the increase in \(\beta\)   with space dimension, \(\frac 1{q_T}\)   accounts for the distance between grid points forhigher order elements, and \(\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\)  for the local speed of transport relative to the cell size. This isthe formula that we use in the program.
  As for the question of whether to use \(Q_1\)   or \(Q_2\)   elements for thetemperature, the following considerations may be useful: First,solving the temperature equation is hardly a factor in the overallscheme since almost the entire compute time goes into solving theStokes system in each time step. Higher order elements for thetemperature equation are therefore not a significant drawback. On theother hand, if one compares the size of the over- and undershoots thesolution produces due to the discontinuous source description, onenotices that for the choice of \(\beta\)   and \(k\)   as above, the \(Q_1\)  solution dips down to around \(-0.47\)  , whereas the \(Q_2\)   solution onlygoes to \(-0.13\)   (remember that the exact solution should never becomenegative at all. This means that the \(Q_2\)   solution is significantlymore accurate; the program therefore uses these higher order elements,despite the penalty we pay in terms of smaller time steps.</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>  <a class="anchor" id="Possibilitiesforextensions"></a><h3>Possibilities for extensions </h3>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>  There are various ways to extend the current program. Of particular interestis, of course, to make it faster and/or increase the resolution of theprogram, in particular in 3d. This is the topic of the   <a class="el" href="step_32.html">step-32</a>  tutorial program which will implement strategies to solve this problem inparallel on a cluster. It is also the basis of the much larger opensource code ASPECT (see <a href="https://aspect.geodynamics.org/">https://aspect.geodynamics.org/</a> ) that can solve realisticproblems and that constitutes the further development of   <a class="el" href="step_32.html">step-32</a>  .
  Another direction would be to make the fluid flow more realistic. The programwas initially written to simulate various cases simulating the convection ofmaterial in the earth's mantle, i.e. the zone between the outer earth core andthe solid earth crust: there, material is heated from below and cooled fromabove, leading to thermal convection. The physics of this fluid are much morecomplicated than shown in this program, however: The viscosity of mantlematerial is strongly dependent on the temperature, i.e. \(\eta=\eta(T)\)  , withthe dependency frequently modeled as a viscosity that is reduced exponentiallywith rising temperature. Secondly, much of the dynamics of the mantle isdetermined by chemical reactions, primarily phase changes of the variouscrystals that make up the mantle; the buoyancy term on the right hand side ofthe Stokes equations then depends not only on the temperature, but also on thechemical composition at a given location which is advected by the flow fieldbut also changes as a function of pressure and temperature. We willinvestigate some of these effects in later tutorial programs as well.</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>  <a class="anchor" id="PlainProg"></a><h1>The plain program</h1>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>  <div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2007 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Martin Kronbichler, Uppsala University,</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University 2007, 2008</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step31</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>EquationData</div><div class="line">  {</div><div class="line">    constexpr <span class="keywordtype">double</span> eta     = 1;</div><div class="line">    constexpr <span class="keywordtype">double</span> kappa   = 1e-6;</div><div class="line">    constexpr <span class="keywordtype">double</span> beta    = 10;</div><div class="line">    constexpr <span class="keywordtype">double</span> density = 1;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>TemperatureInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      TemperatureInitialValues()</div><div class="line">        : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                Vector&lt;double&gt; &amp;  value)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">          value(c) = TemperatureInitialValues&lt;dim&gt;::value(p, c);</div><div class="line">      }</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>TemperatureRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      TemperatureRightHandSide()</div><div class="line">        : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        (void)component;</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0,</div><div class="line">               <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Invalid operation for a scalar function.&quot;</span>));</div><div class="line"></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((dim == 2) || (dim == 3), <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> source_centers[3] = {</div><div class="line">          (dim == 2 ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(.3, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.3, .5, .1)),</div><div class="line">          (dim == 2 ? <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.45, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.45, .5, .1)),</div><div class="line">          (dim == 2 ? <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.75, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.75, .5, .1))};</div><div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> source_radius = (dim == 2 ? 1. / 32 : 1. / 8);</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> ((source_centers[0].distance(p) &lt; source_radius) ||</div><div class="line">                    (source_centers[1].<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(p) &lt; source_radius) ||</div><div class="line">                    (source_centers[2].distance(p) &lt; source_radius) ?</div><div class="line">                  1 :</div><div class="line">                  0);</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                Vector&lt;double&gt; &amp;  value)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">          value(c) = TemperatureRightHandSide&lt;dim&gt;::value(p, c);</div><div class="line">      }</div><div class="line">    };</div><div class="line">  } <span class="comment">// namespace EquationData</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>LinearSolvers</div><div class="line">  {</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                    <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">      <span class="keywordtype">void</span> vmult(<a class="code" href="classVectorType.html">VectorType</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">      <span class="keyword">const</span> PreconditionerType &amp;           preconditioner;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">      <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">      <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">      : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">      , preconditioner(preconditioner)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">    <span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">      <a class="code" href="classVectorType.html">VectorType</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>        solver_control(src.size(), 1e-7 * src.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;VectorType&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">      dst = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">try</span></div><div class="line">        {</div><div class="line">          cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, preconditioner);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">catch</span> (std::exception &amp;e)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(e.what()));</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    <span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      BlockSchurPreconditioner(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">        <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                            PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">        <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner);</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#aff5a880cfa288ecdd2a83a876abacf0d">vmult</a>(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">        stokes_matrix;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;<span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                             PreconditionerTypeMp&gt;&gt;</div><div class="line">                                 m_inverse;</div><div class="line">      <span class="keyword">const</span> PreconditionerTypeA &amp;a_preconditioner;</div><div class="line"></div><div class="line">      <span class="keyword">mutable</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::</div><div class="line">      BlockSchurPreconditioner(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">        <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                            PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">        <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner)</div><div class="line">      : stokes_matrix(&amp;S)</div><div class="line">      , m_inverse(&amp;Mpinv)</div><div class="line">      , a_preconditioner(Apreconditioner)</div><div class="line">      , tmp(<a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(stokes_matrix-&gt;block(1, 1).m()))</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::vmult(</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      a_preconditioner.vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">      stokes_matrix-&gt;block(1, 0).residual(tmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">      tmp *= -1;</div><div class="line">      m_inverse-&gt;vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div><div class="line">    }</div><div class="line">  } <span class="comment">// namespace LinearSolvers</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoussinesqFlowProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoussinesqFlowProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span>   setup_dofs();</div><div class="line">    <span class="keywordtype">void</span>   assemble_stokes_preconditioner();</div><div class="line">    <span class="keywordtype">void</span>   build_stokes_preconditioner();</div><div class="line">    <span class="keywordtype">void</span>   assemble_stokes_system();</div><div class="line">    <span class="keywordtype">void</span>   assemble_temperature_system(<span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity);</div><div class="line">    <span class="keywordtype">void</span>   assemble_temperature_matrix();</div><div class="line">    <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div><div class="line">    std::pair&lt;double, double&gt; get_extrapolated_temperature_range() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span>                      solve();</div><div class="line">    <span class="keywordtype">void</span>                      output_results() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span>                      refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> compute_viscosity(</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        gamma_values,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_u_infty,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_T_variation,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <span class="keywordtype">double</span>             global_Omega_diameter;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        stokes_degree;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             stokes_fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           stokes_dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> stokes_constraints;</div><div class="line"></div><div class="line">    std::vector&lt;IndexSet&gt;               stokes_partitioning;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_matrix;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_preconditioner_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_stokes_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_rhs;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        temperature_degree;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 temperature_fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           temperature_dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> temperature_constraints;</div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix temperature_mass_matrix;</div><div class="line">    TrilinosWrappers::SparseMatrix temperature_stiffness_matrix;</div><div class="line">    TrilinosWrappers::SparseMatrix temperature_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_rhs;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time_step;</div><div class="line">    <span class="keywordtype">double</span>       old_time_step;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionAMG&gt; Amg_preconditioner;</div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt;  Mp_preconditioner;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> rebuild_stokes_matrix;</div><div class="line">    <span class="keywordtype">bool</span> rebuild_temperature_matrices;</div><div class="line">    <span class="keywordtype">bool</span> rebuild_stokes_preconditioner;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::BoussinesqFlowProblem()</div><div class="line">    : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">    , global_Omega_diameter(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">    , stokes_degree(1)</div><div class="line">    , stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree), 1)</div><div class="line">    , stokes_dof_handler(triangulation)</div><div class="line">    ,</div><div class="line"></div><div class="line">    temperature_degree(2)</div><div class="line">    , temperature_fe(temperature_degree)</div><div class="line">    , temperature_dof_handler(triangulation)</div><div class="line">    ,</div><div class="line"></div><div class="line">    time_step(0)</div><div class="line">    , old_time_step(0)</div><div class="line">    , timestep_number(0)</div><div class="line">    , rebuild_stokes_matrix(true)</div><div class="line">    , rebuild_temperature_matrices(true)</div><div class="line">    , rebuild_stokes_preconditioner(true)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(), stokes_degree + 1);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(stokes_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points);</div><div class="line">    <span class="keywordtype">double</span>                      max_velocity = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(stokes_solution,</div><div class="line">                                                  velocity_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity, velocity_values[q].<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> max_velocity;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::pair&lt;double, double&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::get_extrapolated_temperature_range()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                            temperature_degree);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(temperature_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">               max_temperature = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                          old_temperature_values);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_temperature_solution,</div><div class="line">                                          old_old_temperature_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> temperature =</div><div class="line">                  (1. + time_step / old_time_step) * old_temperature_values[q] -</div><div class="line">                  time_step / old_time_step * old_old_temperature_values[q];</div><div class="line"></div><div class="line">                min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_temperature, temperature);</div><div class="line">                max_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_temperature, temperature);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> std::make_pair(min_temperature, max_temperature);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">               max_temperature = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                          old_temperature_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> temperature = old_temperature_values[q];</div><div class="line"></div><div class="line">                min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_temperature, temperature);</div><div class="line">                max_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_temperature, temperature);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> std::make_pair(min_temperature, max_temperature);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::compute_viscosity(</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        gamma_values,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_u_infty,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_T_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    constexpr <span class="keywordtype">double</span> beta  = 0.017 * dim;</div><div class="line">    constexpr <span class="keywordtype">double</span> alpha = 1.0;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (global_u_infty == 0)</div><div class="line">      <span class="keywordflow">return</span> 5e-3 * cell_diameter;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_temperature.size();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_residual = 0;</div><div class="line">    <span class="keywordtype">double</span> max_velocity = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u =</div><div class="line">          (old_velocity_values[q] + old_old_velocity_values[q]) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> dT_dt =</div><div class="line">          (old_temperature[q] - old_old_temperature[q]) / old_time_step;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_T =</div><div class="line">          u * (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> kappa_Delta_T =</div><div class="line">          EquationData::kappa *</div><div class="line">          (old_temperature_laplacians[q] + old_old_temperature_laplacians[q]) /</div><div class="line">          2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> residual =</div><div class="line">          <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>((dT_dt + u_grad_T - kappa_Delta_T - gamma_values[q]) *</div><div class="line">                   std::pow((old_temperature[q] + old_old_temperature[q]) / 2,</div><div class="line">                            alpha - 1.));</div><div class="line"></div><div class="line">        max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div><div class="line">        max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u * u), max_velocity);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> c_R            = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2., (4. - 2 * alpha) / dim);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> global_scaling = c_R * global_u_infty * global_T_variation *</div><div class="line">                                  <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(global_Omega_diameter, alpha - 2.);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (</div><div class="line">      beta * max_velocity *</div><div class="line">      <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(cell_diameter,</div><div class="line">               std::pow(cell_diameter, alpha) * max_residual / global_scaling));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_dofs()</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; stokes_sub_blocks(dim + 1, 0);</div><div class="line">    stokes_sub_blocks[dim] = 1;</div><div class="line"></div><div class="line">    {</div><div class="line">      stokes_dof_handler.distribute_dofs(stokes_fe);</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">      stokes_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(stokes_dof_handler,</div><div class="line">                                              stokes_constraints);</div><div class="line">      std::set&lt;types::boundary_id&gt; no_normal_flux_boundaries;</div><div class="line">      no_normal_flux_boundaries.insert(0);</div><div class="line">      <a class="code" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a>(stokes_dof_handler,</div><div class="line">                                                      0,</div><div class="line">                                                      no_normal_flux_boundaries,</div><div class="line">                                                      stokes_constraints);</div><div class="line">      stokes_constraints.close();</div><div class="line">    }</div><div class="line">    {</div><div class="line">      temperature_dof_handler.distribute_dofs(temperature_fe);</div><div class="line"></div><div class="line">      temperature_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(temperature_dof_handler,</div><div class="line">                                              temperature_constraints);</div><div class="line">      temperature_constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; stokes_dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = stokes_dofs_per_block[0],</div><div class="line">                       n_p = stokes_dofs_per_block[1],</div><div class="line">                       n_T = temperature_dof_handler.n_dofs();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_T &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">              &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_T &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    stokes_partitioning.resize(2);</div><div class="line">    stokes_partitioning[0] = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_u);</div><div class="line">    stokes_partitioning[1] = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_p);</div><div class="line">    {</div><div class="line">      stokes_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">      dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">      dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">      dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">      dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">      dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        stokes_dof_handler, coupling, dsp, stokes_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      stokes_matrix.reinit(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      Amg_preconditioner.reset();</div><div class="line">      Mp_preconditioner.reset();</div><div class="line">      stokes_preconditioner_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">      dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">      dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">      dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">      dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">      dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (c == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        stokes_dof_handler, coupling, dsp, stokes_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      stokes_preconditioner_matrix.reinit(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      temperature_mass_matrix.clear();</div><div class="line">      temperature_stiffness_matrix.clear();</div><div class="line">      temperature_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_T, n_T);</div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(temperature_dof_handler,</div><div class="line">                                      dsp,</div><div class="line">                                      temperature_constraints,</div><div class="line">                                      <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      temperature_matrix.reinit(dsp);</div><div class="line">      temperature_mass_matrix.reinit(temperature_matrix);</div><div class="line">      temperature_stiffness_matrix.reinit(temperature_matrix);</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> temperature_partitioning = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_T);</div><div class="line">    stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line">    stokes_rhs.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_old_temperature_solution.reinit(temperature_partitioning,</div><div class="line">                                        MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    temperature_rhs.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_preconditioner()</div><div class="line">  {</div><div class="line">    stokes_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(stokes_degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(stokes_fe,</div><div class="line">                                   quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; grad_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;         phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        stokes_fe_values.reinit(cell);</div><div class="line">        local_matrix = 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                grad_phi_u[k] = stokes_fe_values[velocities].gradient(k, q);</div><div class="line">                phi_p[k]      = stokes_fe_values[pressure].value(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                local_matrix(i, j) +=</div><div class="line">                  (EquationData::eta *</div><div class="line">                     <a class="code" href="symmetric__tensor_8h.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[i], grad_phi_u[j]) +</div><div class="line">                   (1. / EquationData::eta) * phi_p[i] * phi_p[j]) *</div><div class="line">                  stokes_fe_values.JxW(q);</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        stokes_constraints.distribute_local_to_global(</div><div class="line">          local_matrix, local_dof_indices, stokes_preconditioner_matrix);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::build_stokes_preconditioner()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_preconditioner == <span class="keyword">false</span>)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding Stokes preconditioner...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    assemble_stokes_preconditioner();</div><div class="line"></div><div class="line">    Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionAMG&gt;();</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocity_components(0);</div><div class="line">    <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(stokes_dof_handler,</div><div class="line">                                     stokes_fe.component_mask(</div><div class="line">                                       velocity_components),</div><div class="line">                                     constant_modes);</div><div class="line">    <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> amg_data;</div><div class="line">    amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a> = constant_modes;</div><div class="line"></div><div class="line">    amg_data.elliptic              = <span class="keyword">true</span>;</div><div class="line">    amg_data.higher_order_elements = <span class="keyword">true</span>;</div><div class="line">    amg_data.smoother_sweeps       = 2;</div><div class="line">    amg_data.aggregation_threshold = 0.02;</div><div class="line">    Amg_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(0, 0),</div><div class="line">                                   amg_data);</div><div class="line"></div><div class="line">    Mp_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">    Mp_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(1, 1));</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    rebuild_stokes_preconditioner = <span class="keyword">false</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_system()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">      stokes_matrix = 0;</div><div class="line"></div><div class="line">    stokes_rhs = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(stokes_degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(</div><div class="line">      stokes_fe,</div><div class="line">      quadrature_formula,</div><div class="line">      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">        (rebuild_stokes_matrix == <span class="keyword">true</span> ? <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> : <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(0)));</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values(temperature_fe,</div><div class="line">                                        quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;          phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; grads_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  div_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell             = stokes_dof_handler.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc             = stokes_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       temperature_cell = temperature_dof_handler.begin_active();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++temperature_cell)</div><div class="line">      {</div><div class="line">        stokes_fe_values.reinit(cell);</div><div class="line">        temperature_fe_values.reinit(temperature_cell);</div><div class="line"></div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs    = 0;</div><div class="line"></div><div class="line">        temperature_fe_values.get_function_values(old_temperature_solution,</div><div class="line">                                                  old_temperature_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> old_temperature = old_temperature_values[q];</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                phi_u[k] = stokes_fe_values[velocities].value(k, q);</div><div class="line">                <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">                  {</div><div class="line">                    grads_phi_u[k] =</div><div class="line">                      stokes_fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">                    div_phi_u[k] =</div><div class="line">                      stokes_fe_values[velocities].divergence(k, q);</div><div class="line">                    phi_p[k] = stokes_fe_values[pressure].value(k, q);</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  local_matrix(i, j) +=</div><div class="line">                    (EquationData::eta * 2 * (grads_phi_u[i] * grads_phi_u[j]) -</div><div class="line">                     div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div><div class="line">                    stokes_fe_values.JxW(q);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> gravity =</div><div class="line">              -((dim == 2) ? (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 1)) : (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0, 1)));</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              local_rhs(i) += (-EquationData::density * EquationData::beta *</div><div class="line">                               gravity * phi_u[i] * old_temperature) *</div><div class="line">                              stokes_fe_values.JxW(q);</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">          stokes_constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                                        local_rhs,</div><div class="line">                                                        local_dof_indices,</div><div class="line">                                                        stokes_matrix,</div><div class="line">                                                        stokes_rhs);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          stokes_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                        local_dof_indices,</div><div class="line">                                                        stokes_rhs);</div><div class="line">      }</div><div class="line"></div><div class="line">    rebuild_stokes_matrix = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_matrix()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (rebuild_temperature_matrices == <span class="keyword">false</span>)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    temperature_mass_matrix      = 0;</div><div class="line">    temperature_stiffness_matrix = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(temperature_degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values(temperature_fe,</div><div class="line">                                        quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = temperature_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_stiffness_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         phi_T(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        local_mass_matrix      = 0;</div><div class="line">        local_stiffness_matrix = 0;</div><div class="line"></div><div class="line">        temperature_fe_values.reinit(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);</div><div class="line">                phi_T[k]      = temperature_fe_values.shape_value(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  local_mass_matrix(i, j) +=</div><div class="line">                    (phi_T[i] * phi_T[j] * temperature_fe_values.JxW(q));</div><div class="line">                  local_stiffness_matrix(i, j) +=</div><div class="line">                    (EquationData::kappa * grad_phi_T[i] * grad_phi_T[j] *</div><div class="line">                     temperature_fe_values.JxW(q));</div><div class="line">                }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        temperature_constraints.distribute_local_to_global(</div><div class="line">          local_mass_matrix, local_dof_indices, temperature_mass_matrix);</div><div class="line">        temperature_constraints.distribute_local_to_global(</div><div class="line">          local_stiffness_matrix,</div><div class="line">          local_dof_indices,</div><div class="line">          temperature_stiffness_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    rebuild_temperature_matrices = <span class="keyword">false</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_system(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (use_bdf2_scheme == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line">        temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">        temperature_matrix *=</div><div class="line">          (2 * time_step + old_time_step) / (time_step + old_time_step);</div><div class="line">        temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">        temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    temperature_rhs = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(temperature_degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     temperature_fe_values(temperature_fe,</div><div class="line">                                        quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(stokes_fe,</div><div class="line">                                   quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = temperature_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    Vector&lt;double&gt; local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_velocity_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_velocity_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_temperature_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_old_temperature_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_temperature_grads(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_temperature_grads(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_temperature_laplacians(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_old_temperature_laplacians(n_q_points);</div><div class="line"></div><div class="line">    EquationData::TemperatureRightHandSide&lt;dim&gt; temperature_right_hand_side;</div><div class="line">    std::vector&lt;double&gt;                         gamma_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         phi_T(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range =</div><div class="line">      get_extrapolated_temperature_range();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell        = temperature_dof_handler.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc        = temperature_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       stokes_cell = stokes_dof_handler.begin_active();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++stokes_cell)</div><div class="line">      {</div><div class="line">        local_rhs = 0;</div><div class="line"></div><div class="line">        temperature_fe_values.reinit(cell);</div><div class="line">        stokes_fe_values.reinit(stokes_cell);</div><div class="line"></div><div class="line">        temperature_fe_values.get_function_values(old_temperature_solution,</div><div class="line">                                                  old_temperature_values);</div><div class="line">        temperature_fe_values.get_function_values(old_old_temperature_solution,</div><div class="line">                                                  old_old_temperature_values);</div><div class="line"></div><div class="line">        temperature_fe_values.get_function_gradients(old_temperature_solution,</div><div class="line">                                                     old_temperature_grads);</div><div class="line">        temperature_fe_values.get_function_gradients(</div><div class="line">          old_old_temperature_solution, old_old_temperature_grads);</div><div class="line"></div><div class="line">        temperature_fe_values.get_function_laplacians(</div><div class="line">          old_temperature_solution, old_temperature_laplacians);</div><div class="line">        temperature_fe_values.get_function_laplacians(</div><div class="line">          old_old_temperature_solution, old_old_temperature_laplacians);</div><div class="line"></div><div class="line">        temperature_right_hand_side.value_list(</div><div class="line">          temperature_fe_values.get_quadrature_points(), gamma_values);</div><div class="line"></div><div class="line">        stokes_fe_values[velocities].get_function_values(stokes_solution,</div><div class="line">                                                         old_velocity_values);</div><div class="line">        stokes_fe_values[velocities].get_function_values(</div><div class="line">          old_stokes_solution, old_old_velocity_values);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div><div class="line">          compute_viscosity(old_temperature_values,</div><div class="line">                            old_old_temperature_values,</div><div class="line">                            old_temperature_grads,</div><div class="line">                            old_old_temperature_grads,</div><div class="line">                            old_temperature_laplacians,</div><div class="line">                            old_old_temperature_laplacians,</div><div class="line">                            old_velocity_values,</div><div class="line">                            old_old_velocity_values,</div><div class="line">                            gamma_values,</div><div class="line">                            maximal_velocity,</div><div class="line">                            global_T_range.second - global_T_range.first,</div><div class="line">                            cell-&gt;diameter());</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);</div><div class="line">                phi_T[k]      = temperature_fe_values.shape_value(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> T_term_for_rhs =</div><div class="line">              (use_bdf2_scheme ?</div><div class="line">                 (old_temperature_values[q] * (1 + time_step / old_time_step) -</div><div class="line">                  old_old_temperature_values[q] * (time_step * time_step) /</div><div class="line">                    (old_time_step * (time_step + old_time_step))) :</div><div class="line">                 old_temperature_values[q]);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ext_grad_T =</div><div class="line">              (use_bdf2_scheme ?</div><div class="line">                 (old_temperature_grads[q] * (1 + time_step / old_time_step) -</div><div class="line">                  old_old_temperature_grads[q] * time_step / old_time_step) :</div><div class="line">                 old_temperature_grads[q]);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> extrapolated_u =</div><div class="line">              (use_bdf2_scheme ?</div><div class="line">                 (old_velocity_values[q] * (1 + time_step / old_time_step) -</div><div class="line">                  old_old_velocity_values[q] * time_step / old_time_step) :</div><div class="line">                 old_velocity_values[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              local_rhs(i) +=</div><div class="line">                (T_term_for_rhs * phi_T[i] -</div><div class="line">                 time_step * extrapolated_u * ext_grad_T * phi_T[i] -</div><div class="line">                 time_step * nu * ext_grad_T * grad_phi_T[i] +</div><div class="line">                 time_step * gamma_values[q] * phi_T[i]) *</div><div class="line">                temperature_fe_values.JxW(q);</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        temperature_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                           local_dof_indices,</div><div class="line">                                                           temperature_rhs);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> LinearSolvers::InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                         <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a>&gt;</div><div class="line">        mp_inverse(stokes_preconditioner_matrix.block(1, 1),</div><div class="line">                   *Mp_preconditioner);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">        <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">TrilinosWrappers::PreconditionAMG</a>,</div><div class="line">        <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a>&gt;</div><div class="line">        preconditioner(stokes_matrix, mp_inverse, *Amg_preconditioner);</div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(stokes_matrix.m(),</div><div class="line">                                   1e-6 * stokes_rhs.l2_norm());</div><div class="line"></div><div class="line">      <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> gmres(</div><div class="line">        solver_control,</div><div class="line">        <a class="code" href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(100));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; stokes_solution.size(); ++i)</div><div class="line">        <span class="keywordflow">if</span> (stokes_constraints.is_constrained(i))</div><div class="line">          stokes_solution(i) = 0;</div><div class="line"></div><div class="line">      gmres.solve(stokes_matrix, stokes_solution, stokes_rhs, preconditioner);</div><div class="line"></div><div class="line">      stokes_constraints.distribute(stokes_solution);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; GMRES iterations for Stokes subsystem.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    old_time_step                 = time_step;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity = get_maximal_velocity();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (maximal_velocity &gt;= 0.01)</div><div class="line">      time_step = 1. / (1.7 * dim * <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim)) / temperature_degree *</div><div class="line">                  <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) /</div><div class="line">                  maximal_velocity;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      time_step = 1. / (1.7 * dim * <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim)) / temperature_degree *</div><div class="line">                  <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / .01;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    temperature_solution = old_temperature_solution;</div><div class="line"></div><div class="line">    assemble_temperature_system(maximal_velocity);</div><div class="line">    {</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(temperature_matrix.m(),</div><div class="line">                                   1e-8 * temperature_rhs.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a> preconditioner;</div><div class="line">      preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html#a95eff1f8abcf2ba67815b6a96a66d375">initialize</a>(temperature_matrix);</div><div class="line"></div><div class="line">      cg.solve(temperature_matrix,</div><div class="line">               temperature_solution,</div><div class="line">               temperature_rhs,</div><div class="line">               preconditioner);</div><div class="line"></div><div class="line">      temperature_constraints.distribute(temperature_solution);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; CG iterations for temperature.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> min_temperature = temperature_solution(0),</div><div class="line">             max_temperature = temperature_solution(0);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; temperature_solution.size(); ++i)</div><div class="line">        {</div><div class="line">          min_temperature =</div><div class="line">            std::min&lt;double&gt;(min_temperature, temperature_solution(i));</div><div class="line">          max_temperature =</div><div class="line">            std::max&lt;double&gt;(max_temperature, temperature_solution(i));</div><div class="line">        }</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Temperature range: &quot;</span> &lt;&lt; min_temperature &lt;&lt; <span class="charliteral">&#39; &#39;</span></div><div class="line">                &lt;&lt; max_temperature &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (timestep_number % 10 != 0)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; stokes_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    stokes_names.emplace_back(<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      stokes_component_interpretation(</div><div class="line">        dim + 1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">      stokes_component_interpretation[i] =</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(stokes_dof_handler,</div><div class="line">                             stokes_solution,</div><div class="line">                             stokes_names,</div><div class="line">                             stokes_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(temperature_dof_handler,</div><div class="line">                             temperature_solution,</div><div class="line">                             <span class="stringliteral">&quot;T&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(stokes_degree, temperature_degree));</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                         <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 4) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(temperature_dof_handler,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(temperature_degree + 1),</div><div class="line">                                       {},</div><div class="line">                                       temperature_solution,</div><div class="line">                                       estimated_error_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a>(triangulation,</div><div class="line">                                                      estimated_error_per_cell,</div><div class="line">                                                      0.8,</div><div class="line">                                                      0.1);</div><div class="line">    <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &gt; max_grid_level)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell :</div><div class="line">           triangulation.<a class="code" href="group__CPP11.html#gac10cd3fe6ef8360e2599d3cff58e13e8">active_cell_iterators_on_level</a>(max_grid_level))</div><div class="line">        cell-&gt;clear_refine_flag();</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::Vector&gt; x_temperature(2);</div><div class="line">    x_temperature[0]                            = temperature_solution;</div><div class="line">    x_temperature[1]                            = old_temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> x_stokes = stokes_solution;</div><div class="line"></div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a> temperature_trans(</div><div class="line">      temperature_dof_handler);</div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::BlockVector&gt;</a> stokes_trans(</div><div class="line">      stokes_dof_handler);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">    temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);</div><div class="line">    stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::Vector&gt; tmp(2);</div><div class="line">    tmp[0].reinit(temperature_solution);</div><div class="line">    tmp[1].reinit(temperature_solution);</div><div class="line">    temperature_trans.interpolate(x_temperature, tmp);</div><div class="line"></div><div class="line">    temperature_solution     = tmp[0];</div><div class="line">    old_temperature_solution = tmp[1];</div><div class="line"></div><div class="line">    temperature_constraints.distribute(temperature_solution);</div><div class="line">    temperature_constraints.distribute(old_temperature_solution);</div><div class="line"></div><div class="line">    stokes_trans.interpolate(x_stokes, stokes_solution);</div><div class="line"></div><div class="line">    stokes_constraints.distribute(stokes_solution);</div><div class="line"></div><div class="line">    rebuild_stokes_matrix         = <span class="keyword">true</span>;</div><div class="line">    rebuild_temperature_matrices  = <span class="keyword">true</span>;</div><div class="line">    rebuild_stokes_preconditioner = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">BoussinesqFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement     = (dim == 2 ? 4 : 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_pre_refinement_steps = (dim == 2 ? 4 : 3);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">    global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(triangulation);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(initial_refinement);</div><div class="line"></div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"></div><div class="line">  start_time_iteration:</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(temperature_dof_handler,</div><div class="line">                         temperature_constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(temperature_degree + 2),</div><div class="line">                         EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">                         old_temperature_solution);</div><div class="line"></div><div class="line">    timestep_number = 0;</div><div class="line">    time_step = old_time_step = 0;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> time = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_stokes_system();</div><div class="line">        build_stokes_preconditioner();</div><div class="line">        assemble_temperature_matrix();</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">            (pre_refinement_step &lt; n_pre_refinement_steps))</div><div class="line">          {</div><div class="line">            refine_mesh(initial_refinement + n_pre_refinement_steps);</div><div class="line">            ++pre_refinement_step;</div><div class="line">            <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp; (timestep_number % 5 == 0))</div><div class="line">          refine_mesh(initial_refinement + n_pre_refinement_steps);</div><div class="line"></div><div class="line">        time += time_step;</div><div class="line">        ++timestep_number;</div><div class="line"></div><div class="line">        old_stokes_solution          = stokes_solution;</div><div class="line">        old_old_temperature_solution = old_temperature_solution;</div><div class="line">        old_temperature_solution     = temperature_solution;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (time &lt;= 100);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step31</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step31;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-31&quot;</span>));</div><div class="line"></div><div class="line">      BoussinesqFlowProblem&lt;2&gt; flow_problem;</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>This tutorial depends on <a class="el" href="step_22.html">step-22</a>.</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#TheBoussinesqequations">The Boussinesq equations</a>
        <li><a href="#Boundaryandinitialconditions">Boundary and initial conditions</a>
        <li><a href="#Solutionapproach">Solution approach</a>
      <ul>
        <li><a href="#Timestepping">Time stepping</a>
        <li><a href="#WeakformandspacediscretizationfortheStokespart">Weak form and space discretization for the Stokes part</a>
        <li><a href="#Stabilizationweakformandspacediscretizationforthetemperatureequation">Stabilization, weak form and space discretization for the temperature equation</a>
        <li><a href="#Linearsolvers">Linear solvers</a>
      <ul>
        <li><a href="#LinearsolversfortheStokesproblem">Linear solvers for the Stokes problem</a>
        <li><a href="#Linearsolversforthetemperatureequation">Linear solvers for the temperature equation</a>
      </ul>
      </ul>
        <li><a href="#Implementationdetails">Implementation details</a>
      <ul>
        <li><a href="#UsingdifferentDoFHandlerobjects">Using different DoFHandler objects</a>
        <li><a href="#UsingTrilinos">Using Trilinos</a>
      </ul>
        <li><a href="#Thetestcase">The testcase</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#Linearsolversandpreconditioners">Linear solvers and preconditioners</a>
      <ul>
        <li><a href="#ThecodeInverseMatrixcodeclasstemplate">The <code>InverseMatrix</code> class template</a>
        <li><a href="#Schurcomplementpreconditioner">Schur complement preconditioner</a>
      </ul>
        <li><a href="#ThecodeBoussinesqFlowProblemcodeclasstemplate">The <code>BoussinesqFlowProblem</code> class template</a>
        <li><a href="#BoussinesqFlowProblemclassimplementation">BoussinesqFlowProblem class implementation</a>
      <ul>
        <li><a href="#BoussinesqFlowProblemBoussinesqFlowProblem">BoussinesqFlowProblem::BoussinesqFlowProblem</a>
        <li><a href="#BoussinesqFlowProblemget_maximal_velocity">BoussinesqFlowProblem::get_maximal_velocity</a>
        <li><a href="#BoussinesqFlowProblemget_extrapolated_temperature_range">BoussinesqFlowProblem::get_extrapolated_temperature_range</a>
        <li><a href="#BoussinesqFlowProblemcompute_viscosity">BoussinesqFlowProblem::compute_viscosity</a>
        <li><a href="#BoussinesqFlowProblemsetup_dofs">BoussinesqFlowProblem::setup_dofs</a>
        <li><a href="#BoussinesqFlowProblemassemble_stokes_preconditioner">BoussinesqFlowProblem::assemble_stokes_preconditioner</a>
        <li><a href="#BoussinesqFlowProblembuild_stokes_preconditioner">BoussinesqFlowProblem::build_stokes_preconditioner</a>
        <li><a href="#BoussinesqFlowProblemassemble_stokes_system">BoussinesqFlowProblem::assemble_stokes_system</a>
        <li><a href="#BoussinesqFlowProblemassemble_temperature_matrix">BoussinesqFlowProblem::assemble_temperature_matrix</a>
        <li><a href="#BoussinesqFlowProblemassemble_temperature_system">BoussinesqFlowProblem::assemble_temperature_system</a>
        <li><a href="#BoussinesqFlowProblemsolve">BoussinesqFlowProblem::solve</a>
        <li><a href="#BoussinesqFlowProblemoutput_results">BoussinesqFlowProblem::output_results</a>
        <li><a href="#BoussinesqFlowProblemrefine_mesh">BoussinesqFlowProblem::refine_mesh</a>
        <li><a href="#BoussinesqFlowProblemrun">BoussinesqFlowProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Resultsin2d"> Results in 2d </a>
        <li><a href="#Resultsin3d"> Results in 3d </a>
        <li><a href="#Numericalexperimentstodetermineoptimalparameters"> Numerical experiments to determine optimal parameters </a>
      <ul>
        <li><a href="#Choosingicsubksubiicsubksubiandbeta"> Choosing <i>c<sub>k</sub></i><i>c<sub>k</sub></i> and beta </a>
      <ul>
        <li><a href="#ResultsforQsub1subelements">Results for Q<sub>1</sub> elements</a>
        <li><a href="#ResultsforQsub2subelements">Results for Q<sub>2</sub> elements</a>
        <li><a href="#Resultsfor3d">Results for 3d</a>
        <li><a href="#Conclusions">Conclusions</a>
      </ul>
      </ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>

examples/step-31/doc/intro.dox</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <br />
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre><em>This program was contributed by Martin Kronbichler and Wolfgang
Bangerth.
<br />

This material is based upon work partly supported by the National
Science Foundation under Award No. EAR-0426271 and The California Institute of
Technology. Any opinions, findings, and conclusions or recommendations
expressed in this publication are those of the author and do not
necessarily reflect the views of the National Science Foundation or of The
California Institute of Technology.
</em></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre><a class="anchor" id="Intro"></a></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre><a class="anchor" id="Introduction"></a><h1>Introduction</h1>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre><a class="anchor" id="TheBoussinesqequations"></a><h3>The Boussinesq equations</h3>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>这个程序涉及一个有趣的物理问题：如果流体（即液体或气体）遇到由温度差异引起的浮力差异，它是如何表现的？很明显，流体中温度较高（因此较轻）的部分会上升，温度较低（密度较大）的部分会在重力作用下下沉。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>在流体运动速度足够慢，以至于惯性效应可以被忽略的情况下，描述这种行为的方程是布西尼斯克方程，其内容如下。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; -\rho\; \beta \; T\; \mathbf{g}, \\ \nabla \cdot {\mathbf u} &amp;=&amp; 0, \\ \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma. \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>这些方程属于矢量值问题的范畴（这个主题的顶层概述可以在 <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> 模块中找到）。这里， \(\mathbf u\) 是速度场， \(p\) 是压力， \(T\) 是流体的温度。 \(\varepsilon ({\mathbf u}) = \frac 12 [(\nabla{\mathbf u}) + (\nabla {\mathbf u})^T]\) 是速度的对称梯度。可以看出，速度和压力解决了描述不可压缩流体运动的斯托克斯方程，这个方程我们以前在步骤22中考虑过；我们将广泛借鉴在该程序中获得的经验，特别是关于高效线性斯托克斯求解器的经验。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>流体运动的强制项是流体的浮力，表示为密度 \(\rho\) 、热膨胀系数 \(\beta\) 、温度 \(T\) 和指向下方的重力矢量 \(\mathbf{g}\) 的积。在第32步的介绍中给出了为什么右手边看起来像它的推导）。前两个方程描述了流体如何通过移动对温差做出反应，第三个方程说明了流体运动如何影响温度场：它是一个平流扩散方程，即温度附着在流体颗粒上，并在流场中平流，还有一个额外的扩散（热传导）项。在许多应用中，扩散系数相当小，温度方程实际上是传输的，而不是扩散主导的，因此其特征是双曲而不是椭圆；我们在开发一个稳定的离散化时必须考虑到这一点。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>在上述方程中，右侧的 \(\gamma\) 项表示热源，可能是一个空间和时间上的变化函数。 \(\eta\) 和 \(\kappa\) 表示粘度和扩散系数，在本教程程序中我们假定这两个系数为常数。当 \(\eta\) 取决于温度时，更普遍的情况是物理应用中的一个重要因素。大多数材料随着温度的升高而变得更加流动（即 \(\eta\) 随着 \(T\) 的降低而降低）；有时，如在温度接近熔点的岩石矿物的情况下， \(\eta\) 可能在典型的温度范围内发生数量级的变化。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>我们注意到，上述斯托克斯方程可以通过引入<a href="http://en.wikipedia.org/wiki/Rayleigh_number" target="_top">Rayleigh
number</a> \(\mathrm{Ra}=\frac{\|\mathbf{g}\| \beta \rho}{\eta \kappa} \delta T L^3\) 来实现非维度化，使用的是典型长度尺度 \(L\) 、典型温差 \(\delta T\) 、密度 \(\rho\) 、热扩散率 \(\eta\) 和热导率 \(\kappa\)  。 \(\mathrm{Ra}\) 是一个无尺寸的数字，它描述了由温差引起的浮力变化导致的热传输和热扩散导致的热传输的比率。一个小的瑞利数意味着浮力相对于粘度来说并不强，流体运动 \(\mathbf{u}\) 足够慢，因此热扩散 \(\kappa\nabla T\) 是主要的热传输项。另一方面，高瑞利数的流体将显示出主导热传导的强烈对流。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>对于我们感兴趣的计算热对流的大多数流体，瑞利数是非常大的，通常是 \(10^6\) 或更大。从方程的结构中，我们看到这将导致大的压力差和大的速度。因此， \(T\) 的对流-扩散方程中的对流项也将非常大，这个方程的精确解将要求我们选择小的时间步长。因此，具有大雷利数的问题很难用数值来解决，其原因与<a href="http://en.wikipedia.org/wiki/Navier-stokes_equations">Navier-Stokes
equations</a>大时难以解决<a href="http://en.wikipedia.org/wiki/Reynolds_number">Reynolds number
 \(\mathrm{Re}\)</a>的问题相似。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>请注意，大的瑞利数不一定涉及大的绝对速度。例如，地幔中的瑞利数大于 \(10^6\)  。然而，速度却很小：该材料实际上是固体岩石，但它是如此之热，而且处于压力之下，它可以非常缓慢地流动，每年最多只有几厘米的速度。然而，这可以导致在数百万年的时间尺度上的混合，这个时间尺度比相同数量的热量通过热传导分布要短得多，而且这个时间尺度与影响地球内部和表面结构的演变有关。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <dl class="section note"><dt>Note</dt><dd>如果你对使用该程序作为你自己实验的基础感兴趣，你也会想看看它在<a class="el" href="step_32.html">step-32</a>中的延续。此外，<a class="el" href="step_32.html">step-32</a>后来被发展成更大的开放源代码ASPECT（见https://aspect.geodynamics.org/），它可以解决现实的问题，在试图将<a class="el" href="step_31.html">step-31</a>变形为可以解决任何你想解决的问题之前，你可能想研究一下它。</dd></dl>
<a class="anchor" id="Boundaryandinitialconditions"></a><h3>Boundary and initial conditions</h3>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>由于Boussinesq方程是在流体运动的惯性不起作用的假设下推导出来的，所以流场在每个时间段完全由该时间段的浮力差决定，而不是由以前的流场决定。这反映在上面的前两个方程是不包含时间导数的稳态斯托克斯方程的事实。因此，我们不需要速度或压力的初始条件。另一方面，温度场确实满足一个有时间导数的方程，所以我们需要初始条件 \(T\)  。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>至于边界条件：如果 \(\kappa&gt;0\) ，那么温度满足一个二阶微分方程，需要边界周围所有时间的边界数据。这些数据可以是规定的边界温度 \(T|_{\partial\Omega}=T_b\) （Dirichlet边界条件），也可以是规定的热通量 \(\mathbf{n}\cdot\kappa\nabla T|_{\partial\Omega}=\phi\) ；在这个程序中，我们将使用一个绝缘的边界条件，即规定没有热通量。 \(\phi=0\)  .</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>同样地，速度场要求我们提出边界条件。这些条件可以是 \(\mathbf{u}=0\) 上的无滑移无通量条件 \(\partial\Omega\) ，如果流体粘在边界上，或者无正常通量条件 \(\mathbf n \cdot \mathbf u = 0\) ，如果流体可以沿边界流动但不能穿过边界，或者任何数量的其他物理上合理的条件。在这个程序中，我们将使用无正常通量条件。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre><a class="anchor" id="Solutionapproach"></a><h3>Solution approach</h3>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>与步骤21中解决的方程一样，我们这里有一个微分代数方程（DAE）系统：就时间变量而言，只有温度方程是微分方程，而 \(\mathbf{u}\) 和 \(p\) 的斯托克斯系统没有时间导数，因此属于必须在每个时间瞬间保持的那种代数约束。与第21步的主要区别是，那里的代数约束是一个混合拉普拉斯系统，其形式为</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} \mathbf u + {\mathbf K}\lambda \nabla p &amp;=&amp; 0, \\ \nabla\cdot \mathbf u &amp;=&amp; f, \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>现在我们有一个斯托克斯系统</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2 \eta \varepsilon ({\mathbf u})) + \nabla p &amp;=&amp; f, \\ \nabla\cdot \mathbf u &amp;=&amp; 0, \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>其中 \(\nabla \cdot \eta \varepsilon (\cdot)\) 是一个类似于拉普拉斯 \(\Delta\) 的算子，适用于一个矢量场。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>鉴于与我们在步骤21中所做的相似，我们选择类似的方法可能并不令人惊讶，尽管我们将不得不对微分算子左上角的算子变化进行调整。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre><a class="anchor" id="Timestepping"></a><h4>Time stepping</h4>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>作为DAE的问题结构允许我们使用与我们在步骤21中已经使用的相同的策略，即我们使用一个时间滞后方案：我们首先解决温度方程（使用外推的速度场），然后将新的温度解插入速度方程的右侧。不过，我们在代码中实现这一方案的方式是从一个稍微不同的角度来看问题。我们首先使用前一个时间步长的温度场来求解速度和压力的斯托克斯方程，这意味着我们得到前一个时间步长的速度。换句话说，我们首先求解时间步长 \(n - 1\) 的斯托克斯系统，即</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} -\nabla \cdot (2\eta \varepsilon ({\mathbf u}^{n-1})) + \nabla p^{n-1} &amp;=&amp; -\rho\; \beta \; T^{n-1} \mathbf{g}, \\ \nabla \cdot {\mathbf u}^{n-1} &amp;=&amp; 0, \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>然后用外推速度场的温度方程到时间 \(n\)  。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>与第21步相比，我们在这里将使用一个高阶时间步进方案，即用（单边）差分商 \(\frac{\frac 32 T^{n}-2T^{n-1}+\frac 12 T^{n-2}}{k}\) 取代时间导数 \(\frac{\partial T}{\partial t}\) ， \(k\) 为时间步长。这就得到了离散化的时间温度方程</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} \frac 32 T^n - k\nabla \cdot \kappa \nabla T^n &amp;=&amp; 2 T^{n-1} - \frac 12 T^{n-2} - k(2{\mathbf u}^{n-1} - {\mathbf u}^{n-2} ) \cdot \nabla (2T^{n-1}-T^{n-2}) + k\gamma. \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>请注意温度方程是如何被半显式解决的：扩散被隐式处理，而平流被显式处理，使用温度和速度的外推法（或前推法），包括刚刚计算的速度 \({\mathbf u}^{n-1}\)  。对当前时间水平的正向投影 \(n\)  是由泰勒扩展得出的， \(T^n \approx T^{n-1} + k_n \frac{\partial T}{\partial t} \approx T^{n-1} + k_n \frac{T^{n-1}-T^{n-2}}{k_n} = 2T^{n-1}-T^{n-2}\)  。我们需要这个投影来保持BDF-2方案的精度。换句话说，我们在显式右手边使用的温度场是当前温度场的二阶近似值&amp;mdash；不完全是显式时间步进方案，但从特征上看也不会太远。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>温度外推的引入将时间步长限制在<a href="http://en.wikipedia.org/wiki/Courant–Friedrichs–Lewy_condition">Courant-Friedrichs-Lewy (CFL) condition</a>，就像在 <a class="el" href="step_21.html">步骤-21 </a>中一样。(如果我们隐含地处理平流项，我们就不会有这个稳定条件，因为BDF-2方案是A级稳定的，代价是我们需要在每个时间步长建立一个新的温度矩阵。)我们将在<a href="#Results">results
section</a>中讨论时间步长的确切选择，但目前重要的是，这个CFL条件意味着时间步长 \(k\) 可能在不同的时间步长中发生变化，我们必须稍微修改上述公式。如果 \(k_n,k_{n-1}\) 是当前和前一个时间步长的时间步长，那么我们使用近似值</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{align*} \frac{\partial T}{\partial t} \approx \frac 1{k_n} \left( \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} T^{n} - \frac{k_n+k_{n-1}}{k_{n-1}}T^{n-1} + \frac{k_n^2}{k_{n-1}(k_n+k_{n-1})} T^{n-2} \right) \end{align*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>和</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{align*} T^n \approx T^{n-1} + k_n \frac{\partial T}{\partial t} \approx T^{n-1} + k_n \frac{T^{n-1}-T^{n-2}}{k_{n-1}} = \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2}, \end{align*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>并将上述方程概括如下。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} T^n - k_n\nabla \cdot \kappa \nabla T^n &amp;=&amp; \frac{k_n+k_{n-1}}{k_{n-1}} T^{n-1} - \frac{k_n^2}{k_{n-1}(k_n+k_{n-1})} T^{n-2} - k_n{\mathbf u}^{*,n} \cdot \nabla T^{*,n} + k_n\gamma, \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>其中 \({(\cdot)}^{*,n} = \left(1+\frac{k_n}{k_{n-1}}\right)(\cdot)^{n-1} - \frac{k_n}{k_{n-1}}(\cdot)^{n-2}\) 表示速度 \(\mathbf u\) 和温度 \(T\) 外推到时间级别 \(n\) ，使用前两个时间步骤的数值。这不是一个容易读懂的方程，但会为我们提供所需的高阶精度。作为一致性检查，很容易验证，如果 \(k_n=k_{n-1}\)  ，它可以还原成与上面相同的方程。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>最后我们注意到，选择高阶时间步进方案当然会迫使我们在内存中保留更多的时间步进；特别是，我们在这里需要保留 \(T^{n-2}\) ，这是一个我们以前可以抛弃的向量。这似乎是一个麻烦，我们以前可以通过使用一阶时间步进方案来避免，但是正如我们在下面讨论稳定化问题时看到的那样，我们无论如何都需要这个向量，因此在时间离散化中保留它基本上是免费的，并给我们提供了使用高阶方案的机会。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre><a class="anchor" id="WeakformandspacediscretizationfortheStokespart"></a><h4>Weak form and space discretization for the Stokes part</h4>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>像解决混合拉普拉斯方程一样，解决斯托克斯方程需要我们为速度和压力变量选择特定的有限元对。因为这在步骤22中已经讨论过了，所以我们只简单介绍一下这个话题。这里，我们使用稳定对 \(Q_{p+1}^d \times Q_p, p\ge 1\)  。这些都是连续元素，所以我们可以通过部分积分和用离散函数替代连续函数来形成斯托克斯方程的弱形式，没有问题。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} (\nabla {\mathbf v}_h, 2\eta \varepsilon ({\mathbf u}^{n-1}_h)) - (\nabla \cdot {\mathbf v}_h, p^{n-1}_h) &amp;=&amp; -({\mathbf v}_h, \rho\; \beta \; T^{n-1}_h \mathbf{g}), \\ (q_h, \nabla \cdot {\mathbf u}^{n-1}_h) &amp;=&amp; 0, \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>为所有测试函数 \(\mathbf v_h, q_h\)  。第一个方程的第一项被认为是张量之间的内积，即 \((\nabla {\mathbf v}_h, \eta \varepsilon ({\mathbf u}^{n-1}_h))_\Omega = \int_\Omega \sum_{i,j=1}^d [\nabla {\mathbf v}_h]_{ij} \eta [\varepsilon ({\mathbf u}^{n-1}_h)]_{ij}\, dx\)  。因为这个乘积中的第二个张量是对称的，所以 \(\nabla {\mathbf v}_h\) 的反对称分量不起作用，如果我们用 \(\mathbf v_h\) 的对称梯度代替，会导致完全一样的形式。因此，我们考虑并实施的表述是</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} (\varepsilon({\mathbf v}_h), 2\eta \varepsilon ({\mathbf u}^{n-1}_h)) - (\nabla \cdot {\mathbf v}_h, p^{n-1}_h) &amp;=&amp; -({\mathbf v}_h, \rho\; \beta \; T^{n-1}_h \mathbf{g}), \\ (q_h, \nabla \cdot {\mathbf u}^{n-1}_h) &amp;=&amp; 0. \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>这与我们在第22步中已经讨论过的完全一样，这里就不多说了。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre><a class="anchor" id="Stabilizationweakformandspacediscretizationforthetemperatureequation"></a><h4>Stabilization, weak form and space discretization for the temperature equation</h4>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>更有趣的问题是如何处理温度平流-扩散方程。默认情况下，并不是所有这个方程的离散化都是同样稳定的，除非我们要么做一些像上卷、稳定化，或者所有这些的事情。实现这一点的方法之一是使用不连续元素（即我们在步骤12中离散传输方程或在步骤20和步骤21中离散压力时使用的FE_DGQ类），并在单元间的界面上定义一个考虑到上卷的流量。如果我们有一个纯粹的平流问题，这可能是最简单的方法。然而，这里我们也有一些扩散，用不连续元素对拉普拉斯算子进行离散化是很麻烦的，因为有大量的附加项需要在单元间的每个面上进行积分。不连续元素还有一个缺点，即使用数值通量会带来额外的数值扩散，这种扩散无处不在，而我们真的希望将数值扩散的影响降到最低，只在需要稳定方案的地方应用它。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>因此，一个更好的选择是在模型中加入一些非线性粘度。从本质上讲，这样做的目的是将温度方程的形式从</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T &amp;=&amp; \gamma \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>到类似于</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot (\kappa+\nu(T)) \nabla T &amp;=&amp; \gamma, \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>其中 \(\nu(T)\) 是一个额外的粘度（扩散）项，只在冲击和其他不连续点附近发挥作用。 \(\nu(T)\) 的选择方式是，如果 \(T\) 满足原始方程，则额外的粘性为零。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>为了实现这一点，文献中包含了许多方法。我们在这里将遵循Guermond和Popov开发的一种方法，它建立在一个适当定义的残差和一个额外粘度的极限程序之上。为此，让我们定义一个残差 \(R_\alpha(T)\) 如下。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} R_\alpha(T) = \left( \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T - \gamma \right) T^{\alpha-1} \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>其中，我们以后将从 \([1,2]\) 范围内选择稳定指数 \(\alpha\) 。请注意，如果 \(T\) 满足温度方程， \(R_\alpha(T)\) 将为零，因为此时括号内的项将为零。将条款相乘，我们得到以下完全等同的形式。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} R_\alpha(T) = \frac 1\alpha \frac{\partial (T^\alpha)}{\partial t} + \frac 1\alpha {\mathbf u} \cdot \nabla (T^\alpha) - \frac 1\alpha \nabla \cdot \kappa \nabla (T^\alpha) + \kappa(\alpha-1) T^{\alpha-2} |\nabla T|^2 - \gamma T^{\alpha-1} \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>有了这个残差，我们现在可以把人工黏度定义为一个片状常数函数，在直径为 \(K\) 的每个单元上分别定义如下。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} \nu_\alpha(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} \min\left\{ h_K, h_K^\alpha \frac{\|R_\alpha(T)\|_{L^\infty(K)}}{c(\mathbf{u},T)} \right\} \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>这里， \(\beta\) 是一个稳定常数（通过维度分析发现它是无单位的，因此与比例无关；我们将在<a href="#Results">results section</a>中讨论其选择）， \(c(\mathbf{u},T)\) 是一个归一化常数，其单位必须是 \(\frac{m^{\alpha-1}K^\alpha}{s}\)  。我们将选择它作为 \(c(\mathbf{u},T) = c_R\ \|\mathbf{u}\|_{L^\infty(\Omega)} \ \mathrm{var}(T) \ |\mathrm{diam}(\Omega)|^{\alpha-2}\)  ，其中 \(\mathrm{var}(T)=\max_\Omega T - \min_\Omega T\) 是目前温度值的范围（记住，浮力是由温度变化驱动的，而不是绝对温度）， \(c_R\) 是一个无尺寸常数。为了理解这个方法为什么有效，请考虑这个问题。如果在一个特定的单元 \(K\) 上，温度场是平滑的，那么我们希望那里的残差很小（事实上是在 \({\cal O}(h_K)\) 的数量级上），注入人工扩散的稳定项在那里的大小将是 \(h_K^{\alpha+1}\) &amp;mdash；也就是说，相当小，就像我们希望它在没有必要进行额外扩散时那样。另一方面，如果我们处于或接近温度场的不连续性，那么残差将很大； \(\nu_\alpha(T)\) 定义中的最小操作将确保稳定项的大小为 \(h_K\) &amp;mdash；这是确保方案稳定的最佳人工粘性量。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>这种方案是否真的有效是个好问题。Guermond和Popov的计算表明，这种形式的稳定方案实际上比其他大多数稳定方案（例如流线扩散，仅举最简单的一种）表现得更好。此外，对于 \(\alpha\in [1,2)\) ，他们甚至可以证明，对于线性传输方程，它比流线扩散产生更好的收敛阶数。对于 \(\alpha=2\) ，目前还没有理论结果，但数值测试表明，其结果比 \(\alpha=1\) 好得多。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>一个更实际的问题是如何将这种人工扩散引入我们想要解决的方程。请注意，数值粘度 \(\nu(T)\) 是随温度变化的，所以我们要解决的方程在 \(T\) 中是非线性的&amp;mdash；这不是人们对稳定方程的简单方法的期望，如果我们意识到 \(\nu(T)\) 在 \(T\) 中是不可分的，那就更不可能了。然而，我们没有理由绝望：我们仍然要在时间上进行离散，我们可以明确地处理这个术语。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>在稳定参数的定义中，我们用 \(\frac{\partial T}{\partial t} \approx \frac{T^{n-1}-T^{n-2}}{k^{n-1}}\)  对时间导数进行近似。这种近似只利用了可用的时间数据，这就是我们需要存储前两个时间步骤的数据的原因（这使我们能够使用BDF-2方案而不需要额外的存储成本）。我们现在可以简单地在 \(t_{n-1}\) 处评估其余的项，但这样一来，离散残差无非是一个向后的欧拉近似，它只有一阶精度。因此，在平滑解的情况下，尽管外部BDF-2方案和空间FE离散化的时间精度为二阶，但残差仍为 \(h\) 阶。这当然不是我们想要的（事实上，我们希望在解决方案表现良好的区域有较小的残差），所以需要更谨慎一些。这个问题的关键是观察我们构造的第一导数实际上是以 \(t_{n-\frac{3}{2}}\) 为中心的。如果我们通过使用近似值 \(\frac 12 T^{n-1}+\frac 12 T^{n-2}\) 来评估 \(t_{n-\frac{3}{2}}\) 处的所有空间项，我们就可以得到所需的二阶精确残差计算，这意味着我们将非线性粘度计算为这个中间温度的函数， \(\nu_\alpha = \nu_\alpha\left(\frac 12 T^{n-1}+\frac 12 T^{n-2}\right)\)  。请注意，这种对残差的评估无非是一个Crank-Nicholson方案，所以我们可以肯定，现在一切正常了。人们可能会想，现在的数值粘度没有在时间 \(n\) 进行评估（相对于方程的其余部分），这是否是一个问题。然而，这种偏移是不严谨的。对于平滑解， \(\nu_\alpha\) 将连续变化，所以时间偏移的误差比非线性粘度本身要小 \(k\) 倍，也就是说，它是被遗漏的一个小的高阶贡献。这很好，因为该项本身已经达到了光滑区域的离散化误差水平。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>使用上面介绍的BDF-2方案，这就得到了更简单的大小为 \(k\) 的均匀时间步长的情况。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} \frac 32 T^n - k\nabla \cdot \kappa \nabla T^n &amp;=&amp; 2 T^{n-1} - \frac 12 T^{n-2} \\ &amp;&amp; + k\nabla \cdot \left[ \nu_\alpha\left(\frac 12 T^{n-1}+\frac 12 T^{n-2}\right) \ \nabla (2T^{n-1}-T^{n-2}) \right] \\ &amp;&amp; - k(2{\mathbf u}^{n-1}-{\mathbf u}^{n-2}) \cdot \nabla (2T^{n-1}-T^{n-2}) \\ &amp;&amp; + k\gamma. \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>在这个方程的左侧仍然是来自时间导数的项和我们隐含处理的原始（物理）扩散（这实际上是一个很好的项：从左侧产生的矩阵是质量矩阵和拉普拉斯矩阵的倍数&amp;mdash；两者都是正定的，如果时间步长 \(k\) 很小，和很容易反转）。在右侧，第一行的条款是时间导数的结果；第二行是时间 \(t_{n-\frac 32}\) 的人工扩散；第三行包含平流条款，第四行是来源。请注意，人工扩散对当前时间的外推温度的作用，与我们在时间步进一节中讨论的平流作用相同。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>我们在现实中必须使用的非均匀时间步长的形式要复杂一些（这就是为什么我们先展示了上面的简单形式），其内容为：。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} T^n - k_n\nabla \cdot \kappa \nabla T^n &amp;=&amp; \frac{k_n+k_{n-1}}{k_{n-1}} T^{n-1} - \frac{k_n^2}{k_{n-1}(k_n+k_{n-1})} T^{n-2} \\ &amp;&amp; + k_n\nabla \cdot \left[ \nu_\alpha\left(\frac 12 T^{n-1}+\frac 12 T^{n-2}\right) \ \nabla \left[ \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2} \right] \right] \\ &amp;&amp; - k_n \left[ \left(1+\frac{k_n}{k_{n-1}}\right){\mathbf u}^{n-1} - \frac{k_n}{k_{n-1}}{\mathbf u}^{n-2} \right] \cdot \nabla \left[ \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2} \right] \\ &amp;&amp; + k_n\gamma. \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>在解决了所有这些问题之后，弱形式自然而然地从最后一个方程中显示的强形式中产生，我们立即得出了离散化方程的弱形式。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} (\tau_h,T_h^n) + k_n (\nabla \tau_h, \kappa \nabla T_h^n) &amp;=&amp; \biggl(\tau_h, \frac{k_n+k_{n-1}}{k_{n-1}} T_h^{n-1} - \frac{k_n^2}{k_{n-1}(k_n+k_{n-1})} T_h^{n-2} \\ &amp;&amp;\qquad - k_n \left[ \left(1+\frac{k_n}{k_{n-1}}\right){\mathbf u}^{n-1} - \frac{k_n}{k_{n-1}}{\mathbf u}^{n-2} \right] \cdot \nabla \left[ \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2} \right] + k_n\gamma \biggr) \\ &amp;&amp; - k_n \left(\nabla \tau_h, \nu_\alpha\left(\frac 12 T_h^{n-1}+\frac 12 T_h^{n-2}\right) \ \nabla \left[ \left(1+\frac{k_n}{k_{n-1}}\right)T^{n-1}-\frac{k_n}{k_{n-1}}T^{n-2} \right] \right) \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>为所有离散测试函数 \(\tau_h\)  。在这里，扩散项已经被部分整合，我们已经使用，我们将施加没有热通量， \(\mathbf{n}\cdot\kappa\nabla T|_{\partial\Omega}=0\)  。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>这就产生了一个矩阵方程，其形式为</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} \left( \frac{2k_n+k_{n-1}}{k_n+k_{n-1}} M+k_n A_T\right) T_h^n = F(U_h^{n-1}, U_h^{n-2},T_h^{n-1},T_h^{n-2}), \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>考虑到左边的矩阵结构（两个正定矩阵之和），使用共轭梯度法很容易解决这个问题。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre><a class="anchor" id="Linearsolvers"></a><h4>Linear solvers</h4>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>如上所述，我们解决速度/压力和温度的联合系统的方法是使用算子分割，我们首先用旧的温度场解决速度和压力的斯托克斯系统，然后用刚刚计算的速度场解决新的温度场。关于算子分割方法的更广泛的讨论可以在步骤58中找到）。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre><a class="anchor" id="LinearsolversfortheStokesproblem"></a><h5>Linear solvers for the Stokes problem</h5>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre></pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>解决来自斯托克斯系统的线性方程已经在步骤22中进行了详细的讨论。特别是在该程序的结果部分，我们讨论了一些替代的线性求解器策略，结果发现这些策略比原来的方法更有效。在那里确定的最佳替代方案是使用一个由涉及舒尔补码的块状矩阵预处理的GMRES求解器。具体来说，斯托克斯算子导致了一个块状结构的矩阵</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>正如那里所讨论的，一个好的预处理程序是</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} P = \left(\begin{array}{cc} A &amp; 0 \\ B &amp; -S \end{array}\right), \qquad \text{or equivalently} \qquad P^{-1} = \left(\begin{array}{cc} A^{-1} &amp; 0 \\ S^{-1} B A^{-1} &amp; -S^{-1} \end{array}\right) \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>其中 \(S\) 是斯托克斯算子的舒尔补 \(S=B^TA^{-1}B\)  。当然，这个预处理程序是没有用的，因为我们不能形成矩阵的各种倒数，但我们可以用下面的方法作为预处理程序。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} \tilde P^{-1} = \left(\begin{array}{cc} \tilde A^{-1} &amp; 0 \\ \tilde S^{-1} B \tilde A^{-1} &amp; -\tilde S^{-1} \end{array}\right) \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>其中 \(\tilde A^{-1},\tilde S^{-1}\) 是反矩阵的近似值。特别是，事实证明 \(S\) 在光谱上等同于质量矩阵，因此，用适用于压力空间上的质量矩阵的CG求解器取代 \(\tilde S^{-1}\) 是一个不错的选择。与步骤22稍有不同的是，我们在这里的动量方程中有一个系数 \(\eta\) ，通过与那里相同的推导，我们应该得出结论，我们应该使用的是具有条目 \(\tilde S_{ij}=(\eta^{-1}\varphi_i,\varphi_j)\) 的加权质量矩阵。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>想出一个好的替代方案 \(\tilde A^{-1}\) 更为复杂，它对应于矢量值速度场的离散化对称拉普拉斯，即 \(A_{ij} = (\varepsilon {\mathbf v}_i, 2\eta \varepsilon ({\mathbf v}_j))\)  。在步骤22中，我们用 \(A\) 的稀疏LU分解（使用SparseDirectUMFPACK类）来代替 \(\tilde A^{-1}\) &mdash; 完美的前置条件&mdash; 在2D中，但对于3D来说，内存和计算时间通常不足以实际计算这个分解；因此，我们在3D中只使用不完全LU分解（ILU，使用稀疏ILU类）。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>对于这个项目，我们想走得更远一点。为此，请注意，矢量场上的对称化双线性形式 \((\varepsilon {\mathbf v}_i, 2 \eta \varepsilon ({\mathbf v}_j))\) 与非对称化版本 \((\nabla {\mathbf v}_i, \eta \nabla {\mathbf v}_j) = \sum_{k,l=1}^d (\partial_k ({\mathbf v}_i)_l, \eta \partial_k ({\mathbf v}_j)_l) \) 相差不大（请注意，在这个形式中因子2已经消失了）。然而，后者的优点是测试函数的 <code>dim</code> 矢量分量不是耦合的（好吧，几乎是，见下文），也就是说，得到的矩阵是块对角线的：每个矢量分量有一个块，这些块中的每个都等于这个矢量分量的拉普拉斯矩阵。因此，假设我们以这样的方式排列自由度，即首先对速度的所有 \(x\) 分量进行编号，然后是 \(y\) 分量，然后是 \(z\) 分量，那么与这种稍有不同的双线性形式相关的矩阵 \(\hat A\) 具有如下形式</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} \hat A = \left(\begin{array}{ccc} A_s &amp; 0 &amp; 0 \\ 0 &amp; A_s &amp; 0 \\ 0 &amp; 0 &amp; A_s \end{array}\right) \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>其中 \(A_s\) 是一个拉普拉斯矩阵，其大小等于与矢量值速度的每个分量相关的形状函数数量。有了这个矩阵，我们就可以对速度矩阵 \(A\) 的预处理进行如下定义。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre> <p class="formulaDsp">
\begin{eqnarray*} \tilde A^{-1} = \left(\begin{array}{ccc} \tilde A_s^{-1} &amp; 0 &amp; 0 \\ 0 &amp; \tilde A_s^{-1} &amp; 0 \\ 0 &amp; 0 &amp; \tilde A_s^{-1} \end{array}\right), \end{eqnarray*}
</p>
</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>其中 \(\tilde A_s^{-1}\) 是拉普拉斯矩阵的预处理程序&mdash;我们非常清楚如何建立良好的预处理程序!</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>在现实中，故事并不那么简单。为了使矩阵 \(\tilde A\) 确定，我们需要通过应用边界条件使各个块 \(\tilde A_s\) 确定。我们可以尝试通过在边界周围应用狄氏边界条件来做到这一点，然后，如果后者的矩阵是由斯托克斯问题产生的，我们在领域周围的速度分量上也有狄氏边界条件，即如果我们执行 \(\mathbf{u} = 0\) ，那么如此定义的前置条件 \(\tilde A^{-1}\) 就变成了 \(A\) 的良好前置条件。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>不幸的是，这个 "如果 "是 "如果且仅是如果"：在下面的程序中，我们将希望使用 \(\mathbf u \cdot \mathbf n = 0\) 形式的无流量边界条件（即允许与边界平行的流量，但没有通过边界的流量）。在这种情况下，事实证明，上面定义的块状对角线矩阵不是一个好的预处理程序，因为它忽略了边界上的成分耦合。因此，更好的方法是如果我们将矩阵 \(\hat A\) 建立为矢量拉普拉斯矩阵 \(\hat A_{ij} = (\nabla {\mathbf v}_i, \eta \nabla {\mathbf v}_j)\) ，然后应用与我们应用于 \(A\) 相同的边界条件。如果这是一个围绕域的迪里希特边界条件， \(\hat A\) 将像上面那样解耦为三个对角线块，如果边界条件是 \(\mathbf u \cdot \mathbf n = 0\) 的形式，那么这将在边界引入自由度的耦合，但只在那里。事实上，这被证明是一个比上面介绍的更好的预处理程序，而且几乎具有我们希望得到的所有好处。</pre><p></code></pre><p></code></p>
<p><code></p><pre><code><pre>总结这整个故事，我们可以看到。   <ul>
<li>
<p class="startli">与我们在步骤22中从对称梯度产生的原始矩阵 \(A\) 建立一个预处理程序相比，我们不得不期待基于拉普拉斯双线性形式的预处理程序表现得更差，因为它没有考虑到向量分量之间的耦合。
</p><pre class="fragment">&lt;li&gt; 另一方面，拉普拉斯矩阵的预处理程序通常比矢量问题的预处理程序更成熟，性能更好。例如，在写这篇文章的时候，代数%多重网格（AMG）算法对于标量问题已经非常成熟，但对于矢量问题却不是如此。

&lt;li&gt; 在建立这个预处理程序时，我们将不得不建立矩阵 \form#3683 及其预处理程序。虽然这意味着我们必须存储一个之前不需要的额外矩阵，但与存储耦合矩阵 \form#71 的预处理程序相比，预处理程序 \form#3687 可能需要的内存要少得多。这是因为矩阵 \form#3685 每行只有三分之一的条目对应于内部自由度，并且只在边界条件引入耦合的部分包含向量分量之间的耦合。因此，存储该矩阵是比较便宜的，我们可以预期，计算和存储预处理程序 \form#3689 也将比为完全耦合的矩阵做这些事情便宜得多。   &lt;/ul&gt; 
</pre><p><a class="anchor" id="Linearsolversforthetemperatureequation"></a></p><h5>Linear solvers for the temperature equation</h5>
<p></p>
<p>这是最容易的部分。温度方程的矩阵具有 \(\alpha M + \beta A\) 的形式，其中 \(M,A\) 是温度空间上的质量和刚度矩阵， \(\alpha,\beta\) 是与时间步进方案以及当前和前一个时间步进有关的常数。这是一个对称正定和一个对称正半定矩阵之和，其结果也是对称正定的。此外， \(\frac\beta\alpha\) 是一个与时间步长成正比的数字，因此只要网格很细就会变小，从而阻尼当时条件不好的刚度矩阵的影响。</p>
<p>因此，用共轭梯度算法反转这个矩阵，使用一个简单的预处理程序，与反转斯托克斯矩阵相比是微不足道和非常便宜的。</p>
<p><a class="anchor" id="Implementationdetails"></a></p><h3>Implementation details</h3>
<p></p>
<p><a class="anchor" id="UsingdifferentDoFHandlerobjects"></a></p><h4>Using different <a class="el" href="classDoFHandler.html">DoFHandler</a> objects</h4>
<p></p>
<p>关于下面的程序，值得事先解释的一件事是使用了两个不同的DoFHandler对象。如果看一下上述方程的结构和它们的求解方案，就会发现几乎没有什么共同点能使斯托克斯部分和温度部分保持一致。在我们以前讨论 <a class="el" href="group__vector__valued.html">矢量值问题 </a>的所有教程程序中，我们总是只使用一个具有几个矢量分量的单一有限元，以及一个DoFHandler对象。有时，我们将得到的矩阵分解成若干块，以方便特定的求解器方案；例如，在目前程序所依据的斯托克斯方程的第22步程序中就是如此。</p>
<p>当然，我们在这里也可以这样做。我们将得到的线性系统看起来像这样。</p>
<p class="formulaDsp">
\begin{eqnarray*} \left(\begin{array}{ccc} A &amp; B^T &amp; 0 \\ B &amp; 0 &amp;0 \\ C &amp; 0 &amp; K \end{array}\right) \left(\begin{array}{ccc} U^{n-1} \\ P^{n-1} \\ T^n \end{array}\right) = \left(\begin{array}{ccc} F_U(T^{n-1}) \\ 0 \\ F_T(U^{n-1},U^{n-2},T^{n-1},T^{n-2}) \end{array}\right). \end{eqnarray*}
</p>
<p>这方面的问题是。我们从未同时使用整个矩阵。事实上，它从未真正同时存在。如上所述， \(K\) 和 \(F_T\) 依赖于已经计算出的解 \(U^n\) ，在第一种情况下，通过时间步长（这依赖于 \(U^n\) ，因为它必须满足CFL条件）。所以我们只有在已经解决了左上角 \(2\times 2\) 块斯托克斯系统后才能组装它，一旦我们转向温度方程，我们就不再需要斯托克斯部分了；我们为一个在任何时候都不会以整体存在于内存中的矩阵建立一个对象，这导致我们在步骤21中跳了一些圈套，所以我们不要重复这类错误。此外，我们实际上并没有建立矩阵 \(C\) ：因为当我们进入温度方程时，我们已经知道了 \(U^n\) ，而且因为我们必须在这个时候组装右手边的 \(F_T\) ，我们只是将项 \(CU^n\) 移到右手边，并将其与所有其他项组装在一起。这意味着矩阵中不存在温度变量和斯托克斯变量耦合的部分，因此所有自由度的全局列举不再重要：如果我们有所有斯托克斯自由度的列举，以及所有温度自由度的独立列举就足够了。</p>
<p>从本质上讲，将<em>everything</em>放入一个块状矩阵中并没有什么用处（当然，对于 \(2\times 2\) 斯托克斯部分，也有同样好的理由这样做），或者，就这一点而言，将所有东西放入同一个DoFHandler对象。</p>
<p>但这样做是否有<em>downsides</em>的好处？这些问题是存在的，尽管它们一开始可能并不明显。主要问题是，如果我们需要创建一个包含速度、压力和温度形状函数的全局有限元，并使用它来初始化DoFHandler。但是我们也用这个有限元对象来初始化我们使用的所有FEValues或FEFaceValues对象。这可能看起来不是什么大问题，但是想象一下，例如，当我们评估我们需要计算人工粘度 \( R_\alpha(T) = \left( \frac{\partial T}{\partial t} + {\mathbf u} \cdot \nabla T - \nabla \cdot \kappa \nabla T - \gamma \right) T^{\alpha-1} \) 的残差 \(\nu_\alpha(T)|_K\) 时会发生什么。  为此，我们需要温度的拉普拉斯，我们使用形状函数的二阶导数（Hessians）张量来计算（为此我们必须给FEValues对象加上 <code>update_hessians</code> 标志）。现在，如果我们有一个包含速度、压力和温度的形状函数的有限性，这意味着我们必须计算<em>all</em>形状函数的Hessians，包括速度的许多高阶形状函数。这是很多我们不需要的计算，事实上，如果一个人要这样做（就像我们在程序的早期版本中那样），组装右手边需要大约四分之一的整体计算时间。</p>
<p>所以我们要做的是使用两个不同的有限元对象，一个用于斯托克斯成分，一个用于温度。这样就有两个不同的DoFHandlers，两个稀疏模式和两个用于斯托克斯和温度部分的矩阵，等等。每当我们要组装包含温度和斯托克斯形状函数的东西时（特别是斯托克斯和温度方程的右侧），我们就使用两个FEValues对象，用两个单元格迭代器进行初始化，通过与同一三角化对象相关的两个DoFHandler对象进行平行行走。对于这两个FEValues对象，我们当然使用相同的正交对象，这样我们就可以在同一组正交点上进行迭代，但是每个FEValues对象将只根据它实际需要计算的内容来获得更新标志。特别是，当我们像上面那样计算残差时，我们只要求得到斯托克斯形状函数的值，但也要求得到温度形状函数的Hessians &amp;mdash；确实便宜得多，而且事实证明：组装温度方程的右手边现在是程序中几乎无法测量的一个组成部分。</p>
<p>有了这些变化，对程序进行计时，可以得出只有以下操作与整个运行时间有关。   </p><ul>
<li>
解决斯托克斯系统：72的运行时间。     </li>
<li>
组装斯托克斯预处理程序，并使用Trilinos ML包计算代数多网格层次结构：占运行时间的11。     </li>
<li>
函数  <code>BoussinesqFlowProblem::setup_dofs</code>  : 占整体运行时间的7。     </li>
<li>
组装斯托克斯和温度右侧向量以及组装矩阵。7%.   </li>
</ul>
<p>实质上这意味着除了代数多重网格之外，所有的瓶颈都已经被移除。</p>
<p><a class="anchor" id="UsingTrilinos"></a></p><h4>Using Trilinos</h4>
<p></p>
<p>与我们在第17步和第18步中使用PETSc来支持我们的线性代数需求一样，我们在这个程序中使用了<a href="http://trilinos.org">Trilinos</a>库的接口（安装说明见deal.II README文件）。Trilinos是一个非常大的集合，包括与线性和非线性代数有关的所有东西，以及围绕这些东西的各种工具（看起来它在未来也会向许多其他方向发展）。</p>
<p>使用Trilinos的主要原因，类似于我们探索的PETSc，是它是一个非常强大的库，比deal.II自己的线性代数库提供了很多工具。这尤其包括在集群上以parallel方式工作的能力，使用MPI，以及更多种类的前置条件器。在后一类中，最有趣的能力之一是Trilinos ML包的存在，它实现了代数多栅（AMG）方法。我们将使用这个预处理程序对动量方程的二阶算子部分进行预处理。在步骤32中，我们将使用与这里讨论的相同的问题，探索以并行方式解决问题的能力。</p>
<p>我们在第17步和第18步中使用的PETSc无疑是一个强大的库，它提供了大量处理矩阵、向量、迭代求解器和预处理器的函数，还有很多其他的东西，其中大部分在parallel中运行得相当好。然而，它比Trilinos早了几年，是用C语言编写的，而且一般来说不像其他一些库那样容易使用。因此，deal.II也获得了与Trilinos的接口，Trilinos与PETSc有很多相同的功能。然而，它是一个年轻了好几年的项目，是用C++编写的，其作者一般都非常重视软件设计。</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The testcase</h3>
<p></p>
<p>我们在这里要解决的情况如下：我们用 \(\kappa=10^{-6}, \eta=1, \rho=1, \beta=10\) 来解决上述的Boussinesq方程，即一个相对缓慢运动的流体，它几乎没有热扩散传导性，主要通过对流来传输热量。在边界上，我们将要求速度（ \(\mathrm{n}\cdot\mathrm{u}=0\) ）和温度（ \(\mathrm{n}\cdot\nabla T=0\) ）没有正态流量。这是在步骤22的介绍中讨论的情况之一，它固定了速度的一个分量，同时允许流动与边界平行。还有 <code>dim-1</code> 分量需要固定，即法向应力的切向分量；对于这些分量，我们选择同质条件，这意味着我们不需要任何特殊条件。初始条件只对温度场是必要的，我们选择它为恒定的零。</p>
<p>然后，问题的演变完全由温度方程的右手边 \(\gamma(\mathrm{x},t)\) 驱动，即由热源和汇驱动。在这里，我们选择了一个在圣诞讲座前发明的设置：美国的教室里当然禁止使用真实的蜡烛，但允许使用虚拟的蜡烛。因此，我们选择了三个球形的热源，不等距地靠近领域的底部，模仿三个蜡烛的样子。位于这些热源处的流体，最初处于静止状态，然后被加热，随着温度的升高，获得浮力，上升；更多的流体被拖上来，穿过热源，导致三个热羽上升，直到它们被外面下沉的流体循环所捕获，取代了因加热而上升的空气。</p>
<p><a class="anchor" id="CommProg"></a>
   </p><h1>The commented program</h1>
<p></p>
<p><a class="anchor" id="Includefiles"></a> 
   </p><h3>Include files</h3>
<p></p>
<p>The first step, as always, is to include the functionality of these
   well-known deal.II library files and some C++ header files.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div></div><!-- fragment --><p>Then we need to include some header files that provide vector, matrix, and
   preconditioner classes that implement interfaces to the respective Trilinos
   classes. In particular, we will need interfaces to the matrix and vector
   classes based on Trilinos as well as Trilinos preconditioners:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, here are a few C++ headers that haven't been included yet by one of
   the aforelisted header files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div></div><!-- fragment --><p>At the end of this top-matter, we import all deal.II names into the global
   namespace:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step31</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> 
   </p><h3>Equation data</h3>
<p></p>
<p>Again, the next stage in the program is the definition of the equation
   data, that is, the various boundary conditions, the right hand sides and
   the initial condition (remember that we're about to solve a
   time-dependent system). The basic strategy for this definition is the
   same as in <a class="el" href="step_22.html">step-22</a>. Regarding the details, though, there are some
   differences.</p>
<p>The first thing is that we don't set any inhomogeneous boundary
   conditions on the velocity, since as is explained in the introduction we
   will use no-flux conditions \(\mathbf{n}\cdot\mathbf{u}=0\). So what is
   left are <code>dim-1</code> conditions for the tangential part of the
   normal component of the stress tensor, \(\textbf{n} \cdot [p \textbf{1} - \eta\varepsilon(\textbf{u})]\); we assume homogeneous values for these
   components, i.e., a natural boundary condition that requires no specific
   action (it appears as a zero term in the right hand side of the weak
   form).</p>
<p>For the temperature \(T\), we assume no thermal energy flux,
   i.e., \(\mathbf{n} \cdot \kappa \nabla T=0\). This, again, is a boundary
   condition that does not require us to do anything in particular.</p>
<p>Secondly, we have to set initial conditions for the temperature (no
   initial conditions are required for the velocity and pressure, since the
   Stokes equations for the quasi-stationary case we consider here have no
   time derivatives of the velocity or pressure). Here, we choose a very
   simple test case, where the initial temperature is zero, and all dynamics
   are driven by the temperature right hand side.</p>
<p>Thirdly, we need to define the right hand side of the temperature
   equation. We choose it to be constant within three circles (or spheres in
   3d) somewhere at the bottom of the domain, as explained in the
   introduction, and zero outside.</p>
<p>Finally, or maybe firstly, at the top of this namespace, we define the
   various material constants we need ( \(\eta,\kappa\), density \(\rho\) and the
   thermal expansion coefficient \(\beta\)):</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>EquationData</div><div class="line">{</div><div class="line">  constexpr <span class="keywordtype">double</span> eta     = 1;</div><div class="line">  constexpr <span class="keywordtype">double</span> kappa   = 1e-6;</div><div class="line">  constexpr <span class="keywordtype">double</span> beta    = 10;</div><div class="line">  constexpr <span class="keywordtype">double</span> density = 1;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TemperatureInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TemperatureInitialValues()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">        value(c) = TemperatureInitialValues&lt;dim&gt;::value(p, c);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>TemperatureRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    TemperatureRightHandSide()</div><div class="line">      : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      (void)component;</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0,</div><div class="line">             <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Invalid operation for a scalar function.&quot;</span>));</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((dim == 2) || (dim == 3), <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">      <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> source_centers[3] = {</div><div class="line">        (dim == 2 ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(.3, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.3, .5, .1)),</div><div class="line">        (dim == 2 ? <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.45, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.45, .5, .1)),</div><div class="line">        (dim == 2 ? <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.75, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.75, .5, .1))};</div><div class="line">      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> source_radius = (dim == 2 ? 1. / 32 : 1. / 8);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> ((source_centers[0].distance(p) &lt; source_radius) ||</div><div class="line">                  (source_centers[1].<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(p) &lt; source_radius) ||</div><div class="line">                  (source_centers[2].distance(p) &lt; source_radius) ?</div><div class="line">                1 :</div><div class="line">                0);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                              <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;  value)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">        value(c) = TemperatureRightHandSide&lt;dim&gt;::value(p, c);</div><div class="line">    }</div><div class="line">  };</div><div class="line">} <span class="comment">// namespace EquationData</span></div></div><!-- fragment --><p><a class="anchor" id="Linearsolversandpreconditioners"></a> 
   </p><h3>Linear solvers and preconditioners</h3>
<p></p>
<p>This section introduces some objects that are used for the solution of
   the linear equations of the Stokes system that we need to solve in each
   time step. Many of the ideas used here are the same as in <a class="el" href="step_20.html">step-20</a>, where
   Schur complement based preconditioners and solvers have been introduced,
   with the actual interface taken from <a class="el" href="step_22.html">step-22</a> (in particular the
   discussion in the "Results" section of <a class="el" href="step_22.html">step-22</a>, in which we introduce
   alternatives to the direct Schur complement approach). Note, however,
   that here we don't use the Schur complement to solve the Stokes
   equations, though an approximate Schur complement (the mass matrix on the
   pressure space) appears in the preconditioner.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>LinearSolvers</div><div class="line">{</div></div><!-- fragment --><p><a class="anchor" id="ThecodeInverseMatrixcodeclasstemplate"></a> 
   </p><h4>The <code>InverseMatrix</code> class template</h4>
<p></p>
<p>This class is an interface to calculate the action of an "inverted"
   matrix on a vector (using the <code>vmult</code> operation) in the same
   way as the corresponding class in <a class="el" href="step_22.html">step-22</a>: when the product of an
   object of this class is requested, we solve a linear equation system
   with that matrix using the CG method, accelerated by a preconditioner
   of (templated) class <code>PreconditionerType</code>.</p>
<p>In a minor deviation from the implementation of the same class in
   <a class="el" href="step_22.html">step-22</a>, we make the <code>vmult</code> function take any
   kind of vector type (it will yield compiler errors, however, if the
   matrix does not allow a matrix-vector product with this kind of
   vector).</p>
<p>Secondly, we catch any exceptions that the solver may have thrown. The
   reason is as follows: When debugging a program like this one
   occasionally makes a mistake of passing an indefinite or nonsymmetric
   matrix or preconditioner to the current class. The solver will, in that
   case, not converge and throw a run-time exception. If not caught here
   it will propagate up the call stack and may end up in
   <code>main()</code> where we output an error message that will say that
   the CG solver failed. The question then becomes: Which CG solver? The
   one that inverted the mass matrix? The one that inverted the top left
   block with the Laplace operator? Or a CG solver in one of the several
   other nested places where we use linear solvers in the current code? No
   indication about this is present in a run-time exception because it
   doesn't store the stack of calls through which we got to the place
   where the exception was generated.</p>
<p>So rather than letting the exception propagate freely up to
   <code>main()</code> we realize that there is little that an outer
   function can do if the inner solver fails and rather convert the
   run-time exception into an assertion that fails and triggers a call to
   <code><a class="el" href="namespacedeal__II__exceptions_1_1internals.html#a600f8f191a6ce368afda0074dd7ea1dc">abort()</a></code>, allowing us to trace back in a debugger how we
   got to the current place.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classVectorType.html">VectorType</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">  <span class="keyword">const</span> PreconditionerType &amp;           preconditioner;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">  <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">  <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">  : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">  , preconditioner(preconditioner)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line"><span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">  <a class="code" href="classVectorType.html">VectorType</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>        solver_control(src.size(), 1e-7 * src.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;VectorType&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">  dst = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, preconditioner);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;e)</div><div class="line">    {</div><div class="line">      <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(e.what()));</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Schurcomplementpreconditioner"></a> 
   </p><h4>Schur complement preconditioner</h4>
<p></p>
<p>This is the implementation of the Schur complement preconditioner as
   described in detail in the introduction. As opposed to <a class="el" href="step_20.html">step-20</a> and
   <a class="el" href="step_22.html">step-22</a>, we solve the block system all-at-once using GMRES, and use the
   Schur complement of the block structured matrix to build a good
   preconditioner instead.</p>
<p>Let's have a look at the ideal preconditioner matrix
 \(P=\left(\begin{array}{cc} A &amp; 0 \\ B &amp; -S \end{array}\right)\)
   described in the introduction. If we apply this matrix in the solution
   of a linear system, convergence of an iterative GMRES solver will be
   governed by the matrix </p><p class="formulaDsp">
\begin{eqnarray*} P^{-1}\left(\begin{array}{cc} A &amp; B^T \\ B &amp; 0 \end{array}\right) = \left(\begin{array}{cc} I &amp; A^{-1} B^T \\ 0 &amp; I \end{array}\right), \end{eqnarray*}
</p>
<p> which indeed is very simple. A
   GMRES solver based on exact matrices would converge in one iteration,
   since all eigenvalues are equal (any Krylov method takes at most as
   many iterations as there are distinct eigenvalues). Such a
   preconditioner for the blocked Stokes system has been proposed by
   Silvester and Wathen ("Fast iterative solution of stabilised Stokes
   systems part II.  Using general block preconditioners", SIAM
   J. Numer. Anal., 31 (1994), pp. 1352-1367).</p>
<p>Replacing \(P\) by \(\tilde{P}\) keeps that spirit alive: the product
 \(P^{-1} A\) will still be close to a matrix with eigenvalues 1 with a
   distribution that does not depend on the problem size. This lets us
   hope to be able to get a number of GMRES iterations that is
   problem-size independent.</p>
<p>The deal.II users who have already gone through the <a class="el" href="step_20.html">step-20</a> and <a class="el" href="step_22.html">step-22</a>
   tutorials can certainly imagine how we're going to implement this.  We
   replace the exact inverse matrices in \(P^{-1}\) by some approximate
   inverses built from the InverseMatrix class, and the inverse Schur
   complement will be approximated by the pressure mass matrix \(M_p\)
   (weighted by \(\eta^{-1}\) as mentioned in the introduction). As pointed
   out in the results section of <a class="el" href="step_22.html">step-22</a>, we can replace the exact inverse
   of \(A\) by just the application of a preconditioner, in this case
   on a vector Laplace matrix as was explained in the introduction. This
   does increase the number of (outer) GMRES iterations, but is still
   significantly cheaper than an exact inverse, which would require
   between 20 and 35 CG iterations for <em>each</em> outer solver step
   (using the AMG preconditioner).</p>
<p>Having the above explanations in mind, we define a preconditioner class
   with a <code>vmult</code> functionality, which is all we need for the
   interaction with the usual solver functions further below in the
   program code.</p>
<p>First the declarations. These are similar to the definition of the
   Schur complement in <a class="el" href="step_20.html">step-20</a>, with the difference that we need some more
   preconditioners in the constructor and that the matrices we use here
   are built upon Trilinos:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line"><span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BlockSchurPreconditioner(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                        PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">    <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> vmult(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">             <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">    stokes_matrix;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;<span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                         PreconditionerTypeMp&gt;&gt;</div><div class="line">                             m_inverse;</div><div class="line">  <span class="keyword">const</span> PreconditionerTypeA &amp;a_preconditioner;</div><div class="line"></div><div class="line">  <span class="keyword">mutable</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp;</div><div class="line">};</div></div><!-- fragment --><p>When using a <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> or a
   <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>, the <a class="el" href="classVector.html">Vector</a> is initialized using an
   <a class="el" href="classIndexSet.html">IndexSet</a>. <a class="el" href="classIndexSet.html">IndexSet</a> is used not only to resize the
   <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> but it also associates an index in the
   <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> with a degree of freedom (see <a class="el" href="step_40.html">step-40</a> for
   a more detailed explanation). The function <a class="el" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set()</a> creates
   an <a class="el" href="classIndexSet.html">IndexSet</a> where every valid index is part of the set. Note that this
   program can only be run sequentially and will throw an exception if used
   in parallel.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::</div><div class="line">  BlockSchurPreconditioner(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">    <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                        PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">    <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner)</div><div class="line">  : stokes_matrix(&amp;S)</div><div class="line">  , m_inverse(&amp;Mpinv)</div><div class="line">  , a_preconditioner(Apreconditioner)</div><div class="line">  , tmp(<a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(stokes_matrix-&gt;block(1, 1).m()))</div><div class="line">{}</div></div><!-- fragment --><p>Next is the <code>vmult</code> function. We implement the action of
 \(P^{-1}\) as described above in three successive steps.  In formulas, we
   want to compute \(Y=P^{-1}X\) where \(X,Y\) are both vectors with two block
   components.</p>
<p>The first step multiplies the velocity part of the vector by a
   preconditioner of the matrix \(A\), i.e., we compute \(Y_0={\tilde A}^{-1}X_0\).  The resulting velocity vector is then multiplied by \(B\)
   and subtracted from the pressure, i.e., we want to compute \(X_1-BY_0\).
   This second step only acts on the pressure vector and is accomplished
   by the residual function of our matrix classes, except that the sign is
   wrong. Consequently, we change the sign in the temporary pressure
   vector and finally multiply by the inverse pressure mass matrix to get
   the final pressure vector, completing our work on the Stokes
   preconditioner:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::vmult(</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    a_preconditioner.vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">    stokes_matrix-&gt;block(1, 0).residual(tmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">    tmp *= -1;</div><div class="line">    m_inverse-&gt;vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace LinearSolvers</span></div></div><!-- fragment --><p><a class="anchor" id="ThecodeBoussinesqFlowProblemcodeclasstemplate"></a> 
   </p><h3>The <code>BoussinesqFlowProblem</code> class template</h3>
<p></p>
<p>The definition of the class that defines the top-level logic of solving
   the time-dependent Boussinesq problem is mainly based on the <a class="el" href="step_22.html">step-22</a>
   tutorial program. The main differences are that now we also have to solve
   for the temperature equation, which forces us to have a second <a class="el" href="classDoFHandler.html">DoFHandler</a>
   object for the temperature variable as well as matrices, right hand
   sides, and solution vectors for the current and previous time steps. As
   mentioned in the introduction, all linear algebra objects are going to
   use wrappers of the corresponding Trilinos functionality.</p>
<p>The member functions of this class are reminiscent of <a class="el" href="step_21.html">step-21</a>, where we
   also used a staggered scheme that first solve the flow equations (here
   the Stokes equations, in <a class="el" href="step_21.html">step-21</a> Darcy flow) and then update the advected
   quantity (here the temperature, there the saturation). The functions that
   are new are mainly concerned with determining the time step, as well as
   the proper size of the artificial viscosity stabilization.</p>
<p>The last three variables indicate whether the various matrices or
   preconditioners need to be rebuilt the next time the corresponding build
   functions are called. This allows us to move the corresponding
   <code>if</code> into the respective function and thereby keeping our main
   <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function clean and easy to read.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoussinesqFlowProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoussinesqFlowProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>   setup_dofs();</div><div class="line">  <span class="keywordtype">void</span>   assemble_stokes_preconditioner();</div><div class="line">  <span class="keywordtype">void</span>   build_stokes_preconditioner();</div><div class="line">  <span class="keywordtype">void</span>   assemble_stokes_system();</div><div class="line">  <span class="keywordtype">void</span>   assemble_temperature_system(<span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity);</div><div class="line">  <span class="keywordtype">void</span>   assemble_temperature_matrix();</div><div class="line">  <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div><div class="line">  std::pair&lt;double, double&gt; get_extrapolated_temperature_range() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span>                      solve();</div><div class="line">  <span class="keywordtype">void</span>                      output_results() <span class="keyword">const</span>;</div><div class="line">  <span class="keywordtype">void</span>                      refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> compute_viscosity(</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        gamma_values,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_u_infty,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_T_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <span class="keywordtype">double</span>             global_Omega_diameter;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        stokes_degree;</div><div class="line">  <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             stokes_fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           stokes_dof_handler;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> stokes_constraints;</div><div class="line"></div><div class="line">  std::vector&lt;IndexSet&gt;               stokes_partitioning;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_matrix;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_preconditioner_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_stokes_solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_rhs;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        temperature_degree;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 temperature_fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           temperature_dof_handler;</div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> temperature_constraints;</div><div class="line"></div><div class="line">  TrilinosWrappers::SparseMatrix temperature_mass_matrix;</div><div class="line">  TrilinosWrappers::SparseMatrix temperature_stiffness_matrix;</div><div class="line">  TrilinosWrappers::SparseMatrix temperature_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_temperature_solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_temperature_solution;</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_rhs;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordtype">double</span>       time_step;</div><div class="line">  <span class="keywordtype">double</span>       old_time_step;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">  std::shared_ptr&lt;TrilinosWrappers::PreconditionAMG&gt; Amg_preconditioner;</div><div class="line">  std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt;  Mp_preconditioner;</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> rebuild_stokes_matrix;</div><div class="line">  <span class="keywordtype">bool</span> rebuild_temperature_matrices;</div><div class="line">  <span class="keywordtype">bool</span> rebuild_stokes_preconditioner;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemclassimplementation"></a> 
   </p><h3>BoussinesqFlowProblem class implementation</h3>
<p></p>
<p><a class="anchor" id="BoussinesqFlowProblemBoussinesqFlowProblem"></a> 
   </p><h4>BoussinesqFlowProblem::BoussinesqFlowProblem</h4>
<p></p>
<p>The constructor of this class is an extension of the constructor in
   <a class="el" href="step_22.html">step-22</a>. We need to add the various variables that concern the
   temperature. As discussed in the introduction, we are going to use
 \(Q_2\times Q_1\) (Taylor-Hood) elements again for the Stokes part, and
 \(Q_2\) elements for the temperature. However, by using variables that
   store the polynomial degree of the Stokes and temperature finite
   elements, it is easy to consistently modify the degree of the elements as
   well as all quadrature formulas used on them downstream. Moreover, we
   initialize the time stepping as well as the options for matrix assembly
   and preconditioning:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::BoussinesqFlowProblem()</div><div class="line">  : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">  , global_Omega_diameter(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">  , stokes_degree(1)</div><div class="line">  , stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree), 1)</div><div class="line">  , stokes_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  temperature_degree(2)</div><div class="line">  , temperature_fe(temperature_degree)</div><div class="line">  , temperature_dof_handler(triangulation)</div><div class="line">  ,</div><div class="line"></div><div class="line">  time_step(0)</div><div class="line">  , old_time_step(0)</div><div class="line">  , timestep_number(0)</div><div class="line">  , rebuild_stokes_matrix(true)</div><div class="line">  , rebuild_temperature_matrices(true)</div><div class="line">  , rebuild_stokes_preconditioner(true)</div><div class="line">{}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemget_maximal_velocity"></a> 
   </p><h4>BoussinesqFlowProblem::get_maximal_velocity</h4>
<p></p>
<p>Starting the real functionality of this class is a helper function that
   determines the maximum ( \(L_\infty\)) velocity in the domain (at the
   quadrature points, in fact). How it works should be relatively obvious to
   all who have gotten to this point of the tutorial. Note that since we are
   only interested in the velocity, rather than using
   <code>stokes_fe_values.get_function_values</code> to get the values of
   the entire Stokes solution (velocities and pressures) we use
   <code>stokes_fe_values[velocities].get_function_values</code> to extract
   only the velocities part. This has the additional benefit that we get it
   as a <a class="el" href="classTensor.html">Tensor&lt;1,dim&gt;</a>, rather than some components in a <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>,
   allowing us to process it right away using the <code><a class="el" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm()</a></code>
   function to get the magnitude of the velocity.</p>
<p>The only point worth thinking about a bit is how to choose the quadrature
   points we use here. Since the goal of this function is to find the
   maximal velocity over a domain by looking at quadrature points on each
   cell. So we should ask how we should best choose these quadrature points
   on each cell. To this end, recall that if we had a single \(Q_1\) field
   (rather than the vector-valued field of higher order) then the maximum
   would be attained at a vertex of the mesh. In other words, we should use
   the <a class="el" href="classQTrapezoid.html">QTrapezoid</a> class that has quadrature points only at the vertices of
   cells.</p>
<p>For higher order shape functions, the situation is more complicated: the
   maxima and minima may be attained at points between the support points of
   shape functions (for the usual \(Q_p\) elements the support points are the
   equidistant Lagrange interpolation points); furthermore, since we are
   looking for the maximum magnitude of a vector-valued quantity, we can
   even less say with certainty where the set of potential maximal points
   are. Nevertheless, intuitively if not provably, the Lagrange
   interpolation points appear to be a better choice than the Gauss points.</p>
<p>There are now different methods to produce a quadrature formula with
   quadrature points equal to the interpolation points of the finite
   element. One option would be to use the
   <a class="el" href="classFiniteElement.html#a5b35a290aa7dd7562911a92a13b11fee">FiniteElement::get_unit_support_points()</a> function, reduce the output to a
   unique set of points to avoid duplicate function evaluations, and create
   a <a class="el" href="classQuadrature.html">Quadrature</a> object using these points. Another option, chosen here, is
   to use the <a class="el" href="classQTrapezoid.html">QTrapezoid</a> class and combine it with the <a class="el" href="classQIterated.html">QIterated</a> class that
   repeats the <a class="el" href="classQTrapezoid.html">QTrapezoid</a> formula on a number of sub-cells in each coordinate
   direction. To cover all support points, we need to iterate it
   <code>stokes_degree+1</code> times since this is the polynomial degree of
   the Stokes element in use:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(), stokes_degree + 1);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(stokes_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points);</div><div class="line">  <span class="keywordtype">double</span>                      max_velocity = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(stokes_solution,</div><div class="line">                                                velocity_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity, velocity_values[q].<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> max_velocity;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemget_extrapolated_temperature_range"></a> 
   </p><h4>BoussinesqFlowProblem::get_extrapolated_temperature_range</h4>
<p></p>
<p>Next a function that determines the minimum and maximum temperature at
   quadrature points inside \(\Omega\) when extrapolated from the two previous
   time steps to the current one. We need this information in the
   computation of the artificial viscosity parameter \(\nu\) as discussed in
   the introduction.</p>
<p>The formula for the extrapolated temperature is
 \(\left(1+\frac{k_n}{k_{n-1}} \right)T^{n-1} + \frac{k_n}{k_{n-1}} T^{n-2}\). The way to compute it is to loop over all quadrature points and
   update the maximum and minimum value if the current value is
   bigger/smaller than the previous one. We initialize the variables that
   store the max and min before the loop over all quadrature points by the
   smallest and the largest number representable as a double. Then we know
   for a fact that it is larger/smaller than the minimum/maximum and that
   the loop over all quadrature points is ultimately going to update the
   initial value with the correct one.</p>
<p>The only other complication worth mentioning here is that in the first
   time step, \(T^{k-2}\) is not yet available of course. In that case, we can
   only use \(T^{k-1}\) which we have from the initial temperature. As
   quadrature points, we use the same choice as in the previous function
   though with the difference that now the number of repetitions is
   determined by the polynomial degree of the temperature field.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">std::pair&lt;double, double&gt;</div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::get_extrapolated_temperature_range()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                          temperature_degree);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(temperature_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">  std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">  std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">             max_temperature = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                        old_temperature_values);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_temperature_solution,</div><div class="line">                                        old_old_temperature_values);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> temperature =</div><div class="line">                (1. + time_step / old_time_step) * old_temperature_values[q] -</div><div class="line">                time_step / old_time_step * old_old_temperature_values[q];</div><div class="line"></div><div class="line">              min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_temperature, temperature);</div><div class="line">              max_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_temperature, temperature);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> std::make_pair(min_temperature, max_temperature);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      <span class="keywordtype">double</span> min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">             max_temperature = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                        old_temperature_values);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> temperature = old_temperature_values[q];</div><div class="line"></div><div class="line">              min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_temperature, temperature);</div><div class="line">              max_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_temperature, temperature);</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> std::make_pair(min_temperature, max_temperature);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemcompute_viscosity"></a> 
   </p><h4>BoussinesqFlowProblem::compute_viscosity</h4>
<p></p>
<p>The last of the tool functions computes the artificial viscosity
   parameter \(\nu|_K\) on a cell \(K\) as a function of the extrapolated
   temperature, its gradient and Hessian (second derivatives), the velocity,
   the right hand side \(\gamma\) all on the quadrature points of the current
   cell, and various other parameters as described in detail in the
   introduction.</p>
<p>There are some universal constants worth mentioning here. First, we need
   to fix \(\beta\); we choose \(\beta=0.017\cdot dim\), a choice discussed in
   detail in the results section of this tutorial program. The second is the
   exponent \(\alpha\); \(\alpha=1\) appears to work fine for the current
   program, even though some additional benefit might be expected from
   choosing \(\alpha = 2\). Finally, there is one thing that requires special
   casing: In the first time step, the velocity equals zero, and the formula
   for \(\nu|_K\) is not defined. In that case, we return \(\nu|_K=5\cdot 10^3 \cdot h_K\), a choice admittedly more motivated by heuristics than
   anything else (it is in the same order of magnitude, however, as the
   value returned for most cells on the second time step).</p>
<p>The rest of the function should be mostly obvious based on the material
   discussed in the introduction:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::compute_viscosity(</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        gamma_values,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_u_infty,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_T_variation,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  constexpr <span class="keywordtype">double</span> beta  = 0.017 * dim;</div><div class="line">  constexpr <span class="keywordtype">double</span> alpha = 1.0;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (global_u_infty == 0)</div><div class="line">    <span class="keywordflow">return</span> 5e-3 * cell_diameter;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_temperature.size();</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> max_residual = 0;</div><div class="line">  <span class="keywordtype">double</span> max_velocity = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u =</div><div class="line">        (old_velocity_values[q] + old_old_velocity_values[q]) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> dT_dt =</div><div class="line">        (old_temperature[q] - old_old_temperature[q]) / old_time_step;</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_T =</div><div class="line">        u * (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> kappa_Delta_T =</div><div class="line">        EquationData::kappa *</div><div class="line">        (old_temperature_laplacians[q] + old_old_temperature_laplacians[q]) /</div><div class="line">        2;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> residual =</div><div class="line">        <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>((dT_dt + u_grad_T - kappa_Delta_T - gamma_values[q]) *</div><div class="line">                 std::pow((old_temperature[q] + old_old_temperature[q]) / 2,</div><div class="line">                          alpha - 1.));</div><div class="line"></div><div class="line">      max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div><div class="line">      max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u * u), max_velocity);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> c_R            = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2., (4. - 2 * alpha) / dim);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> global_scaling = c_R * global_u_infty * global_T_variation *</div><div class="line">                                <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(global_Omega_diameter, alpha - 2.);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> (</div><div class="line">    beta * max_velocity *</div><div class="line">    <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(cell_diameter,</div><div class="line">             std::pow(cell_diameter, alpha) * max_residual / global_scaling));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemsetup_dofs"></a> 
   </p><h4>BoussinesqFlowProblem::setup_dofs</h4>
<p></p>
<p>This is the function that sets up the <a class="el" href="classDoFHandler.html">DoFHandler</a> objects we have here
   (one for the Stokes part and one for the temperature part) as well as set
   to the right sizes the various objects required for the linear algebra in
   this program. Its basic operations are similar to what we do in <a class="el" href="step_22.html">step-22</a>.</p>
<p>The body of the function first enumerates all degrees of freedom for the
   Stokes and temperature systems. For the Stokes part, degrees of freedom
   are then sorted to ensure that velocities precede pressure DoFs so that
   we can partition the Stokes matrix into a \(2\times 2\) matrix. As a
   difference to <a class="el" href="step_22.html">step-22</a>, we do not perform any additional DoF
   renumbering. In that program, it paid off since our solver was heavily
   dependent on ILU's, whereas we use AMG here which is not sensitive to the
   DoF numbering. The IC preconditioner for the inversion of the pressure
   mass matrix would of course take advantage of a Cuthill-McKee like
   renumbering, but its costs are low compared to the velocity portion, so
   the additional work does not pay off.</p>
<p>We then proceed with the generation of the hanging node constraints that
   arise from adaptive grid refinement for both <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. For the
   velocity, we impose no-flux boundary conditions \(\mathbf{u}\cdot \mathbf{n}=0\) by adding constraints to the object that already stores the
   hanging node constraints matrix. The second parameter in the function
   describes the first of the velocity components in the total dof vector,
   which is zero here. The variable <code>no_normal_flux_boundaries</code>
   denotes the boundary indicators for which to set the no flux boundary
   conditions; here, this is boundary indicator zero.</p>
<p>After having done so, we count the number of degrees of freedom in the
   various blocks:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_dofs()</div><div class="line">{</div><div class="line">  std::vector&lt;unsigned int&gt; stokes_sub_blocks(dim + 1, 0);</div><div class="line">  stokes_sub_blocks[dim] = 1;</div><div class="line"></div><div class="line">  {</div><div class="line">    stokes_dof_handler.distribute_dofs(stokes_fe);</div><div class="line">    <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">    stokes_constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(stokes_dof_handler,</div><div class="line">                                            stokes_constraints);</div><div class="line">    std::set&lt;types::boundary_id&gt; no_normal_flux_boundaries;</div><div class="line">    no_normal_flux_boundaries.insert(0);</div><div class="line">    <a class="code" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a>(stokes_dof_handler,</div><div class="line">                                                    0,</div><div class="line">                                                    no_normal_flux_boundaries,</div><div class="line">                                                    stokes_constraints);</div><div class="line">    stokes_constraints.close();</div><div class="line">  }</div><div class="line">  {</div><div class="line">    temperature_dof_handler.distribute_dofs(temperature_fe);</div><div class="line"></div><div class="line">    temperature_constraints.clear();</div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(temperature_dof_handler,</div><div class="line">                                            temperature_constraints);</div><div class="line">    temperature_constraints.close();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; stokes_dofs_per_block =</div><div class="line">    <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = stokes_dofs_per_block[0],</div><div class="line">                     n_p = stokes_dofs_per_block[1],</div><div class="line">                     n_T = temperature_dof_handler.n_dofs();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_T &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">            &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_T &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">            &lt;&lt; std::endl;</div></div><!-- fragment --><p>The next step is to create the sparsity pattern for the Stokes and
   temperature system matrices as well as the preconditioner matrix from
   which we build the Stokes preconditioner. As in <a class="el" href="step_22.html">step-22</a>, we choose to
   create the pattern by
   using the blocked version of <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>.</p>
<p>So, we first release the memory stored in the matrices, then set up an
   object of type <a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> consisting of
 \(2\times 2\) blocks (for the Stokes system matrix and preconditioner) or
   <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> (for the temperature part). We then
   fill these objects with the nonzero pattern, taking into account that
   for the Stokes system matrix, there are no entries in the
   pressure-pressure block (but all velocity vector components couple with
   each other and with the pressure). Similarly, in the Stokes
   preconditioner matrix, only the diagonal blocks are nonzero, since we
   use the vector Laplacian as discussed in the introduction. This
   operator only couples each vector component of the Laplacian with
   itself, but not with the other vector components. (Application of the
   constraints resulting from the no-flux boundary conditions will couple
   vector components at the boundary again, however.)</p>
<p>When generating the sparsity pattern, we directly apply the constraints
   from hanging nodes and no-flux boundary conditions. This approach was
   already used in <a class="el" href="step_27.html">step-27</a>, but is different from the one in early
   tutorial programs where we first built the original sparsity pattern
   and only then added the entries resulting from constraints. The reason
   for doing so is that later during assembly we are going to distribute
   the constraints immediately when transferring local to global
   dofs. Consequently, there will be no data written at positions of
   constrained degrees of freedom, so we can let the
   <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> function omit these entries by setting
   the last Boolean flag to <code>false</code>. Once the sparsity pattern
   is ready, we can use it to initialize the Trilinos matrices. Since the
   Trilinos matrices store the sparsity pattern internally, there is no
   need to keep the sparsity pattern around after the initialization of
   the matrix.</p>
<div class="fragment"><div class="line">stokes_partitioning.resize(2);</div><div class="line">stokes_partitioning[0] = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_u);</div><div class="line">stokes_partitioning[1] = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_p);</div><div class="line">{</div><div class="line">  stokes_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">  dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">  dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">  dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">  dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">  dsp.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">    stokes_dof_handler, coupling, dsp, stokes_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  stokes_matrix.reinit(dsp);</div><div class="line">}</div><div class="line"></div><div class="line">{</div><div class="line">  Amg_preconditioner.reset();</div><div class="line">  Mp_preconditioner.reset();</div><div class="line">  stokes_preconditioner_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">  dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">  dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">  dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">  dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">  dsp.collect_sizes();</div><div class="line"></div><div class="line">  <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      <span class="keywordflow">if</span> (c == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">    stokes_dof_handler, coupling, dsp, stokes_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  stokes_preconditioner_matrix.reinit(dsp);</div><div class="line">}</div></div><!-- fragment --><p>The creation of the temperature matrix (or, rather, matrices, since we
   provide a temperature mass matrix and a temperature stiffness matrix,
   that will be added together for time discretization) follows the
   generation of the Stokes matrix &ndash; except that it is much easier
   here since we do not need to take care of any blocks or coupling
   between components. Note how we initialize the three temperature
   matrices: We only use the sparsity pattern for reinitialization of the
   first matrix, whereas we use the previously generated matrix for the
   two remaining reinits. The reason for doing so is that reinitialization
   from an already generated matrix allows Trilinos to reuse the sparsity
   pattern instead of generating a new one for each copy. This saves both
   some time and memory.</p>
<div class="fragment"><div class="line">{</div><div class="line">  temperature_mass_matrix.clear();</div><div class="line">  temperature_stiffness_matrix.clear();</div><div class="line">  temperature_matrix.clear();</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_T, n_T);</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(temperature_dof_handler,</div><div class="line">                                  dsp,</div><div class="line">                                  temperature_constraints,</div><div class="line">                                  <span class="keyword">false</span>);</div><div class="line"></div><div class="line">  temperature_matrix.reinit(dsp);</div><div class="line">  temperature_mass_matrix.reinit(temperature_matrix);</div><div class="line">  temperature_stiffness_matrix.reinit(temperature_matrix);</div><div class="line">}</div></div><!-- fragment --><p>Lastly, we set the vectors for the Stokes solutions \(\mathbf u^{n-1}\)
   and \(\mathbf u^{n-2}\), as well as for the temperatures \(T^{n}\),
 \(T^{n-1}\) and \(T^{n-2}\) (required for time stepping) and all the system
   right hand sides to their correct sizes and block structure:</p>
<div class="fragment"><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> temperature_partitioning = <a class="code" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_T);</div><div class="line">  stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line">  stokes_rhs.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">  old_old_temperature_solution.reinit(temperature_partitioning,</div><div class="line">                                      MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  temperature_rhs.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemassemble_stokes_preconditioner"></a> 
   </p><h4>BoussinesqFlowProblem::assemble_stokes_preconditioner</h4>
<p></p>
<p>This function assembles the matrix we use for preconditioning the Stokes
   system. What we need are a vector Laplace matrix on the velocity
   components and a mass matrix weighted by \(\eta^{-1}\) on the pressure
   component. We start by generating a quadrature object of appropriate
   order, the <a class="el" href="classFEValues.html">FEValues</a> object that can give values and gradients at the
   quadrature points (together with quadrature weights). Next we create data
   structures for the cell matrix and the relation between local and global
   DoFs. The vectors <code>grad_phi_u</code> and <code>phi_p</code> are
   going to hold the values of the basis functions in order to faster build
   up the local matrices, as was already done in <a class="el" href="step_22.html">step-22</a>. Before we start
   the loop over all active cells, we have to specify which components are
   pressure and which are velocity.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_preconditioner()</div><div class="line">{</div><div class="line">  stokes_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(stokes_degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(stokes_fe,</div><div class="line">                                 quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;Tensor&lt;2, dim&gt;&gt; grad_phi_u(dofs_per_cell);</div><div class="line">  std::vector&lt;double&gt;         phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      stokes_fe_values.reinit(cell);</div><div class="line">      local_matrix = 0;</div></div><!-- fragment --><p>The creation of the local matrix is rather simple. There are only a
   Laplace term (on the velocity) and a mass matrix weighted by
 \(\eta^{-1}\) to be generated, so the creation of the local matrix is
   done in two lines. Once the local matrix is ready (loop over rows
   and columns in the local matrix on each quadrature point), we get
   the local DoF indices and write the local information into the
   global matrix. We do this as in <a class="el" href="step_27.html">step-27</a>, i.e., we directly apply the
   constraints from hanging nodes locally. By doing so, we don't have
   to do that afterwards, and we don't also write into entries of the
   matrix that will actually be set to zero again later when
   eliminating constraints.</p>
<div class="fragment"><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              grad_phi_u[k] = stokes_fe_values[velocities].gradient(k, q);</div><div class="line">              phi_p[k]      = stokes_fe_values[pressure].value(k, q);</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              local_matrix(i, j) +=</div><div class="line">                (EquationData::eta *</div><div class="line">                   <a class="code" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[i], grad_phi_u[j]) +</div><div class="line">                 (1. / EquationData::eta) * phi_p[i] * phi_p[j]) *</div><div class="line">                stokes_fe_values.JxW(q);</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      stokes_constraints.distribute_local_to_global(</div><div class="line">        local_matrix, local_dof_indices, stokes_preconditioner_matrix);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblembuild_stokes_preconditioner"></a> 
   </p><h4>BoussinesqFlowProblem::build_stokes_preconditioner</h4>
<p></p>
<p>This function generates the inner preconditioners that are going to be
   used for the Schur complement block preconditioner. Since the
   preconditioners need only to be regenerated when the matrices change,
   this function does not have to do anything in case the matrices have not
   changed (i.e., the flag <code>rebuild_stokes_preconditioner</code> has
   the value <code>false</code>). Otherwise its first task is to call
   <code>assemble_stokes_preconditioner</code> to generate the
   preconditioner matrices.</p>
<p>Next, we set up the preconditioner for the velocity-velocity matrix
 \(A\). As explained in the introduction, we are going to use an AMG
   preconditioner based on a vector Laplace matrix \(\hat{A}\) (which is
   spectrally close to the Stokes matrix \(A\)). Usually, the
   <a class="el" href="classTrilinosWrappers_1_1PreconditionAMG.html">TrilinosWrappers::PreconditionAMG</a> class can be seen as a good black-box
   preconditioner which does not need any special knowledge. In this case,
   however, we have to be careful: since we build an AMG for a vector
   problem, we have to tell the preconditioner setup which dofs belong to
   which vector component. We do this using the function
   <a class="el" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>, a function that generates a set of
   <code>dim</code> vectors, where each one has ones in the respective
   component of the vector problem and zeros elsewhere. Hence, these are the
   constant modes on each component, which explains the name of the
   variable.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::build_stokes_preconditioner()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_preconditioner == <span class="keyword">false</span>)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding Stokes preconditioner...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  assemble_stokes_preconditioner();</div><div class="line"></div><div class="line">  Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionAMG&gt;();</div><div class="line"></div><div class="line">  std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div><div class="line">  <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocity_components(0);</div><div class="line">  <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(stokes_dof_handler,</div><div class="line">                                   stokes_fe.component_mask(</div><div class="line">                                     velocity_components),</div><div class="line">                                   constant_modes);</div><div class="line">  <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> amg_data;</div><div class="line">  amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a> = constant_modes;</div></div><!-- fragment --><p>Next, we set some more options of the AMG preconditioner. In
   particular, we need to tell the AMG setup that we use quadratic basis
   functions for the velocity matrix (this implies more nonzero elements
   in the matrix, so that a more robust algorithm needs to be chosen
   internally). Moreover, we want to be able to control how the coarsening
   structure is build up. The way the Trilinos smoothed aggregation AMG
   does this is to look which matrix entries are of similar size as the
   diagonal entry in order to algebraically build a coarse-grid
   structure. By setting the parameter <code>aggregation_threshold</code>
   to 0.02, we specify that all entries that are more than two percent of
   size of some diagonal pivots in that row should form one coarse grid
   point. This parameter is rather ad hoc, and some fine-tuning of it can
   influence the performance of the preconditioner. As a rule of thumb,
   larger values of <code>aggregation_threshold</code> will decrease the
   number of iterations, but increase the costs per iteration. A look at
   the Trilinos documentation will provide more information on these
   parameters. With this data set, we then initialize the preconditioner
   with the matrix we want it to apply to.</p>
<p>Finally, we also initialize the preconditioner for the inversion of the
   pressure mass matrix. This matrix is symmetric and well-behaved, so we
   can chose a simple preconditioner. We stick with an incomplete Cholesky
   (IC) factorization preconditioner, which is designed for symmetric
   matrices. We could have also chosen an SSOR preconditioner with
   relaxation factor around 1.2, but IC is cheaper for our example. We
   wrap the preconditioners into a <code>std::shared_ptr</code>
   pointer, which makes it easier to recreate the preconditioner next time
   around since we do not have to care about destroying the previously
   used object.</p>
<div class="fragment"><div class="line">  amg_data.elliptic              = <span class="keyword">true</span>;</div><div class="line">  amg_data.higher_order_elements = <span class="keyword">true</span>;</div><div class="line">  amg_data.smoother_sweeps       = 2;</div><div class="line">  amg_data.aggregation_threshold = 0.02;</div><div class="line">  Amg_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(0, 0),</div><div class="line">                                 amg_data);</div><div class="line"></div><div class="line">  Mp_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">  Mp_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(1, 1));</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  rebuild_stokes_preconditioner = <span class="keyword">false</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemassemble_stokes_system"></a> 
   </p><h4>BoussinesqFlowProblem::assemble_stokes_system</h4>
<p></p>
<p>The time lag scheme we use for advancing the coupled Stokes-temperature
   system forces us to split up the assembly (and the solution of linear
   systems) into two step. The first one is to create the Stokes system
   matrix and right hand side, and the second is to create matrix and right
   hand sides for the temperature dofs, which depends on the result of the
   linear system for the velocity.</p>
<p>This function is called at the beginning of each time step. In the first
   time step or if the mesh has changed, indicated by the
   <code>rebuild_stokes_matrix</code>, we need to assemble the Stokes
   matrix; on the other hand, if the mesh hasn't changed and the matrix is
   already available, this is not necessary and all we need to do is
   assemble the right hand side vector which changes in each time step.</p>
<p>Regarding the technical details of implementation, not much has changed
   from <a class="el" href="step_22.html">step-22</a>. We reset matrix and vector, create a quadrature formula on
   the cells, and then create the respective <a class="el" href="classFEValues.html">FEValues</a> object. For the update
   flags, we require basis function derivatives only in case of a full
   assembly, since they are not needed for the right hand side; as always,
   choosing the minimal set of flags depending on what is currently needed
   makes the call to <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit</a> further down in the program more
   efficient.</p>
<p>There is one thing that needs to be commented &ndash; since we have a
   separate finite element and <a class="el" href="classDoFHandler.html">DoFHandler</a> for the temperature, we need to
   generate a second <a class="el" href="classFEValues.html">FEValues</a> object for the proper evaluation of the
   temperature solution. This isn't too complicated to realize here: just
   use the temperature structures and set an update flag for the basis
   function values which we need for evaluation of the temperature
   solution. The only important part to remember here is that the same
   quadrature formula is used for both <a class="el" href="classFEValues.html">FEValues</a> objects to ensure that we
   get matching information when we loop over the quadrature points of the
   two objects.</p>
<p>The declarations proceed with some shortcuts for array sizes, the
   creation of the local matrix and right hand side as well as the vector
   for the indices of the local dofs compared to the global system.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_system()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">    stokes_matrix = 0;</div><div class="line"></div><div class="line">  stokes_rhs = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(stokes_degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(</div><div class="line">    stokes_fe,</div><div class="line">    quadrature_formula,</div><div class="line">    <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">      (rebuild_stokes_matrix == <span class="keyword">true</span> ? <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> : <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(0)));</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values(temperature_fe,</div><div class="line">                                      quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div></div><!-- fragment --><p>Next we need a vector that will contain the values of the temperature
   solution at the previous time level at the quadrature points to
   assemble the source term in the right hand side of the momentum
   equation. Let's call this vector <code>old_solution_values</code>.</p>
<p>The set of vectors we create next hold the evaluations of the basis
   functions as well as their gradients and symmetrized gradients that
   will be used for creating the matrices. Putting these into their own
   arrays rather than asking the <a class="el" href="classFEValues.html">FEValues</a> object for this information each
   time it is needed is an optimization to accelerate the assembly
   process, see <a class="el" href="step_22.html">step-22</a> for details.</p>
<p>The last two declarations are used to extract the individual blocks
   (velocity, pressure, temperature) from the total FE system.</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt;          phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; grads_phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;                  div_phi_u(dofs_per_cell);</div><div class="line">std::vector&lt;double&gt;                  phi_p(dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div></div><!-- fragment --><p>Now start the loop over all cells in the problem. We are working on two
   different DoFHandlers for this assembly routine, so we must have two
   different cell iterators for the two objects in use. This might seem a
   bit peculiar, since both the Stokes system and the temperature system
   use the same grid, but that's the only way to keep degrees of freedom
   in sync. The first statements within the loop are again all very
   familiar, doing the update of the finite element data as specified by
   the update flags, zeroing out the local arrays and getting the values
   of the old solution at the quadrature points. Then we are ready to loop
   over the quadrature points on the cell.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>       cell             = stokes_dof_handler.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> endc             = stokes_dof_handler.end();</div><div class="line"><span class="keyword">auto</span>       temperature_cell = temperature_dof_handler.begin_active();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell != endc; ++cell, ++temperature_cell)</div><div class="line">  {</div><div class="line">    stokes_fe_values.reinit(cell);</div><div class="line">    temperature_fe_values.reinit(temperature_cell);</div><div class="line"></div><div class="line">    local_matrix = 0;</div><div class="line">    local_rhs    = 0;</div><div class="line"></div><div class="line">    temperature_fe_values.get_function_values(old_temperature_solution,</div><div class="line">                                              old_temperature_values);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> old_temperature = old_temperature_values[q];</div></div><!-- fragment --><p>Next we extract the values and gradients of basis functions
   relevant to the terms in the inner products. As shown in
   <a class="el" href="step_22.html">step-22</a> this helps accelerate assembly.</p>
<p>Once this is done, we start the loop over the rows and columns
   of the local matrix and feed the matrix with the relevant
   products. The right hand side is filled with the forcing term
   driven by temperature in direction of gravity (which is
   vertical in our example).  Note that the right hand side term
   is always generated, whereas the matrix contributions are only
   updated when it is requested by the
   <code>rebuild_matrices</code> flag.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">    {</div><div class="line">      phi_u[k] = stokes_fe_values[velocities].value(k, q);</div><div class="line">      <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">        {</div><div class="line">          grads_phi_u[k] =</div><div class="line">            stokes_fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">          div_phi_u[k] =</div><div class="line">            stokes_fe_values[velocities].divergence(k, q);</div><div class="line">          phi_p[k] = stokes_fe_values[pressure].value(k, q);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">        local_matrix(i, j) +=</div><div class="line">          (EquationData::eta * 2 * (grads_phi_u[i] * grads_phi_u[j]) -</div><div class="line">           div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div><div class="line">          stokes_fe_values.JxW(q);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> gravity =</div><div class="line">    -((dim == 2) ? (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 1)) : (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0, 1)));</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">    local_rhs(i) += (-EquationData::density * EquationData::beta *</div><div class="line">                     gravity * phi_u[i] * old_temperature) *</div><div class="line">                    stokes_fe_values.JxW(q);</div><div class="line">}</div></div><!-- fragment --><p>The last step in the loop over all cells is to enter the local
   contributions into the global matrix and vector structures to the
   positions specified in <code>local_dof_indices</code>.  Again, we
   let the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> class do the insertion of the cell
   matrix elements to the global matrix, which already condenses the
   hanging node constraints.</p>
<div class="fragment"><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">        stokes_constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                                      local_rhs,</div><div class="line">                                                      local_dof_indices,</div><div class="line">                                                      stokes_matrix,</div><div class="line">                                                      stokes_rhs);</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        stokes_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                      local_dof_indices,</div><div class="line">                                                      stokes_rhs);</div><div class="line">    }</div><div class="line"></div><div class="line">  rebuild_stokes_matrix = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemassemble_temperature_matrix"></a> 
   </p><h4>BoussinesqFlowProblem::assemble_temperature_matrix</h4>
<p></p>
<p>This function assembles the matrix in the temperature equation. The
   temperature matrix consists of two parts, a mass matrix and the time step
   size times a stiffness matrix given by a Laplace term times the amount of
   diffusion. Since the matrix depends on the time step size (which varies
   from one step to another), the temperature matrix needs to be updated
   every time step. We could simply regenerate the matrices in every time
   step, but this is not really efficient since mass and Laplace matrix do
   only change when we change the mesh. Hence, we do this more efficiently
   by generating two separate matrices in this function, one for the mass
   matrix and one for the stiffness (diffusion) matrix. We will then sum up
   the matrix plus the stiffness matrix times the time step size once we
   know the actual time step.</p>
<p>So the details for this first step are very simple. In case we need to
   rebuild the matrix (i.e., the mesh has changed), we zero the data
   structures, get a quadrature formula and a <a class="el" href="classFEValues.html">FEValues</a> object, and create
   local matrices, local dof indices and evaluation structures for the basis
   functions.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_matrix()</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (rebuild_temperature_matrices == <span class="keyword">false</span>)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  temperature_mass_matrix      = 0;</div><div class="line">  temperature_stiffness_matrix = 0;</div><div class="line"></div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(temperature_degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values(temperature_fe,</div><div class="line">                                      quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = temperature_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_stiffness_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;double&gt;         phi_T(dofs_per_cell);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T(dofs_per_cell);</div></div><!-- fragment --><p>Now, let's start the loop over all cells in the triangulation. We need
   to zero out the local matrices, update the finite element evaluations,
   and then loop over the rows and columns of the matrices on each
   quadrature point, where we then create the mass matrix and the
   stiffness matrix (Laplace terms times the diffusion
   <code>EquationData::kappa</code>. Finally, we let the constraints
   object insert these values into the global matrix, and directly
   condense the constraints into the matrix.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      local_mass_matrix      = 0;</div><div class="line">      local_stiffness_matrix = 0;</div><div class="line"></div><div class="line">      temperature_fe_values.reinit(cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);</div><div class="line">              phi_T[k]      = temperature_fe_values.shape_value(k, q);</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                local_mass_matrix(i, j) +=</div><div class="line">                  (phi_T[i] * phi_T[j] * temperature_fe_values.JxW(q));</div><div class="line">                local_stiffness_matrix(i, j) +=</div><div class="line">                  (EquationData::kappa * grad_phi_T[i] * grad_phi_T[j] *</div><div class="line">                   temperature_fe_values.JxW(q));</div><div class="line">              }</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">      temperature_constraints.distribute_local_to_global(</div><div class="line">        local_mass_matrix, local_dof_indices, temperature_mass_matrix);</div><div class="line">      temperature_constraints.distribute_local_to_global(</div><div class="line">        local_stiffness_matrix,</div><div class="line">        local_dof_indices,</div><div class="line">        temperature_stiffness_matrix);</div><div class="line">    }</div><div class="line"></div><div class="line">  rebuild_temperature_matrices = <span class="keyword">false</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemassemble_temperature_system"></a> 
   </p><h4>BoussinesqFlowProblem::assemble_temperature_system</h4>
<p></p>
<p>This function does the second part of the assembly work on the
   temperature matrix, the actual addition of pressure mass and stiffness
   matrix (where the time step size comes into play), as well as the
   creation of the velocity-dependent right hand side. The declarations for
   the right hand side assembly in this function are pretty much the same as
   the ones used in the other assembly routines, except that we restrict
   ourselves to vectors this time. We are going to calculate residuals on
   the temperature system, which means that we have to evaluate second
   derivatives, specified by the update flag <code>update_hessians</code>.</p>
<p>The temperature equation is coupled to the Stokes system by means of the
   fluid velocity. These two parts of the solution are associated with
   different DoFHandlers, so we again need to create a second <a class="el" href="classFEValues.html">FEValues</a>
   object for the evaluation of the velocity at the quadrature points.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_system(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (use_bdf2_scheme == <span class="keyword">true</span>)</div><div class="line">    {</div><div class="line">      temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">      temperature_matrix *=</div><div class="line">        (2 * time_step + old_time_step) / (time_step + old_time_step);</div><div class="line">      temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">      temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">      temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">    }</div><div class="line"></div><div class="line">  temperature_rhs = 0;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(temperature_degree + 2);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     temperature_fe_values(temperature_fe,</div><div class="line">                                      quadrature_formula,</div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(stokes_fe,</div><div class="line">                                 quadrature_formula,</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = temperature_fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div></div><!-- fragment --><p>Next comes the declaration of vectors to hold the old and older
   solution values (as a notation for time levels \(n-1\) and
 \(n-2\), respectively) and gradients at quadrature points of the
   current cell. We also declare an object to hold the temperature right
   hand side values (<code>gamma_values</code>), and we again use
   shortcuts for the temperature basis functions. Eventually, we need to
   find the temperature extrema and the diameter of the computational
   domain which will be used for the definition of the stabilization
   parameter (we got the maximal velocity as an input to this function).</p>
<div class="fragment"><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_velocity_values(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_velocity_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_temperature_values(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_old_temperature_values(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_temperature_grads(n_q_points);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_temperature_grads(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_temperature_laplacians(n_q_points);</div><div class="line">std::vector&lt;double&gt;         old_old_temperature_laplacians(n_q_points);</div><div class="line"></div><div class="line">EquationData::TemperatureRightHandSide&lt;dim&gt; temperature_right_hand_side;</div><div class="line">std::vector&lt;double&gt;                         gamma_values(n_q_points);</div><div class="line"></div><div class="line">std::vector&lt;double&gt;         phi_T(dofs_per_cell);</div><div class="line">std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T(dofs_per_cell);</div><div class="line"></div><div class="line"><span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range =</div><div class="line">  get_extrapolated_temperature_range();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div></div><!-- fragment --><p>Now, let's start the loop over all cells in the triangulation. Again,
   we need two cell iterators that walk in parallel through the cells of
   the two involved <a class="el" href="classDoFHandler.html">DoFHandler</a> objects for the Stokes and temperature
   part. Within the loop, we first set the local rhs to zero, and then get
   the values and derivatives of the old solution functions at the
   quadrature points, since they are going to be needed for the definition
   of the stabilization parameters and as coefficients in the equation,
   respectively. Note that since the temperature has its own <a class="el" href="classDoFHandler.html">DoFHandler</a>
   and <a class="el" href="classFEValues.html">FEValues</a> object we get the entire solution at the quadrature point
   (which is the scalar temperature field only anyway) whereas for the
   Stokes part we restrict ourselves to extracting the velocity part (and
   ignoring the pressure part) by using
   <code>stokes_fe_values[velocities].get_function_values</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span>       cell        = temperature_dof_handler.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> endc        = temperature_dof_handler.end();</div><div class="line"><span class="keyword">auto</span>       stokes_cell = stokes_dof_handler.begin_active();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (; cell != endc; ++cell, ++stokes_cell)</div><div class="line">  {</div><div class="line">    local_rhs = 0;</div><div class="line"></div><div class="line">    temperature_fe_values.reinit(cell);</div><div class="line">    stokes_fe_values.reinit(stokes_cell);</div><div class="line"></div><div class="line">    temperature_fe_values.get_function_values(old_temperature_solution,</div><div class="line">                                              old_temperature_values);</div><div class="line">    temperature_fe_values.get_function_values(old_old_temperature_solution,</div><div class="line">                                              old_old_temperature_values);</div><div class="line"></div><div class="line">    temperature_fe_values.get_function_gradients(old_temperature_solution,</div><div class="line">                                                 old_temperature_grads);</div><div class="line">    temperature_fe_values.get_function_gradients(</div><div class="line">      old_old_temperature_solution, old_old_temperature_grads);</div><div class="line"></div><div class="line">    temperature_fe_values.get_function_laplacians(</div><div class="line">      old_temperature_solution, old_temperature_laplacians);</div><div class="line">    temperature_fe_values.get_function_laplacians(</div><div class="line">      old_old_temperature_solution, old_old_temperature_laplacians);</div><div class="line"></div><div class="line">    temperature_right_hand_side.value_list(</div><div class="line">      temperature_fe_values.get_quadrature_points(), gamma_values);</div><div class="line"></div><div class="line">    stokes_fe_values[velocities].get_function_values(stokes_solution,</div><div class="line">                                                     old_velocity_values);</div><div class="line">    stokes_fe_values[velocities].get_function_values(</div><div class="line">      old_stokes_solution, old_old_velocity_values);</div></div><!-- fragment --><p>Next, we calculate the artificial viscosity for stabilization
   according to the discussion in the introduction using the dedicated
   function. With that at hand, we can get into the loop over
   quadrature points and local rhs vector components. The terms here
   are quite lengthy, but their definition follows the time-discrete
   system developed in the introduction of this program. The BDF-2
   scheme needs one more term from the old time step (and involves
   more complicated factors) than the backward Euler scheme that is
   used for the first time step. When all this is done, we distribute
   the local vector into the global one (including hanging node
   constraints).</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div><div class="line">        compute_viscosity(old_temperature_values,</div><div class="line">                          old_old_temperature_values,</div><div class="line">                          old_temperature_grads,</div><div class="line">                          old_old_temperature_grads,</div><div class="line">                          old_temperature_laplacians,</div><div class="line">                          old_old_temperature_laplacians,</div><div class="line">                          old_velocity_values,</div><div class="line">                          old_old_velocity_values,</div><div class="line">                          gamma_values,</div><div class="line">                          maximal_velocity,</div><div class="line">                          global_T_range.second - global_T_range.first,</div><div class="line">                          cell-&gt;diameter());</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">            {</div><div class="line">              grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);</div><div class="line">              phi_T[k]      = temperature_fe_values.shape_value(k, q);</div><div class="line">            }</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> T_term_for_rhs =</div><div class="line">            (use_bdf2_scheme ?</div><div class="line">               (old_temperature_values[q] * (1 + time_step / old_time_step) -</div><div class="line">                old_old_temperature_values[q] * (time_step * time_step) /</div><div class="line">                  (old_time_step * (time_step + old_time_step))) :</div><div class="line">               old_temperature_values[q]);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ext_grad_T =</div><div class="line">            (use_bdf2_scheme ?</div><div class="line">               (old_temperature_grads[q] * (1 + time_step / old_time_step) -</div><div class="line">                old_old_temperature_grads[q] * time_step / old_time_step) :</div><div class="line">               old_temperature_grads[q]);</div><div class="line"></div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> extrapolated_u =</div><div class="line">            (use_bdf2_scheme ?</div><div class="line">               (old_velocity_values[q] * (1 + time_step / old_time_step) -</div><div class="line">                old_old_velocity_values[q] * time_step / old_time_step) :</div><div class="line">               old_velocity_values[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            local_rhs(i) +=</div><div class="line">              (T_term_for_rhs * phi_T[i] -</div><div class="line">               time_step * extrapolated_u * ext_grad_T * phi_T[i] -</div><div class="line">               time_step * nu * ext_grad_T * grad_phi_T[i] +</div><div class="line">               time_step * gamma_values[q] * phi_T[i]) *</div><div class="line">              temperature_fe_values.JxW(q);</div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      temperature_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                         local_dof_indices,</div><div class="line">                                                         temperature_rhs);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemsolve"></a> 
   </p><h4>BoussinesqFlowProblem::solve</h4>
<p></p>
<p>This function solves the linear systems of equations. Following the
   introduction, we start with the Stokes system, where we need to generate
   our block Schur preconditioner. Since all the relevant actions are
   implemented in the class <code>BlockSchurPreconditioner</code>, all we
   have to do is to initialize the class appropriately. What we need to pass
   down is an <code>InverseMatrix</code> object for the pressure mass
   matrix, which we set up using the respective class together with the IC
   preconditioner we already generated, and the AMG preconditioner for the
   velocity-velocity matrix. Note that both <code>Mp_preconditioner</code>
   and <code>Amg_preconditioner</code> are only pointers, so we use
   <code>*</code> to pass down the actual preconditioner objects.</p>
<p>Once the preconditioner is ready, we create a GMRES solver for the block
   system. Since we are working with Trilinos data structures, we have to
   set the respective template argument in the solver. GMRES needs to
   internally store temporary vectors for each iteration (see the discussion
   in the results section of <a class="el" href="step_22.html">step-22</a>) &ndash; the more vectors it can use,
   the better it will generally perform. To keep memory demands in check, we
   set the number of vectors to 100. This means that up to 100 solver
   iterations, every temporary vector can be stored. If the solver needs to
   iterate more often to get the specified tolerance, it will work on a
   reduced set of vectors by restarting at every 100 iterations.</p>
<p>With this all set up, we solve the system and distribute the constraints
   in the Stokes system, i.e., hanging nodes and no-flux boundary condition,
   in order to have the appropriate solution values even at constrained
   dofs. Finally, we write the number of iterations to the screen.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> LinearSolvers::InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                       <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a>&gt;</div><div class="line">      mp_inverse(stokes_preconditioner_matrix.block(1, 1),</div><div class="line">                 *Mp_preconditioner);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">      <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">TrilinosWrappers::PreconditionAMG</a>,</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a>&gt;</div><div class="line">      preconditioner(stokes_matrix, mp_inverse, *Amg_preconditioner);</div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(stokes_matrix.m(),</div><div class="line">                                 1e-6 * stokes_rhs.l2_norm());</div><div class="line"></div><div class="line">    <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> gmres(</div><div class="line">      solver_control,</div><div class="line">      <a class="code" href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(100));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; stokes_solution.size(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (stokes_constraints.is_constrained(i))</div><div class="line">        stokes_solution(i) = 0;</div><div class="line"></div><div class="line">    gmres.solve(stokes_matrix, stokes_solution, stokes_rhs, preconditioner);</div><div class="line"></div><div class="line">    stokes_constraints.distribute(stokes_solution);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; GMRES iterations for Stokes subsystem.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div></div><!-- fragment --><p>Once we know the Stokes solution, we can determine the new time step
   from the maximal velocity. We have to do this to satisfy the CFL
   condition since convection terms are treated explicitly in the
   temperature equation, as discussed in the introduction. The exact form
   of the formula used here for the time step is discussed in the results
   section of this program.</p>
<p>There is a snatch here. The formula contains a division by the maximum
   value of the velocity. However, at the start of the computation, we
   have a constant temperature field (we start with a constant
   temperature, and it will be nonconstant only after the first time step
   during which the source acts). Constant temperature means that no
   buoyancy acts, and so the velocity is zero. Dividing by it will not
   likely lead to anything good.</p>
<p>To avoid the resulting infinite time step, we ask whether the maximal
   velocity is very small (in particular smaller than the values we
   encounter during any of the following time steps) and if so rather than
   dividing by zero we just divide by a small value, resulting in a large
   but finite time step.</p>
<div class="fragment"><div class="line">old_time_step                 = time_step;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity = get_maximal_velocity();</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (maximal_velocity &gt;= 0.01)</div><div class="line">  time_step = 1. / (1.7 * dim * <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim)) / temperature_degree *</div><div class="line">              <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) /</div><div class="line">              maximal_velocity;</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  time_step = 1. / (1.7 * dim * <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim)) / temperature_degree *</div><div class="line">              <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / .01;</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div><div class="line">          &lt;&lt; <span class="stringliteral">&quot;Time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">temperature_solution = old_temperature_solution;</div></div><!-- fragment --><p>Next we set up the temperature system and the right hand side using the
   function <code>assemble_temperature_system()</code>.  Knowing the
   matrix and right hand side of the temperature equation, we set up a
   preconditioner and a solver. The temperature matrix is a mass matrix
   (with eigenvalues around one) plus a Laplace matrix (with eigenvalues
   between zero and \(ch^{-2}\)) times a small number proportional to the
   time step \(k_n\). Hence, the resulting symmetric and positive definite
   matrix has eigenvalues in the range \([1,1+k_nh^{-2}]\) (up to
   constants). This matrix is only moderately ill conditioned even for
   small mesh sizes and we get a reasonably good preconditioner by simple
   means, for example with an incomplete Cholesky decomposition
   preconditioner (IC) as we also use for preconditioning the pressure
   mass matrix solver. As a solver, we choose the conjugate gradient
   method CG. As before, we tell the solver to use Trilinos vectors via
   the template argument <code><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a></code>.
   Finally, we solve, distribute the hanging node constraints and write out
   the number of iterations.</p>
<div class="fragment"><div class="line">assemble_temperature_system(maximal_velocity);</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(temperature_matrix.m(),</div><div class="line">                               1e-8 * temperature_rhs.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a> preconditioner;</div><div class="line">  preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html#a95eff1f8abcf2ba67815b6a96a66d375">initialize</a>(temperature_matrix);</div><div class="line"></div><div class="line">  cg.solve(temperature_matrix,</div><div class="line">           temperature_solution,</div><div class="line">           temperature_rhs,</div><div class="line">           preconditioner);</div><div class="line"></div><div class="line">  temperature_constraints.distribute(temperature_solution);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; CG iterations for temperature.&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p>At the end of this function, we step through the vector and read out
   the maximum and minimum temperature value, which we also want to
   output. This will come in handy when determining the correct constant
   in the choice of time step as discuss in the results section of this
   program.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">double</span> min_temperature = temperature_solution(0),</div><div class="line">           max_temperature = temperature_solution(0);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; temperature_solution.size(); ++i)</div><div class="line">      {</div><div class="line">        min_temperature =</div><div class="line">          std::min&lt;double&gt;(min_temperature, temperature_solution(i));</div><div class="line">        max_temperature =</div><div class="line">          std::max&lt;double&gt;(max_temperature, temperature_solution(i));</div><div class="line">      }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Temperature range: &quot;</span> &lt;&lt; min_temperature &lt;&lt; <span class="charliteral">&#39; &#39;</span></div><div class="line">              &lt;&lt; max_temperature &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemoutput_results"></a> 
   </p><h4>BoussinesqFlowProblem::output_results</h4>
<p></p>
<p>This function writes the solution to a VTK output file for visualization,
   which is done every tenth time step. This is usually quite a simple task,
   since the deal.II library provides functions that do almost all the job
   for us. There is one new function compared to previous examples: We want
   to visualize both the Stokes solution and the temperature as one data
   set, but we have done all the calculations based on two different
   <a class="el" href="classDoFHandler.html">DoFHandler</a> objects. Luckily, the <a class="el" href="classDataOut.html">DataOut</a> class is prepared to deal with
   it. All we have to do is to not attach one single <a class="el" href="classDoFHandler.html">DoFHandler</a> at the
   beginning and then use that for all added vector, but specify the
   <a class="el" href="classDoFHandler.html">DoFHandler</a> to each vector separately. The rest is done as in <a class="el" href="step_22.html">step-22</a>. We
   create solution names (that are going to appear in the visualization
   program for the individual components). The first <code>dim</code>
   components are the vector velocity, and then we have pressure for the
   Stokes part, whereas temperature is scalar. This information is read out
   using the <a class="el" href="namespaceDataComponentInterpretation.html">DataComponentInterpretation</a> helper class. Next, we actually
   attach the data vectors with their <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, build patches
   according to the degree of freedom, which are (sub-) elements that
   describe the data for visualization programs. Finally, we open a file
   (that includes the time step number) and write the vtk data into it.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">if</span> (timestep_number % 10 != 0)</div><div class="line">    <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">  std::vector&lt;std::string&gt; stokes_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">  stokes_names.emplace_back(<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">  std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">    stokes_component_interpretation(</div><div class="line">      dim + 1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    stokes_component_interpretation[i] =</div><div class="line">      <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(stokes_dof_handler,</div><div class="line">                           stokes_solution,</div><div class="line">                           stokes_names,</div><div class="line">                           stokes_component_interpretation);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(temperature_dof_handler,</div><div class="line">                           temperature_solution,</div><div class="line">                           <span class="stringliteral">&quot;T&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(stokes_degree, temperature_degree));</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                       <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 4) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemrefine_mesh"></a> 
   </p><h4>BoussinesqFlowProblem::refine_mesh</h4>
<p></p>
<p>This function takes care of the adaptive mesh refinement. The three tasks
   this function performs is to first find out which cells to
   refine/coarsen, then to actually do the refinement and eventually
   transfer the solution vectors between the two different grids. The first
   task is simply achieved by using the well-established Kelly error
   estimator on the temperature (it is the temperature we're mainly
   interested in for this program, and we need to be accurate in regions of
   high temperature gradients, also to not have too much numerical
   diffusion). The second task is to actually do the remeshing. That
   involves only basic functions as well, such as the
   <code>refine_and_coarsen_fixed_fraction</code> that refines those cells
   with the largest estimated error that together make up 80 per cent of the
   error, and coarsens those cells with the smallest error that make up for
   a combined 10 per cent of the error.</p>
<p>If implemented like this, we would get a program that will not make much
   progress: Remember that we expect temperature fields that are nearly
   discontinuous (the diffusivity \(\kappa\) is very small after all) and
   consequently we can expect that a freely adapted mesh will refine further
   and further into the areas of large gradients. This decrease in mesh size
   will then be accompanied by a decrease in time step, requiring an
   exceedingly large number of time steps to solve to a given final time. It
   will also lead to meshes that are much better at resolving
   discontinuities after several mesh refinement cycles than in the
   beginning.</p>
<p>In particular to prevent the decrease in time step size and the
   correspondingly large number of time steps, we limit the maximal
   refinement depth of the mesh. To this end, after the refinement indicator
   has been applied to the cells, we simply loop over all cells on the
   finest level and unselect them from refinement if they would result in
   too high a mesh level.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">BoussinesqFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(temperature_dof_handler,</div><div class="line">                                     <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(temperature_degree + 1),</div><div class="line">                                     {},</div><div class="line">                                     temperature_solution,</div><div class="line">                                     estimated_error_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.8,</div><div class="line">                                                    0.1);</div><div class="line">  <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &gt; max_grid_level)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell :</div><div class="line">         triangulation.<a class="code" href="group__CPP11.html#gac10cd3fe6ef8360e2599d3cff58e13e8">active_cell_iterators_on_level</a>(max_grid_level))</div><div class="line">      cell-&gt;clear_refine_flag();</div></div><!-- fragment --><p>As part of mesh refinement we need to transfer the solution vectors
   from the old mesh to the new one. To this end we use the
   <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> class and we have to prepare the solution vectors that
   should be transferred to the new grid (we will lose the old grid once
   we have done the refinement so the transfer has to happen concurrently
   with refinement). What we definitely need are the current and the old
   temperature (BDF-2 time stepping requires two old solutions). Since the
   <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> objects only support to transfer one object per dof
   handler, we need to collect the two temperature solutions in one data
   structure. Moreover, we choose to transfer the Stokes solution, too,
   since we need the velocity at two previous time steps, of which only
   one is calculated on the fly.</p>
<p>Consequently, we initialize two <a class="el" href="classSolutionTransfer.html">SolutionTransfer</a> objects for the Stokes
   and temperature <a class="el" href="classDoFHandler.html">DoFHandler</a> objects, by attaching them to the old dof
   handlers. With this at place, we can prepare the triangulation and the
   data vectors for refinement (in this order).</p>
<div class="fragment"><div class="line">std::vector&lt;TrilinosWrappers::MPI::Vector&gt; x_temperature(2);</div><div class="line">x_temperature[0]                            = temperature_solution;</div><div class="line">x_temperature[1]                            = old_temperature_solution;</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> x_stokes = stokes_solution;</div><div class="line"></div><div class="line"><a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a> temperature_trans(</div><div class="line">  temperature_dof_handler);</div><div class="line"><a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::BlockVector&gt;</a> stokes_trans(</div><div class="line">  stokes_dof_handler);</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);</div><div class="line">stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);</div></div><!-- fragment --><p>Now everything is ready, so do the refinement and recreate the dof
   structure on the new grid, and initialize the matrix structures and the
   new vectors in the <code>setup_dofs</code> function. Next, we actually
   perform the interpolation of the solutions between the grids. We create
   another copy of temporary vectors for temperature (now corresponding to
   the new grid), and let the interpolate function do the job. Then, the
   resulting array of vectors is written into the respective vector member
   variables.</p>
<p>Remember that the set of constraints will be updated for the new
   triangulation in the setup_dofs() call.</p>
<div class="fragment"><div class="line">triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">setup_dofs();</div><div class="line"></div><div class="line">std::vector&lt;TrilinosWrappers::MPI::Vector&gt; tmp(2);</div><div class="line">tmp[0].reinit(temperature_solution);</div><div class="line">tmp[1].reinit(temperature_solution);</div><div class="line">temperature_trans.interpolate(x_temperature, tmp);</div><div class="line"></div><div class="line">temperature_solution     = tmp[0];</div><div class="line">old_temperature_solution = tmp[1];</div></div><!-- fragment --><p>After the solution has been transferred we then enforce the constraints
   on the transferred solution.</p>
<div class="fragment"><div class="line">temperature_constraints.distribute(temperature_solution);</div><div class="line">temperature_constraints.distribute(old_temperature_solution);</div></div><!-- fragment --><p>For the Stokes vector, everything is just the same &ndash; except that
   we do not need another temporary vector since we just interpolate a
   single vector. In the end, we have to tell the program that the matrices
   and preconditioners need to be regenerated, since the mesh has changed.</p>
<div class="fragment"><div class="line">  stokes_trans.interpolate(x_stokes, stokes_solution);</div><div class="line"></div><div class="line">  stokes_constraints.distribute(stokes_solution);</div><div class="line"></div><div class="line">  rebuild_stokes_matrix         = <span class="keyword">true</span>;</div><div class="line">  rebuild_temperature_matrices  = <span class="keyword">true</span>;</div><div class="line">  rebuild_stokes_preconditioner = <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="BoussinesqFlowProblemrun"></a> 
   </p><h4>BoussinesqFlowProblem::run</h4>
<p></p>
<p>This function performs all the essential steps in the Boussinesq
   program. It starts by setting up a grid (depending on the spatial
   dimension, we choose some different level of initial refinement and
   additional adaptive refinement steps, and then create a cube in
   <code>dim</code> dimensions and set up the dofs for the first time. Since
   we want to start the time stepping already with an adaptively refined
   grid, we perform some pre-refinement steps, consisting of all assembly,
   solution and refinement, but without actually advancing in time. Rather,
   we use the vilified <code>goto</code> statement to jump out of the time
   loop right after mesh refinement to start all over again on the new mesh
   beginning at the <code>start_time_iteration</code> label. (The use of the
   <code>goto</code> is discussed in <a class="el" href="step_26.html">step-26</a>.)</p>
<p>Before we start, we project the initial values to the grid and obtain the
   first data for the <code>old_temperature_solution</code> vector. Then, we
   initialize time step number and time step and start the time loop.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">BoussinesqFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement     = (dim == 2 ? 4 : 2);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_pre_refinement_steps = (dim == 2 ? 4 : 3);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">  global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(triangulation);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(initial_refinement);</div><div class="line"></div><div class="line">  setup_dofs();</div><div class="line"></div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"></div><div class="line">start_time_iteration:</div><div class="line"></div><div class="line">  <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(temperature_dof_handler,</div><div class="line">                       temperature_constraints,</div><div class="line">                       <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(temperature_degree + 2),</div><div class="line">                       EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">                       old_temperature_solution);</div><div class="line"></div><div class="line">  timestep_number = 0;</div><div class="line">  time_step = old_time_step = 0;</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> time = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time</div><div class="line">                &lt;&lt; std::endl;</div></div><!-- fragment --><p>The first steps in the time loop are all obvious &ndash; we
   assemble the Stokes system, the preconditioner, the temperature
   matrix (matrices and preconditioner do actually only change in case
   we've remeshed before), and then do the solve. Before going on with
   the next time step, we have to check whether we should first finish
   the pre-refinement steps or if we should remesh (every fifth time
   step), refining up to a level that is consistent with initial
   refinement and pre-refinement steps. Last in the loop is to advance
   the solutions, i.e., to copy the solutions to the next "older" time
   level.</p>
<div class="fragment"><div class="line">  assemble_stokes_system();</div><div class="line">  build_stokes_preconditioner();</div><div class="line">  assemble_temperature_matrix();</div><div class="line"></div><div class="line">  solve();</div><div class="line"></div><div class="line">  output_results();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">      (pre_refinement_step &lt; n_pre_refinement_steps))</div><div class="line">    {</div><div class="line">      refine_mesh(initial_refinement + n_pre_refinement_steps);</div><div class="line">      ++pre_refinement_step;</div><div class="line">      <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp; (timestep_number % 5 == 0))</div><div class="line">    refine_mesh(initial_refinement + n_pre_refinement_steps);</div><div class="line"></div><div class="line">  time += time_step;</div><div class="line">  ++timestep_number;</div><div class="line"></div><div class="line">  old_stokes_solution          = stokes_solution;</div><div class="line">  old_old_temperature_solution = old_temperature_solution;</div><div class="line">  old_temperature_solution     = temperature_solution;</div><div class="line">}</div></div><!-- fragment --><p>Do all the above until we arrive at time 100.</p>
<div class="fragment"><div class="line">    <span class="keywordflow">while</span> (time &lt;= 100);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step31</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> 
   </p><h3>The <code>main</code> function</h3>
<p></p>
<p>The main function looks almost the same as in all other programs.</p>
<p>There is one difference we have to be careful about. This program uses
   Trilinos and, typically, Trilinos is configured so that it can run in
   parallel using MPI. This doesn't mean that it <em>has</em> to run in
   parallel, and in fact this program (unlike <a class="el" href="step_32.html">step-32</a>) makes no attempt at
   all to do anything in parallel using MPI. Nevertheless, Trilinos wants the
   MPI system to be initialized. We do that be creating an object of type
   <a class="el" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> that initializes MPI (if available) using
   the arguments given to main() (i.e., <code>argc</code> and
   <code>argv</code>) and de-initializes it again when the object goes out of
   scope.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step31;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div></div><!-- fragment --><p>This program can only be run in serial. Otherwise, throw an exception.</p>
<div class="fragment"><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-31&quot;</span>));</div><div class="line"></div><div class="line">      BoussinesqFlowProblem&lt;2&gt; flow_problem;</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>
examples/step-31/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p></p>
<p><a class="anchor" id="Resultsin2d"></a></p><h3>Results in 2d </h3>
<p></p>
<p>当你在2D中运行该程序时，输出将看起来像这样。<code> </p><pre> 活动单元的数量：256（在5层） 自由度的数量：3556（2178+289+1089)</pre><p></code></p>
<p><code></p><pre>时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：0.919118温度的9次CG迭代。    温度范围：-0.16687 1.30011</pre><p></code></p>
<p><code></p><pre>活动单元的数量：280（在6层） 自由度的数量：4062（2490+327+1245）。</pre><p></code></p>
<p><code></p><pre>时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：0.459559温度的9次CG迭代。    温度范围：-0.0982971 0.598503</pre><p></code></p>
<p><code></p><pre>活动单元的数量：520（在7个层面上） 自由度的数量：7432（4562+589+2281）。</pre><p></code></p>
<p><code></p><pre>时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：0.229779 温度的9次CG迭代。    温度范围：-0.0551098 0.294493</pre><p></code></p>
<p><code></p><pre>活动单元的数量：1072（在8层） 自由度的数量：15294（9398+1197+4699）。</pre><p></code></p>
<p><code></p><pre>时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：0.11489 温度的9次CG迭代。    温度范围：-0.0273524 0.156861</pre><p></code></p>
<p><code></p><pre>活动单元的数量：2116（在9层） 自由度的数量：30114（18518+2337+9259）。</pre><p></code></p>
<p><code></p><pre>时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：0.0574449温度的9次CG迭代。    温度范围：-0.014993 0.0738328</pre><p></code></p>
<p><code></p><pre>时间步骤1：t=0.0574449 装配...    解决...    斯托克斯子系统的56次GMRES迭代。    时间步长：0.0574449 温度的9次CG迭代。    温度范围：-0.0273934 0.14488</pre><p></code></p>
<p><code></p><pre>...</pre><p> </code></p>
<p>在开始的时候，我们自适应地细化了几次网格，并总是返回到时间步长为零的新细化的网格上重新开始。只有这样，我们才开始实际的时间迭代。</p>
<p>程序运行了一段时间。时间步数为0、500、1000、1500、2000、3000、4000和5000的温度字段看起来是这样的（注意温度使用的色标并不总是相同）。</p>
<table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.00.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.01.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.02.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.03.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.04.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.05.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.06.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.solution.07.png"/>
</div>
   </td></tr>
</table>
<p>这里显示的视觉效果是使用实例的一个版本生成的，该版本在传输网格后没有强制执行约束。</p>
<p>可以看出，我们有三个加热流体的热源，因此产生了一个浮力效应，让流体的热袋上升并旋转起来。通过烟囱效应，这三股气流被来自外部并想加入上升气流的流体压在一起。请注意，由于流体最初处于静止状态，那些最初在源头上的流体部分比后来被充分发展的流场拖到源头上的流体获得更长的加热时间。因此，它更热，这一事实可以从三个羽流的红色尖端看出。还要注意流场的相对精细的特征，这是我们选择的温度方程的复杂传输稳定的结果。</p>
<p>除了上面的图片外，下面的图片显示了自适应网格和同一时间步长的流场。</p>
<table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.00.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.01.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.02.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.03.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.04.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.05.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.06.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.2d.grid.07.png"/>
</div>
   </td></tr>
</table>
<p><a class="anchor" id="Resultsin3d"></a></p><h3>Results in 3d </h3>
<p></p>
<p>当然，同样的事情也可以在3D中完成，将 <code>main()</code> 中的BoussinesqFlowProblem对象的模板参数从2改为3，这样，现在的输出看起来如下。</p>
<p><code> </p><pre> 活动单元的数量：64（在3层） 自由度的数量：3041（2187+125+729）。</pre><p></code></p>
<p><code></p><pre>时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：2.45098 温度的9次CG迭代。    温度范围：-0.675683 4.94725</pre><p></code></p>
<p><code></p><pre>活动单元的数量：288（在4层） 自由度的数量：12379（8943+455+2981）。</pre><p></code></p>
<p><code></p><pre>时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：1.22549 温度的9次CG迭代。    温度范围：-0.527701 2.25764</pre><p></code></p>
<p><code></p><pre>活动单元的数量：1296（在5层） 自由度的数量：51497（37305+1757+12435）。</pre><p></code></p>
<p><code></p><pre>时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：0.612745温度的10次CG迭代。    温度范围：-0.496942 0.847395</pre><p></code></p>
<p><code></p><pre>活动单元的数量：5048（在6层） 自由度的数量：192425（139569+6333+46523）。</pre><p></code></p>
<p><code></p><pre>时间步数0: t=0 正在组装...    重建斯托克斯预处理程序...    解算...    0次GMRES迭代，用于斯托克斯子系统。    时间步长：0.306373 温度的10次CG迭代。    温度范围：-0.267683 0.497739</pre><p></code></p>
<p><code></p><pre>时间步数1：t=0.306373 正在组装...    解决...    斯托克斯子系统的27次GMRES迭代。    时间步长：0.306373 温度的10次CG迭代。    温度范围：-0.461787 0.958679</pre><p></code></p>
<p><code></p><pre>...</pre><p> </code></p>
<p>在时间步数为0、50、100、150、200、300、400、500、600、700和800的情况下，将温度等值线可视化，得到以下图示。</p>
<table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.00.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.01.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.02.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.03.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.04.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.05.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.06.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.07.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.08.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.09.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.3d.solution.10.png"/>
</div>
  </td><td></td></tr>
</table>
<p>第一张图片看起来像三只刺猬，这是因为我们的方案基本上是将源乘以第一时间步长投射到网格上，以获得第一时间步的温度场。由于源函数是不连续的，我们需要期待这个项目的过冲和欠冲。这就是事实上发生的情况（在2d中更容易检查），并导致等值面的皱缩外观。 这里显示的视觉效果是使用例子的一个版本生成的，该版本在传输网格后没有强制执行约束。</p>
<p><a class="anchor" id="Numericalexperimentstodetermineoptimalparameters"></a></p><h3>Numerical experiments to determine optimal parameters </h3>
<p></p>
<p class="endli">现在的程序有三个参数，我们在理论上并没有掌握如何以最佳方式进行选择。这三个参数是。 </p><ul>
<li>
时间步骤必须满足CFL条件 \(k\le \min_K \frac{c_kh_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 。这里， \(c_k\) 是无量纲的，但什么是正确的值？ </li>
<li>
<p class="startli">在计算人工黏度时。</p>
<p class="formulaDsp">
\begin{eqnarray*} \nu_\alpha(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} \min\left\{ h_K, h_K^\alpha \frac{\|R_\alpha(T)\|_{L^\infty(K)}}{c(\mathbf{u},T)} \right\}, \end{eqnarray*}
</p>
 <pre class="fragment"> 与 \form#3652@_fakenl@_fakenl  。       这里，无量纲%数 \form#3737 的选择是有意义的。   &lt;/ul&gt;  在所有这些情况下，我们将不得不期望每个值的正确选择取决于其他值的正确选择，而且很可能也取决于用于温度的有限元的空间尺寸和多项式程度。下面我们将讨论一些数值实验来选择常数 \form#3735  和 \form#633  。
</pre><p>下面，我们将不讨论 \(c_R\) 的选择问题。在程序中，我们将其设定为 \(c_R=2^{\frac{4-2\alpha}{d}}\) 。这个值的原因有点复杂，与程序的历史而不是推理有关：虽然全局缩放参数 \(c(\mathbf{u},T)\) 的正确公式如上所示，但程序（包括与deal.II 6.2一起出厂的版本）最初有一个错误，即我们计算的是 \(c(\mathbf{u},T) = \|\mathbf{u}\|_{L^\infty(\Omega)} \ \mathrm{var}(T) \ \frac{1}{|\mathrm{diam}(\Omega)|^{\alpha-2}}\) ，而在这里我们将缩放参数设置为1。由于我们只在 \(\mathrm{diam}(\Omega)=2^{1/d}\) 的单位平方/立方体上进行计算，这完全等同于使用 \(c_R=\left(2^{1/d}\right)^{4-2\alpha}=2^{\frac{4-2\alpha}{d}}\) 的正确公式。由于 \(c_R\) 的这个值对于当前的程序来说似乎很好用，我们在程序中修正了公式，并将 \(c_R\) 设置为一个值，正好再现了我们之前的结果。不过，我们将在第32步中再次审视这个问题。</p>
<p>然而，现在回到讨论 \(c_k\) 和 \(\beta\) 的什么值来选择。</p>
<p><a class="anchor" id="Choosingicsubksubiicsubksubiandbeta"></a></p><h4>Choosing <em>c<sub>k</sub></em><em>c<sub>k</sub></em> and beta </h4>
<p>。</p>
<p>这两个常数肯定在某种程度上有联系。原因很容易看出来。在纯平流问题的情况下， \(\frac{\partial T}{\partial t} + \mathbf{u}\cdot\nabla T = \gamma\) ，任何显式方案都必须满足形式为 \(k\le \min_K \frac{c_k^a h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 的CFL条件。另一方面，对于纯扩散问题， \(\frac{\partial T}{\partial t} + \nu \Delta T = \gamma\) ，显式方案需要满足一个条件 \(k\le \min_K \frac{c_k^d h_K^2}{\nu}\) 。因此，鉴于上述 \(\nu\) 的形式，像我们这里要解决的平流扩散问题将导致一个 \( k\le \min_K \min \left\{ \frac{c_k^a h_K}{\|\mathbf{u}\|_{L^\infty(K)}}, \frac{c_k^d h_K^2}{\beta \|\mathbf{u}\|_{L^\infty(K)} h_K}\right\} = \min_K \left( \min \left\{ c_k^a, \frac{c_k^d}{\beta}\right\} \frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}} \right) \) 的条件。因此，我们必须面对这样一个事实：我们可能想选择 \(\beta\) 大一些，以提高数值方案的稳定性（通过增加人工扩散量），但我们必须以更小的、因而更多的时间步骤为代价。因此，在实践中，人们希望尽可能地选择 \(\beta\) ，以保持传输问题的充分稳定，同时尽量选择大的时间步长，以减少总体工作量。</p>
<p>要找到正确的平衡，唯一的办法是做一些计算实验。下面是我们的做法。我们稍微修改了程序，允许更少的网格细化（所以我们不一定要等那么久），并选择 \( \nu(T)|_K = \beta \|\mathbf{u}\|_{L^\infty(K)} h_K \) 来消除常数 \(c_R\) 的影响（我们知道通过使用这个版本的 \(\nu(T)\) 作为人工粘度，解决方案是稳定的，但我们可以通过使用这个人工粘度的更复杂的公式来改善情况&ndash;即使解决方案更清晰）。然后我们对不同的值 \(c_k,\beta\) 运行程序，观察域中的最大和最小温度。我们期望看到的情况是这样的。如果我们选择的时间步长过大（即选择一个比理论上允许的大的 \(c_k\) ），那么我们将得到温度的指数式增长。如果我们选择 \(\beta\) 太小，那么传输稳定变得不充分，解决方案将显示出明显的振荡，但不是指数级增长。</p>
<p><a class="anchor" id="ResultsforQsub1subelements"></a></p><h5>Results for Q<sub>1</sub> elements</h5>
<p></p>
<p>下面是我们对 \(\beta=0.01, \beta=0.1\) ，和 \(\beta=0.5\) ， \(c_k\) 的不同选择，以及2d的双线性元素（ <code>temperature_degree=1</code> ）得到的结果。</p>
<table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q1.beta=0.01.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q1.beta=0.03.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q1.beta=0.1.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q1.beta=0.5.png"/>
</div>
   </td></tr>
</table>
<p>解释这些图表的方法是这样的：对于 \(\beta=0.01\) 和 \(c_k=\frac 12,\frac 14\) ，我们看到指数增长或至少是大的变化，但如果我们选择 \(k=\frac 18\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 或更小，那么这个方案虽然有点摇摆不定，但还是稳定的。对于更多的人工扩散，我们可以选择 \(k=\frac 14\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 或更小的 \(\beta=0.03\) ， \(k=\frac 13\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 或更小的 \(\beta=0.1\) ，并再次需要 \(k=\frac 1{15}\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 的 \(\beta=0.5\) （这次是因为许多扩散需要一个小的时间步长）。</p>
<p>那么该如何选择呢？如果我们只是对大时间步长感兴趣，那么我们会选择 \(\beta=0.1\) 和 \(k=\frac 13\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 。另一方面，我们也对准确性感兴趣，在这里，实际调查这些曲线所显示的内容可能会有兴趣。为此，请注意，我们从零温度开始，我们的来源是正的&amp;mdash；所以我们会直观地期望温度永远不会降到零以下。但它确实如此，这是使用连续元素来近似不连续的解决方案时，吉布现象的结果。因此，我们可以看到，选择 \(\beta\) 太小是不好的：太少的人工扩散会导致没有扩散掉的过冲和欠冲。另一方面，对于大的 \(\beta\) ，最低温度在开始时下降到零以下，但随后迅速扩散回零。</p>
<p>另一方面，我们也来看看最高温度。观察溶液的电影，我们看到最初流体处于静止状态。源头不断加热相同体积的流体，其温度在开始时呈线性增长，直到其浮力能够使其向上移动。因此，流体中最热的部分被带离了溶液，取而代之的流体只被加热了很短的时间就被移出了源区，因此仍然比初始气泡要冷。如果 \(\kappa=0\) （在程序中是非零的，但非常小），那么流体中最热的部分应该随着流动而平移，其温度不变。这就是我们在最小的 \(\beta\) 图中可以看到的：一旦达到最高温度，它就几乎不再变化。另一方面，人工扩散越大，热点的扩散就越多。请注意，对于这个标准，时间步长的大小并不发挥重要作用。</p>
<p>因此，总结起来，可能最好的选择似乎是 \(\beta=0.03\) 和 \(k=\frac 14\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 。曲线有点摇摆不定，但总的来说，图片看起来相当合理，除了由于吉布现象而在接近开始时间时出现一些过冲和欠冲的情况。</p>
<p><a class="anchor" id="ResultsforQsub2subelements"></a></p><h5>Results for Q<sub>2</sub> elements</h5>
<p></p>
<p>我们也可以对高阶元素重复同样的实验序列。这里是温度的双二次方形状函数（ <code>temperature_degree=2</code> ）的图形，同时我们保留了斯托克斯系统的 \(Q_2/Q_1\) 稳定泰勒-胡德元素。</p>
<table align="center" class="doxtable">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q2.beta=0.01.png"/>
</div>
  </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q2.beta=0.03.png"/>
</div>
   </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-31.timestep.q2.beta=0.1.png"/>
</div>
   </td></tr>
</table>
<p>同样， \(\beta\) 的小值会导致较少的扩散，但我们必须选择非常小的时间步长来保持事情的控制。太大的 \(\beta\) 值会导致更多的扩散，但同样需要小的时间步骤。最佳值似乎是 \(\beta=0.03\) ，和 \(Q_1\) 元素一样，然后我们必须选择 \(k=\frac 18\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) &amp;mdash；正好是 \(Q_1\) 元素的一半大小。]元素，如果我们把CFL条件说成是要求时间步长足够小，以便运输在每个时间步长中的移动距离不超过一个<em>grid point</em>距离（对于 \(Q_1\) 元素是 \(h_K\) ，但对于 \(Q_2\) 元素是 \(h_K/2\) ），这个事实可能并不令人惊讶。事实证明， \(\beta\) 需要稍微大一点，以便在模拟后期获得稳定的结果，时间大于60，所以我们实际上在代码中选择它作为 \(\beta = 0.034\) 。</p>
<p><a class="anchor" id="Resultsfor3d"></a></p><h5>Results for 3d</h5>
<p></p>
<p>我们可以在3D中重复这些实验，找到每个 \(\beta\) 值的最佳时间步骤，并找到 \(\beta\) 的最佳值。人们发现，对于2d中已经使用的相同的 \(\beta\) ，时间步长需要小一点，大约是1.2倍左右。这很容易解释：时间步长的限制是 \(k=\min_K \frac{ch_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) ，其中 \(h_K\) 是单元的<em>diameter</em>。然而，真正需要的是网格点之间的距离，它是 \(\frac{h_K}{\sqrt{d}}\) 。所以更合适的形式是 \(k=\min_K \frac{ch_K}{\|\mathbf{u}\|_{L^\infty(K)}\sqrt{d}}\) 。</p>
<p>第二个发现是，需要把 \(\beta\) 选得稍微大一点（大约 \(\beta=0.05\) 左右）。这就再次减少了我们可以采取的时间步骤。</p>
<p><a class="anchor" id="Conclusions"></a></p><h5>Conclusions</h5>
<p></p>
<p>总之，从上面的简单计算来看， \(\beta=0.034\) 似乎是2D中稳定参数的一个好选择，而 \(\beta=0.05\) 则是3D中的稳定参数。以独立于维度的方式，我们可以将其建模为 \(\beta=0.017d\) 。如果在更细的网格上做更长时间的计算（几千个时间步长），就会意识到时间步长还不够小，为了稳定，就必须把上述数值再降低一些（大约是 \(\frac 78\) 的一个系数）。</p>
<p>因此，调和2D、3D和可变多项式程度并考虑到所有因素的公式如下。</p>
<p class="formulaDsp">
\begin{eqnarray*} k = \frac 1{2 \cdot 1.7} \frac 1{\sqrt{d}} \frac 2d \frac 1{q_T} \frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}} = \frac 1{1.7 d\sqrt{d}} \frac 1{q_T} \frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}. \end{eqnarray*}
</p>
<p>在第一种形式中（方程中心）， \(\frac 1{2 \cdot 1.7}\) 是一个通用常数， \(\frac 1{\sqrt{d}}\) 是说明单元直径和网格点间距的因素， \(\frac 2d\) 说明 \(\beta\) 随着空间尺寸的增加而增加， \(\frac 1{q_T}\) 说明高阶元素的网格点之间的距离， \(\frac{h_K}{\|\mathbf{u}\|_{L^\infty(K)}}\) 说明相对于单元尺寸的局部传输速度。这就是我们在程序中使用的公式。</p>
<p>至于对温度使用 \(Q_1\) 或 \(Q_2\) 元素的问题，以下考虑可能是有用的。首先，解决温度方程在整个方案中几乎不是一个因素，因为几乎所有的计算时间都用于解决每个时间步骤中的斯托克斯系统。因此，温度方程的高阶元素并不是一个重要的缺点。另一方面，如果比较一下由于不连续的源描述而产生的过冲和欠冲的大小，我们会注意到，对于上述 \(\beta\) 和 \(k\) 的选择， \(Q_1\) 的解决方案下降到 \(-0.47\) 左右，而 \(Q_2\) 的解决方案只到 \(-0.13\) （记住，精确解决方案根本不应该变成负数。这意味着 \(Q_2\) 解明显更准确；因此程序使用这些高阶元素，尽管我们在较小的时间步长方面付出了代价。</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p></p>
<p>有各种方法来扩展当前的程序。当然，特别感兴趣的是使其更快和/或提高程序的分辨率，特别是在3D方面。这就是<a class="el" href="step_32.html">step-32</a>教程程序的主题，它将实现在集群上以并行方式解决这个问题的策略。它也是更大的开放源代码ASPECT（见https://aspect.geodynamics.org/）的基础，它可以解决现实问题，并构成<a class="el" href="step_32.html">step-32</a>的进一步发展。</p>
<p>另一个方向是使流体流动更加真实。这个程序最初是为了模拟各种情况，模拟地幔中的物质对流，即外地核和固体地壳之间的区域：在那里，物质从下面被加热，从上面被冷却，导致热对流。然而，这种流体的物理学要比这个程序中显示的复杂得多。地幔材料的粘度与温度有很大的关系，即 \(\eta=\eta(T)\) ，这种关系经常被模拟为粘度随温度升高而呈指数下降。其次，地幔的大部分动态是由化学反应决定的，主要是构成地幔的各种晶体的相变；然后，斯托克斯方程右边的浮力项不仅取决于温度，而且还取决于某个特定位置的化学成分，这些化学成分被流场平流，但也作为压力和温度的函数而变化。我们将在以后的教程程序中也研究其中的一些影响。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2007 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Martin Kronbichler, Uppsala University,</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University 2007, 2008</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__gmres_8h.html">deal.II/lac/solver_gmres.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="block__sparsity__pattern_8h.html">deal.II/lac/block_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__sparse__matrix_8h.html">deal.II/lac/trilinos_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__block__sparse__matrix_8h.html">deal.II/lac/trilinos_block_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__vector_8h.html">deal.II/lac/trilinos_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__parallel__block__vector_8h.html">deal.II/lac/trilinos_parallel_block_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="trilinos__precondition_8h.html">deal.II/lac/trilinos_precondition.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;limits&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step31</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>EquationData</div><div class="line">  {</div><div class="line">    constexpr <span class="keywordtype">double</span> eta     = 1;</div><div class="line">    constexpr <span class="keywordtype">double</span> kappa   = 1e-6;</div><div class="line">    constexpr <span class="keywordtype">double</span> beta    = 10;</div><div class="line">    constexpr <span class="keywordtype">double</span> density = 1;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>TemperatureInitialValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      TemperatureInitialValues()</div><div class="line">        : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; <span class="comment">/*p*/</span>,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span> = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                Vector&lt;double&gt; &amp;  value)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">          value(c) = TemperatureInitialValues&lt;dim&gt;::value(p, c);</div><div class="line">      }</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">    <span class="keyword">class </span>TemperatureRightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      TemperatureRightHandSide()</div><div class="line">        : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1)</div><div class="line">      {}</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        (void)component;</div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(component == 0,</div><div class="line">               <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(<span class="stringliteral">&quot;Invalid operation for a scalar function.&quot;</span>));</div><div class="line"></div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>((dim == 2) || (dim == 3), <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> source_centers[3] = {</div><div class="line">          (dim == 2 ? <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(.3, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.3, .5, .1)),</div><div class="line">          (dim == 2 ? <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.45, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.45, .5, .1)),</div><div class="line">          (dim == 2 ? <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.75, .1) : <a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(.75, .5, .1))};</div><div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> source_radius = (dim == 2 ? 1. / 32 : 1. / 8);</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> ((source_centers[0].distance(p) &lt; source_radius) ||</div><div class="line">                    (source_centers[1].<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(p) &lt; source_radius) ||</div><div class="line">                    (source_centers[2].distance(p) &lt; source_radius) ?</div><div class="line">                  1 :</div><div class="line">                  0);</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="keyword">virtual</span> <span class="keywordtype">void</span> vector_value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                Vector&lt;double&gt; &amp;  value)<span class="keyword"> const override</span></div><div class="line"><span class="keyword">      </span>{</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; this-&gt;n_components; ++c)</div><div class="line">          value(c) = TemperatureRightHandSide&lt;dim&gt;::value(p, c);</div><div class="line">      }</div><div class="line">    };</div><div class="line">  } <span class="comment">// namespace EquationData</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">namespace </span>LinearSolvers</div><div class="line">  {</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    <span class="keyword">class </span>InverseMatrix : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      InverseMatrix(<span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">                    <span class="keyword">const</span> PreconditionerType &amp;preconditioner);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">      <span class="keywordtype">void</span> vmult(<a class="code" href="classVectorType.html">VectorType</a> &amp;dst, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const MatrixType&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>;</div><div class="line">      <span class="keyword">const</span> PreconditionerType &amp;           preconditioner;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    InverseMatrix&lt;MatrixType, PreconditionerType&gt;::InverseMatrix(</div><div class="line">      <span class="keyword">const</span> MatrixType &amp;        m,</div><div class="line">      <span class="keyword">const</span> PreconditionerType &amp;preconditioner)</div><div class="line">      : <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>(&amp;m)</div><div class="line">      , preconditioner(preconditioner)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> MatrixType, <span class="keyword">class</span> PreconditionerType&gt;</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">    <span class="keywordtype">void</span> InverseMatrix&lt;MatrixType, PreconditionerType&gt;::vmult(</div><div class="line">      <a class="code" href="classVectorType.html">VectorType</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a>        solver_control(src.size(), 1e-7 * src.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;VectorType&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">      dst = 0;</div><div class="line"></div><div class="line">      <span class="keywordflow">try</span></div><div class="line">        {</div><div class="line">          cg.solve(*<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, dst, src, preconditioner);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">catch</span> (std::exception &amp;e)</div><div class="line">        {</div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(e.what()));</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    <span class="keyword">class </span>BlockSchurPreconditioner : <span class="keyword">public</span> <a class="code" href="classSubscriptor.html">Subscriptor</a></div><div class="line">    {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">      BlockSchurPreconditioner(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">        <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                            PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">        <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner);</div><div class="line"></div><div class="line">      <span class="keywordtype">void</span> <a class="code" href="structSUNDIALS_1_1SundialsPreconditioner.html#aff5a880cfa288ecdd2a83a876abacf0d">vmult</a>(<a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">                 <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer&lt;const TrilinosWrappers::BlockSparseMatrix&gt;</a></div><div class="line">        stokes_matrix;</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSmartPointer.html">SmartPointer</a>&lt;<span class="keyword">const</span> InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                             PreconditionerTypeMp&gt;&gt;</div><div class="line">                                 m_inverse;</div><div class="line">      <span class="keyword">const</span> PreconditionerTypeA &amp;a_preconditioner;</div><div class="line"></div><div class="line">      <span class="keyword">mutable</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> tmp;</div><div class="line">    };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::</div><div class="line">      BlockSchurPreconditioner(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;S,</div><div class="line">        <span class="keyword">const</span> InverseMatrix&lt;TrilinosWrappers::SparseMatrix,</div><div class="line">                            PreconditionerTypeMp&gt; &amp;Mpinv,</div><div class="line">        <span class="keyword">const</span> PreconditionerTypeA &amp;                Apreconditioner)</div><div class="line">      : stokes_matrix(&amp;S)</div><div class="line">      , m_inverse(&amp;Mpinv)</div><div class="line">      , a_preconditioner(Apreconditioner)</div><div class="line">      , tmp(<a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(stokes_matrix-&gt;block(1, 1).m()))</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> PreconditionerTypeA, <span class="keyword">class</span> PreconditionerTypeMp&gt;</div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    BlockSchurPreconditioner&lt;PreconditionerTypeA, PreconditionerTypeMp&gt;::vmult(</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;      dst,</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;src)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      a_preconditioner.vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0));</div><div class="line">      stokes_matrix-&gt;block(1, 0).residual(tmp, dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(0), src.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1));</div><div class="line">      tmp *= -1;</div><div class="line">      m_inverse-&gt;vmult(dst.<a class="code" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a>(1), tmp);</div><div class="line">    }</div><div class="line">  } <span class="comment">// namespace LinearSolvers</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoussinesqFlowProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoussinesqFlowProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span>   setup_dofs();</div><div class="line">    <span class="keywordtype">void</span>   assemble_stokes_preconditioner();</div><div class="line">    <span class="keywordtype">void</span>   build_stokes_preconditioner();</div><div class="line">    <span class="keywordtype">void</span>   assemble_stokes_system();</div><div class="line">    <span class="keywordtype">void</span>   assemble_temperature_system(<span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity);</div><div class="line">    <span class="keywordtype">void</span>   assemble_temperature_matrix();</div><div class="line">    <span class="keywordtype">double</span> get_maximal_velocity() <span class="keyword">const</span>;</div><div class="line">    std::pair&lt;double, double&gt; get_extrapolated_temperature_range() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span>                      solve();</div><div class="line">    <span class="keywordtype">void</span>                      output_results() <span class="keyword">const</span>;</div><div class="line">    <span class="keywordtype">void</span>                      refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level);</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> compute_viscosity(</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        gamma_values,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_u_infty,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_T_variation,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <span class="keywordtype">double</span>             global_Omega_diameter;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        stokes_degree;</div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>             stokes_fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           stokes_dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> stokes_constraints;</div><div class="line"></div><div class="line">    std::vector&lt;IndexSet&gt;               stokes_partitioning;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_matrix;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> stokes_preconditioner_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> old_stokes_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> stokes_rhs;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        temperature_degree;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>                 temperature_fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>           temperature_dof_handler;</div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> temperature_constraints;</div><div class="line"></div><div class="line">    TrilinosWrappers::SparseMatrix temperature_mass_matrix;</div><div class="line">    TrilinosWrappers::SparseMatrix temperature_stiffness_matrix;</div><div class="line">    TrilinosWrappers::SparseMatrix temperature_matrix;</div><div class="line"></div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> old_old_temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> temperature_rhs;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       time_step;</div><div class="line">    <span class="keywordtype">double</span>       old_time_step;</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> timestep_number;</div><div class="line"></div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionAMG&gt; Amg_preconditioner;</div><div class="line">    std::shared_ptr&lt;TrilinosWrappers::PreconditionIC&gt;  Mp_preconditioner;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> rebuild_stokes_matrix;</div><div class="line">    <span class="keywordtype">bool</span> rebuild_temperature_matrices;</div><div class="line">    <span class="keywordtype">bool</span> rebuild_stokes_preconditioner;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::BoussinesqFlowProblem()</div><div class="line">    : triangulation(<a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::maximum_smoothing)</div><div class="line">    , global_Omega_diameter(<a class="code" href="namespacestd.html">std</a>::numeric_limits&lt;<a class="code" href="classdouble.html">double</a>&gt;::quiet_NaN())</div><div class="line">    , stokes_degree(1)</div><div class="line">    , stokes_fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree + 1), dim, <a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(stokes_degree), 1)</div><div class="line">    , stokes_dof_handler(triangulation)</div><div class="line">    ,</div><div class="line"></div><div class="line">    temperature_degree(2)</div><div class="line">    , temperature_fe(temperature_degree)</div><div class="line">    , temperature_dof_handler(triangulation)</div><div class="line">    ,</div><div class="line"></div><div class="line">    time_step(0)</div><div class="line">    , old_time_step(0)</div><div class="line">    , timestep_number(0)</div><div class="line">    , rebuild_stokes_matrix(true)</div><div class="line">    , rebuild_temperature_matrices(true)</div><div class="line">    , rebuild_stokes_preconditioner(true)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::get_maximal_velocity()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(), stokes_degree + 1);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(stokes_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; velocity_values(n_q_points);</div><div class="line">    <span class="keywordtype">double</span>                      max_velocity = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        fe_values[velocities].<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(stokes_solution,</div><div class="line">                                                  velocity_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_velocity, velocity_values[q].<a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>());</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> max_velocity;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  std::pair&lt;double, double&gt;</div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::get_extrapolated_temperature_range()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQIterated.html">QIterated&lt;dim&gt;</a> quadrature_formula(<a class="code" href="classQTrapezoid.html">QTrapezoid&lt;1&gt;</a>(),</div><div class="line">                                            temperature_degree);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   n_q_points = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(temperature_fe, quadrature_formula, <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line">    std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt; old_old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (timestep_number != 0)</div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">               max_temperature = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                          old_temperature_values);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_old_temperature_solution,</div><div class="line">                                          old_old_temperature_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> temperature =</div><div class="line">                  (1. + time_step / old_time_step) * old_temperature_values[q] -</div><div class="line">                  time_step / old_time_step * old_old_temperature_values[q];</div><div class="line"></div><div class="line">                min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_temperature, temperature);</div><div class="line">                max_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_temperature, temperature);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> std::make_pair(min_temperature, max_temperature);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        <span class="keywordtype">double</span> min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">               max_temperature = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">          {</div><div class="line">            fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">            fe_values.<a class="code" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a>(old_temperature_solution,</div><div class="line">                                          old_temperature_values);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">              {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">double</span> temperature = old_temperature_values[q];</div><div class="line"></div><div class="line">                min_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_temperature, temperature);</div><div class="line">                max_temperature = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_temperature, temperature);</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> std::make_pair(min_temperature, max_temperature);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoussinesqFlowProblem&lt;dim&gt;::compute_viscosity(</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_temperature_grads,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        old_old_temperature_laplacians,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>&gt; &amp;old_old_velocity_values,</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        gamma_values,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_u_infty,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       global_T_variation,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                       cell_diameter)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    constexpr <span class="keywordtype">double</span> beta  = 0.017 * dim;</div><div class="line">    constexpr <span class="keywordtype">double</span> alpha = 1.0;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (global_u_infty == 0)</div><div class="line">      <span class="keywordflow">return</span> 5e-3 * cell_diameter;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points = old_temperature.size();</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> max_residual = 0;</div><div class="line">    <span class="keywordtype">double</span> max_velocity = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> u =</div><div class="line">          (old_velocity_values[q] + old_old_velocity_values[q]) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> dT_dt =</div><div class="line">          (old_temperature[q] - old_old_temperature[q]) / old_time_step;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> u_grad_T =</div><div class="line">          u * (old_temperature_grads[q] + old_old_temperature_grads[q]) / 2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> kappa_Delta_T =</div><div class="line">          EquationData::kappa *</div><div class="line">          (old_temperature_laplacians[q] + old_old_temperature_laplacians[q]) /</div><div class="line">          2;</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> residual =</div><div class="line">          <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>((dT_dt + u_grad_T - kappa_Delta_T - gamma_values[q]) *</div><div class="line">                   std::pow((old_temperature[q] + old_old_temperature[q]) / 2,</div><div class="line">                            alpha - 1.));</div><div class="line"></div><div class="line">        max_residual = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(residual, max_residual);</div><div class="line">        max_velocity = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(std::sqrt(u * u), max_velocity);</div><div class="line">      }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> c_R            = <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2., (4. - 2 * alpha) / dim);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> global_scaling = c_R * global_u_infty * global_T_variation *</div><div class="line">                                  <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(global_Omega_diameter, alpha - 2.);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> (</div><div class="line">      beta * max_velocity *</div><div class="line">      <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(cell_diameter,</div><div class="line">               std::pow(cell_diameter, alpha) * max_residual / global_scaling));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::setup_dofs()</div><div class="line">  {</div><div class="line">    std::vector&lt;unsigned int&gt; stokes_sub_blocks(dim + 1, 0);</div><div class="line">    stokes_sub_blocks[dim] = 1;</div><div class="line"></div><div class="line">    {</div><div class="line">      stokes_dof_handler.distribute_dofs(stokes_fe);</div><div class="line">      <a class="code" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">      stokes_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(stokes_dof_handler,</div><div class="line">                                              stokes_constraints);</div><div class="line">      std::set&lt;types::boundary_id&gt; no_normal_flux_boundaries;</div><div class="line">      no_normal_flux_boundaries.insert(0);</div><div class="line">      <a class="code" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints</a>(stokes_dof_handler,</div><div class="line">                                                      0,</div><div class="line">                                                      no_normal_flux_boundaries,</div><div class="line">                                                      stokes_constraints);</div><div class="line">      stokes_constraints.close();</div><div class="line">    }</div><div class="line">    {</div><div class="line">      temperature_dof_handler.distribute_dofs(temperature_fe);</div><div class="line"></div><div class="line">      temperature_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(temperature_dof_handler,</div><div class="line">                                              temperature_constraints);</div><div class="line">      temperature_constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; stokes_dofs_per_block =</div><div class="line">      <a class="code" href="namespaceDoFTools.html#a796721b56b3a90e4e3973c7caae4c3d8">DoFTools::count_dofs_per_fe_block</a>(stokes_dof_handler, stokes_sub_blocks);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_u = stokes_dofs_per_block[0],</div><div class="line">                       n_p = stokes_dofs_per_block[1],</div><div class="line">                       n_T = temperature_dof_handler.n_dofs();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Number of active cells: &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; (on &quot;</span> &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &lt;&lt; <span class="stringliteral">&quot; levels)&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Number of degrees of freedom: &quot;</span> &lt;&lt; n_u + n_p + n_T &lt;&lt; <span class="stringliteral">&quot; (&quot;</span></div><div class="line">              &lt;&lt; n_u &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_p &lt;&lt; <span class="charliteral">&#39;+&#39;</span> &lt;&lt; n_T &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    stokes_partitioning.resize(2);</div><div class="line">    stokes_partitioning[0] = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_u);</div><div class="line">    stokes_partitioning[1] = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_p);</div><div class="line">    {</div><div class="line">      stokes_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">      dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">      dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">      dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">      dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">      dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (!((c == dim) &amp;&amp; (<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> == dim)))</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        stokes_dof_handler, coupling, dsp, stokes_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      stokes_matrix.reinit(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      Amg_preconditioner.reset();</div><div class="line">      Mp_preconditioner.reset();</div><div class="line">      stokes_preconditioner_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> dsp(2, 2);</div><div class="line"></div><div class="line">      dsp.block(0, 0).reinit(n_u, n_u);</div><div class="line">      dsp.block(0, 1).reinit(n_u, n_p);</div><div class="line">      dsp.block(1, 0).reinit(n_p, n_u);</div><div class="line">      dsp.block(1, 1).reinit(n_p, n_p);</div><div class="line"></div><div class="line">      dsp.collect_sizes();</div><div class="line"></div><div class="line">      <a class="code" href="classTable.html">Table&lt;2, DoFTools::Coupling&gt;</a> coupling(dim + 1, dim + 1);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = 0; c &lt; dim + 1; ++c)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> &lt; dim + 1; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">          <span class="keywordflow">if</span> (c == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a6a742e14fbc92a1c202d77d4f319d5ec">DoFTools::always</a>;</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            coupling[c][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>] = <a class="code" href="namespaceDoFTools.html#ad31df71a29dd76de9b4ab241b2527160a193fa079dee88a75524f669136d6faba">DoFTools::none</a>;</div><div class="line"></div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(</div><div class="line">        stokes_dof_handler, coupling, dsp, stokes_constraints, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      stokes_preconditioner_matrix.reinit(dsp);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      temperature_mass_matrix.clear();</div><div class="line">      temperature_stiffness_matrix.clear();</div><div class="line">      temperature_matrix.clear();</div><div class="line"></div><div class="line">      <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(n_T, n_T);</div><div class="line">      <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(temperature_dof_handler,</div><div class="line">                                      dsp,</div><div class="line">                                      temperature_constraints,</div><div class="line">                                      <span class="keyword">false</span>);</div><div class="line"></div><div class="line">      temperature_matrix.reinit(dsp);</div><div class="line">      temperature_mass_matrix.reinit(temperature_matrix);</div><div class="line">      temperature_stiffness_matrix.reinit(temperature_matrix);</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> temperature_partitioning = <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(n_T);</div><div class="line">    stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_stokes_solution.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line">    stokes_rhs.reinit(stokes_partitioning, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_temperature_solution.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">    old_old_temperature_solution.reinit(temperature_partitioning,</div><div class="line">                                        MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    temperature_rhs.reinit(temperature_partitioning, MPI_COMM_WORLD);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_preconditioner()</div><div class="line">  {</div><div class="line">    stokes_preconditioner_matrix = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(stokes_degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(stokes_fe,</div><div class="line">                                   quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                     <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;2, dim&gt;&gt; grad_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;         phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : stokes_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        stokes_fe_values.reinit(cell);</div><div class="line">        local_matrix = 0;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                grad_phi_u[k] = stokes_fe_values[velocities].gradient(k, q);</div><div class="line">                phi_p[k]      = stokes_fe_values[pressure].value(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                local_matrix(i, j) +=</div><div class="line">                  (EquationData::eta *</div><div class="line">                     <a class="code" href="symmetric__tensor_8h.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a>(grad_phi_u[i], grad_phi_u[j]) +</div><div class="line">                   (1. / EquationData::eta) * phi_p[i] * phi_p[j]) *</div><div class="line">                  stokes_fe_values.JxW(q);</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        stokes_constraints.distribute_local_to_global(</div><div class="line">          local_matrix, local_dof_indices, stokes_preconditioner_matrix);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::build_stokes_preconditioner()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_preconditioner == <span class="keyword">false</span>)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Rebuilding Stokes preconditioner...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    assemble_stokes_preconditioner();</div><div class="line"></div><div class="line">    Amg_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionAMG&gt;();</div><div class="line"></div><div class="line">    std::vector&lt;std::vector&lt;bool&gt;&gt; constant_modes;</div><div class="line">    <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a>     velocity_components(0);</div><div class="line">    <a class="code" href="namespaceDoFTools.html#afc96893388fe1a55c6ae5ae19ba52c6d">DoFTools::extract_constant_modes</a>(stokes_dof_handler,</div><div class="line">                                     stokes_fe.component_mask(</div><div class="line">                                       velocity_components),</div><div class="line">                                     constant_modes);</div><div class="line">    <a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html">TrilinosWrappers::PreconditionAMG::AdditionalData</a> amg_data;</div><div class="line">    amg_data.<a class="code" href="structTrilinosWrappers_1_1PreconditionAMG_1_1AdditionalData.html#a133c7bf7e618aaab51cd84214b731532">constant_modes</a> = constant_modes;</div><div class="line"></div><div class="line">    amg_data.elliptic              = <span class="keyword">true</span>;</div><div class="line">    amg_data.higher_order_elements = <span class="keyword">true</span>;</div><div class="line">    amg_data.smoother_sweeps       = 2;</div><div class="line">    amg_data.aggregation_threshold = 0.02;</div><div class="line">    Amg_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(0, 0),</div><div class="line">                                   amg_data);</div><div class="line"></div><div class="line">    Mp_preconditioner = std::make_shared&lt;TrilinosWrappers::PreconditionIC&gt;();</div><div class="line">    Mp_preconditioner-&gt;initialize(stokes_preconditioner_matrix.block(1, 1));</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    rebuild_stokes_preconditioner = <span class="keyword">false</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_stokes_system()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Assembling...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">      stokes_matrix = 0;</div><div class="line"></div><div class="line">    stokes_rhs = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(stokes_degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(</div><div class="line">      stokes_fe,</div><div class="line">      quadrature_formula,</div><div class="line">      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">        (rebuild_stokes_matrix == <span class="keyword">true</span> ? <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> : <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>(0)));</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values(temperature_fe,</div><div class="line">                                        quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = stokes_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    Vector&lt;double&gt;     local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; old_temperature_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt;          phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;SymmetricTensor&lt;2, dim&gt;&gt; grads_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  div_phi_u(dofs_per_cell);</div><div class="line">    std::vector&lt;double&gt;                  phi_p(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure(dim);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell             = stokes_dof_handler.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc             = stokes_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       temperature_cell = temperature_dof_handler.begin_active();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++temperature_cell)</div><div class="line">      {</div><div class="line">        stokes_fe_values.reinit(cell);</div><div class="line">        temperature_fe_values.reinit(temperature_cell);</div><div class="line"></div><div class="line">        local_matrix = 0;</div><div class="line">        local_rhs    = 0;</div><div class="line"></div><div class="line">        temperature_fe_values.get_function_values(old_temperature_solution,</div><div class="line">                                                  old_temperature_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> old_temperature = old_temperature_values[q];</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                phi_u[k] = stokes_fe_values[velocities].value(k, q);</div><div class="line">                <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">                  {</div><div class="line">                    grads_phi_u[k] =</div><div class="line">                      stokes_fe_values[velocities].symmetric_gradient(k, q);</div><div class="line">                    div_phi_u[k] =</div><div class="line">                      stokes_fe_values[velocities].divergence(k, q);</div><div class="line">                    phi_p[k] = stokes_fe_values[pressure].value(k, q);</div><div class="line">                  }</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (rebuild_stokes_matrix)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  local_matrix(i, j) +=</div><div class="line">                    (EquationData::eta * 2 * (grads_phi_u[i] * grads_phi_u[j]) -</div><div class="line">                     div_phi_u[i] * phi_p[j] - phi_p[i] * div_phi_u[j]) *</div><div class="line">                    stokes_fe_values.JxW(q);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> gravity =</div><div class="line">              -((dim == 2) ? (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 1)) : (<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>(0, 0, 1)));</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              local_rhs(i) += (-EquationData::density * EquationData::beta *</div><div class="line">                               gravity * phi_u[i] * old_temperature) *</div><div class="line">                              stokes_fe_values.JxW(q);</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (rebuild_stokes_matrix == <span class="keyword">true</span>)</div><div class="line">          stokes_constraints.distribute_local_to_global(local_matrix,</div><div class="line">                                                        local_rhs,</div><div class="line">                                                        local_dof_indices,</div><div class="line">                                                        stokes_matrix,</div><div class="line">                                                        stokes_rhs);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          stokes_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                        local_dof_indices,</div><div class="line">                                                        stokes_rhs);</div><div class="line">      }</div><div class="line"></div><div class="line">    rebuild_stokes_matrix = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_matrix()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (rebuild_temperature_matrices == <span class="keyword">false</span>)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    temperature_mass_matrix      = 0;</div><div class="line">    temperature_stiffness_matrix = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>   quadrature_formula(temperature_degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> temperature_fe_values(temperature_fe,</div><div class="line">                                        quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = temperature_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> local_stiffness_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         phi_T(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : temperature_dof_handler.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        local_mass_matrix      = 0;</div><div class="line">        local_stiffness_matrix = 0;</div><div class="line"></div><div class="line">        temperature_fe_values.reinit(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);</div><div class="line">                phi_T[k]      = temperature_fe_values.shape_value(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                {</div><div class="line">                  local_mass_matrix(i, j) +=</div><div class="line">                    (phi_T[i] * phi_T[j] * temperature_fe_values.JxW(q));</div><div class="line">                  local_stiffness_matrix(i, j) +=</div><div class="line">                    (EquationData::kappa * grad_phi_T[i] * grad_phi_T[j] *</div><div class="line">                     temperature_fe_values.JxW(q));</div><div class="line">                }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        temperature_constraints.distribute_local_to_global(</div><div class="line">          local_mass_matrix, local_dof_indices, temperature_mass_matrix);</div><div class="line">        temperature_constraints.distribute_local_to_global(</div><div class="line">          local_stiffness_matrix,</div><div class="line">          local_dof_indices,</div><div class="line">          temperature_stiffness_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    rebuild_temperature_matrices = <span class="keyword">false</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::assemble_temperature_system(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity)</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> use_bdf2_scheme = (timestep_number != 0);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (use_bdf2_scheme == <span class="keyword">true</span>)</div><div class="line">      {</div><div class="line">        temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">        temperature_matrix *=</div><div class="line">          (2 * time_step + old_time_step) / (time_step + old_time_step);</div><div class="line">        temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">      }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      {</div><div class="line">        temperature_matrix.copy_from(temperature_mass_matrix);</div><div class="line">        temperature_matrix.add(time_step, temperature_stiffness_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    temperature_rhs = 0;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(temperature_degree + 2);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     temperature_fe_values(temperature_fe,</div><div class="line">                                        quadrature_formula,</div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa378cbcddbdf54fb3f9f0acf47b1c4719">update_hessians</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     stokes_fe_values(stokes_fe,</div><div class="line">                                   quadrature_formula,</div><div class="line">                                   <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = temperature_fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    Vector&lt;double&gt; local_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_velocity_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_velocity_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_temperature_values(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_old_temperature_values(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_temperature_grads(n_q_points);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_old_temperature_grads(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_temperature_laplacians(n_q_points);</div><div class="line">    std::vector&lt;double&gt;         old_old_temperature_laplacians(n_q_points);</div><div class="line"></div><div class="line">    EquationData::TemperatureRightHandSide&lt;dim&gt; temperature_right_hand_side;</div><div class="line">    std::vector&lt;double&gt;                         gamma_values(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;double&gt;         phi_T(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; grad_phi_T(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::pair&lt;double, double&gt; global_T_range =</div><div class="line">      get_extrapolated_temperature_range();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities(0);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>       cell        = temperature_dof_handler.<a class="code" href="classTriangulation.html#a9388e821c728eab8d0e699d0ca112482">begin_active</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> endc        = temperature_dof_handler.end();</div><div class="line">    <span class="keyword">auto</span>       stokes_cell = stokes_dof_handler.begin_active();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (; cell != endc; ++cell, ++stokes_cell)</div><div class="line">      {</div><div class="line">        local_rhs = 0;</div><div class="line"></div><div class="line">        temperature_fe_values.reinit(cell);</div><div class="line">        stokes_fe_values.reinit(stokes_cell);</div><div class="line"></div><div class="line">        temperature_fe_values.get_function_values(old_temperature_solution,</div><div class="line">                                                  old_temperature_values);</div><div class="line">        temperature_fe_values.get_function_values(old_old_temperature_solution,</div><div class="line">                                                  old_old_temperature_values);</div><div class="line"></div><div class="line">        temperature_fe_values.get_function_gradients(old_temperature_solution,</div><div class="line">                                                     old_temperature_grads);</div><div class="line">        temperature_fe_values.get_function_gradients(</div><div class="line">          old_old_temperature_solution, old_old_temperature_grads);</div><div class="line"></div><div class="line">        temperature_fe_values.get_function_laplacians(</div><div class="line">          old_temperature_solution, old_temperature_laplacians);</div><div class="line">        temperature_fe_values.get_function_laplacians(</div><div class="line">          old_old_temperature_solution, old_old_temperature_laplacians);</div><div class="line"></div><div class="line">        temperature_right_hand_side.value_list(</div><div class="line">          temperature_fe_values.get_quadrature_points(), gamma_values);</div><div class="line"></div><div class="line">        stokes_fe_values[velocities].get_function_values(stokes_solution,</div><div class="line">                                                         old_velocity_values);</div><div class="line">        stokes_fe_values[velocities].get_function_values(</div><div class="line">          old_stokes_solution, old_old_velocity_values);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> nu =</div><div class="line">          compute_viscosity(old_temperature_values,</div><div class="line">                            old_old_temperature_values,</div><div class="line">                            old_temperature_grads,</div><div class="line">                            old_old_temperature_grads,</div><div class="line">                            old_temperature_laplacians,</div><div class="line">                            old_old_temperature_laplacians,</div><div class="line">                            old_velocity_values,</div><div class="line">                            old_old_velocity_values,</div><div class="line">                            gamma_values,</div><div class="line">                            maximal_velocity,</div><div class="line">                            global_T_range.second - global_T_range.first,</div><div class="line">                            cell-&gt;diameter());</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dofs_per_cell; ++k)</div><div class="line">              {</div><div class="line">                grad_phi_T[k] = temperature_fe_values.shape_grad(k, q);</div><div class="line">                phi_T[k]      = temperature_fe_values.shape_value(k, q);</div><div class="line">              }</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> T_term_for_rhs =</div><div class="line">              (use_bdf2_scheme ?</div><div class="line">                 (old_temperature_values[q] * (1 + time_step / old_time_step) -</div><div class="line">                  old_old_temperature_values[q] * (time_step * time_step) /</div><div class="line">                    (old_time_step * (time_step + old_time_step))) :</div><div class="line">                 old_temperature_values[q]);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> ext_grad_T =</div><div class="line">              (use_bdf2_scheme ?</div><div class="line">                 (old_temperature_grads[q] * (1 + time_step / old_time_step) -</div><div class="line">                  old_old_temperature_grads[q] * time_step / old_time_step) :</div><div class="line">                 old_temperature_grads[q]);</div><div class="line"></div><div class="line">            <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> extrapolated_u =</div><div class="line">              (use_bdf2_scheme ?</div><div class="line">                 (old_velocity_values[q] * (1 + time_step / old_time_step) -</div><div class="line">                  old_old_velocity_values[q] * time_step / old_time_step) :</div><div class="line">                 old_velocity_values[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              local_rhs(i) +=</div><div class="line">                (T_term_for_rhs * phi_T[i] -</div><div class="line">                 time_step * extrapolated_u * ext_grad_T * phi_T[i] -</div><div class="line">                 time_step * nu * ext_grad_T * grad_phi_T[i] +</div><div class="line">                 time_step * gamma_values[q] * phi_T[i]) *</div><div class="line">                temperature_fe_values.JxW(q);</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        temperature_constraints.distribute_local_to_global(local_rhs,</div><div class="line">                                                           local_dof_indices,</div><div class="line">                                                           temperature_rhs);</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solving...&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> LinearSolvers::InverseMatrix&lt;<a class="code" href="namespaceLinearAlgebraDealII.html#a912abe2208022aec6753876bcc72f6bf">TrilinosWrappers::SparseMatrix</a>,</div><div class="line">                                         <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a>&gt;</div><div class="line">        mp_inverse(stokes_preconditioner_matrix.block(1, 1),</div><div class="line">                   *Mp_preconditioner);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> LinearSolvers::BlockSchurPreconditioner&lt;</div><div class="line">        <a class="code" href="namespaceLinearAlgebraPETSc_1_1MPI.html#a41f11f7a1992c6d6aa9367b12c68f791">TrilinosWrappers::PreconditionAMG</a>,</div><div class="line">        <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a>&gt;</div><div class="line">        preconditioner(stokes_matrix, mp_inverse, *Amg_preconditioner);</div><div class="line"></div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(stokes_matrix.m(),</div><div class="line">                                   1e-6 * stokes_rhs.l2_norm());</div><div class="line"></div><div class="line">      <a class="code" href="classSolverGMRES.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;</a> gmres(</div><div class="line">        solver_control,</div><div class="line">        <a class="code" href="structSolverGMRES_1_1AdditionalData.html">SolverGMRES&lt;TrilinosWrappers::MPI::BlockVector&gt;::AdditionalData</a>(100));</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; stokes_solution.size(); ++i)</div><div class="line">        <span class="keywordflow">if</span> (stokes_constraints.is_constrained(i))</div><div class="line">          stokes_solution(i) = 0;</div><div class="line"></div><div class="line">      gmres.solve(stokes_matrix, stokes_solution, stokes_rhs, preconditioner);</div><div class="line"></div><div class="line">      stokes_constraints.distribute(stokes_solution);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; GMRES iterations for Stokes subsystem.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    old_time_step                 = time_step;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> maximal_velocity = get_maximal_velocity();</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (maximal_velocity &gt;= 0.01)</div><div class="line">      time_step = 1. / (1.7 * dim * <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim)) / temperature_degree *</div><div class="line">                  <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) /</div><div class="line">                  maximal_velocity;</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">      time_step = 1. / (1.7 * dim * <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1. * dim)) / temperature_degree *</div><div class="line">                  <a class="code" href="namespaceGridTools.html#a47c293eff2ec7ce4b90ba08b35d1f2e2">GridTools::minimal_cell_diameter</a>(triangulation) / .01;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Time step: &quot;</span> &lt;&lt; time_step &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    temperature_solution = old_temperature_solution;</div><div class="line"></div><div class="line">    assemble_temperature_system(maximal_velocity);</div><div class="line">    {</div><div class="line">      <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(temperature_matrix.m(),</div><div class="line">                                   1e-8 * temperature_rhs.l2_norm());</div><div class="line">      <a class="code" href="classSolverCG.html">SolverCG&lt;TrilinosWrappers::MPI::Vector&gt;</a> cg(solver_control);</div><div class="line"></div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html">TrilinosWrappers::PreconditionIC</a> preconditioner;</div><div class="line">      preconditioner.<a class="code" href="classTrilinosWrappers_1_1PreconditionIC.html#a95eff1f8abcf2ba67815b6a96a66d375">initialize</a>(temperature_matrix);</div><div class="line"></div><div class="line">      cg.solve(temperature_matrix,</div><div class="line">               temperature_solution,</div><div class="line">               temperature_rhs,</div><div class="line">               preconditioner);</div><div class="line"></div><div class="line">      temperature_constraints.distribute(temperature_solution);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot; CG iterations for temperature.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordtype">double</span> min_temperature = temperature_solution(0),</div><div class="line">             max_temperature = temperature_solution(0);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; temperature_solution.size(); ++i)</div><div class="line">        {</div><div class="line">          min_temperature =</div><div class="line">            std::min&lt;double&gt;(min_temperature, temperature_solution(i));</div><div class="line">          max_temperature =</div><div class="line">            std::max&lt;double&gt;(max_temperature, temperature_solution(i));</div><div class="line">        }</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;   Temperature range: &quot;</span> &lt;&lt; min_temperature &lt;&lt; <span class="charliteral">&#39; &#39;</span></div><div class="line">                &lt;&lt; max_temperature &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoussinesqFlowProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">if</span> (timestep_number % 10 != 0)</div><div class="line">      <span class="keywordflow">return</span>;</div><div class="line"></div><div class="line">    std::vector&lt;std::string&gt; stokes_names(dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">    stokes_names.emplace_back(<span class="stringliteral">&quot;p&quot;</span>);</div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">      stokes_component_interpretation(</div><div class="line">        dim + 1, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">      stokes_component_interpretation[i] =</div><div class="line">        <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(stokes_dof_handler,</div><div class="line">                             stokes_solution,</div><div class="line">                             stokes_names,</div><div class="line">                             stokes_component_interpretation);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(temperature_dof_handler,</div><div class="line">                             temperature_solution,</div><div class="line">                             <span class="stringliteral">&quot;T&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(stokes_degree, temperature_degree));</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;solution-&quot;</span> +</div><div class="line">                         <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(timestep_number, 4) + <span class="stringliteral">&quot;.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  BoussinesqFlowProblem&lt;dim&gt;::refine_mesh(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_grid_level)</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(temperature_dof_handler,</div><div class="line">                                       <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(temperature_degree + 1),</div><div class="line">                                       {},</div><div class="line">                                       temperature_solution,</div><div class="line">                                       estimated_error_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a>(triangulation,</div><div class="line">                                                      estimated_error_per_cell,</div><div class="line">                                                      0.8,</div><div class="line">                                                      0.1);</div><div class="line">    <span class="keywordflow">if</span> (triangulation.<a class="code" href="classTriangulation.html#a777f035a17e91a4d822971516ca11db5">n_levels</a>() &gt; max_grid_level)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell :</div><div class="line">           triangulation.<a class="code" href="group__CPP11.html#gac10cd3fe6ef8360e2599d3cff58e13e8">active_cell_iterators_on_level</a>(max_grid_level))</div><div class="line">        cell-&gt;clear_refine_flag();</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::Vector&gt; x_temperature(2);</div><div class="line">    x_temperature[0]                            = temperature_solution;</div><div class="line">    x_temperature[1]                            = old_temperature_solution;</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> x_stokes = stokes_solution;</div><div class="line"></div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::Vector&gt;</a> temperature_trans(</div><div class="line">      temperature_dof_handler);</div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim, TrilinosWrappers::MPI::BlockVector&gt;</a> stokes_trans(</div><div class="line">      stokes_dof_handler);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ab9fa3177e0e43ab0cf243215d284a35a">prepare_coarsening_and_refinement</a>();</div><div class="line">    temperature_trans.prepare_for_coarsening_and_refinement(x_temperature);</div><div class="line">    stokes_trans.prepare_for_coarsening_and_refinement(x_stokes);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    std::vector&lt;TrilinosWrappers::MPI::Vector&gt; tmp(2);</div><div class="line">    tmp[0].reinit(temperature_solution);</div><div class="line">    tmp[1].reinit(temperature_solution);</div><div class="line">    temperature_trans.interpolate(x_temperature, tmp);</div><div class="line"></div><div class="line">    temperature_solution     = tmp[0];</div><div class="line">    old_temperature_solution = tmp[1];</div><div class="line"></div><div class="line">    temperature_constraints.distribute(temperature_solution);</div><div class="line">    temperature_constraints.distribute(old_temperature_solution);</div><div class="line"></div><div class="line">    stokes_trans.interpolate(x_stokes, stokes_solution);</div><div class="line"></div><div class="line">    stokes_constraints.distribute(stokes_solution);</div><div class="line"></div><div class="line">    rebuild_stokes_matrix         = <span class="keyword">true</span>;</div><div class="line">    rebuild_temperature_matrices  = <span class="keyword">true</span>;</div><div class="line">    rebuild_stokes_preconditioner = <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">BoussinesqFlowProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_refinement     = (dim == 2 ? 4 : 2);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_pre_refinement_steps = (dim == 2 ? 4 : 3);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">    global_Omega_diameter = <a class="code" href="namespaceGridTools.html#acd5ccc543d561cfb086b571d1f7818cb">GridTools::diameter</a>(triangulation);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(initial_refinement);</div><div class="line"></div><div class="line">    setup_dofs();</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pre_refinement_step = 0;</div><div class="line"></div><div class="line">  start_time_iteration:</div><div class="line"></div><div class="line">    <a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a>(temperature_dof_handler,</div><div class="line">                         temperature_constraints,</div><div class="line">                         <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(temperature_degree + 2),</div><div class="line">                         EquationData::TemperatureInitialValues&lt;dim&gt;(),</div><div class="line">                         old_temperature_solution);</div><div class="line"></div><div class="line">    timestep_number = 0;</div><div class="line">    time_step = old_time_step = 0;</div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> time = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Timestep &quot;</span> &lt;&lt; timestep_number &lt;&lt; <span class="stringliteral">&quot;:  t=&quot;</span> &lt;&lt; time</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_stokes_system();</div><div class="line">        build_stokes_preconditioner();</div><div class="line">        assemble_temperature_matrix();</div><div class="line"></div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> ((timestep_number == 0) &amp;&amp;</div><div class="line">            (pre_refinement_step &lt; n_pre_refinement_steps))</div><div class="line">          {</div><div class="line">            refine_mesh(initial_refinement + n_pre_refinement_steps);</div><div class="line">            ++pre_refinement_step;</div><div class="line">            <span class="keywordflow">goto</span> start_time_iteration;</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((timestep_number &gt; 0) &amp;&amp; (timestep_number % 5 == 0))</div><div class="line">          refine_mesh(initial_refinement + n_pre_refinement_steps);</div><div class="line"></div><div class="line">        time += time_step;</div><div class="line">        ++timestep_number;</div><div class="line"></div><div class="line">        old_stokes_solution          = stokes_solution;</div><div class="line">        old_old_temperature_solution = old_temperature_solution;</div><div class="line">        old_temperature_solution     = temperature_solution;</div><div class="line">      }</div><div class="line">    <span class="keywordflow">while</span> (time &lt;= 100);</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step31</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step31;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(</div><div class="line">        argc, argv, <a class="code" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>);</div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-31&quot;</span>));</div><div class="line"></div><div class="line">      BoussinesqFlowProblem&lt;2&gt; flow_problem;</div><div class="line">      flow_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </li>
</ul>
</li>
</ul>
</pre><p></code></pre><p></code></p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
