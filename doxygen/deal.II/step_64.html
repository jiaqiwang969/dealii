<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_64.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-64 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-64 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_7.html">step-7</a>, <a class="el" href="step_37.html">step-37</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thetestcase">The test case</a>
        <li><a href="#Movingdatatoandfromthedevice">Moving data to and from the device</a>
        <li><a href="#Matrixvectorproductimplementation">Matrix-vector product implementation</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#ClasscodeVaryingCoefficientFunctorcode">Class <code>VaryingCoefficientFunctor</code></a>
        <li><a href="#ClasscodeHelmholtzOperatorQuadcode">Class <code>HelmholtzOperatorQuad</code></a>
        <li><a href="#ClasscodeLocalHelmholtzOperatorcode">Class <code>LocalHelmholtzOperator</code></a>
        <li><a href="#ClasscodeHelmholtzOperatorcode">Class <code>HelmholtzOperator</code></a>
        <li><a href="#ClasscodeHelmholtzProblemcode">Class <code>HelmholtzProblem</code></a>
        <li><a href="#Thecodemaincodefunction">The <code>main()</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em> This program was contributed by Bruno Turcksin and Daniel Arndt, Oak Ridge National Laboratory. </em></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This example shows how to implement a matrix-free method on the GPU using CUDA for the Helmholtz equation with variable coefficients on a hypercube. The linear system will be solved using the conjugate gradient method and is parallelized with MPI.</p>
<p>In the last few years, heterogeneous computing in general and GPUs in particular have gained a lot of popularity. This is because GPUs offer better computing capabilities and memory bandwidth than CPUs for a given power budget. Among the architectures available in early 2019, GPUs are about 2x-3x as power efficient than server CPUs with wide <a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> for PDE-related tasks. GPUs are also the most popular architecture for machine learning. On the other hand, GPUs are not easy to program. This program explores the deal.II capabilities to see how efficiently such a program can be implemented.</p>
<p>While we have tried for the interface of the matrix-free classes for the CPU and the GPU to be as close as possible, there are a few differences. When using the matrix-free framework on a GPU, one must write some CUDA code. However, the amount is fairly small and the use of CUDA is limited to a few keywords.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>In this example, we consider the Helmholtz problem </p><p class="formulaDsp">
\begin{eqnarray*} - \nabla \cdot \nabla u + a(\mathbf x) u &amp;=&amp;1,\\ u &amp;=&amp; 0 \quad \text{on } \partial \Omega \end{eqnarray*}
</p>
<p> where \(a(\mathbf x)\) is a variable coefficient.</p>
<p>We choose as domain \(\Omega=[0,1]^3\) and \(a(\mathbf x)=\frac{10}{0.05 + 2\|\mathbf x\|^2}\). Since the coefficient is symmetric around the origin but the domain is not, we will end up with a non-symmetric solution.</p>
<p>If you've made it this far into the tutorial, you will know how the weak formulation of this problem looks like and how, in principle, one assembles linear systems for it. Of course, in this program we will in fact not actually form the matrix, but rather only represent its action when one multiplies with it.</p>
<p><a class="anchor" id="Movingdatatoandfromthedevice"></a></p><h3>Moving data to and from the device</h3>
<p>GPUs (we will use the term "device" from now on to refer to the GPU) have their own memory that is separate from the memory accessible to the CPU (we will use the term "host" from now on). A normal calculation on the device can be divided in three separate steps:</p><ol type="1">
<li>the data is moved from the host to the device,</li>
<li>the computation is done on the device,</li>
<li>the result is moved back from the device to the host</li>
</ol>
<p>The data movements can either be done explicitly by the user code or done automatically using UVM (Unified Virtual Memory). In deal.II, only the first method is supported. While it means an extra burden for the user, this allows for better control of data movement and more importantly it avoids to mistakenly run important kernels on the host instead of the device.</p>
<p>The data movement in deal.II is done using <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>. These vectors can be seen as buffers on the host that are used to either store data received from the device or to send data to the device. There are two types of vectors that can be used on the device:</p><ul>
<li><a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a>, which is similar to the more common <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector&lt;Number&gt;</a>, and</li>
<li><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt;Number, <a class="el" href="structMemorySpace_1_1CUDA.html">MemorySpace::CUDA</a>&gt;, which is a regular <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> where we have specified which memory space to use.</li>
</ul>
<p>If no memory space is specified, the default is <a class="el" href="structMemorySpace_1_1Host.html">MemorySpace::Host</a>.</p>
<p>Next, we show how to move data to/from the device using <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a>: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = 10;</div><div class="line"><a class="code" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector&lt;double&gt;</a> rw_vector(size);</div><div class="line"></div><div class="line">...do something with the rw_vector...</div><div class="line"></div><div class="line"><span class="comment">// Move the data to the device:</span></div><div class="line">LinearAlgebra::CUDAWrappers::Vector&lt;<span class="keywordtype">double</span>&gt; vector_dev(size);</div><div class="line">vector_dev.import(rw_vector, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div><div class="line"></div><div class="line">...do some computations on the device...</div><div class="line"></div><div class="line"><span class="comment">// Move the data back to the host:</span></div><div class="line">rw_vector.import(vector_dev, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div></div><!-- fragment --><p> Both of the vector classes used here only work on a single machine, i.e., one memory space on a host and one on a device.</p>
<p>But there are cases where one wants to run a parallel computation between multiple MPI processes on a number of machines, each of which is equipped with GPUs. In that case, one wants to use <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt;Number,<a class="el" href="structMemorySpace_1_1CUDA.html">MemorySpace::CUDA</a>&gt;</code>, which is similar but the <code>import()</code> stage may involve MPI communication: </p><div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs, locally_relevant_dofs;</div><div class="line">...fill the two <a class="code" href="classIndexSet.html">IndexSet</a> objects...</div><div class="line"></div><div class="line"><span class="comment">// Create the ReadWriteVector using an IndexSet instead of the size</span></div><div class="line">LinearAlgebra::ReadWriteVector&lt;<span class="keywordtype">double</span>&gt; owned_rw_vector(locally_owned_dofs);</div><div class="line"></div><div class="line">...do something with the rw_vector...</div><div class="line"></div><div class="line"><span class="comment">// Move the data to the device:</span></div><div class="line">LinearAlgebra::distributed::Vector&lt;double, <a class="code" href="structMemorySpace_1_1CUDA.html">MemorySpace::CUDA</a>&gt;</div><div class="line">  distributed_vector_dev(locally_owned_dofs, MPI_COMM_WORLD);</div><div class="line">distributed_vector_dev.import(owned_rw_vector, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div><div class="line"></div><div class="line">...do something with the dev_vector...</div><div class="line"></div><div class="line"><span class="comment">// Create a ReadWriteVector with a different IndexSet:</span></div><div class="line">LinearAlgebra::ReadWriteVector&lt;<span class="keywordtype">double</span>&gt;</div><div class="line">  relevant_rw_vector(locally_relevant_dofs);</div><div class="line"></div><div class="line"><span class="comment">// Move the data to the host, possibly using MPI communication:</span></div><div class="line">relevant_rw_vector.import(distributed_vector_dev, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div></div><!-- fragment --><p> The <code>relevant_rw_vector</code> is an object that stores a subset of all elements of the vector. Typically, these are the <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant DoFs</a>, which implies that they overlap between different MPI processes. Consequently, the elements stored in that vector on one machine may not coincide with the ones stored by the GPU on that machine, requiring MPI communication to import them.</p>
<p>In all of these cases, while importing a vector, values can either be inserted (using <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>) or added to prior content of the vector (using <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>).</p>
<p><a class="anchor" id="Matrixvectorproductimplementation"></a></p><h3>Matrix-vector product implementation</h3>
<p>The code necessary to evaluate the matrix-free operator on the device is very similar to the one on the host. However, there are a few differences, the main ones being that the <code>local_apply()</code> function in <a class="el" href="step_37.html">step-37</a> and the loop over quadrature points both need to be encapsulated in their own functors.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>First include the necessary files from the deal.II library known from the previous tutorials.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="la__parallel__vector_8h.html">deal.II/lac/la_parallel_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The following ones include the data structures for the implementation of matrix-free methods on GPU:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2cuda_8h.html">deal.II/base/cuda.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cuda__fe__evaluation_8h.html">deal.II/matrix_free/cuda_fe_evaluation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cuda__matrix__free_8h.html">deal.II/matrix_free/cuda_matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="operators_8h.html">deal.II/matrix_free/operators.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>As usual, we enclose everything into a namespace of its own:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step64</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeVaryingCoefficientFunctorcode"></a> </p><h3>Class <code>VaryingCoefficientFunctor</code></h3>
<p>Next, we define a class that implements the varying coefficients we want to use in the Helmholtz operator. Later, we want to pass an object of this type to a <a class="el" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree</a> object that expects the class to have an <code>operator()</code> that fills the values provided in the constructor for a given cell. This operator needs to run on the device, so it needs to be marked as <code>__device__</code> for the compiler.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>VaryingCoefficientFunctor</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  VaryingCoefficientFunctor(<span class="keywordtype">double</span> *coefficient)</div><div class="line">    : coef(coefficient)</div><div class="line">  {}</div><div class="line"></div><div class="line">  __device__ <span class="keywordtype">void</span> operator()(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                          cell,</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1Data.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data</a> *gpu_data);</div></div><!-- fragment --><p>Since <a class="el" href="structCUDAWrappers_1_1MatrixFree_1_1Data.html">CUDAWrappers::MatrixFree::Data</a> doesn't know about the size of its arrays, we need to store the number of quadrature points and the numbers of degrees of freedom in this class to do necessary index conversions.</p>
<div class="fragment"><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_1d = fe_degree + 1;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_local_dofs =</div><div class="line">    ::Utilities::pow(n_dofs_1d, dim);</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    ::Utilities::pow(n_dofs_1d, dim);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span> *coef;</div><div class="line">};</div></div><!-- fragment --><p>The following function implements this coefficient. Recall from the introduction that we have defined it as \(a(\mathbf x)=\frac{10}{0.05 + 2\|\mathbf x\|^2}\)</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">__device__ <span class="keywordtype">void</span> VaryingCoefficientFunctor&lt;dim, fe_degree&gt;::operator()(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                          cell,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1Data.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data</a> *gpu_data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = CUDAWrappers::local_q_point_id&lt;dim, double&gt;(</div><div class="line">    cell, gpu_data, n_dofs_1d, n_q_points);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> q_point =</div><div class="line">    CUDAWrappers::get_quadrature_point&lt;dim, double&gt;(cell,</div><div class="line">                                                    gpu_data,</div><div class="line">                                                    n_dofs_1d);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> p_square = 0.;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> coord = q_point[i];</div><div class="line">      p_square += coord * coord;</div><div class="line">    }</div><div class="line">  coef[pos] = 10. / (0.05 + 2. * p_square);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeHelmholtzOperatorQuadcode"></a> </p><h3>Class <code>HelmholtzOperatorQuad</code></h3>
<p>The class <code>HelmholtzOperatorQuad</code> implements the evaluation of the Helmholtz operator at each quadrature point. It uses a similar mechanism as the <a class="el" href="classMatrixFree.html">MatrixFree</a> framework introduced in <a class="el" href="step_37.html">step-37</a>. In contrast to there, the actual quadrature point index is treated implicitly by converting the current thread index. As before, the functions of this class need to run on the device, so need to be marked as <code>__device__</code> for the compiler.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>HelmholtzOperatorQuad</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  __device__ HelmholtzOperatorQuad(<span class="keywordtype">double</span> coef)</div><div class="line">    : coef(coef)</div><div class="line">  {}</div><div class="line"></div><div class="line">  __device__ <span class="keywordtype">void</span></div><div class="line">  operator()(<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html">CUDAWrappers::FEEvaluation&lt;dim, fe_degree&gt;</a> *fe_eval) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span> coef;</div><div class="line">};</div></div><!-- fragment --><p>The Helmholtz problem we want to solve here reads in weak form as follows: </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla v, \nabla u)+ (v, a(\mathbf x) u) &amp;=&amp;(v,1) \quad \forall v. \end{eqnarray*}
</p>
<p> If you have seen <a class="el" href="step_37.html">step-37</a>, then it will be obvious that the two terms on the left-hand side correspond to the two function calls here:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">__device__ <span class="keywordtype">void</span> HelmholtzOperatorQuad&lt;dim, fe_degree&gt;::</div><div class="line">                operator()(<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html">CUDAWrappers::FEEvaluation&lt;dim, fe_degree&gt;</a> *fe_eval)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  fe_eval-&gt;<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#a58daeed0b26fcaeee745936a62403623">submit_value</a>(coef * fe_eval-&gt;<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#aacf72a37d0ef60c9cd248b896fdafb99">get_value</a>());</div><div class="line">  fe_eval-&gt;<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#a25fffdd57bc94870cc1bc4db2f4f6379">submit_gradient</a>(fe_eval-&gt;<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#ae14d61c332a97c1e2a5023db782f1155">get_gradient</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeLocalHelmholtzOperatorcode"></a> </p><h3>Class <code>LocalHelmholtzOperator</code></h3>
<p>Finally, we need to define a class that implements the whole operator evaluation that corresponds to a matrix-vector product in matrix-based approaches.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>LocalHelmholtzOperator</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LocalHelmholtzOperator(<span class="keywordtype">double</span> *coefficient)</div><div class="line">    : coef(coefficient)</div><div class="line">  {}</div><div class="line"></div><div class="line">  __device__ <span class="keywordtype">void</span> operator()(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                          cell,</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1Data.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data</a> *gpu_data,</div><div class="line">    <a class="code" href="structCUDAWrappers_1_1SharedData.html">CUDAWrappers::SharedData&lt;dim, double&gt;</a> *                     shared_data,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> *                                              src,</div><div class="line">    <span class="keywordtype">double</span> *                                                    dst) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Again, the <a class="el" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree</a> object doesn't know about the number of degrees of freedom and the number of quadrature points so we need to store these for index calculations in the call operator.</p>
<div class="fragment"><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_1d    = fe_degree + 1;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_local_dofs = <a class="code" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">Utilities::pow</a>(fe_degree + 1, dim);</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points   = <a class="code" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">Utilities::pow</a>(fe_degree + 1, dim);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span> *coef;</div><div class="line">};</div></div><!-- fragment --><p>This is the call operator that performs the Helmholtz operator evaluation on a given cell similar to the <a class="el" href="classMatrixFree.html">MatrixFree</a> framework on the CPU. In particular, we need access to both values and gradients of the source vector and we write value and gradient information to the destination vector.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">__device__ <span class="keywordtype">void</span> LocalHelmholtzOperator&lt;dim, fe_degree&gt;::operator()(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                          cell,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1Data.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data</a> *gpu_data,</div><div class="line">  <a class="code" href="structCUDAWrappers_1_1SharedData.html">CUDAWrappers::SharedData&lt;dim, double&gt;</a> *                     shared_data,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> *                                              src,</div><div class="line">  <span class="keywordtype">double</span> *                                                    dst)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = CUDAWrappers::local_q_point_id&lt;dim, double&gt;(</div><div class="line">    cell, gpu_data, n_dofs_1d, n_q_points);</div><div class="line"></div><div class="line">  <a class="code" href="classCUDAWrappers_1_1FEEvaluation.html">CUDAWrappers::FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, double&gt;</a></div><div class="line">    fe_eval(cell, gpu_data, shared_data);</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#ae0e594e5dc5dc91391190c4bb1d8c45c">read_dof_values</a>(src);</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#aa50f53d6eb1b0416a791008a5e1a3b25">evaluate</a>(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#af54da23ff99a33dcd23ddccf52dee2f5">apply_for_each_quad_point</a>(</div><div class="line">    HelmholtzOperatorQuad&lt;dim, fe_degree&gt;(coef[pos]));</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#a12939db3c43822e5cbf51520ad52dedb">integrate</a>(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#a90c2f1b2718e90aa49b7d49fac3600d5">distribute_local_to_global</a>(dst);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeHelmholtzOperatorcode"></a> </p><h3>Class <code>HelmholtzOperator</code></h3>
<p>The <code>HelmholtzOperator</code> class acts as wrapper for <code>LocalHelmholtzOperator</code> defining an interface that can be used with linear solvers like <a class="el" href="classSolverCG.html">SolverCG</a>. In particular, like every class that implements the interface of a linear operator, it needs to have a <code>vmult()</code> function that performs the action of the linear operator on a source vector.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>HelmholtzOperator</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  HelmholtzOperator(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;          dof_handler,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;constraints);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  vmult(<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;dst,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a></div><div class="line">          &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> initialize_dof_vector(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;vec) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <a class="code" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;</a>       mf_data;</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector&lt;double&gt;</a> coef;</div><div class="line">};</div></div><!-- fragment --><p>The following is the implementation of the constructor of this class. In the first part, we initialize the <code>mf_data</code> member variable that is going to provide us with the necessary information when evaluating the operator.</p>
<p>In the second half, we need to store the value of the coefficient for each quadrature point in every active, locally owned cell. We can ask the parallel triangulation for the number of active, locally owned cells but only have a <a class="el" href="classDoFHandler.html">DoFHandler</a> object at hand. Since <a class="el" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">DoFHandler::get_triangulation()</a> returns a <a class="el" href="classTriangulation.html">Triangulation</a> object, not a <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> object, we have to downcast the return value. This is safe to do here because we know that the triangulation is a parallel:distributed::<a class="el" href="classTriangulation.html">Triangulation</a> object in fact.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">HelmholtzOperator&lt;dim, fe_degree&gt;::HelmholtzOperator(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;          dof_handler,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;constraints)</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(fe_degree);</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1AdditionalData.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::AdditionalData</a></div><div class="line">    additional_data;</div><div class="line">  additional_data.<a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1AdditionalData.html#a4fc9f434f93f40a8c1dff4ed6b9fd509">mapping_update_flags</a> = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a> quad(fe_degree + 1);</div><div class="line">  mf_data.reinit(mapping, dof_handler, constraints, quad, additional_data);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_owned_cells =</div><div class="line">    <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span><a class="code" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase&lt;dim&gt;</a> *<span class="keyword">&gt;</span>(</div><div class="line">      &amp;dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>())</div><div class="line">      -&gt;n_locally_owned_active_cells();</div><div class="line">  coef.reinit(<a class="code" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">Utilities::pow</a>(fe_degree + 1, dim) * n_owned_cells);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> VaryingCoefficientFunctor&lt;dim, fe_degree&gt; functor(coef.get_values());</div><div class="line">  mf_data.evaluate_coefficients(functor);</div><div class="line">}</div></div><!-- fragment --><p>The key step then is to use all of the previous classes to loop over all cells to perform the matrix-vector product. We implement this in the next function.</p>
<p>When applying the Helmholtz operator, we have to be careful to handle boundary conditions correctly. Since the local operator doesn't know about constraints, we have to copy the correct values from the source to the destination vector afterwards.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzOperator&lt;dim, fe_degree&gt;::vmult(</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;src)<span class="keyword"></span></div><div class="line"><span class="keyword">  const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  dst = 0.;</div><div class="line">  LocalHelmholtzOperator&lt;dim, fe_degree&gt; helmholtz_operator(</div><div class="line">    coef.get_values());</div><div class="line">  mf_data.cell_loop(helmholtz_operator, src, dst);</div><div class="line">  mf_data.copy_constrained_values(src, dst);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzOperator&lt;dim, fe_degree&gt;::initialize_dof_vector(</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;vec)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  mf_data.initialize_dof_vector(vec);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeHelmholtzProblemcode"></a> </p><h3>Class <code>HelmholtzProblem</code></h3>
<p>This is the main class of this program. It defines the usual framework we use for tutorial programs. The only point worth commenting on is the <code>solve()</code> function and the choice of vector types.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>HelmholtzProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  HelmholtzProblem();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_rhs();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classMPI__Comm.html">MPI_Comm</a> mpi_communicator;</div><div class="line"></div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a>                          constraints;</div><div class="line">  std::unique_ptr&lt;HelmholtzOperator&lt;dim, fe_degree&gt;&gt; system_matrix_dev;</div></div><!-- fragment --><p>Since all the operations in the <code>solve()</code> function are executed on the graphics card, it is necessary for the vectors used to store their values on the GPU as well. <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> can be told which memory space to use. There is also <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a> that always uses GPU memory storage but doesn't work with MPI. It might be worth noticing that the communication between different MPI processes can be improved if the MPI implementation is CUDA-aware and the configure flag <code>DEAL_II_MPI_WITH_CUDA_SUPPORT</code> is enabled. (The value of this flag needs to be set at the time you call <code>cmake</code> when installing deal.II.)</p>
<p>In addition, we also keep a solution vector with CPU storage such that we can view and display the solution as usual.</p>
<div class="fragment"><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::Host&gt;</a></div><div class="line">                                                                ghost_solution_host;</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> solution_dev;</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a></div><div class="line">    system_rhs_dev;</div><div class="line"></div><div class="line">  <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line">};</div></div><!-- fragment --><p>The implementation of all the remaining functions of this class apart from <code>Helmholtzproblem::solve()</code> doesn't contain anything new and we won't further comment much on the overall approach.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">HelmholtzProblem&lt;dim, fe_degree&gt;::HelmholtzProblem()</div><div class="line">  : mpi_communicator(MPI_COMM_WORLD)</div><div class="line">  , triangulation(mpi_communicator)</div><div class="line">  , fe(fe_degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , pcout(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim, fe_degree&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  locally_owned_dofs = dof_handler.<a class="code" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">locally_owned_dofs</a>();</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line">  system_rhs_dev.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">  system_matrix_dev.reset(</div><div class="line">    <span class="keyword">new</span> HelmholtzOperator&lt;dim, fe_degree&gt;(dof_handler, constraints));</div><div class="line"></div><div class="line">  ghost_solution_host.reinit(locally_owned_dofs,</div><div class="line">                             locally_relevant_dofs,</div><div class="line">                             mpi_communicator);</div><div class="line">  system_matrix_dev-&gt;initialize_dof_vector(solution_dev);</div><div class="line">  system_rhs_dev.reinit(solution_dev);</div><div class="line">}</div></div><!-- fragment --><p>Unlike programs such as <a class="el" href="step_4.html">step-4</a> or <a class="el" href="step_6.html">step-6</a>, we will not have to assemble the whole linear system but only the right hand side vector. This looks in essence like we did in <a class="el" href="step_4.html">step-4</a>, for example, but we have to pay attention to using the right constraints object when copying local contributions into the global vector. In particular, we need to make sure the entries that correspond to boundary nodes are properly zeroed out. This is necessary for CG to converge. (Another solution would be to modify the <code>vmult()</code> function above in such a way that we pretend the source vector has zero entries by just not taking them into account in matrix-vector products. But the approach used here is simpler.)</p>
<p>At the end of the function, we can't directly copy the values from the host to the device but need to use an intermediate object of type <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a> to construct the correct communication pattern necessary.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim, fe_degree&gt;::assemble_rhs()</div><div class="line">{</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::Host&gt;</a></div><div class="line">                    system_rhs_host(locally_owned_dofs,</div><div class="line">                    locally_relevant_dofs,</div><div class="line">                    mpi_communicator);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt; cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * 1.0 *</div><div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_rhs_host);</div><div class="line">      }</div><div class="line">  system_rhs_host.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector&lt;double&gt;</a> rw_vector(locally_owned_dofs);</div><div class="line">  rw_vector.import(system_rhs_host, <a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">  system_rhs_dev.import(rw_vector, <a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">}</div></div><!-- fragment --><p>This solve() function finally contains the calls to the new classes previously discussed. Here we don't use any preconditioner, i.e., precondition by the identity matrix, to focus just on the peculiarities of the <a class="el" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree</a> framework. Of course, in a real application the choice of a suitable preconditioner is crucial but we have at least the same restrictions as in <a class="el" href="step_37.html">step-37</a> since matrix entries are computed on the fly and not stored.</p>
<p>After solving the linear system in the first part of the function, we copy the solution from the device to the host to be able to view its values and display it in <code>output_results()</code>. This transfer works the same as at the end of the previous function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim, fe_degree&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a> preconditioner;</div><div class="line"></div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(system_rhs_dev.size(),</div><div class="line">                               1e-12 * system_rhs_dev.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a>&gt; cg(</div><div class="line">    solver_control);</div><div class="line">  cg.solve(*system_matrix_dev, solution_dev, system_rhs_dev, preconditioner);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;  Solved in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector&lt;double&gt;</a> rw_vector(locally_owned_dofs);</div><div class="line">  rw_vector.import(solution_dev, <a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">  ghost_solution_host.import(rw_vector, <a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(ghost_solution_host);</div><div class="line"></div><div class="line">  ghost_solution_host.update_ghost_values();</div><div class="line">}</div></div><!-- fragment --><p>The output results function is as usual since we have already copied the values back from the GPU to the CPU.</p>
<p>While we're already doing something with the function, we might as well compute the \(L_2\) norm of the solution. We do this by calling <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a>. That function is meant to compute the error by evaluating the difference between the numerical solution (given by a vector of values for the degrees of freedom) and an object representing the exact solution. But we can easily compute the \(L_2\) norm of the solution by passing in a zero function instead. That is, instead of evaluating the error \(\|u_h-u\|_{L_2(\Omega)}\), we are just evaluating \(\|u_h-0\|_{L_2(\Omega)}=\|u_h\|_{L_2(\Omega)}\) instead.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim, fe_degree&gt;::output_results(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(ghost_solution_host, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">  flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> = <a class="code" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a>;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">    <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution&quot;</span>, cycle, mpi_communicator, 2);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> cellwise_norm(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler,</div><div class="line">                                    ghost_solution_host,</div><div class="line">                                    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                    cellwise_norm,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> global_norm =</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                      cellwise_norm,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;  solution norm: &quot;</span> &lt;&lt; global_norm &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>There is nothing surprising in the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function either. We simply compute the solution on a series of (globally) refined meshes.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">HelmholtzProblem&lt;dim, fe_degree&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 7 - dim; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 1.);</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_rhs();</div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step64</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main()</code> function</h3>
<p>Finally for the <code>main()</code> function. By default, all the MPI ranks will try to access the device with number 0, which we assume to be the GPU device associated with the CPU on which a particular MPI rank runs. This works, but if we are running with MPI support it may be that multiple MPI processes are running on the same machine (for example, one per CPU core) and then they would all want to access the same GPU on that machine. If there is only one GPU in the machine, there is nothing we can do about it: All MPI ranks on that machine need to share it. But if there are more than one GPU, then it is better to address different graphic cards for different processes. The choice below is based on the MPI process id by assigning GPUs round robin to GPU ranks. (To work correctly, this scheme assumes that the MPI ranks on one machine are consecutive. If that were not the case, then the rank-GPU association may just not be optimal.) To make this work, MPI needs to be initialized before using this function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step64;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">      <span class="keywordtype">int</span>         n_devices       = 0;</div><div class="line">      cudaError_t cuda_error_code = cudaGetDeviceCount(&amp;n_devices);</div><div class="line">      <a class="code" href="group__Exceptions.html#gac1b7e8a4a8d5d910cd9fbd8814e9955e">AssertCuda</a>(cuda_error_code);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> my_mpi_id =</div><div class="line">        <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> device_id = my_mpi_id % n_devices;</div><div class="line">      cuda_error_code     = cudaSetDevice(device_id);</div><div class="line">      <a class="code" href="group__Exceptions.html#gac1b7e8a4a8d5d910cd9fbd8814e9955e">AssertCuda</a>(cuda_error_code);</div><div class="line"></div><div class="line">      HelmholtzProblem&lt;3, 3&gt; helmholtz_problem;</div><div class="line">      helmholtz_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Since the main purpose of this tutorial is to demonstrate how to use the <a class="el" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree</a> interface, not to compute anything useful in itself, we just show the expected output here: </p><div class="fragment"><div class="line">Cycle 0</div><div class="line">   Number of active cells:       8</div><div class="line">   Number of degrees of freedom: 343</div><div class="line">  Solved in 27 iterations.</div><div class="line">  solution <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 0.0205439</div><div class="line"></div><div class="line">Cycle 1</div><div class="line">   Number of active cells:       64</div><div class="line">   Number of degrees of freedom: 2197</div><div class="line">  Solved in 60 iterations.</div><div class="line">  solution <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 0.0205269</div><div class="line"></div><div class="line">Cycle 2</div><div class="line">   Number of active cells:       512</div><div class="line">   Number of degrees of freedom: 15625</div><div class="line">  Solved in 114 iterations.</div><div class="line">  solution <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 0.0205261</div><div class="line"></div><div class="line">Cycle 3</div><div class="line">   Number of active cells:       4096</div><div class="line">   Number of degrees of freedom: 117649</div><div class="line">  Solved in 227 iterations.</div><div class="line">  solution <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 0.0205261</div></div><!-- fragment --><p>One can make two observations here: First, the norm of the numerical solution converges, presumably to the norm of the exact (but unknown) solution. And second, the number of iterations roughly doubles with each refinement of the mesh. (This is in keeping with the expectation that the number of CG iterations grows with the square root of the condition number of the matrix; and that we know that the condition number of the matrix of a second-order differential operation grows like \({\cal O}(h^{-2})\).) This is of course rather inefficient, as an optimal solver would have a number of iterations that is independent of the size of the problem. But having such a solver would require using a better preconditioner than the identity matrix we have used here.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>Currently, this program uses no preconditioner at all. This is mainly since constructing an efficient matrix-free preconditioner is non-trivial. However, simple choices just requiring the diagonal of the corresponding matrix are good candidates and these can be computed in a matrix-free way as well. Alternatively, and maybe even better, one could extend the tutorial to use multigrid with Chebyshev smoothers similar to <a class="el" href="step_37.html">step-37</a>.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line">/* ---------------------------------------------------------------------</div><div class="line"> *</div><div class="line"> * Copyright (C) 2019 - 2020 by the deal.II authors</div><div class="line"> *</div><div class="line"> * This file is part of the deal.II library.</div><div class="line"> *</div><div class="line"> * The deal.II library is free software; you can use it, redistribute</div><div class="line"> * it, and/or modify it under the terms of the GNU Lesser General</div><div class="line"> * Public License as published by the Free Software Foundation; either</div><div class="line"> * version 2.1 of the License, or (at your option) any later version.</div><div class="line"> * The full text of the license can be found in the file LICENSE.md at</div><div class="line"> * the top level directory of deal.II.</div><div class="line"> *</div><div class="line"> * ---------------------------------------------------------------------</div><div class="line"></div><div class="line"> *</div><div class="line"> * Authors: Bruno Turcksin, Daniel Arndt, Oak Ridge National Laboratory, 2019</div><div class="line"> */</div><div class="line"></div><div class="line">#include &lt;deal.II/base/conditional_ostream.h&gt;</div><div class="line">#include &lt;deal.II/base/quadrature_lib.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/dofs/dof_tools.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/fe/fe_q.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/grid/grid_generator.h&gt;</div><div class="line">#include &lt;deal.II/grid/tria.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/lac/affine_constraints.h&gt;</div><div class="line">#include &lt;deal.II/lac/la_parallel_vector.h&gt;</div><div class="line">#include &lt;deal.II/lac/precondition.h&gt;</div><div class="line">#include &lt;deal.II/lac/solver_cg.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/numerics/data_out.h&gt;</div><div class="line">#include &lt;deal.II/numerics/vector_tools.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/base/cuda.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/matrix_free/cuda_fe_evaluation.h&gt;</div><div class="line">#include &lt;deal.II/matrix_free/cuda_matrix_free.h&gt;</div><div class="line">#include &lt;deal.II/matrix_free/operators.h&gt;</div><div class="line"></div><div class="line">#include &lt;fstream&gt;</div><div class="line"></div><div class="line"></div><div class="line">namespace Step64</div><div class="line">{</div><div class="line">  using namespace dealii;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class VaryingCoefficientFunctor</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    VaryingCoefficientFunctor(double *coefficient)</div><div class="line">      : coef(coefficient)</div><div class="line">    {}</div><div class="line"></div><div class="line">    __device__ void operator()(</div><div class="line">      const unsigned int                                          cell,</div><div class="line">      const typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data *gpu_data);</div><div class="line"></div><div class="line">    static const unsigned int n_dofs_1d = fe_degree + 1;</div><div class="line">    static const unsigned int n_local_dofs =</div><div class="line">      ::Utilities::pow(n_dofs_1d, dim);</div><div class="line">    static const unsigned int n_q_points =</div><div class="line">      ::Utilities::pow(n_dofs_1d, dim);</div><div class="line"></div><div class="line">  private:</div><div class="line">    double *coef;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  __device__ void VaryingCoefficientFunctor&lt;dim, fe_degree&gt;::operator()(</div><div class="line">    const unsigned int                                          cell,</div><div class="line">    const typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data *gpu_data)</div><div class="line">  {</div><div class="line">    const unsigned int pos = CUDAWrappers::local_q_point_id&lt;dim, double&gt;(</div><div class="line">      cell, gpu_data, n_dofs_1d, n_q_points);</div><div class="line">    const Point&lt;dim&gt; q_point =</div><div class="line">      CUDAWrappers::get_quadrature_point&lt;dim, double&gt;(cell,</div><div class="line">                                                      gpu_data,</div><div class="line">                                                      n_dofs_1d);</div><div class="line"></div><div class="line">    double p_square = 0.;</div><div class="line">    for (unsigned int i = 0; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        const double coord = q_point[i];</div><div class="line">        p_square += coord * coord;</div><div class="line">      }</div><div class="line">    coef[pos] = 10. / (0.05 + 2. * p_square);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class HelmholtzOperatorQuad</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    __device__ HelmholtzOperatorQuad(double coef)</div><div class="line">      : coef(coef)</div><div class="line">    {}</div><div class="line"></div><div class="line">    __device__ void</div><div class="line">    operator()(CUDAWrappers::FEEvaluation&lt;dim, fe_degree&gt; *fe_eval) const;</div><div class="line"></div><div class="line">  private:</div><div class="line">    double coef;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  __device__ void HelmholtzOperatorQuad&lt;dim, fe_degree&gt;::</div><div class="line">                  operator()(CUDAWrappers::FEEvaluation&lt;dim, fe_degree&gt; *fe_eval) const</div><div class="line">  {</div><div class="line">    fe_eval-&gt;submit_value(coef * fe_eval-&gt;get_value());</div><div class="line">    fe_eval-&gt;submit_gradient(fe_eval-&gt;get_gradient());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class LocalHelmholtzOperator</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    LocalHelmholtzOperator(double *coefficient)</div><div class="line">      : coef(coefficient)</div><div class="line">    {}</div><div class="line"></div><div class="line">    __device__ void operator()(</div><div class="line">      const unsigned int                                          cell,</div><div class="line">      const typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data *gpu_data,</div><div class="line">      CUDAWrappers::SharedData&lt;dim, double&gt; *                     shared_data,</div><div class="line">      const double *                                              src,</div><div class="line">      double *                                                    dst) const;</div><div class="line"></div><div class="line">    static const unsigned int n_dofs_1d    = fe_degree + 1;</div><div class="line">    static const unsigned int n_local_dofs = Utilities::pow(fe_degree + 1, dim);</div><div class="line">    static const unsigned int n_q_points   = Utilities::pow(fe_degree + 1, dim);</div><div class="line"></div><div class="line">  private:</div><div class="line">    double *coef;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  __device__ void LocalHelmholtzOperator&lt;dim, fe_degree&gt;::operator()(</div><div class="line">    const unsigned int                                          cell,</div><div class="line">    const typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data *gpu_data,</div><div class="line">    CUDAWrappers::SharedData&lt;dim, double&gt; *                     shared_data,</div><div class="line">    const double *                                              src,</div><div class="line">    double *                                                    dst) const</div><div class="line">  {</div><div class="line">    const unsigned int pos = CUDAWrappers::local_q_point_id&lt;dim, double&gt;(</div><div class="line">      cell, gpu_data, n_dofs_1d, n_q_points);</div><div class="line"></div><div class="line">    CUDAWrappers::FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, double&gt;</div><div class="line">      fe_eval(cell, gpu_data, shared_data);</div><div class="line">    fe_eval.read_dof_values(src);</div><div class="line">    fe_eval.evaluate(true, true);</div><div class="line">    fe_eval.apply_for_each_quad_point(</div><div class="line">      HelmholtzOperatorQuad&lt;dim, fe_degree&gt;(coef[pos]));</div><div class="line">    fe_eval.integrate(true, true);</div><div class="line">    fe_eval.distribute_local_to_global(dst);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class HelmholtzOperator</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    HelmholtzOperator(const DoFHandler&lt;dim&gt; &amp;          dof_handler,</div><div class="line">                      const AffineConstraints&lt;double&gt; &amp;constraints);</div><div class="line"></div><div class="line">    void</div><div class="line">    vmult(LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;dst,</div><div class="line">          const LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</div><div class="line">            &amp;src) const;</div><div class="line"></div><div class="line">    void initialize_dof_vector(</div><div class="line">      LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;vec) const;</div><div class="line"></div><div class="line">  private:</div><div class="line">    CUDAWrappers::MatrixFree&lt;dim, double&gt;       mf_data;</div><div class="line">    LinearAlgebra::CUDAWrappers::Vector&lt;double&gt; coef;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  HelmholtzOperator&lt;dim, fe_degree&gt;::HelmholtzOperator(</div><div class="line">    const DoFHandler&lt;dim&gt; &amp;          dof_handler,</div><div class="line">    const AffineConstraints&lt;double&gt; &amp;constraints)</div><div class="line">  {</div><div class="line">    MappingQGeneric&lt;dim&gt; mapping(fe_degree);</div><div class="line">    typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::AdditionalData</div><div class="line">      additional_data;</div><div class="line">    additional_data.mapping_update_flags = update_values | update_gradients |</div><div class="line">                                           update_JxW_values |</div><div class="line">                                           update_quadrature_points;</div><div class="line">    const QGauss&lt;1&gt; quad(fe_degree + 1);</div><div class="line">    mf_data.reinit(mapping, dof_handler, constraints, quad, additional_data);</div><div class="line"></div><div class="line"></div><div class="line">    const unsigned int n_owned_cells =</div><div class="line">      dynamic_cast&lt;const parallel::TriangulationBase&lt;dim&gt; *&gt;(</div><div class="line">        &amp;dof_handler.get_triangulation())</div><div class="line">        -&gt;n_locally_owned_active_cells();</div><div class="line">    coef.reinit(Utilities::pow(fe_degree + 1, dim) * n_owned_cells);</div><div class="line"></div><div class="line">    const VaryingCoefficientFunctor&lt;dim, fe_degree&gt; functor(coef.get_values());</div><div class="line">    mf_data.evaluate_coefficients(functor);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzOperator&lt;dim, fe_degree&gt;::vmult(</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;      dst,</div><div class="line">    const LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;src)</div><div class="line">    const</div><div class="line">  {</div><div class="line">    dst = 0.;</div><div class="line">    LocalHelmholtzOperator&lt;dim, fe_degree&gt; helmholtz_operator(</div><div class="line">      coef.get_values());</div><div class="line">    mf_data.cell_loop(helmholtz_operator, src, dst);</div><div class="line">    mf_data.copy_constrained_values(src, dst);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzOperator&lt;dim, fe_degree&gt;::initialize_dof_vector(</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;vec) const</div><div class="line">  {</div><div class="line">    mf_data.initialize_dof_vector(vec);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class HelmholtzProblem</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    HelmholtzProblem();</div><div class="line"></div><div class="line">    void run();</div><div class="line"></div><div class="line">  private:</div><div class="line">    void setup_system();</div><div class="line"></div><div class="line">    void assemble_rhs();</div><div class="line"></div><div class="line">    void solve();</div><div class="line"></div><div class="line">    void output_results(const unsigned int cycle) const;</div><div class="line"></div><div class="line">    MPI_Comm mpi_communicator;</div><div class="line"></div><div class="line">    parallel::distributed::Triangulation&lt;dim&gt; triangulation;</div><div class="line"></div><div class="line">    FE_Q&lt;dim&gt;       fe;</div><div class="line">    DoFHandler&lt;dim&gt; dof_handler;</div><div class="line"></div><div class="line">    IndexSet locally_owned_dofs;</div><div class="line">    IndexSet locally_relevant_dofs;</div><div class="line"></div><div class="line">    AffineConstraints&lt;double&gt;                          constraints;</div><div class="line">    std::unique_ptr&lt;HelmholtzOperator&lt;dim, fe_degree&gt;&gt; system_matrix_dev;</div><div class="line"></div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::Host&gt;</div><div class="line">                                                                  ghost_solution_host;</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; solution_dev;</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</div><div class="line">      system_rhs_dev;</div><div class="line"></div><div class="line">    ConditionalOStream pcout;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  HelmholtzProblem&lt;dim, fe_degree&gt;::HelmholtzProblem()</div><div class="line">    : mpi_communicator(MPI_COMM_WORLD)</div><div class="line">    , triangulation(mpi_communicator)</div><div class="line">    , fe(fe_degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , pcout(std::cout, Utilities::MPI::this_mpi_process(mpi_communicator) == 0)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">    locally_owned_dofs = dof_handler.locally_owned_dofs();</div><div class="line">    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);</div><div class="line">    system_rhs_dev.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line"></div><div class="line">    constraints.clear();</div><div class="line">    constraints.reinit(locally_relevant_dofs);</div><div class="line">    DoFTools::make_hanging_node_constraints(dof_handler, constraints);</div><div class="line">    VectorTools::interpolate_boundary_values(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             Functions::ZeroFunction&lt;dim&gt;(),</div><div class="line">                                             constraints);</div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    system_matrix_dev.reset(</div><div class="line">      new HelmholtzOperator&lt;dim, fe_degree&gt;(dof_handler, constraints));</div><div class="line"></div><div class="line">    ghost_solution_host.reinit(locally_owned_dofs,</div><div class="line">                               locally_relevant_dofs,</div><div class="line">                               mpi_communicator);</div><div class="line">    system_matrix_dev-&gt;initialize_dof_vector(solution_dev);</div><div class="line">    system_rhs_dev.reinit(solution_dev);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::assemble_rhs()</div><div class="line">  {</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::Host&gt;</div><div class="line">                      system_rhs_host(locally_owned_dofs,</div><div class="line">                      locally_relevant_dofs,</div><div class="line">                      mpi_communicator);</div><div class="line">    const QGauss&lt;dim&gt; quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">    FEValues&lt;dim&gt; fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            update_values | update_quadrature_points |</div><div class="line">                              update_JxW_values);</div><div class="line"></div><div class="line">    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    const unsigned int n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    Vector&lt;double&gt; cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    for (const auto &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">      if (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          cell_rhs = 0;</div><div class="line"></div><div class="line">          fe_values.reinit(cell);</div><div class="line"></div><div class="line">          for (unsigned int q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">            {</div><div class="line">              for (unsigned int i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                cell_rhs(i) += (fe_values.shape_value(i, q_index) * 1.0 *</div><div class="line">                                fe_values.JxW(q_index));</div><div class="line">            }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          constraints.distribute_local_to_global(cell_rhs,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 system_rhs_host);</div><div class="line">        }</div><div class="line">    system_rhs_host.compress(VectorOperation::add);</div><div class="line"></div><div class="line">    LinearAlgebra::ReadWriteVector&lt;double&gt; rw_vector(locally_owned_dofs);</div><div class="line">    rw_vector.import(system_rhs_host, VectorOperation::insert);</div><div class="line">    system_rhs_dev.import(rw_vector, VectorOperation::insert);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::solve()</div><div class="line">  {</div><div class="line">    PreconditionIdentity preconditioner;</div><div class="line"></div><div class="line">    SolverControl solver_control(system_rhs_dev.size(),</div><div class="line">                                 1e-12 * system_rhs_dev.l2_norm());</div><div class="line">    SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;&gt; cg(</div><div class="line">      solver_control);</div><div class="line">    cg.solve(*system_matrix_dev, solution_dev, system_rhs_dev, preconditioner);</div><div class="line"></div><div class="line">    pcout &lt;&lt; &quot;  Solved in &quot; &lt;&lt; solver_control.last_step() &lt;&lt; &quot; iterations.&quot;</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    LinearAlgebra::ReadWriteVector&lt;double&gt; rw_vector(locally_owned_dofs);</div><div class="line">    rw_vector.import(solution_dev, VectorOperation::insert);</div><div class="line">    ghost_solution_host.import(rw_vector, VectorOperation::insert);</div><div class="line"></div><div class="line">    constraints.distribute(ghost_solution_host);</div><div class="line"></div><div class="line">    ghost_solution_host.update_ghost_values();</div><div class="line">  }</div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::output_results(</div><div class="line">    const unsigned int cycle) const</div><div class="line">  {</div><div class="line">    DataOut&lt;dim&gt; data_out;</div><div class="line"></div><div class="line">    data_out.attach_dof_handler(dof_handler);</div><div class="line">    data_out.add_data_vector(ghost_solution_host, &quot;solution&quot;);</div><div class="line">    data_out.build_patches();</div><div class="line"></div><div class="line">    DataOutBase::VtkFlags flags;</div><div class="line">    flags.compression_level = DataOutBase::VtkFlags::best_speed;</div><div class="line">    data_out.set_flags(flags);</div><div class="line">    data_out.write_vtu_with_pvtu_record(</div><div class="line">      &quot;./&quot;, &quot;solution&quot;, cycle, mpi_communicator, 2);</div><div class="line"></div><div class="line">    Vector&lt;float&gt; cellwise_norm(triangulation.n_active_cells());</div><div class="line">    VectorTools::integrate_difference(dof_handler,</div><div class="line">                                      ghost_solution_host,</div><div class="line">                                      Functions::ZeroFunction&lt;dim&gt;(),</div><div class="line">                                      cellwise_norm,</div><div class="line">                                      QGauss&lt;dim&gt;(fe.degree + 2),</div><div class="line">                                      VectorTools::L2_norm);</div><div class="line">    const double global_norm =</div><div class="line">      VectorTools::compute_global_error(triangulation,</div><div class="line">                                        cellwise_norm,</div><div class="line">                                        VectorTools::L2_norm);</div><div class="line">    pcout &lt;&lt; &quot;  solution norm: &quot; &lt;&lt; global_norm &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::run()</div><div class="line">  {</div><div class="line">    for (unsigned int cycle = 0; cycle &lt; 7 - dim; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; &quot;Cycle &quot; &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        if (cycle == 0)</div><div class="line">          GridGenerator::hyper_cube(triangulation, 0., 1.);</div><div class="line">        triangulation.refine_global(1);</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        pcout &lt;&lt; &quot;   Number of active cells:       &quot;</div><div class="line">              &lt;&lt; triangulation.n_global_active_cells() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; &quot;   Number of degrees of freedom: &quot; &lt;&lt; dof_handler.n_dofs()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_rhs();</div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} // namespace Step64</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">{</div><div class="line">  try</div><div class="line">    {</div><div class="line">      using namespace Step64;</div><div class="line"></div><div class="line">      Utilities::MPI::MPI_InitFinalize mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">      int         n_devices       = 0;</div><div class="line">      cudaError_t cuda_error_code = cudaGetDeviceCount(&amp;n_devices);</div><div class="line">      AssertCuda(cuda_error_code);</div><div class="line">      const unsigned int my_mpi_id =</div><div class="line">        Utilities::MPI::this_mpi_process(MPI_COMM_WORLD);</div><div class="line">      const int device_id = my_mpi_id % n_devices;</div><div class="line">      cuda_error_code     = cudaSetDevice(device_id);</div><div class="line">      AssertCuda(cuda_error_code);</div><div class="line"></div><div class="line">      HelmholtzProblem&lt;3, 3&gt; helmholtz_problem;</div><div class="line">      helmholtz_problem.run();</div><div class="line">    }</div><div class="line">  catch (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;----------------------------------------------------&quot;</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; &quot;Exception on processing: &quot; &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;Aborting!&quot; &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;----------------------------------------------------&quot;</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      return 1;</div><div class="line">    }</div><div class="line">  catch (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;----------------------------------------------------&quot;</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; &quot;Unknown exception!&quot; &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;Aborting!&quot; &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;----------------------------------------------------&quot;</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      return 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  return 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_7.html">step-7</a> , <a class="el" href="step_37.html">step-37</a> . <table
 class="tutorial" width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#Thetestcase">The test case</a><a href="#Thetestcase">The test
 case</a>
 <li><a href="#Movingdatatoandfromthedevice">Moving data to and from the
 device</a><a href="#Movingdatatoandfromthedevice">Moving data to and from
 the device</a>
 <li><a href="#Matrixvectorproductimplementation">Matrix-vector product
 implementation</a><a
 href="#Matrixvectorproductimplementation">Matrix-vector product
 implementation</a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#ClasscodeVaryingCoefficientFunctorcode">Class
 <code>VaryingCoefficientFunctor</code></a><a
 href="#ClasscodeVaryingCoefficientFunctorcode">Class
 <code>VaryingCoefficientFunctor</code></a>
 <li><a href="#ClasscodeHelmholtzOperatorQuadcode">Class
 <code>HelmholtzOperatorQuad</code></a><a
 href="#ClasscodeHelmholtzOperatorQuadcode">Class
 <code>HelmholtzOperatorQuad</code></a>
 <li><a href="#ClasscodeLocalHelmholtzOperatorcode">Class
 <code>LocalHelmholtzOperator</code></a><a
 href="#ClasscodeLocalHelmholtzOperatorcode">Class
 <code>LocalHelmholtzOperator</code></a>
 <li><a href="#ClasscodeHelmholtzOperatorcode">Class
 <code>HelmholtzOperator</code></a><a
 href="#ClasscodeHelmholtzOperatorcode">Class
 <code>HelmholtzOperator</code></a>
 <li><a href="#ClasscodeHelmholtzProblemcode">Class
 <code>HelmholtzProblem</code></a><a
 href="#ClasscodeHelmholtzProblemcode">Class
 <code>HelmholtzProblem</code></a>
 <li><a href="#Thecodemaincodefunction">The <code>main()</code>
 function</a><a href="#Thecodemaincodefunction">The <code>main()</code>
 function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#Possibilitiesforextensions"> Possibilities for extensions
 </a><a href="#Possibilitiesforextensions"> Possibilities for extensions
 </a>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <br />
 <em> This program was contributed by Bruno Turcksin and Daniel Arndt, Oak Ridge National Laboratory. </em></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This example shows how to implement a matrix-free method on the GPU using CUDAfor the Helmholtz equation with variable coefficients on a hypercube. The linearsystem will be solved using the conjugate gradient method and is parallelized with MPI. In the last few years, heterogeneous computing in general and GPUs in particularhave gained a lot of popularity. This is because GPUs offer better computingcapabilities and memory bandwidth than CPUs for a given power budget.Among the architectures available in early 2019, GPUs are about 2x-3x as powerefficient than server CPUs with wide <a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> for PDE-relatedtasks. GPUs are alsothe most popular architecture for machine learning. On the other hand,GPUs are not easy to program. This program explores the deal.IIcapabilities to see how efficiently such a program can be implemented. While we have tried for the interface of the matrix-free classes for the CPU andthe GPU to be as close as possible, there are a few differences. When usingthe matrix-free framework on a GPU, one must write some CUDA code. However, theamount is fairly small and the use of CUDA is limited to a few keywords.</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p>In this example, we consider the Helmholtz problem </p><p class="formulaDsp">
\begin{eqnarray*} - \nabla \cdot \nabla u + a(\mathbf x) u &amp;=&amp;1,\\ u &amp;=&amp; 0 \quad \text{on } \partial \Omega \end{eqnarray*}
</p>
<p> where \(a(\mathbf x)\) is a variable coefficient. We choose as domain \(\Omega=[0,1]^3\) and \(a(\mathbf x)=\frac{10}{0.05 + 2\|\mathbf x\|^2}\) . Since the coefficient is symmetric around the origin butthe domain is not, we will end up with a non-symmetric solution. If you've made it this far into the tutorial, you will know how theweak formulation of this problem looks like and how, in principle, oneassembles linear systems for it. Of course, in this program we will infact not actually form the matrix, but rather only represent itsaction when one multiplies with it.</p>
<p><a class="anchor" id="Movingdatatoandfromthedevice"></a></p><h3>Moving data to and from the device</h3>
<p>GPUs (we will use the term "device" from now on to refer to the GPU) have their own memorythat is separate from the memory accessible to the CPU (we will use the term"host" from now on). A normal calculation on the device can be divided in threeseparate steps:</p>
<ul>
<li>the data is moved from the host to the device,</li>
<li>the computation is done on the device,</li>
<li>the result is moved back from the device to the host The data movements can either be done explicitly by the user code or doneautomatically using UVM (Unified Virtual Memory). In deal.II, only the firstmethod is supported. While it means an extra burden for the user, thisallows forbetter control of data movement and more importantly it avoids to mistakenly runimportant kernels on the host instead of the device. The data movement in deal.II is done using <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>. Thesevectors can be seen as buffers on the host that are used to either store datareceived from the device or to send data to the device. There are two types of vectorsthat can be used on the device:</li>
<li><a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a>, which is similar to the more commonVector&lt;Number&gt;, and</li>
<li>LinearAlgebra::distributed::Vector&lt;Number,    MemorySpace::CUDA&gt;, which is a regular <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> where we have specified which memoryspace to use. If no memory space is specified, the default is <a class="el" href="structMemorySpace_1_1Host.html">MemorySpace::Host</a>. Next, we show how to move data to/from the device using <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a>: <div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = 10;</div><div class="line"><a class="code" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector&lt;double&gt;</a> rw_vector(size);</div><div class="line"></div><div class="line">...do something with the rw_vector...</div><div class="line"></div><div class="line"><span class="comment">// Move the data to the device:</span></div><div class="line">LinearAlgebra::CUDAWrappers::Vector&lt;<span class="keywordtype">double</span>&gt; vector_dev(size);</div><div class="line">vector_dev.import(rw_vector, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div><div class="line"></div><div class="line">...do some computations on the device...</div><div class="line"></div><div class="line"><span class="comment">// Move the data back to the host:</span></div><div class="line">rw_vector.import(vector_dev, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div></div><!-- fragment --> Both of the vector classes used here only work on a single machine,i.e., one memory space on a host and one on a device. But there are cases where one wants to run a parallel computationbetween multiple MPI processes on a number of machines, each of whichis equipped with GPUs. In that case, one wants to use <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt;Number,<a class="el" href="structMemorySpace_1_1CUDA.html">MemorySpace::CUDA</a>&gt;</code>, which is similar but the <code>import()</code> stage may involve MPI communication: <div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs, locally_relevant_dofs;</div><div class="line">...fill the two <a class="code" href="classIndexSet.html">IndexSet</a> objects...</div><div class="line"></div><div class="line"><span class="comment">// Create the ReadWriteVector using an IndexSet instead of the size</span></div><div class="line">LinearAlgebra::ReadWriteVector&lt;<span class="keywordtype">double</span>&gt; owned_rw_vector(locally_owned_dofs);</div><div class="line"></div><div class="line">...do something with the rw_vector...</div><div class="line"></div><div class="line"><span class="comment">// Move the data to the device:</span></div><div class="line">LinearAlgebra::distributed::Vector&lt;double, <a class="code" href="structMemorySpace_1_1CUDA.html">MemorySpace::CUDA</a>&gt;</div><div class="line"> distributed_vector_dev(locally_owned_dofs, MPI_COMM_WORLD);</div><div class="line">distributed_vector_dev.import(owned_rw_vector, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div><div class="line"></div><div class="line">...do something with the dev_vector...</div><div class="line"></div><div class="line"><span class="comment">// Create a ReadWriteVector with a different IndexSet:</span></div><div class="line">LinearAlgebra::ReadWriteVector&lt;<span class="keywordtype">double</span>&gt;</div><div class="line"> relevant_rw_vector(locally_relevant_dofs);</div><div class="line"></div><div class="line"><span class="comment">// Move the data to the host, possibly using MPI communication:</span></div><div class="line">relevant_rw_vector.import(distributed_vector_dev, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div></div><!-- fragment --> The <code>relevant_rw_vector</code> is an object that stores a subset of allelements of the vector. Typically, these are the <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">locally relevant DoFs</a>, which implies that they overlap between different MPIprocesses. Consequently, the elements stored in that vector on onemachine may not coincide with the ones stored by the GPU on thatmachine, requiring MPI communication to import them. In all of these cases, while importing a vector, values can either beinserted (using <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>) or added to prior content ofthe vector (using <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>).</li>
</ul>
<p><a class="anchor" id="Matrixvectorproductimplementation"></a></p><h3>Matrix-vector product implementation</h3>
<p>The code necessary to evaluate the matrix-free operator on the device is verysimilar to the one on the host. However, there are a few differences, the mainones being that the <code>local_apply()</code> function in <a class="el" href="step_37.html">step-37</a> and the loop overquadrature points both need to be encapsulated in their own functors.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>First include the necessary files from the deal.II library known from the previous tutorials.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="la__parallel__vector_8h.html">deal.II/lac/la_parallel_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The following ones include the data structures for the implementation of matrix-free methods on GPU:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2cuda_8h.html">deal.II/base/cuda.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cuda__fe__evaluation_8h.html">deal.II/matrix_free/cuda_fe_evaluation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cuda__matrix__free_8h.html">deal.II/matrix_free/cuda_matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="operators_8h.html">deal.II/matrix_free/operators.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>As usual, we enclose everything into a namespace of its own:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step64</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeVaryingCoefficientFunctorcode"></a> </p><h3>Class <code>VaryingCoefficientFunctor</code></h3>
<p>Next, we define a class that implements the varying coefficients we want to use in the Helmholtz operator. Later, we want to pass an object of this type to a <a class="el" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree</a> object that expects the class to have an <code>operator()</code> that fills the values provided in the constructor for a given cell. This operator needs to run on the device, so it needs to be marked as <code>__device__</code> for the compiler.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>VaryingCoefficientFunctor</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  VaryingCoefficientFunctor(doublecoefficient)</div><div class="line">    : coef(coefficient)</div><div class="line">  {}</div><div class="line"></div><div class="line">  __device__ <span class="keywordtype">void</span> operator()(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                          cell,</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::Datagpu_data</a>);</div></div><!-- fragment --><p>Since <a class="el" href="structCUDAWrappers_1_1MatrixFree_1_1Data.html">CUDAWrappers::MatrixFree::Data</a> doesn't know about the size of its arrays, we need to store the number of quadrature points and the numbers of degrees of freedom in this class to do necessary index conversions.</p>
<div class="fragment"><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_1d = fe_degree + 1;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_local_dofs =</div><div class="line">    ::Utilities::pow(n_dofs_1d, dim);</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    ::Utilities::pow(n_dofs_1d, dim);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  doublecoef;</div><div class="line">};</div></div><!-- fragment --><p>The following function implements this coefficient. Recall from the introduction that we have defined it as \(a(\mathbf x)=\frac{10}{0.05 + 2\|\mathbf x\|^2}\)</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">__device__ <span class="keywordtype">void</span> VaryingCoefficientFunctor&lt;dim, fe_degree&gt;::operator()(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                          cell,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::Datagpu_data</a>)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = CUDAWrappers::local_q_point_id&lt;dim, double&gt;(</div><div class="line">    cell, gpu_data, n_dofs_1d, n_q_points);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> q_point =</div><div class="line">    CUDAWrappers::get_quadrature_point&lt;dim, double&gt;(cell,</div><div class="line">                                                    gpu_data,</div><div class="line">                                                    n_dofs_1d);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> p_square = 0.;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> coord = q_point[i];</div><div class="line">      p_square += coord coord;</div><div class="line">    }</div><div class="line">  coef[pos] = 10. / (0.05 + 2. p_square);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeHelmholtzOperatorQuadcode"></a> </p><h3>Class <code>HelmholtzOperatorQuad</code></h3>
<p>The class <code>HelmholtzOperatorQuad</code> implements the evaluation of the Helmholtz operator at each quadrature point. It uses a similar mechanism as the <a class="el" href="classMatrixFree.html">MatrixFree</a> framework introduced in <a class="el" href="step_37.html">step-37</a> . In contrast to there, the actual quadrature point index is treated implicitly by converting the current thread index. As before, the functions of this class need to run on the device, so need to be marked as <code>__device__</code> for the compiler.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>HelmholtzOperatorQuad</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  __device__ HelmholtzOperatorQuad(<span class="keywordtype">double</span> coef)</div><div class="line">    : coef(coef)</div><div class="line">  {}</div><div class="line"></div><div class="line">  __device__ <span class="keywordtype">void</span></div><div class="line">  operator()(<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html">CUDAWrappers::FEEvaluation&lt;dim, fe_degree&gt;</a>fe_eval) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span> coef;</div><div class="line">};</div></div><!-- fragment --><p>The Helmholtz problem we want to solve here reads in weak form as follows: </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla v, \nabla u)+ (v, a(\mathbf x) u) &amp;=&amp;(v,1) \quad \forall v. \end{eqnarray*}
</p>
<p> If you have seen <a class="el" href="step_37.html">step-37</a> , then it will be obvious that the two terms on the left-hand side correspond to the two function calls here:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">__device__ <span class="keywordtype">void</span> HelmholtzOperatorQuad&lt;dim, fe_degree&gt;::</div><div class="line">                operator()(<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html">CUDAWrappers::FEEvaluation&lt;dim, fe_degree&gt;</a>fe_eval)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  fe_eval-&gt;<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#a58daeed0b26fcaeee745936a62403623">submit_value</a>(coef fe_eval-&gt;<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#aacf72a37d0ef60c9cd248b896fdafb99">get_value</a>());</div><div class="line">  fe_eval-&gt;<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#a25fffdd57bc94870cc1bc4db2f4f6379">submit_gradient</a>(fe_eval-&gt;<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#ae14d61c332a97c1e2a5023db782f1155">get_gradient</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeLocalHelmholtzOperatorcode"></a> </p><h3>Class <code>LocalHelmholtzOperator</code></h3>
<p>Finally, we need to define a class that implements the whole operator evaluation that corresponds to a matrix-vector product in matrix-based approaches.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>LocalHelmholtzOperator</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LocalHelmholtzOperator(doublecoefficient)</div><div class="line">    : coef(coefficient)</div><div class="line">  {}</div><div class="line"></div><div class="line">  __device__ <span class="keywordtype">void</span> operator()(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                          cell,</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::Datagpu_data</a>,</div><div class="line">    <a class="code" href="structCUDAWrappers_1_1SharedData.html">CUDAWrappers::SharedData&lt;dim, double&gt;</a>                     shared_data,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                              src,</div><div class="line">    <span class="keywordtype">double</span>                                                    dst) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Again, the <a class="el" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree</a> object doesn't know about the number of degrees of freedom and the number of quadrature points so we need to store these for index calculations in the call operator.</p>
<div class="fragment"><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_1d    = fe_degree + 1;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_local_dofs = <a class="code" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">Utilities::pow</a>(fe_degree + 1, dim);</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points   = <a class="code" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">Utilities::pow</a>(fe_degree + 1, dim);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  doublecoef;</div><div class="line">};</div></div><!-- fragment --><p>This is the call operator that performs the Helmholtz operator evaluation on a given cell similar to the <a class="el" href="classMatrixFree.html">MatrixFree</a> framework on the CPU. In particular, we need access to both values and gradients of the source vector and we write value and gradient information to the destination vector.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">__device__ <span class="keywordtype">void</span> LocalHelmholtzOperator&lt;dim, fe_degree&gt;::operator()(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                          cell,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::Datagpu_data</a>,</div><div class="line">  <a class="code" href="structCUDAWrappers_1_1SharedData.html">CUDAWrappers::SharedData&lt;dim, double&gt;</a>                     shared_data,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>                                              src,</div><div class="line">  <span class="keywordtype">double</span>                                                    dst)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = CUDAWrappers::local_q_point_id&lt;dim, double&gt;(</div><div class="line">    cell, gpu_data, n_dofs_1d, n_q_points);</div><div class="line"></div><div class="line">  <a class="code" href="classCUDAWrappers_1_1FEEvaluation.html">CUDAWrappers::FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, double&gt;</a></div><div class="line">    fe_eval(cell, gpu_data, shared_data);</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#ae0e594e5dc5dc91391190c4bb1d8c45c">read_dof_values</a>(src);</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#aa50f53d6eb1b0416a791008a5e1a3b25">evaluate</a>(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#af54da23ff99a33dcd23ddccf52dee2f5">apply_for_each_quad_point</a>(</div><div class="line">    HelmholtzOperatorQuad&lt;dim, fe_degree&gt;(coef[pos]));</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#a12939db3c43822e5cbf51520ad52dedb">integrate</a>(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#a90c2f1b2718e90aa49b7d49fac3600d5">distribute_local_to_global</a>(dst);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeHelmholtzOperatorcode"></a> </p><h3>Class <code>HelmholtzOperator</code></h3>
<p>The <code>HelmholtzOperator</code> class acts as wrapper for <code>LocalHelmholtzOperator</code> defining an interface that can be used with linear solvers like <a class="el" href="classSolverCG.html">SolverCG</a>. In particular, like every class that implements the interface of a linear operator, it needs to have a <code>vmult()</code> function that performs the action of the linear operator on a source vector.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>HelmholtzOperator</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  HelmholtzOperator(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;          dof_handler,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;constraints);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  vmult(<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;dst,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a></div><div class="line">          &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> initialize_dof_vector(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;vec) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <a class="code" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;</a>       mf_data;</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector&lt;double&gt;</a> coef;</div><div class="line">};</div></div><!-- fragment --><p>The following is the implementation of the constructor of this class. In the first part, we initialize the <code>mf_data</code> member variable that is going to provide us with the necessary information when evaluating the operator. In the second half, we need to store the value of the coefficient for each quadrature point in every active, locally owned cell. We can ask the parallel triangulation for the number of active, locally owned cells but only have a <a class="el" href="classDoFHandler.html">DoFHandler</a> object at hand. Since <a class="el" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">DoFHandler::get_triangulation()</a> returns a <a class="el" href="classTriangulation.html">Triangulation</a> object, not a <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> object, we have to downcast the return value. This is safe to do here because we know that the triangulation is a parallel:distributed::<a class="el" href="classTriangulation.html">Triangulation</a> object in fact.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">HelmholtzOperator&lt;dim, fe_degree&gt;::HelmholtzOperator(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;          dof_handler,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;constraints)</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(fe_degree);</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1AdditionalData.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::AdditionalData</a></div><div class="line">    additional_data;</div><div class="line">  additional_data.<a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1AdditionalData.html#a4fc9f434f93f40a8c1dff4ed6b9fd509">mapping_update_flags</a> = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a> quad(fe_degree + 1);</div><div class="line">  mf_data.reinit(mapping, dof_handler, constraints, quad, additional_data);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_owned_cells =</div><div class="line">    <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span><a class="code" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase&lt;dim&gt;</a><span class="keyword">&gt;</span>(</div><div class="line">      &amp;dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>())</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-&gt;n_locally_owned_active_cells();</div><div class="line">  coef.reinit(<a class="code" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">Utilities::pow</a>(fe_degree + 1, dim) n_owned_cells);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> VaryingCoefficientFunctor&lt;dim, fe_degree&gt; functor(coef.get_values());</div><div class="line">  mf_data.evaluate_coefficients(functor);</div><div class="line">}</div></div><!-- fragment --><p>The key step then is to use all of the previous classes to loop over all cells to perform the matrix-vector product. We implement this in the next function. When applying the Helmholtz operator, we have to be careful to handle boundary conditions correctly. Since the local operator doesn't know about constraints, we have to copy the correct values from the source to the destination vector afterwards.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzOperator&lt;dim, fe_degree&gt;::vmult(</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;src)<span class="keyword"></span></div><div class="line"><span class="keyword">  const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  dst = 0.;</div><div class="line">  LocalHelmholtzOperator&lt;dim, fe_degree&gt; helmholtz_operator(</div><div class="line">    coef.get_values());</div><div class="line">  mf_data.cell_loop(helmholtz_operator, src, dst);</div><div class="line">  mf_data.copy_constrained_values(src, dst);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzOperator&lt;dim, fe_degree&gt;::initialize_dof_vector(</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;vec)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  mf_data.initialize_dof_vector(vec);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeHelmholtzProblemcode"></a> </p><h3>Class <code>HelmholtzProblem</code></h3>
<p>This is the main class of this program. It defines the usual framework we use for tutorial programs. The only point worth commenting on is the <code>solve()</code> function and the choice of vector types.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>HelmholtzProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  HelmholtzProblem();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_rhs();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classMPI__Comm.html">MPI_Comm</a> mpi_communicator;</div><div class="line"></div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a>                          constraints;</div><div class="line">  std::unique_ptr&lt;HelmholtzOperator&lt;dim, fe_degree&gt;&gt; system_matrix_dev;</div></div><!-- fragment --><p>Since all the operations in the <code>solve()</code> function are executed on the graphics card, it is necessary for the vectors used to store their values on the GPU as well. <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> can be told which memory space to use. There is also <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a> that always uses GPU memory storage but doesn't work with MPI. It might be worth noticing that the communication between different MPI processes can be improved if the MPI implementation is CUDA-aware and the configure flag <code>DEAL_II_MPI_WITH_CUDA_SUPPORT</code> is enabled. (The value of this flag needs to be set at the time you call <code>cmake</code> when installing deal.II.) In addition, we also keep a solution vector with CPU storage such that we can view and display the solution as usual.</p>
<div class="fragment"><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::Host&gt;</a></div><div class="line">                                                                ghost_solution_host;</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> solution_dev;</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a></div><div class="line">    system_rhs_dev;</div><div class="line"></div><div class="line">  <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line">};</div></div><!-- fragment --><p>The implementation of all the remaining functions of this class apart from <code>Helmholtzproblem::solve()</code> doesn't contain anything new and we won't further comment much on the overall approach.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">HelmholtzProblem&lt;dim, fe_degree&gt;::HelmholtzProblem()</div><div class="line">  : mpi_communicator(MPI_COMM_WORLD)</div><div class="line">  , triangulation(mpi_communicator)</div><div class="line">  , fe(fe_degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , pcout(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim, fe_degree&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  locally_owned_dofs = dof_handler.<a class="code" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">locally_owned_dofs</a>();</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line">  system_rhs_dev.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">  system_matrix_dev.reset(</div><div class="line">    <span class="keyword">new</span> HelmholtzOperator&lt;dim, fe_degree&gt;(dof_handler, constraints));</div><div class="line"></div><div class="line">  ghost_solution_host.reinit(locally_owned_dofs,</div><div class="line">                             locally_relevant_dofs,</div><div class="line">                             mpi_communicator);</div><div class="line">  system_matrix_dev-&gt;initialize_dof_vector(solution_dev);</div><div class="line">  system_rhs_dev.reinit(solution_dev);</div><div class="line">}</div></div><!-- fragment --><p>Unlike programs such as <a class="el" href="step_4.html">step-4</a> or <a class="el" href="step_6.html">step-6</a> , we will not have to assemble the whole linear system but only the right hand side vector. This looks in essence like we did in <a class="el" href="step_4.html">step-4</a> , for example, but we have to pay attention to using the right constraints object when copying local contributions into the global vector. In particular, we need to make sure the entries that correspond to boundary nodes are properly zeroed out. This is necessary for CG to converge. (Another solution would be to modify the <code>vmult()</code> function above in such a way that we pretend the source vector has zero entries by just not taking them into account in matrix-vector products. But the approach used here is simpler.) At the end of the function, we can't directly copy the values from the host to the device but need to use an intermediate object of type <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a> to construct the correct communication pattern necessary.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim, fe_degree&gt;::assemble_rhs()</div><div class="line">{</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::Host&gt;</a></div><div class="line">                    system_rhs_host(locally_owned_dofs,</div><div class="line">                    locally_relevant_dofs,</div><div class="line">                    mpi_communicator);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt; cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) 1.0</div><div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_rhs_host);</div><div class="line">      }</div><div class="line">  system_rhs_host.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector&lt;double&gt;</a> rw_vector(locally_owned_dofs);</div><div class="line">  rw_vector.import(system_rhs_host, <a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">  system_rhs_dev.import(rw_vector, <a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">}</div></div><!-- fragment --><p>This solve() function finally contains the calls to the new classes previously discussed. Here we don't use any preconditioner, i.e., precondition by the identity matrix, to focus just on the peculiarities of the <a class="el" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree</a> framework. Of course, in a real application the choice of a suitable preconditioner is crucial but we have at least the same restrictions as in <a class="el" href="step_37.html">step-37</a> since matrix entries are computed on the fly and not stored. After solving the linear system in the first part of the function, we copy the solution from the device to the host to be able to view its values and display it in <code>output_results()</code>. This transfer works the same as at the end of the previous function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim, fe_degree&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a> preconditioner;</div><div class="line"></div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(system_rhs_dev.size(),</div><div class="line">                               1e-12 system_rhs_dev.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a>&gt; cg(</div><div class="line">    solver_control);</div><div class="line">  cg.solve(*system_matrix_dev, solution_dev, system_rhs_dev, preconditioner);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;  Solved in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector&lt;double&gt;</a> rw_vector(locally_owned_dofs);</div><div class="line">  rw_vector.import(solution_dev, <a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">  ghost_solution_host.import(rw_vector, <a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(ghost_solution_host);</div><div class="line"></div><div class="line">  ghost_solution_host.update_ghost_values();</div><div class="line">}</div></div><!-- fragment --><p>The output results function is as usual since we have already copied the values back from the GPU to the CPU. While we're already doing something with the function, we might as well compute the \(L_2\) norm of the solution. We do this by calling <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a>. That function is meant to compute the error by evaluating the difference between the numerical solution (given by a vector of values for the degrees of freedom) and an object representing the exact solution. But we can easily compute the \(L_2\) norm of the solution by passing in a zero function instead. That is, instead of evaluating the error \(\|u_h-u\|_{L_2(\Omega)}\) , we are just evaluating \(\|u_h-0\|_{L_2(\Omega)}=\|u_h\|_{L_2(\Omega)}\) instead.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim, fe_degree&gt;::output_results(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(ghost_solution_host, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">  flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> = <a class="code" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a>;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">    <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution&quot;</span>, cycle, mpi_communicator, 2);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> cellwise_norm(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler,</div><div class="line">                                    ghost_solution_host,</div><div class="line">                                    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                    cellwise_norm,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> global_norm =</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                      cellwise_norm,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;  solution norm: &quot;</span> &lt;&lt; global_norm &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>There is nothing surprising in the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function either. We simply compute the solution on a series of (globally) refined meshes.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">HelmholtzProblem&lt;dim, fe_degree&gt;::run</a>()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 7</div><div class="line"></div><div class="line">- dim; ++cycle)</div><div class="line">    {</div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">        <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 1.);</div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line"></div><div class="line">      setup_system();</div><div class="line"></div><div class="line">      pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">            &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      assemble_rhs();</div><div class="line">      solve();</div><div class="line">      output_results(cycle);</div><div class="line">      pcout &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div><div class="line">} <span class="comment">// namespace Step64</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main()</code> function</h3>
<p>Finally for the <code>main()</code> function. By default, all the MPI ranks will try to access the device with number 0, which we assume to be the GPU device associated with the CPU on which a particular MPI rank runs. This works, but if we are running with MPI support it may be that multiple MPI processes are running on the same machine (for example, one per CPU core) and then they would all want to access the same GPU on that machine. If there is only one GPU in the machine, there is nothing we can do about it: All MPI ranks on that machine need to share it. But if there are more than one GPU, then it is better to address different graphic cards for different processes. The choice below is based on the MPI process id by assigning GPUs round robin to GPU ranks. (To work correctly, this scheme assumes that the MPI ranks on one machine are consecutive. If that were not the case, then the rank-GPU association may just not be optimal.) To make this work, MPI needs to be initialized before using this function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, charargv[])</div><div class="line">{</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    <span class="keyword">using namespace </span>Step64;</div><div class="line"></div><div class="line">    <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span>         n_devices       = 0;</div><div class="line">    cudaError_t cuda_error_code = cudaGetDeviceCount(&amp;n_devices);</div><div class="line">    <a class="code" href="group__Exceptions.html#gac1b7e8a4a8d5d910cd9fbd8814e9955e">AssertCuda</a>(cuda_error_code);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> my_mpi_id =</div><div class="line">      <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> device_id = my_mpi_id % n_devices;</div><div class="line">    cuda_error_code     = cudaSetDevice(device_id);</div><div class="line">    <a class="code" href="group__Exceptions.html#gac1b7e8a4a8d5d910cd9fbd8814e9955e">AssertCuda</a>(cuda_error_code);</div><div class="line"></div><div class="line">    HelmholtzProblem&lt;3, 3&gt; helmholtz_problem;</div><div class="line">    helmholtz_problem.run();</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>Since the main purpose of this tutorial is to demonstrate how to use the <a class="el" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree</a> interface, not to compute anything useful initself, we just show the expected output here: </p><div class="fragment"><div class="line">Cycle 0</div><div class="line">Number of active cells:       8</div><div class="line">Number of degrees of freedom: 343</div><div class="line">Solved in 27 iterations.</div><div class="line">solution <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 0.0205439</div><div class="line"></div><div class="line">Cycle 1</div><div class="line">Number of active cells:       64</div><div class="line">Number of degrees of freedom: 2197</div><div class="line">Solved in 60 iterations.</div><div class="line">solution <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 0.0205269</div><div class="line"></div><div class="line">Cycle 2</div><div class="line">Number of active cells:       512</div><div class="line">Number of degrees of freedom: 15625</div><div class="line">Solved in 114 iterations.</div><div class="line">solution <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 0.0205261</div><div class="line"></div><div class="line">Cycle 3</div><div class="line">Number of active cells:       4096</div><div class="line">Number of degrees of freedom: 117649</div><div class="line">Solved in 227 iterations.</div><div class="line">solution <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 0.0205261</div></div><!-- fragment --><p>One can make two observations here: First, the norm of the numerical solutionconverges, presumably to the norm of the exact (but unknown)solution. And second, the number of iterations roughly doubles witheach refinement of the mesh. (This is in keeping with the expectationthat the number of CG iterations grows with the square root of thecondition number of the matrix; and that we know that the conditionnumber of the matrix of a second-order differential operation growslike \({\cal O}(h^{-2})\) .) This is of course rather inefficient, as anoptimal solver would have a number of iterations that is independentof the size of the problem. But having such a solver would requireusing a better preconditioner than the identity matrix we have used here.</p>
<p><a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>Currently, this program uses no preconditioner at all. This is mainlysince constructing an efficient matrix-free preconditioner isnon-trivial. However, simple choices just requiring the diagonal ofthe corresponding matrix are good candidates and these can be computedin a matrix-free way as well. Alternatively, and maybe even better,one could extend the tutorial to use multigrid with Chebyshevsmoothers similar to <a class="el" href="step_37.html">step-37</a> .</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line">/* ---------------------------------------------------------------------</div><div class="line"> *</div><div class="line"> * Copyright (C) 2019 - 2020 by the deal.II authors</div><div class="line"> *</div><div class="line"> * This file is part of the deal.II library.</div><div class="line"> *</div><div class="line"> * The deal.II library is free software; you can use it, redistribute</div><div class="line"> * it, and/or modify it under the terms of the GNU Lesser General</div><div class="line"> * Public License as published by the Free Software Foundation; either</div><div class="line"> * version 2.1 of the License, or (at your option) any later version.</div><div class="line"> * The full text of the license can be found in the file LICENSE.md at</div><div class="line"> * the top level directory of deal.II.</div><div class="line"> *</div><div class="line"> * ---------------------------------------------------------------------</div><div class="line"></div><div class="line"> *</div><div class="line"> * Authors: Bruno Turcksin, Daniel Arndt, Oak Ridge National Laboratory, 2019</div><div class="line"> */</div><div class="line"></div><div class="line">#include &lt;deal.II/base/conditional_ostream.h&gt;</div><div class="line">#include &lt;deal.II/base/quadrature_lib.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/dofs/dof_tools.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/fe/fe_q.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/grid/grid_generator.h&gt;</div><div class="line">#include &lt;deal.II/grid/tria.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/lac/affine_constraints.h&gt;</div><div class="line">#include &lt;deal.II/lac/la_parallel_vector.h&gt;</div><div class="line">#include &lt;deal.II/lac/precondition.h&gt;</div><div class="line">#include &lt;deal.II/lac/solver_cg.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/numerics/data_out.h&gt;</div><div class="line">#include &lt;deal.II/numerics/vector_tools.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/base/cuda.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/matrix_free/cuda_fe_evaluation.h&gt;</div><div class="line">#include &lt;deal.II/matrix_free/cuda_matrix_free.h&gt;</div><div class="line">#include &lt;deal.II/matrix_free/operators.h&gt;</div><div class="line"></div><div class="line">#include &lt;fstream&gt;</div><div class="line"></div><div class="line"></div><div class="line">namespace Step64</div><div class="line">{</div><div class="line">  using namespace dealii;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class VaryingCoefficientFunctor</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    VaryingCoefficientFunctor(double *coefficient)</div><div class="line">      : coef(coefficient)</div><div class="line">    {}</div><div class="line"></div><div class="line">    __device__ void operator()(</div><div class="line">      const unsigned int                                          cell,</div><div class="line">      const typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data *gpu_data);</div><div class="line"></div><div class="line">    static const unsigned int n_dofs_1d = fe_degree + 1;</div><div class="line">    static const unsigned int n_local_dofs =</div><div class="line">      ::Utilities::pow(n_dofs_1d, dim);</div><div class="line">    static const unsigned int n_q_points =</div><div class="line">      ::Utilities::pow(n_dofs_1d, dim);</div><div class="line"></div><div class="line">  private:</div><div class="line">    double *coef;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  __device__ void VaryingCoefficientFunctor&lt;dim, fe_degree&gt;::operator()(</div><div class="line">    const unsigned int                                          cell,</div><div class="line">    const typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data *gpu_data)</div><div class="line">  {</div><div class="line">    const unsigned int pos = CUDAWrappers::local_q_point_id&lt;dim, double&gt;(</div><div class="line">      cell, gpu_data, n_dofs_1d, n_q_points);</div><div class="line">    const Point&lt;dim&gt; q_point =</div><div class="line">      CUDAWrappers::get_quadrature_point&lt;dim, double&gt;(cell,</div><div class="line">                                                      gpu_data,</div><div class="line">                                                      n_dofs_1d);</div><div class="line"></div><div class="line">    double p_square = 0.;</div><div class="line">    for (unsigned int i = 0; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        const double coord = q_point[i];</div><div class="line">        p_square += coord * coord;</div><div class="line">      }</div><div class="line">    coef[pos] = 10. / (0.05 + 2. * p_square);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class HelmholtzOperatorQuad</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    __device__ HelmholtzOperatorQuad(double coef)</div><div class="line">      : coef(coef)</div><div class="line">    {}</div><div class="line"></div><div class="line">    __device__ void</div><div class="line">    operator()(CUDAWrappers::FEEvaluation&lt;dim, fe_degree&gt; *fe_eval) const;</div><div class="line"></div><div class="line">  private:</div><div class="line">    double coef;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  __device__ void HelmholtzOperatorQuad&lt;dim, fe_degree&gt;::</div><div class="line">                  operator()(CUDAWrappers::FEEvaluation&lt;dim, fe_degree&gt; *fe_eval) const</div><div class="line">  {</div><div class="line">    fe_eval-&gt;submit_value(coef * fe_eval-&gt;get_value());</div><div class="line">    fe_eval-&gt;submit_gradient(fe_eval-&gt;get_gradient());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class LocalHelmholtzOperator</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    LocalHelmholtzOperator(double *coefficient)</div><div class="line">      : coef(coefficient)</div><div class="line">    {}</div><div class="line"></div><div class="line">    __device__ void operator()(</div><div class="line">      const unsigned int                                          cell,</div><div class="line">      const typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data *gpu_data,</div><div class="line">      CUDAWrappers::SharedData&lt;dim, double&gt; *                     shared_data,</div><div class="line">      const double *                                              src,</div><div class="line">      double *                                                    dst) const;</div><div class="line"></div><div class="line">    static const unsigned int n_dofs_1d    = fe_degree + 1;</div><div class="line">    static const unsigned int n_local_dofs = Utilities::pow(fe_degree + 1, dim);</div><div class="line">    static const unsigned int n_q_points   = Utilities::pow(fe_degree + 1, dim);</div><div class="line"></div><div class="line">  private:</div><div class="line">    double *coef;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  __device__ void LocalHelmholtzOperator&lt;dim, fe_degree&gt;::operator()(</div><div class="line">    const unsigned int                                          cell,</div><div class="line">    const typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data *gpu_data,</div><div class="line">    CUDAWrappers::SharedData&lt;dim, double&gt; *                     shared_data,</div><div class="line">    const double *                                              src,</div><div class="line">    double *                                                    dst) const</div><div class="line">  {</div><div class="line">    const unsigned int pos = CUDAWrappers::local_q_point_id&lt;dim, double&gt;(</div><div class="line">      cell, gpu_data, n_dofs_1d, n_q_points);</div><div class="line"></div><div class="line">    CUDAWrappers::FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, double&gt;</div><div class="line">      fe_eval(cell, gpu_data, shared_data);</div><div class="line">    fe_eval.read_dof_values(src);</div><div class="line">    fe_eval.evaluate(true, true);</div><div class="line">    fe_eval.apply_for_each_quad_point(</div><div class="line">      HelmholtzOperatorQuad&lt;dim, fe_degree&gt;(coef[pos]));</div><div class="line">    fe_eval.integrate(true, true);</div><div class="line">    fe_eval.distribute_local_to_global(dst);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class HelmholtzOperator</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    HelmholtzOperator(const DoFHandler&lt;dim&gt; &amp;          dof_handler,</div><div class="line">                      const AffineConstraints&lt;double&gt; &amp;constraints);</div><div class="line"></div><div class="line">    void</div><div class="line">    vmult(LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;dst,</div><div class="line">          const LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</div><div class="line">            &amp;src) const;</div><div class="line"></div><div class="line">    void initialize_dof_vector(</div><div class="line">      LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;vec) const;</div><div class="line"></div><div class="line">  private:</div><div class="line">    CUDAWrappers::MatrixFree&lt;dim, double&gt;       mf_data;</div><div class="line">    LinearAlgebra::CUDAWrappers::Vector&lt;double&gt; coef;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  HelmholtzOperator&lt;dim, fe_degree&gt;::HelmholtzOperator(</div><div class="line">    const DoFHandler&lt;dim&gt; &amp;          dof_handler,</div><div class="line">    const AffineConstraints&lt;double&gt; &amp;constraints)</div><div class="line">  {</div><div class="line">    MappingQGeneric&lt;dim&gt; mapping(fe_degree);</div><div class="line">    typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::AdditionalData</div><div class="line">      additional_data;</div><div class="line">    additional_data.mapping_update_flags = update_values | update_gradients |</div><div class="line">                                           update_JxW_values |</div><div class="line">                                           update_quadrature_points;</div><div class="line">    const QGauss&lt;1&gt; quad(fe_degree + 1);</div><div class="line">    mf_data.reinit(mapping, dof_handler, constraints, quad, additional_data);</div><div class="line"></div><div class="line"></div><div class="line">    const unsigned int n_owned_cells =</div><div class="line">      dynamic_cast&lt;const parallel::TriangulationBase&lt;dim&gt; *&gt;(</div><div class="line">        &amp;dof_handler.get_triangulation())</div><div class="line">        -&gt;n_locally_owned_active_cells();</div><div class="line">    coef.reinit(Utilities::pow(fe_degree + 1, dim) * n_owned_cells);</div><div class="line"></div><div class="line">    const VaryingCoefficientFunctor&lt;dim, fe_degree&gt; functor(coef.get_values());</div><div class="line">    mf_data.evaluate_coefficients(functor);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzOperator&lt;dim, fe_degree&gt;::vmult(</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;      dst,</div><div class="line">    const LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;src)</div><div class="line">    const</div><div class="line">  {</div><div class="line">    dst = 0.;</div><div class="line">    LocalHelmholtzOperator&lt;dim, fe_degree&gt; helmholtz_operator(</div><div class="line">      coef.get_values());</div><div class="line">    mf_data.cell_loop(helmholtz_operator, src, dst);</div><div class="line">    mf_data.copy_constrained_values(src, dst);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzOperator&lt;dim, fe_degree&gt;::initialize_dof_vector(</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;vec) const</div><div class="line">  {</div><div class="line">    mf_data.initialize_dof_vector(vec);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class HelmholtzProblem</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    HelmholtzProblem();</div><div class="line"></div><div class="line">    void run();</div><div class="line"></div><div class="line">  private:</div><div class="line">    void setup_system();</div><div class="line"></div><div class="line">    void assemble_rhs();</div><div class="line"></div><div class="line">    void solve();</div><div class="line"></div><div class="line">    void output_results(const unsigned int cycle) const;</div><div class="line"></div><div class="line">    MPI_Comm mpi_communicator;</div><div class="line"></div><div class="line">    parallel::distributed::Triangulation&lt;dim&gt; triangulation;</div><div class="line"></div><div class="line">    FE_Q&lt;dim&gt;       fe;</div><div class="line">    DoFHandler&lt;dim&gt; dof_handler;</div><div class="line"></div><div class="line">    IndexSet locally_owned_dofs;</div><div class="line">    IndexSet locally_relevant_dofs;</div><div class="line"></div><div class="line">    AffineConstraints&lt;double&gt;                          constraints;</div><div class="line">    std::unique_ptr&lt;HelmholtzOperator&lt;dim, fe_degree&gt;&gt; system_matrix_dev;</div><div class="line"></div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::Host&gt;</div><div class="line">                                                                  ghost_solution_host;</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; solution_dev;</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</div><div class="line">      system_rhs_dev;</div><div class="line"></div><div class="line">    ConditionalOStream pcout;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  HelmholtzProblem&lt;dim, fe_degree&gt;::HelmholtzProblem()</div><div class="line">    : mpi_communicator(MPI_COMM_WORLD)</div><div class="line">    , triangulation(mpi_communicator)</div><div class="line">    , fe(fe_degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , pcout(std::cout, Utilities::MPI::this_mpi_process(mpi_communicator) == 0)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">    locally_owned_dofs = dof_handler.locally_owned_dofs();</div><div class="line">    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);</div><div class="line">    system_rhs_dev.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line"></div><div class="line">    constraints.clear();</div><div class="line">    constraints.reinit(locally_relevant_dofs);</div><div class="line">    DoFTools::make_hanging_node_constraints(dof_handler, constraints);</div><div class="line">    VectorTools::interpolate_boundary_values(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             Functions::ZeroFunction&lt;dim&gt;(),</div><div class="line">                                             constraints);</div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    system_matrix_dev.reset(</div><div class="line">      new HelmholtzOperator&lt;dim, fe_degree&gt;(dof_handler, constraints));</div><div class="line"></div><div class="line">    ghost_solution_host.reinit(locally_owned_dofs,</div><div class="line">                               locally_relevant_dofs,</div><div class="line">                               mpi_communicator);</div><div class="line">    system_matrix_dev-&gt;initialize_dof_vector(solution_dev);</div><div class="line">    system_rhs_dev.reinit(solution_dev);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::assemble_rhs()</div><div class="line">  {</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::Host&gt;</div><div class="line">                      system_rhs_host(locally_owned_dofs,</div><div class="line">                      locally_relevant_dofs,</div><div class="line">                      mpi_communicator);</div><div class="line">    const QGauss&lt;dim&gt; quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">    FEValues&lt;dim&gt; fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            update_values | update_quadrature_points |</div><div class="line">                              update_JxW_values);</div><div class="line"></div><div class="line">    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    const unsigned int n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    Vector&lt;double&gt; cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    for (const auto &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">      if (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          cell_rhs = 0;</div><div class="line"></div><div class="line">          fe_values.reinit(cell);</div><div class="line"></div><div class="line">          for (unsigned int q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">            {</div><div class="line">              for (unsigned int i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                cell_rhs(i) += (fe_values.shape_value(i, q_index) * 1.0 *</div><div class="line">                                fe_values.JxW(q_index));</div><div class="line">            }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          constraints.distribute_local_to_global(cell_rhs,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 system_rhs_host);</div><div class="line">        }</div><div class="line">    system_rhs_host.compress(VectorOperation::add);</div><div class="line"></div><div class="line">    LinearAlgebra::ReadWriteVector&lt;double&gt; rw_vector(locally_owned_dofs);</div><div class="line">    rw_vector.import(system_rhs_host, VectorOperation::insert);</div><div class="line">    system_rhs_dev.import(rw_vector, VectorOperation::insert);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::solve()</div><div class="line">  {</div><div class="line">    PreconditionIdentity preconditioner;</div><div class="line"></div><div class="line">    SolverControl solver_control(system_rhs_dev.size(),</div><div class="line">                                 1e-12 * system_rhs_dev.l2_norm());</div><div class="line">    SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;&gt; cg(</div><div class="line">      solver_control);</div><div class="line">    cg.solve(*system_matrix_dev, solution_dev, system_rhs_dev, preconditioner);</div><div class="line"></div><div class="line">    pcout &lt;&lt; &quot;  Solved in &quot; &lt;&lt; solver_control.last_step() &lt;&lt; &quot; iterations.&quot;</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    LinearAlgebra::ReadWriteVector&lt;double&gt; rw_vector(locally_owned_dofs);</div><div class="line">    rw_vector.import(solution_dev, VectorOperation::insert);</div><div class="line">    ghost_solution_host.import(rw_vector, VectorOperation::insert);</div><div class="line"></div><div class="line">    constraints.distribute(ghost_solution_host);</div><div class="line"></div><div class="line">    ghost_solution_host.update_ghost_values();</div><div class="line">  }</div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::output_results(</div><div class="line">    const unsigned int cycle) const</div><div class="line">  {</div><div class="line">    DataOut&lt;dim&gt; data_out;</div><div class="line"></div><div class="line">    data_out.attach_dof_handler(dof_handler);</div><div class="line">    data_out.add_data_vector(ghost_solution_host, &quot;solution&quot;);</div><div class="line">    data_out.build_patches();</div><div class="line"></div><div class="line">    DataOutBase::VtkFlags flags;</div><div class="line">    flags.compression_level = DataOutBase::VtkFlags::best_speed;</div><div class="line">    data_out.set_flags(flags);</div><div class="line">    data_out.write_vtu_with_pvtu_record(</div><div class="line">      &quot;./&quot;, &quot;solution&quot;, cycle, mpi_communicator, 2);</div><div class="line"></div><div class="line">    Vector&lt;float&gt; cellwise_norm(triangulation.n_active_cells());</div><div class="line">    VectorTools::integrate_difference(dof_handler,</div><div class="line">                                      ghost_solution_host,</div><div class="line">                                      Functions::ZeroFunction&lt;dim&gt;(),</div><div class="line">                                      cellwise_norm,</div><div class="line">                                      QGauss&lt;dim&gt;(fe.degree + 2),</div><div class="line">                                      VectorTools::L2_norm);</div><div class="line">    const double global_norm =</div><div class="line">      VectorTools::compute_global_error(triangulation,</div><div class="line">                                        cellwise_norm,</div><div class="line">                                        VectorTools::L2_norm);</div><div class="line">    pcout &lt;&lt; &quot;  solution norm: &quot; &lt;&lt; global_norm &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::run()</div><div class="line">  {</div><div class="line">    for (unsigned int cycle = 0; cycle &lt; 7 - dim; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; &quot;Cycle &quot; &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        if (cycle == 0)</div><div class="line">          GridGenerator::hyper_cube(triangulation, 0., 1.);</div><div class="line">        triangulation.refine_global(1);</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        pcout &lt;&lt; &quot;   Number of active cells:       &quot;</div><div class="line">              &lt;&lt; triangulation.n_global_active_cells() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; &quot;   Number of degrees of freedom: &quot; &lt;&lt; dof_handler.n_dofs()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_rhs();</div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} // namespace Step64</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">{</div><div class="line">  try</div><div class="line">    {</div><div class="line">      using namespace Step64;</div><div class="line"></div><div class="line">      Utilities::MPI::MPI_InitFinalize mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">      int         n_devices       = 0;</div><div class="line">      cudaError_t cuda_error_code = cudaGetDeviceCount(&amp;n_devices);</div><div class="line">      AssertCuda(cuda_error_code);</div><div class="line">      const unsigned int my_mpi_id =</div><div class="line">        Utilities::MPI::this_mpi_process(MPI_COMM_WORLD);</div><div class="line">      const int device_id = my_mpi_id % n_devices;</div><div class="line">      cuda_error_code     = cudaSetDevice(device_id);</div><div class="line">      AssertCuda(cuda_error_code);</div><div class="line"></div><div class="line">      HelmholtzProblem&lt;3, 3&gt; helmholtz_problem;</div><div class="line">      helmholtz_problem.run();</div><div class="line">    }</div><div class="line">  catch (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;----------------------------------------------------&quot;</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; &quot;Exception on processing: &quot; &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;Aborting!&quot; &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;----------------------------------------------------&quot;</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      return 1;</div><div class="line">    }</div><div class="line">  catch (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;----------------------------------------------------&quot;</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; &quot;Unknown exception!&quot; &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;Aborting!&quot; &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;----------------------------------------------------&quot;</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      return 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  return 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_7.html">step-7</a>, <a class="el" href="step_37.html">step-37</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Thetestcase">The test case</a>
        <li><a href="#Movingdatatoandfromthedevice">Moving data to and from the device</a>
        <li><a href="#Matrixvectorproductimplementation">Matrix-vector product implementation</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#ClasscodeVaryingCoefficientFunctorcode">Class <code>VaryingCoefficientFunctor</code></a>
        <li><a href="#ClasscodeHelmholtzOperatorQuadcode">Class <code>HelmholtzOperatorQuad</code></a>
        <li><a href="#ClasscodeLocalHelmholtzOperatorcode">Class <code>LocalHelmholtzOperator</code></a>
        <li><a href="#ClasscodeHelmholtzOperatorcode">Class <code>HelmholtzOperator</code></a>
        <li><a href="#ClasscodeHelmholtzProblemcode">Class <code>HelmholtzProblem</code></a>
        <li><a href="#Thecodemaincodefunction">The <code>main()</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-64/doc/intro.dox</p>
<p><br />
</p>
<p><em> This program was contributed by Bruno Turcksin and Daniel Arndt, Oak Ridge National Laboratory. </em></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>CUDAGPUMPI</p>
<p>GPUGPUCPU2019PDEGPUCPU2-3<a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a>GPUGPUdeal.II</p>
<p>CPUGPUGPUCUDACUDA</p>
<p><a class="anchor" id="Thetestcase"></a></p><h3>The test case</h3>
<p> </p><p class="formulaDsp">
\begin{eqnarray*} - \nabla \cdot \nabla u + a(\mathbf x) u &amp;=&amp;1,\\ u &amp;=&amp; 0 \quad \text{on } \partial \Omega \end{eqnarray*}
</p>
<p> </p>
<p> \(a(\mathbf x)\) </p>
<p> \(\Omega=[0,1]^3\)  \(a(\mathbf x)=\frac{10}{0.05 + 2\|\mathbf x\|^2}\) </p>
<p></p>
<p><a class="anchor" id="Movingdatatoandfromthedevice"></a></p><h3>Moving data to and from the device</h3>
<p>GPU " "GPUCPU " "</p>
<ol type="1">
<li></li>
</ol>
<p>-#</p>
<ol type="1">
<li></li>
</ol>
<p>UVMdeal.II</p>
<p>deal.II <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>. </p>
<ul>
<li><a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a>, Vector&lt;Number&gt;</li>
<li>LinearAlgebra::distributed::Vector&lt;Number,   MemorySpace::CUDA&gt;,  <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> </li>
</ul>
<p> <a class="el" href="structMemorySpace_1_1Host.html">MemorySpace::Host</a>. </p>
<p> <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a>: /</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = 10;</div><div class="line"><a class="code" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector&lt;double&gt;</a> rw_vector(size);</div><div class="line"></div><div class="line"></div><div class="line">...do something with the rw_vector...</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Move the data to the device:</span></div><div class="line">LinearAlgebra::CUDAWrappers::Vector&lt;<span class="keywordtype">double</span>&gt; vector_dev(size);</div><div class="line">vector_dev.import(rw_vector, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div><div class="line"></div><div class="line"></div><div class="line">...do some computations on the device...</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Move the data back to the host:</span></div><div class="line">rw_vector.import(vector_dev, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div></div><!-- fragment --><p></p>
<p>MPIGPU <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt;Number,<a class="el" href="structMemorySpace_1_1CUDA.html">MemorySpace::CUDA</a>&gt;</code>, <code>import()</code>MPI</p>
<div class="fragment"><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs, locally_relevant_dofs;</div><div class="line">...fill the two <a class="code" href="classIndexSet.html">IndexSet</a> objects...</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Create the ReadWriteVector using an IndexSet instead of the size</span></div><div class="line">LinearAlgebra::ReadWriteVector&lt;<span class="keywordtype">double</span>&gt; owned_rw_vector(locally_owned_dofs);</div><div class="line"></div><div class="line"></div><div class="line">...do something with the rw_vector...</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Move the data to the device:</span></div><div class="line">LinearAlgebra::distributed::Vector&lt;double, <a class="code" href="structMemorySpace_1_1CUDA.html">MemorySpace::CUDA</a>&gt;</div><div class="line">  distributed_vector_dev(locally_owned_dofs, MPI_COMM_WORLD);</div><div class="line">distributed_vector_dev.import(owned_rw_vector, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div><div class="line"></div><div class="line"></div><div class="line">...do something with the dev_vector...</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Create a ReadWriteVector with a different IndexSet:</span></div><div class="line">LinearAlgebra::ReadWriteVector&lt;<span class="keywordtype">double</span>&gt;</div><div class="line">  relevant_rw_vector(locally_relevant_dofs);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Move the data to the host, possibly using MPI communication:</span></div><div class="line">relevant_rw_vector.import(distributed_vector_dev, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div></div><!-- fragment --><p><code>relevant_rw_vector</code> <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">DoF</a>MPIGPUMPI</p>
<p> <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>)  <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>). </p>
<p><a class="anchor" id="Matrixvectorproductimplementation"></a></p><h3>Matrix-vector product implementation</h3>
<p><a class="el" href="step_37.html">step-37</a><code>local_apply()</code></p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>First include the necessary files from the deal.II library known from the previous tutorials.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="la__parallel__vector_8h.html">deal.II/lac/la_parallel_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div></div><!-- fragment --><p>The following ones include the data structures for the implementation of matrix-free methods on GPU:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2cuda_8h.html">deal.II/base/cuda.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cuda__fe__evaluation_8h.html">deal.II/matrix_free/cuda_fe_evaluation.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cuda__matrix__free_8h.html">deal.II/matrix_free/cuda_matrix_free.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="operators_8h.html">deal.II/matrix_free/operators.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>As usual, we enclose everything into a namespace of its own:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step64</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeVaryingCoefficientFunctorcode"></a> </p><h3>Class <code>VaryingCoefficientFunctor</code></h3>
<p>Next, we define a class that implements the varying coefficients we want to use in the Helmholtz operator. Later, we want to pass an object of this type to a <a class="el" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree</a> object that expects the class to have an <code>operator()</code> that fills the values provided in the constructor for a given cell. This operator needs to run on the device, so it needs to be marked as <code>__device__</code> for the compiler.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>VaryingCoefficientFunctor</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  VaryingCoefficientFunctor(<span class="keywordtype">double</span> *coefficient)</div><div class="line">    : coef(coefficient)</div><div class="line">  {}</div><div class="line"></div><div class="line">  __device__ <span class="keywordtype">void</span> operator()(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                          cell,</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1Data.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data</a> *gpu_data);</div></div><!-- fragment --><p>Since <a class="el" href="structCUDAWrappers_1_1MatrixFree_1_1Data.html">CUDAWrappers::MatrixFree::Data</a> doesn't know about the size of its arrays, we need to store the number of quadrature points and the numbers of degrees of freedom in this class to do necessary index conversions.</p>
<div class="fragment"><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_1d = fe_degree + 1;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_local_dofs =</div><div class="line">    ::Utilities::pow(n_dofs_1d, dim);</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points =</div><div class="line">    ::Utilities::pow(n_dofs_1d, dim);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span> *coef;</div><div class="line">};</div></div><!-- fragment --><p>The following function implements this coefficient. Recall from the introduction that we have defined it as \(a(\mathbf x)=\frac{10}{0.05 + 2\|\mathbf x\|^2}\)</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">__device__ <span class="keywordtype">void</span> VaryingCoefficientFunctor&lt;dim, fe_degree&gt;::operator()(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                          cell,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1Data.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data</a> *gpu_data)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = CUDAWrappers::local_q_point_id&lt;dim, double&gt;(</div><div class="line">    cell, gpu_data, n_dofs_1d, n_q_points);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> q_point =</div><div class="line">    CUDAWrappers::get_quadrature_point&lt;dim, double&gt;(cell,</div><div class="line">                                                    gpu_data,</div><div class="line">                                                    n_dofs_1d);</div><div class="line"></div><div class="line">  <span class="keywordtype">double</span> p_square = 0.;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> coord = q_point[i];</div><div class="line">      p_square += coord * coord;</div><div class="line">    }</div><div class="line">  coef[pos] = 10. / (0.05 + 2. * p_square);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeHelmholtzOperatorQuadcode"></a> </p><h3>Class <code>HelmholtzOperatorQuad</code></h3>
<p>The class <code>HelmholtzOperatorQuad</code> implements the evaluation of the Helmholtz operator at each quadrature point. It uses a similar mechanism as the <a class="el" href="classMatrixFree.html">MatrixFree</a> framework introduced in <a class="el" href="step_37.html">step-37</a>. In contrast to there, the actual quadrature point index is treated implicitly by converting the current thread index. As before, the functions of this class need to run on the device, so need to be marked as <code>__device__</code> for the compiler.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>HelmholtzOperatorQuad</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  __device__ HelmholtzOperatorQuad(<span class="keywordtype">double</span> coef)</div><div class="line">    : coef(coef)</div><div class="line">  {}</div><div class="line"></div><div class="line">  __device__ <span class="keywordtype">void</span></div><div class="line">  operator()(<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html">CUDAWrappers::FEEvaluation&lt;dim, fe_degree&gt;</a> *fe_eval) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span> coef;</div><div class="line">};</div></div><!-- fragment --><p>The Helmholtz problem we want to solve here reads in weak form as follows: </p><p class="formulaDsp">
\begin{eqnarray*} (\nabla v, \nabla u)+ (v, a(\mathbf x) u) &amp;=&amp;(v,1) \quad \forall v. \end{eqnarray*}
</p>
<p> If you have seen <a class="el" href="step_37.html">step-37</a>, then it will be obvious that the two terms on the left-hand side correspond to the two function calls here:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">__device__ <span class="keywordtype">void</span> HelmholtzOperatorQuad&lt;dim, fe_degree&gt;::</div><div class="line">                operator()(<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html">CUDAWrappers::FEEvaluation&lt;dim, fe_degree&gt;</a> *fe_eval)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  fe_eval-&gt;<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#a58daeed0b26fcaeee745936a62403623">submit_value</a>(coef * fe_eval-&gt;<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#aacf72a37d0ef60c9cd248b896fdafb99">get_value</a>());</div><div class="line">  fe_eval-&gt;<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#a25fffdd57bc94870cc1bc4db2f4f6379">submit_gradient</a>(fe_eval-&gt;<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#ae14d61c332a97c1e2a5023db782f1155">get_gradient</a>());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeLocalHelmholtzOperatorcode"></a> </p><h3>Class <code>LocalHelmholtzOperator</code></h3>
<p>Finally, we need to define a class that implements the whole operator evaluation that corresponds to a matrix-vector product in matrix-based approaches.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>LocalHelmholtzOperator</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  LocalHelmholtzOperator(<span class="keywordtype">double</span> *coefficient)</div><div class="line">    : coef(coefficient)</div><div class="line">  {}</div><div class="line"></div><div class="line">  __device__ <span class="keywordtype">void</span> operator()(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                          cell,</div><div class="line">    <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1Data.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data</a> *gpu_data,</div><div class="line">    <a class="code" href="structCUDAWrappers_1_1SharedData.html">CUDAWrappers::SharedData&lt;dim, double&gt;</a> *                     shared_data,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> *                                              src,</div><div class="line">    <span class="keywordtype">double</span> *                                                    dst) <span class="keyword">const</span>;</div></div><!-- fragment --><p>Again, the <a class="el" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree</a> object doesn't know about the number of degrees of freedom and the number of quadrature points so we need to store these for index calculations in the call operator.</p>
<div class="fragment"><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs_1d    = fe_degree + 1;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_local_dofs = <a class="code" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">Utilities::pow</a>(fe_degree + 1, dim);</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points   = <a class="code" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">Utilities::pow</a>(fe_degree + 1, dim);</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">double</span> *coef;</div><div class="line">};</div></div><!-- fragment --><p>This is the call operator that performs the Helmholtz operator evaluation on a given cell similar to the <a class="el" href="classMatrixFree.html">MatrixFree</a> framework on the CPU. In particular, we need access to both values and gradients of the source vector and we write value and gradient information to the destination vector.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">__device__ <span class="keywordtype">void</span> LocalHelmholtzOperator&lt;dim, fe_degree&gt;::operator()(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                                          cell,</div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1Data.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data</a> *gpu_data,</div><div class="line">  <a class="code" href="structCUDAWrappers_1_1SharedData.html">CUDAWrappers::SharedData&lt;dim, double&gt;</a> *                     shared_data,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> *                                              src,</div><div class="line">  <span class="keywordtype">double</span> *                                                    dst)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = CUDAWrappers::local_q_point_id&lt;dim, double&gt;(</div><div class="line">    cell, gpu_data, n_dofs_1d, n_q_points);</div><div class="line"></div><div class="line">  <a class="code" href="classCUDAWrappers_1_1FEEvaluation.html">CUDAWrappers::FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, double&gt;</a></div><div class="line">    fe_eval(cell, gpu_data, shared_data);</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#ae0e594e5dc5dc91391190c4bb1d8c45c">read_dof_values</a>(src);</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#aa50f53d6eb1b0416a791008a5e1a3b25">evaluate</a>(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#af54da23ff99a33dcd23ddccf52dee2f5">apply_for_each_quad_point</a>(</div><div class="line">    HelmholtzOperatorQuad&lt;dim, fe_degree&gt;(coef[pos]));</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#a12939db3c43822e5cbf51520ad52dedb">integrate</a>(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line">  fe_eval.<a class="code" href="classCUDAWrappers_1_1FEEvaluation.html#a90c2f1b2718e90aa49b7d49fac3600d5">distribute_local_to_global</a>(dst);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeHelmholtzOperatorcode"></a> </p><h3>Class <code>HelmholtzOperator</code></h3>
<p>The <code>HelmholtzOperator</code> class acts as wrapper for <code>LocalHelmholtzOperator</code> defining an interface that can be used with linear solvers like <a class="el" href="classSolverCG.html">SolverCG</a>. In particular, like every class that implements the interface of a linear operator, it needs to have a <code>vmult()</code> function that performs the action of the linear operator on a source vector.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>HelmholtzOperator</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  HelmholtzOperator(<span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;          dof_handler,</div><div class="line">                    <span class="keyword">const</span> <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;constraints);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  vmult(<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;dst,</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a></div><div class="line">          &amp;src) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> initialize_dof_vector(</div><div class="line">    <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;vec) <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <a class="code" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;</a>       mf_data;</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector&lt;double&gt;</a> coef;</div><div class="line">};</div></div><!-- fragment --><p>The following is the implementation of the constructor of this class. In the first part, we initialize the <code>mf_data</code> member variable that is going to provide us with the necessary information when evaluating the operator.</p>
<p>In the second half, we need to store the value of the coefficient for each quadrature point in every active, locally owned cell. We can ask the parallel triangulation for the number of active, locally owned cells but only have a <a class="el" href="classDoFHandler.html">DoFHandler</a> object at hand. Since <a class="el" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">DoFHandler::get_triangulation()</a> returns a <a class="el" href="classTriangulation.html">Triangulation</a> object, not a <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> object, we have to downcast the return value. This is safe to do here because we know that the triangulation is a parallel:distributed::<a class="el" href="classTriangulation.html">Triangulation</a> object in fact.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">HelmholtzOperator&lt;dim, fe_degree&gt;::HelmholtzOperator(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> &amp;          dof_handler,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> &amp;constraints)</div><div class="line">{</div><div class="line">  <a class="code" href="classMappingQGeneric.html">MappingQGeneric&lt;dim&gt;</a> mapping(fe_degree);</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1AdditionalData.html">CUDAWrappers::MatrixFree&lt;dim, double&gt;::AdditionalData</a></div><div class="line">    additional_data;</div><div class="line">  additional_data.<a class="code" href="structCUDAWrappers_1_1MatrixFree_1_1AdditionalData.html#a4fc9f434f93f40a8c1dff4ed6b9fd509">mapping_update_flags</a> = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> |</div><div class="line">                                         <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a>;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;1&gt;</a> quad(fe_degree + 1);</div><div class="line">  mf_data.reinit(mapping, dof_handler, constraints, quad, additional_data);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_owned_cells =</div><div class="line">    <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span><a class="code" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase&lt;dim&gt;</a> *<span class="keyword">&gt;</span>(</div><div class="line">      &amp;dof_handler.<a class="code" href="classDoFHandler.html#a7797f796c0be511fbc7f230ccc22532e">get_triangulation</a>())</div><div class="line">      -&gt;n_locally_owned_active_cells();</div><div class="line">  coef.reinit(<a class="code" href="namespaceUtilities.html#a0900f35b37ee122e73fb2c80bba9beb9">Utilities::pow</a>(fe_degree + 1, dim) * n_owned_cells);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> VaryingCoefficientFunctor&lt;dim, fe_degree&gt; functor(coef.get_values());</div><div class="line">  mf_data.evaluate_coefficients(functor);</div><div class="line">}</div></div><!-- fragment --><p>The key step then is to use all of the previous classes to loop over all cells to perform the matrix-vector product. We implement this in the next function.</p>
<p>When applying the Helmholtz operator, we have to be careful to handle boundary conditions correctly. Since the local operator doesn't know about constraints, we have to copy the correct values from the source to the destination vector afterwards.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzOperator&lt;dim, fe_degree&gt;::vmult(</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;      dst,</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;src)<span class="keyword"></span></div><div class="line"><span class="keyword">  const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  dst = 0.;</div><div class="line">  LocalHelmholtzOperator&lt;dim, fe_degree&gt; helmholtz_operator(</div><div class="line">    coef.get_values());</div><div class="line">  mf_data.cell_loop(helmholtz_operator, src, dst);</div><div class="line">  mf_data.copy_constrained_values(src, dst);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzOperator&lt;dim, fe_degree&gt;::initialize_dof_vector(</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> &amp;vec)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  mf_data.initialize_dof_vector(vec);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ClasscodeHelmholtzProblemcode"></a> </p><h3>Class <code>HelmholtzProblem</code></h3>
<p>This is the main class of this program. It defines the usual framework we use for tutorial programs. The only point worth commenting on is the <code>solve()</code> function and the choice of vector types.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keyword">class </span>HelmholtzProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  HelmholtzProblem();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> assemble_rhs();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classMPI__Comm.html">MPI_Comm</a> mpi_communicator;</div><div class="line"></div><div class="line">  <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line"></div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs;</div><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a>                          constraints;</div><div class="line">  std::unique_ptr&lt;HelmholtzOperator&lt;dim, fe_degree&gt;&gt; system_matrix_dev;</div></div><!-- fragment --><p>Since all the operations in the <code>solve()</code> function are executed on the graphics card, it is necessary for the vectors used to store their values on the GPU as well. <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a> can be told which memory space to use. There is also <a class="el" href="classLinearAlgebra_1_1CUDAWrappers_1_1Vector.html">LinearAlgebra::CUDAWrappers::Vector</a> that always uses GPU memory storage but doesn't work with MPI. It might be worth noticing that the communication between different MPI processes can be improved if the MPI implementation is CUDA-aware and the configure flag <code>DEAL_II_MPI_WITH_CUDA_SUPPORT</code> is enabled. (The value of this flag needs to be set at the time you call <code>cmake</code> when installing deal.II.)</p>
<p>In addition, we also keep a solution vector with CPU storage such that we can view and display the solution as usual.</p>
<div class="fragment"><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::Host&gt;</a></div><div class="line">                                                                ghost_solution_host;</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a> solution_dev;</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a></div><div class="line">    system_rhs_dev;</div><div class="line"></div><div class="line">  <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout;</div><div class="line">};</div></div><!-- fragment --><p>The implementation of all the remaining functions of this class apart from <code>Helmholtzproblem::solve()</code> doesn't contain anything new and we won't further comment much on the overall approach.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">HelmholtzProblem&lt;dim, fe_degree&gt;::HelmholtzProblem()</div><div class="line">  : mpi_communicator(MPI_COMM_WORLD)</div><div class="line">  , triangulation(mpi_communicator)</div><div class="line">  , fe(fe_degree)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , pcout(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="namespaceUtilities.html">Utilities</a>::MPI::<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a>(mpi_communicator) == 0)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim, fe_degree&gt;::setup_system()</div><div class="line">{</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  locally_owned_dofs = dof_handler.<a class="code" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">locally_owned_dofs</a>();</div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs);</div><div class="line">  system_rhs_dev.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>();</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs);</div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints);</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                           constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">  system_matrix_dev.reset(</div><div class="line">    <span class="keyword">new</span> HelmholtzOperator&lt;dim, fe_degree&gt;(dof_handler, constraints));</div><div class="line"></div><div class="line">  ghost_solution_host.reinit(locally_owned_dofs,</div><div class="line">                             locally_relevant_dofs,</div><div class="line">                             mpi_communicator);</div><div class="line">  system_matrix_dev-&gt;initialize_dof_vector(solution_dev);</div><div class="line">  system_rhs_dev.reinit(solution_dev);</div><div class="line">}</div></div><!-- fragment --><p>Unlike programs such as <a class="el" href="step_4.html">step-4</a> or <a class="el" href="step_6.html">step-6</a>, we will not have to assemble the whole linear system but only the right hand side vector. This looks in essence like we did in <a class="el" href="step_4.html">step-4</a>, for example, but we have to pay attention to using the right constraints object when copying local contributions into the global vector. In particular, we need to make sure the entries that correspond to boundary nodes are properly zeroed out. This is necessary for CG to converge. (Another solution would be to modify the <code>vmult()</code> function above in such a way that we pretend the source vector has zero entries by just not taking them into account in matrix-vector products. But the approach used here is simpler.)</p>
<p>At the end of the function, we can't directly copy the values from the host to the device but need to use an intermediate object of type <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a> to construct the correct communication pattern necessary.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim, fe_degree&gt;::assemble_rhs()</div><div class="line">{</div><div class="line">  <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector&lt;double, MemorySpace::Host&gt;</a></div><div class="line">                    system_rhs_host(locally_owned_dofs,</div><div class="line">                    locally_relevant_dofs,</div><div class="line">                    mpi_communicator);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt; cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">      {</div><div class="line">        cell_rhs = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              cell_rhs(i) += (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_index) * 1.0 *</div><div class="line">                              fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_index));</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_rhs,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               system_rhs_host);</div><div class="line">      }</div><div class="line">  system_rhs_host.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line">  <a class="code" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector&lt;double&gt;</a> rw_vector(locally_owned_dofs);</div><div class="line">  rw_vector.import(system_rhs_host, <a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">  system_rhs_dev.import(rw_vector, <a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">}</div></div><!-- fragment --><p>This solve() function finally contains the calls to the new classes previously discussed. Here we don't use any preconditioner, i.e., precondition by the identity matrix, to focus just on the peculiarities of the <a class="el" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree</a> framework. Of course, in a real application the choice of a suitable preconditioner is crucial but we have at least the same restrictions as in <a class="el" href="step_37.html">step-37</a> since matrix entries are computed on the fly and not stored.</p>
<p>After solving the linear system in the first part of the function, we copy the solution from the device to the host to be able to view its values and display it in <code>output_results()</code>. This transfer works the same as at the end of the previous function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim, fe_degree&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a> preconditioner;</div><div class="line"></div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control(system_rhs_dev.size(),</div><div class="line">                               1e-12 * system_rhs_dev.l2_norm());</div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</a>&gt; cg(</div><div class="line">    solver_control);</div><div class="line">  cg.solve(*system_matrix_dev, solution_dev, system_rhs_dev, preconditioner);</div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;  Solved in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">        &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <a class="code" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector&lt;double&gt;</a> rw_vector(locally_owned_dofs);</div><div class="line">  rw_vector.import(solution_dev, <a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line">  ghost_solution_host.import(rw_vector, <a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(ghost_solution_host);</div><div class="line"></div><div class="line">  ghost_solution_host.update_ghost_values();</div><div class="line">}</div></div><!-- fragment --><p>The output results function is as usual since we have already copied the values back from the GPU to the CPU.</p>
<p>While we're already doing something with the function, we might as well compute the \(L_2\) norm of the solution. We do this by calling <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a>. That function is meant to compute the error by evaluating the difference between the numerical solution (given by a vector of values for the degrees of freedom) and an object representing the exact solution. But we can easily compute the \(L_2\) norm of the solution by passing in a zero function instead. That is, instead of evaluating the error \(\|u_h-u\|_{L_2(\Omega)}\), we are just evaluating \(\|u_h-0\|_{L_2(\Omega)}=\|u_h\|_{L_2(\Omega)}\) instead.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line"><span class="keywordtype">void</span> HelmholtzProblem&lt;dim, fe_degree&gt;::output_results(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(ghost_solution_host, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <a class="code" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> flags;</div><div class="line">  flags.<a class="code" href="structDataOutBase_1_1VtkFlags.html#a3be0d6de1c92b770e8664bce2fc7c107">compression_level</a> = <a class="code" href="structDataOutBase_1_1VtkFlags.html#a7ad65742b9dbfb7eeb04b511b5a08d63a3b747f53b680a2f1dd1c8e345a1e7261">DataOutBase::VtkFlags::best_speed</a>;</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a>(flags);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a>(</div><div class="line">    <span class="stringliteral">&quot;./&quot;</span>, <span class="stringliteral">&quot;solution&quot;</span>, cycle, mpi_communicator, 2);</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> cellwise_norm(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(dof_handler,</div><div class="line">                                    ghost_solution_host,</div><div class="line">                                    <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                    cellwise_norm,</div><div class="line">                                    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>(fe.degree + 2),</div><div class="line">                                    <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> global_norm =</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                      cellwise_norm,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">VectorTools::L2_norm</a>);</div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;  solution norm: &quot;</span> &lt;&lt; global_norm &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>There is nothing surprising in the <code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code> function either. We simply compute the solution on a series of (globally) refined meshes.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> fe_degree&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">HelmholtzProblem&lt;dim, fe_degree&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 7 - dim; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, 0., 1.);</div><div class="line">        triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(1);</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a584733c8499dbd140694bfe04e0963ca">n_global_active_cells</a>() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_rhs();</div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step64</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main()</code> function</h3>
<p>Finally for the <code>main()</code> function. By default, all the MPI ranks will try to access the device with number 0, which we assume to be the GPU device associated with the CPU on which a particular MPI rank runs. This works, but if we are running with MPI support it may be that multiple MPI processes are running on the same machine (for example, one per CPU core) and then they would all want to access the same GPU on that machine. If there is only one GPU in the machine, there is nothing we can do about it: All MPI ranks on that machine need to share it. But if there are more than one GPU, then it is better to address different graphic cards for different processes. The choice below is based on the MPI process id by assigning GPUs round robin to GPU ranks. (To work correctly, this scheme assumes that the MPI ranks on one machine are consecutive. If that were not the case, then the rank-GPU association may just not be optimal.) To make this work, MPI needs to be initialized before using this function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step64;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">      <span class="keywordtype">int</span>         n_devices       = 0;</div><div class="line">      cudaError_t cuda_error_code = cudaGetDeviceCount(&amp;n_devices);</div><div class="line">      <a class="code" href="group__Exceptions.html#gac1b7e8a4a8d5d910cd9fbd8814e9955e">AssertCuda</a>(cuda_error_code);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> my_mpi_id =</div><div class="line">        <a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(MPI_COMM_WORLD);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">int</span> device_id = my_mpi_id % n_devices;</div><div class="line">      cuda_error_code     = cudaSetDevice(device_id);</div><div class="line">      <a class="code" href="group__Exceptions.html#gac1b7e8a4a8d5d910cd9fbd8814e9955e">AssertCuda</a>(cuda_error_code);</div><div class="line"></div><div class="line">      HelmholtzProblem&lt;3, 3&gt; helmholtz_problem;</div><div class="line">      helmholtz_problem.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-64/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p> <a class="el" href="classCUDAWrappers_1_1MatrixFree.html">CUDAWrappers::MatrixFree</a> </p>
<div class="fragment"><div class="line">Cycle 0</div><div class="line">   Number of active cells:       8</div><div class="line">   Number of degrees of freedom: 343</div><div class="line">  Solved in 27 iterations.</div><div class="line">  solution <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 0.0205439</div><div class="line"></div><div class="line"></div><div class="line">Cycle 1</div><div class="line">   Number of active cells:       64</div><div class="line">   Number of degrees of freedom: 2197</div><div class="line">  Solved in 60 iterations.</div><div class="line">  solution <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 0.0205269</div><div class="line"></div><div class="line"></div><div class="line">Cycle 2</div><div class="line">   Number of active cells:       512</div><div class="line">   Number of degrees of freedom: 15625</div><div class="line">  Solved in 114 iterations.</div><div class="line">  solution <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 0.0205261</div><div class="line"></div><div class="line"></div><div class="line">Cycle 3</div><div class="line">   Number of active cells:       4096</div><div class="line">   Number of degrees of freedom: 117649</div><div class="line">  Solved in 227 iterations.</div><div class="line">  solution <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 0.0205261</div></div><!-- fragment --><p>CG \({\cal O}(h^{-2})\) </p>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p> 37</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line">/* ---------------------------------------------------------------------</div><div class="line"> *</div><div class="line"> * Copyright (C) 2019 - 2020 by the deal.II authors</div><div class="line"> *</div><div class="line"> * This file is part of the deal.II library.</div><div class="line"> *</div><div class="line"> * The deal.II library is free software; you can use it, redistribute</div><div class="line"> * it, and/or modify it under the terms of the GNU Lesser General</div><div class="line"> * Public License as published by the Free Software Foundation; either</div><div class="line"> * version 2.1 of the License, or (at your option) any later version.</div><div class="line"> * The full text of the license can be found in the file LICENSE.md at</div><div class="line"> * the top level directory of deal.II.</div><div class="line"> *</div><div class="line"> * ---------------------------------------------------------------------</div><div class="line"></div><div class="line"> *</div><div class="line"> * Authors: Bruno Turcksin, Daniel Arndt, Oak Ridge National Laboratory, 2019</div><div class="line"> */</div><div class="line"></div><div class="line">#include &lt;deal.II/base/conditional_ostream.h&gt;</div><div class="line">#include &lt;deal.II/base/quadrature_lib.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/dofs/dof_tools.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/fe/fe_q.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/grid/grid_generator.h&gt;</div><div class="line">#include &lt;deal.II/grid/tria.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/lac/affine_constraints.h&gt;</div><div class="line">#include &lt;deal.II/lac/la_parallel_vector.h&gt;</div><div class="line">#include &lt;deal.II/lac/precondition.h&gt;</div><div class="line">#include &lt;deal.II/lac/solver_cg.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/numerics/data_out.h&gt;</div><div class="line">#include &lt;deal.II/numerics/vector_tools.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/base/cuda.h&gt;</div><div class="line"></div><div class="line">#include &lt;deal.II/matrix_free/cuda_fe_evaluation.h&gt;</div><div class="line">#include &lt;deal.II/matrix_free/cuda_matrix_free.h&gt;</div><div class="line">#include &lt;deal.II/matrix_free/operators.h&gt;</div><div class="line"></div><div class="line">#include &lt;fstream&gt;</div><div class="line"></div><div class="line"></div><div class="line">namespace Step64</div><div class="line">{</div><div class="line">  using namespace dealii;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class VaryingCoefficientFunctor</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    VaryingCoefficientFunctor(double *coefficient)</div><div class="line">      : coef(coefficient)</div><div class="line">    {}</div><div class="line"></div><div class="line">    __device__ void operator()(</div><div class="line">      const unsigned int                                          cell,</div><div class="line">      const typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data *gpu_data);</div><div class="line"></div><div class="line">    static const unsigned int n_dofs_1d = fe_degree + 1;</div><div class="line">    static const unsigned int n_local_dofs =</div><div class="line">      ::Utilities::pow(n_dofs_1d, dim);</div><div class="line">    static const unsigned int n_q_points =</div><div class="line">      ::Utilities::pow(n_dofs_1d, dim);</div><div class="line"></div><div class="line">  private:</div><div class="line">    double *coef;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  __device__ void VaryingCoefficientFunctor&lt;dim, fe_degree&gt;::operator()(</div><div class="line">    const unsigned int                                          cell,</div><div class="line">    const typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data *gpu_data)</div><div class="line">  {</div><div class="line">    const unsigned int pos = CUDAWrappers::local_q_point_id&lt;dim, double&gt;(</div><div class="line">      cell, gpu_data, n_dofs_1d, n_q_points);</div><div class="line">    const Point&lt;dim&gt; q_point =</div><div class="line">      CUDAWrappers::get_quadrature_point&lt;dim, double&gt;(cell,</div><div class="line">                                                      gpu_data,</div><div class="line">                                                      n_dofs_1d);</div><div class="line"></div><div class="line">    double p_square = 0.;</div><div class="line">    for (unsigned int i = 0; i &lt; dim; ++i)</div><div class="line">      {</div><div class="line">        const double coord = q_point[i];</div><div class="line">        p_square += coord * coord;</div><div class="line">      }</div><div class="line">    coef[pos] = 10. / (0.05 + 2. * p_square);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class HelmholtzOperatorQuad</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    __device__ HelmholtzOperatorQuad(double coef)</div><div class="line">      : coef(coef)</div><div class="line">    {}</div><div class="line"></div><div class="line">    __device__ void</div><div class="line">    operator()(CUDAWrappers::FEEvaluation&lt;dim, fe_degree&gt; *fe_eval) const;</div><div class="line"></div><div class="line">  private:</div><div class="line">    double coef;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  __device__ void HelmholtzOperatorQuad&lt;dim, fe_degree&gt;::</div><div class="line">                  operator()(CUDAWrappers::FEEvaluation&lt;dim, fe_degree&gt; *fe_eval) const</div><div class="line">  {</div><div class="line">    fe_eval-&gt;submit_value(coef * fe_eval-&gt;get_value());</div><div class="line">    fe_eval-&gt;submit_gradient(fe_eval-&gt;get_gradient());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class LocalHelmholtzOperator</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    LocalHelmholtzOperator(double *coefficient)</div><div class="line">      : coef(coefficient)</div><div class="line">    {}</div><div class="line"></div><div class="line">    __device__ void operator()(</div><div class="line">      const unsigned int                                          cell,</div><div class="line">      const typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data *gpu_data,</div><div class="line">      CUDAWrappers::SharedData&lt;dim, double&gt; *                     shared_data,</div><div class="line">      const double *                                              src,</div><div class="line">      double *                                                    dst) const;</div><div class="line"></div><div class="line">    static const unsigned int n_dofs_1d    = fe_degree + 1;</div><div class="line">    static const unsigned int n_local_dofs = Utilities::pow(fe_degree + 1, dim);</div><div class="line">    static const unsigned int n_q_points   = Utilities::pow(fe_degree + 1, dim);</div><div class="line"></div><div class="line">  private:</div><div class="line">    double *coef;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  __device__ void LocalHelmholtzOperator&lt;dim, fe_degree&gt;::operator()(</div><div class="line">    const unsigned int                                          cell,</div><div class="line">    const typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::Data *gpu_data,</div><div class="line">    CUDAWrappers::SharedData&lt;dim, double&gt; *                     shared_data,</div><div class="line">    const double *                                              src,</div><div class="line">    double *                                                    dst) const</div><div class="line">  {</div><div class="line">    const unsigned int pos = CUDAWrappers::local_q_point_id&lt;dim, double&gt;(</div><div class="line">      cell, gpu_data, n_dofs_1d, n_q_points);</div><div class="line"></div><div class="line">    CUDAWrappers::FEEvaluation&lt;dim, fe_degree, fe_degree + 1, 1, double&gt;</div><div class="line">      fe_eval(cell, gpu_data, shared_data);</div><div class="line">    fe_eval.read_dof_values(src);</div><div class="line">    fe_eval.evaluate(true, true);</div><div class="line">    fe_eval.apply_for_each_quad_point(</div><div class="line">      HelmholtzOperatorQuad&lt;dim, fe_degree&gt;(coef[pos]));</div><div class="line">    fe_eval.integrate(true, true);</div><div class="line">    fe_eval.distribute_local_to_global(dst);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class HelmholtzOperator</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    HelmholtzOperator(const DoFHandler&lt;dim&gt; &amp;          dof_handler,</div><div class="line">                      const AffineConstraints&lt;double&gt; &amp;constraints);</div><div class="line"></div><div class="line">    void</div><div class="line">    vmult(LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;dst,</div><div class="line">          const LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</div><div class="line">            &amp;src) const;</div><div class="line"></div><div class="line">    void initialize_dof_vector(</div><div class="line">      LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;vec) const;</div><div class="line"></div><div class="line">  private:</div><div class="line">    CUDAWrappers::MatrixFree&lt;dim, double&gt;       mf_data;</div><div class="line">    LinearAlgebra::CUDAWrappers::Vector&lt;double&gt; coef;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  HelmholtzOperator&lt;dim, fe_degree&gt;::HelmholtzOperator(</div><div class="line">    const DoFHandler&lt;dim&gt; &amp;          dof_handler,</div><div class="line">    const AffineConstraints&lt;double&gt; &amp;constraints)</div><div class="line">  {</div><div class="line">    MappingQGeneric&lt;dim&gt; mapping(fe_degree);</div><div class="line">    typename CUDAWrappers::MatrixFree&lt;dim, double&gt;::AdditionalData</div><div class="line">      additional_data;</div><div class="line">    additional_data.mapping_update_flags = update_values | update_gradients |</div><div class="line">                                           update_JxW_values |</div><div class="line">                                           update_quadrature_points;</div><div class="line">    const QGauss&lt;1&gt; quad(fe_degree + 1);</div><div class="line">    mf_data.reinit(mapping, dof_handler, constraints, quad, additional_data);</div><div class="line"></div><div class="line"></div><div class="line">    const unsigned int n_owned_cells =</div><div class="line">      dynamic_cast&lt;const parallel::TriangulationBase&lt;dim&gt; *&gt;(</div><div class="line">        &amp;dof_handler.get_triangulation())</div><div class="line">        -&gt;n_locally_owned_active_cells();</div><div class="line">    coef.reinit(Utilities::pow(fe_degree + 1, dim) * n_owned_cells);</div><div class="line"></div><div class="line">    const VaryingCoefficientFunctor&lt;dim, fe_degree&gt; functor(coef.get_values());</div><div class="line">    mf_data.evaluate_coefficients(functor);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzOperator&lt;dim, fe_degree&gt;::vmult(</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;      dst,</div><div class="line">    const LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;src)</div><div class="line">    const</div><div class="line">  {</div><div class="line">    dst = 0.;</div><div class="line">    LocalHelmholtzOperator&lt;dim, fe_degree&gt; helmholtz_operator(</div><div class="line">      coef.get_values());</div><div class="line">    mf_data.cell_loop(helmholtz_operator, src, dst);</div><div class="line">    mf_data.copy_constrained_values(src, dst);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzOperator&lt;dim, fe_degree&gt;::initialize_dof_vector(</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; &amp;vec) const</div><div class="line">  {</div><div class="line">    mf_data.initialize_dof_vector(vec);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  class HelmholtzProblem</div><div class="line">  {</div><div class="line">  public:</div><div class="line">    HelmholtzProblem();</div><div class="line"></div><div class="line">    void run();</div><div class="line"></div><div class="line">  private:</div><div class="line">    void setup_system();</div><div class="line"></div><div class="line">    void assemble_rhs();</div><div class="line"></div><div class="line">    void solve();</div><div class="line"></div><div class="line">    void output_results(const unsigned int cycle) const;</div><div class="line"></div><div class="line">    MPI_Comm mpi_communicator;</div><div class="line"></div><div class="line">    parallel::distributed::Triangulation&lt;dim&gt; triangulation;</div><div class="line"></div><div class="line">    FE_Q&lt;dim&gt;       fe;</div><div class="line">    DoFHandler&lt;dim&gt; dof_handler;</div><div class="line"></div><div class="line">    IndexSet locally_owned_dofs;</div><div class="line">    IndexSet locally_relevant_dofs;</div><div class="line"></div><div class="line">    AffineConstraints&lt;double&gt;                          constraints;</div><div class="line">    std::unique_ptr&lt;HelmholtzOperator&lt;dim, fe_degree&gt;&gt; system_matrix_dev;</div><div class="line"></div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::Host&gt;</div><div class="line">                                                                  ghost_solution_host;</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt; solution_dev;</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;</div><div class="line">      system_rhs_dev;</div><div class="line"></div><div class="line">    ConditionalOStream pcout;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  HelmholtzProblem&lt;dim, fe_degree&gt;::HelmholtzProblem()</div><div class="line">    : mpi_communicator(MPI_COMM_WORLD)</div><div class="line">    , triangulation(mpi_communicator)</div><div class="line">    , fe(fe_degree)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , pcout(std::cout, Utilities::MPI::this_mpi_process(mpi_communicator) == 0)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">    locally_owned_dofs = dof_handler.locally_owned_dofs();</div><div class="line">    DoFTools::extract_locally_relevant_dofs(dof_handler, locally_relevant_dofs);</div><div class="line">    system_rhs_dev.reinit(locally_owned_dofs, mpi_communicator);</div><div class="line"></div><div class="line">    constraints.clear();</div><div class="line">    constraints.reinit(locally_relevant_dofs);</div><div class="line">    DoFTools::make_hanging_node_constraints(dof_handler, constraints);</div><div class="line">    VectorTools::interpolate_boundary_values(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             Functions::ZeroFunction&lt;dim&gt;(),</div><div class="line">                                             constraints);</div><div class="line">    constraints.close();</div><div class="line"></div><div class="line">    system_matrix_dev.reset(</div><div class="line">      new HelmholtzOperator&lt;dim, fe_degree&gt;(dof_handler, constraints));</div><div class="line"></div><div class="line">    ghost_solution_host.reinit(locally_owned_dofs,</div><div class="line">                               locally_relevant_dofs,</div><div class="line">                               mpi_communicator);</div><div class="line">    system_matrix_dev-&gt;initialize_dof_vector(solution_dev);</div><div class="line">    system_rhs_dev.reinit(solution_dev);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::assemble_rhs()</div><div class="line">  {</div><div class="line">    LinearAlgebra::distributed::Vector&lt;double, MemorySpace::Host&gt;</div><div class="line">                      system_rhs_host(locally_owned_dofs,</div><div class="line">                      locally_relevant_dofs,</div><div class="line">                      mpi_communicator);</div><div class="line">    const QGauss&lt;dim&gt; quadrature_formula(fe_degree + 1);</div><div class="line"></div><div class="line">    FEValues&lt;dim&gt; fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            update_values | update_quadrature_points |</div><div class="line">                              update_JxW_values);</div><div class="line"></div><div class="line">    const unsigned int dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    const unsigned int n_q_points    = quadrature_formula.size();</div><div class="line"></div><div class="line">    Vector&lt;double&gt; cell_rhs(dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    for (const auto &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">      if (cell-&gt;is_locally_owned())</div><div class="line">        {</div><div class="line">          cell_rhs = 0;</div><div class="line"></div><div class="line">          fe_values.reinit(cell);</div><div class="line"></div><div class="line">          for (unsigned int q_index = 0; q_index &lt; n_q_points; ++q_index)</div><div class="line">            {</div><div class="line">              for (unsigned int i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                cell_rhs(i) += (fe_values.shape_value(i, q_index) * 1.0 *</div><div class="line">                                fe_values.JxW(q_index));</div><div class="line">            }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          constraints.distribute_local_to_global(cell_rhs,</div><div class="line">                                                 local_dof_indices,</div><div class="line">                                                 system_rhs_host);</div><div class="line">        }</div><div class="line">    system_rhs_host.compress(VectorOperation::add);</div><div class="line"></div><div class="line">    LinearAlgebra::ReadWriteVector&lt;double&gt; rw_vector(locally_owned_dofs);</div><div class="line">    rw_vector.import(system_rhs_host, VectorOperation::insert);</div><div class="line">    system_rhs_dev.import(rw_vector, VectorOperation::insert);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::solve()</div><div class="line">  {</div><div class="line">    PreconditionIdentity preconditioner;</div><div class="line"></div><div class="line">    SolverControl solver_control(system_rhs_dev.size(),</div><div class="line">                                 1e-12 * system_rhs_dev.l2_norm());</div><div class="line">    SolverCG&lt;LinearAlgebra::distributed::Vector&lt;double, MemorySpace::CUDA&gt;&gt; cg(</div><div class="line">      solver_control);</div><div class="line">    cg.solve(*system_matrix_dev, solution_dev, system_rhs_dev, preconditioner);</div><div class="line"></div><div class="line">    pcout &lt;&lt; &quot;  Solved in &quot; &lt;&lt; solver_control.last_step() &lt;&lt; &quot; iterations.&quot;</div><div class="line">          &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    LinearAlgebra::ReadWriteVector&lt;double&gt; rw_vector(locally_owned_dofs);</div><div class="line">    rw_vector.import(solution_dev, VectorOperation::insert);</div><div class="line">    ghost_solution_host.import(rw_vector, VectorOperation::insert);</div><div class="line"></div><div class="line">    constraints.distribute(ghost_solution_host);</div><div class="line"></div><div class="line">    ghost_solution_host.update_ghost_values();</div><div class="line">  }</div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::output_results(</div><div class="line">    const unsigned int cycle) const</div><div class="line">  {</div><div class="line">    DataOut&lt;dim&gt; data_out;</div><div class="line"></div><div class="line">    data_out.attach_dof_handler(dof_handler);</div><div class="line">    data_out.add_data_vector(ghost_solution_host, &quot;solution&quot;);</div><div class="line">    data_out.build_patches();</div><div class="line"></div><div class="line">    DataOutBase::VtkFlags flags;</div><div class="line">    flags.compression_level = DataOutBase::VtkFlags::best_speed;</div><div class="line">    data_out.set_flags(flags);</div><div class="line">    data_out.write_vtu_with_pvtu_record(</div><div class="line">      &quot;./&quot;, &quot;solution&quot;, cycle, mpi_communicator, 2);</div><div class="line"></div><div class="line">    Vector&lt;float&gt; cellwise_norm(triangulation.n_active_cells());</div><div class="line">    VectorTools::integrate_difference(dof_handler,</div><div class="line">                                      ghost_solution_host,</div><div class="line">                                      Functions::ZeroFunction&lt;dim&gt;(),</div><div class="line">                                      cellwise_norm,</div><div class="line">                                      QGauss&lt;dim&gt;(fe.degree + 2),</div><div class="line">                                      VectorTools::L2_norm);</div><div class="line">    const double global_norm =</div><div class="line">      VectorTools::compute_global_error(triangulation,</div><div class="line">                                        cellwise_norm,</div><div class="line">                                        VectorTools::L2_norm);</div><div class="line">    pcout &lt;&lt; &quot;  solution norm: &quot; &lt;&lt; global_norm &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  template &lt;int dim, int fe_degree&gt;</div><div class="line">  void HelmholtzProblem&lt;dim, fe_degree&gt;::run()</div><div class="line">  {</div><div class="line">    for (unsigned int cycle = 0; cycle &lt; 7 - dim; ++cycle)</div><div class="line">      {</div><div class="line">        pcout &lt;&lt; &quot;Cycle &quot; &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        if (cycle == 0)</div><div class="line">          GridGenerator::hyper_cube(triangulation, 0., 1.);</div><div class="line">        triangulation.refine_global(1);</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        pcout &lt;&lt; &quot;   Number of active cells:       &quot;</div><div class="line">              &lt;&lt; triangulation.n_global_active_cells() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; &quot;   Number of degrees of freedom: &quot; &lt;&lt; dof_handler.n_dofs()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_rhs();</div><div class="line">        solve();</div><div class="line">        output_results(cycle);</div><div class="line">        pcout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} // namespace Step64</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">{</div><div class="line">  try</div><div class="line">    {</div><div class="line">      using namespace Step64;</div><div class="line"></div><div class="line">      Utilities::MPI::MPI_InitFinalize mpi_init(argc, argv, 1);</div><div class="line"></div><div class="line">      int         n_devices       = 0;</div><div class="line">      cudaError_t cuda_error_code = cudaGetDeviceCount(&amp;n_devices);</div><div class="line">      AssertCuda(cuda_error_code);</div><div class="line">      const unsigned int my_mpi_id =</div><div class="line">        Utilities::MPI::this_mpi_process(MPI_COMM_WORLD);</div><div class="line">      const int device_id = my_mpi_id % n_devices;</div><div class="line">      cuda_error_code     = cudaSetDevice(device_id);</div><div class="line">      AssertCuda(cuda_error_code);</div><div class="line"></div><div class="line">      HelmholtzProblem&lt;3, 3&gt; helmholtz_problem;</div><div class="line">      helmholtz_problem.run();</div><div class="line">    }</div><div class="line">  catch (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;----------------------------------------------------&quot;</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; &quot;Exception on processing: &quot; &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;Aborting!&quot; &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;----------------------------------------------------&quot;</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      return 1;</div><div class="line">    }</div><div class="line">  catch (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;----------------------------------------------------&quot;</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; &quot;Unknown exception!&quot; &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;Aborting!&quot; &lt;&lt; std::endl</div><div class="line">                &lt;&lt; &quot;----------------------------------------------------&quot;</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      return 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  return 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
