<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/include_2deal_8II-translator_2A-tutorial_2step-72_8h_source.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: include/deal.II-translator/A-tutorial/step-72.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_386d89ad50a3909c2af5a93b48d2c3ff.html">deal.II-translator</a></li><li class="navelem"><a class="el" href="dir_7812fe2bbb6fb6db2d3962cae8700ca0.html">A-tutorial</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">step-72.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="include_2deal_8II-translator_2A-tutorial_2step-72_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; ) <span class="keyword">const</span></div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;   {</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;     <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a> (p[0] + p[1]));</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;   }</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;* </div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160; </div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;* </div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;*   &lt;a name=<span class="stringliteral">&quot;ThecodeMinimalSurfaceProblemcodeclassimplementation&quot;</span>&gt;&lt;/a&gt;  &lt;h3&gt;The &lt;code&gt;MinimalSurfaceProblem&lt;/code&gt; <span class="keyword">class </span>implementation&lt;/h3&gt;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;* </div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;* </div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;*   &lt;a name=<span class="stringliteral">&quot;MinimalSurfaceProblemMinimalSurfaceProblem&quot;</span>&gt;&lt;/a&gt;  &lt;h4&gt;MinimalSurfaceProblem::MinimalSurfaceProblem&lt;/h4&gt;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;* </div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;* </div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;*  There have been no changes made to the <span class="keyword">class </span>constructor.</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;* </div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;* </div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;* @code</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;   MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;     : dof_handler(<a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>)</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;     , fe(2)</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;     , quadrature_formula(fe.degree + 1)</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;   {}</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;* </div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160; </div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;* </div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;*   &lt;a name=<span class="stringliteral">&quot;MinimalSurfaceProblemsetup_system&quot;</span>&gt;&lt;/a&gt;  &lt;h4&gt;MinimalSurfaceProblem::setup_system&lt;/h4&gt;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;* </div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;* </div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;*  There have been no changes made to the <span class="keyword">function</span> that sets up the <span class="keyword">class </span>data structures, namely the <a class="code" href="classDoFHandler.html">DoFHandler</a>, the hanging node constraints applied to the problem, and the linear system.</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;* </div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;* </div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;* @code</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;   <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;   {</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;     <span class="keywordflow">if</span> (initial_step)</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;       {</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;         dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;         current_solution.reinit(dof_handler.n_dofs());</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;* </div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;         hanging_node_constraints.clear();</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;         <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;                                                 hanging_node_constraints);</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;         hanging_node_constraints.close();</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;       }</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;* </div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;     newton_update.reinit(dof_handler.n_dofs());</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;     system_rhs.reinit(dof_handler.n_dofs());</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;* </div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;     <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;     <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;* </div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;     hanging_node_constraints.condense(dsp);</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;* </div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;     sparsity_pattern.copy_from(dsp);</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;     system_matrix.reinit(sparsity_pattern);</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;   }</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;* </div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;* </div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;*   &lt;a name=<span class="stringliteral">&quot;Assemblingthelinearsystem&quot;</span>&gt;&lt;/a&gt;  &lt;h4&gt;Assembling the linear system&lt;/h4&gt;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;* </div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;* </div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;*   &lt;a name=<span class="stringliteral">&quot;Manualassembly&quot;</span>&gt;&lt;/a&gt;  &lt;h5&gt;Manual assembly&lt;/h5&gt;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;* </div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;* </div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;*  The assembly <a class="code" href="namespaceinternal_1_1p4est.html#a4b980c7b4b4d9984e93d73c7d30173ea">functions</a> are the interesting contributions to <span class="keyword">this</span> tutorial. The assemble_system_unassisted() method implements exactly the same assembly function as is detailed in   @ref step_15 &quot;step-15&quot;  , but in this instance we use the   <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::<a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop</a>()   function to multithread the assembly process. The reason for doing this is quite simple: When using automatic differentiation, we know that there is to be some additional computational overhead incurred. In order to mitigate this performance loss, we&#39;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> like to take advantage of as many (easily available) computational resources as possible. The   <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::<a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop</a>()   concept makes this a relatively straightforward task. At the same time, for the purposes of fair comparison, we need to do the same to the implementation that uses no assistance when computing the residual or its linearization. (The   <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::<a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop</a>()   function is <a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a> discussed in   @ref step_12 &quot;step-12&quot;   and   @ref step_16 &quot;step-16&quot;  , if you&#39;<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a> like to read up on it.)   </div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;*   The steps required to implement the multithreading are the same between the three <a class="code" href="namespaceinternal_1_1p4est.html#a4b980c7b4b4d9984e93d73c7d30173ea">functions</a>, so we&#39;ll use the assemble_system_unassisted() function as an opportunity to focus on the multithreading itself.</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;* </div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;* </div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;* @code</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;   template &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;   <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_unassisted()</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;   {</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;     system_matrix = 0;</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;     system_rhs    = 0;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;* </div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;* </div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;* </div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;*  The   <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>()   expects that we provide two exemplar data structures. The <a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a>, `ScratchData`, is to store all large data that is to be reused between threads. The `CopyData` will hold the contributions to the linear system that come from each cell. These independent <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>-vector pairs must be accumulated into the global linear system sequentially. Since we don&#39;t need anything on top of what the   <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::ScratchData   and   <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::CopyData   classes already provide, we use these exact class definitions for our problem. Note that we only require a single instance of a local <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, local right-hand side vector, and cell degree of freedom index vector</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;* </div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;*  -  the   <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::CopyData   therefore has `1` for all three of its template arguments.</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;* </div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;* </div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;* @code</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;     using ScratchData = <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::ScratchData&lt;dim&gt;;</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;     using CopyData    = <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::CopyData&lt;1, 1, 1&gt;;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;* </div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160; @endcode</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;* </div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;*  We also need to know what type of iterator we&#39;ll be working with during assembly. For simplicity, we just ask the compiler to work this out for us using the decltype() specifier, knowing that we&#39;ll be iterating over active cells owned by the   @p dof_handler.  </div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;* </div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;* </div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;* @code</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;     using CellIteratorType = decltype(dof_handler.begin_active());</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;* </div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160; @endcode</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;* </div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;*  Here we initialize the exemplar data structures. Since we know that we need to compute the shape function <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>, weighted Jacobian, and the position of the quadrate points in real space, we pass these flags into the class constructor.</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;* </div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;* </div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;* @code</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;     const ScratchData sample_scratch_data(fe,</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;                                           quadrature_formula,</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;     const CopyData    sample_copy_data(dofs_per_cell);</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;* </div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160; @endcode</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;* </div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;*  Now we define a lambda function that will perform the assembly on a single cell. The three arguments are those that will be expected by   <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::<a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop</a>(),   due to the arguments that we&#39;ll pass to that final <a class="code" href="namespaceThreads_1_1internal.html#a8d237a30d09b13e0b5adbe0fd1dfb188">call</a>. We also capture the   @p this   pointer, which means that we&#39;ll have access to &quot;this&quot; (i.<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>., the current `MinimalSurfaceProblem&lt;dim&gt;`) class instance, and its private member data (since the lambda function is defined within a MinimalSurfaceProblem&lt;dim&gt; method).     </div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;*   At the top of the function, we initialize the data structures that are dependent on the cell for which the work is being performed. Observe that the reinitialization <a class="code" href="namespaceThreads_1_1internal.html#a8d237a30d09b13e0b5adbe0fd1dfb188">call</a> actually returns an instance to an <a class="code" href="classFEValues.html">FEValues</a> <span class="keywordtype">object</span> that is initialized and stored within (and, therefore, reused by) the `scratch_data` <span class="keywordtype">object</span>.     </div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;*   Similarly, we get aliases to the local matrix, local RHS vector, and local cell DoF indices from the `copy_data` instance that   <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::mesh_loop()   provides. We then initialize the cell DoF indices, knowing that the local matrix and vector are already correctly sized.</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;* </div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;* </div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;* @code</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;     const auto cell_worker = [this](const CellIteratorType &amp;cell,</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;                                     ScratchData &amp;           scratch_data,</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;                                     CopyData &amp;              copy_data) {</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;       <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.reinit(cell);</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;* </div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;       <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> = copy_data.matrices[0];</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;       <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;       std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;         copy_data.local_dof_indices[0];</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;       cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;* </div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;* </div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;*  For Newton<span class="stringliteral">&#39;s method, we require the gradient of the solution at the point about which the problem is being linearized.       </span></div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;<span class="stringliteral">*   Once we have that, we can perform assembly for this cell in the usual way.  One minor difference to   @ref step_15 &quot;step-15&quot;   is that we&#39;</span>ve used the (rather convenient) range-based loops to iterate over all quadrature points and degrees-of-freedom.</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;* </div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;* </div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;* @code</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;       std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_solution_gradients(</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;         fe_values.n_quadrature_points);</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;       fe_values.get_function_gradients(current_solution,</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;                                        old_solution_gradients);</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;* </div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;       <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.quadrature_point_indices())</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;         {</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;           <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;             1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q]</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;                                     old_solution_gradients[q]);</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;* </div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;           <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.dof_indices())</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;             {</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;               <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.dof_indices())</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;                 <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;                   (((fe_values.shape_grad(i, q)      <span class="comment">// ((\nabla \phi_i</span></div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;                      coeff                         <span class="comment">//   a_n</span></div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;                      fe_values.shape_grad(j, q))   <span class="comment">//   \nabla \phi_j)</span></div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;* </div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;* </div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;* </div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;* </div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;* </div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;* </div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;* </div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;* </div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;* </div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;* </div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;* </div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;* </div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;* </div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;* </div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;* </div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;* </div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;* </div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;* </div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;* </div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;</div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;* </div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;* </div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;* </div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;* </div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;* </div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;* </div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;* </div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;* </div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;* </div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;* </div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;* </div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;* </div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;* </div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;* </div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;* </div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;* </div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;* </div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;* </div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;* </div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;* </div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;* </div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;* </div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;* </div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;* </div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;-                                <span class="comment">//</span></div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;* </div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;* </div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;* </div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;-</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;                     (fe_values.shape_grad(i, q)      <span class="comment">//  (\nabla \phi_i</span></div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;                      coeff coeff coeff         <span class="comment">//   a_n^3</span></div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;                      (fe_values.shape_grad(j, q)   <span class="comment">//   (\nabla \phi_j</span></div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;                         old_solution_gradients[q]) <span class="comment">//      \nabla u_n)</span></div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;                      old_solution_gradients[q]))   <span class="comment">//   \nabla u_n)))</span></div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;                    fe_values.JxW(q));              <span class="comment">// dx</span></div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;* </div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;               cell_rhs(i)</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;* </div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;-= (fe_values.shape_grad(i, q)  <span class="comment">// \nabla \phi_i</span></div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;                               coeff                     <span class="comment">// a_n</span></div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;                               old_solution_gradients[q] <span class="comment">// u_n</span></div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;                               fe_values.JxW(q));        <span class="comment">// dx</span></div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;             }</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;         }</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;     };</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;* </div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;* </div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;*  The <a class="code" href="grid__out_8cc.html#a2cc229a4f1ffc75e83ed269d5f725729">second</a> <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba945f3fc449518a73b9f5f32868db466c">lambda</a> <span class="keyword">function</span> that   <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>()   requires is <a class="code" href="namespaceLAPACKSupport.html#aceda56512460bbad2f9fdb8a3d0e1e51">one</a> that performs the task of accumulating the local contributions in the global linear system. That is precisely what this <a class="code" href="namespaceLAPACKSupport.html#aceda56512460bbad2f9fdb8a3d0e1e51">one</a> does, and the details of the implementation have been seen before. The primary <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> to recognize is that the local contributions are stored in the `copy_data` instance that is passed into this function. This `copy_data` has been filled with data during   @a   some <a class="code" href="namespaceThreads_1_1internal.html#a8d237a30d09b13e0b5adbe0fd1dfb188">call</a> to the `cell_worker`.</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;* </div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;* </div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;* @code</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;     const auto copier = [dofs_per_cell, this](const CopyData &amp;copy_data) {</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;       <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0];</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;       <span class="keyword">const</span> <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;    cell_rhs    = copy_data.vectors[0];</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;       <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;         copy_data.local_dof_indices[0];</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;* </div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;         {</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;             system_matrix.add(local_dof_indices[i],</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;                               local_dof_indices[j],</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;                               cell_matrix(i, j));</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;* </div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;           system_rhs(local_dof_indices[i]) += cell_rhs(i);</div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;         }</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;     };</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;* </div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;* </div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;*  We have all of the required functions definitions in place, so now we <a class="code" href="namespaceThreads_1_1internal.html#a8d237a30d09b13e0b5adbe0fd1dfb188">call</a> the   <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>()   to perform the actual assembly.  We pass a flag as the last parameter which states that we only want to perform the assembly on the cells. Internally,   <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::mesh_loop()   then distributes the available work to different threads, making efficient use of the multiple cores almost all of today&#39;s processors have to offer.</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;* </div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;</div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;* </div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;* @code</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;     <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::mesh_loop(dof_handler.active_cell_iterators(),</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;                           cell_worker,</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;                           copier,</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;                           sample_scratch_data,</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;                           sample_copy_data,</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;                           <a class="code" href="namespaceMeshWorker.html">MeshWorker</a>::<a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">assemble_own_cells</a>);</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;* </div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160; @endcode</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;* </div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;*  And finally, as is done in   @ref step_15 &quot;step-15&quot;  , we remove hanging nodes from the system and <a class="code" href="namespacestd__cxx17.html#aa2fc1031c06af4aea4de90c5a1905473">apply</a> <a class="code" href="namespaceLAPACKSupport.html#a0d8802698d585eec62a2a54e6387b05b">zero</a> boundary <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a> to the linear system that defines the Newton updates   @f$\delta u^n@f$  .</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;* </div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;* </div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;* @code</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;     hanging_node_constraints.condense(system_matrix);</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;     hanging_node_constraints.condense(system_rhs);</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;* </div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;     <a class="code" href="namespacestd.html">std</a>::map&lt;<a class="code" href="namespacetypes.html">types</a>::<a class="code" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">global_dof_index</a>, <span class="keywordtype">double</span>&gt; boundary_values;</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;     <a class="code" href="namespaceVectorTools.html">VectorTools</a>::<a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">interpolate_boundary_values</a>(dof_handler,</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;                                              0,</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;                                              <a class="code" href="namespaceFunctions.html">Functions</a>::<a class="code" href="classFunctions_1_1ZeroFunction.html">ZeroFunction</a>&lt;dim&gt;(),</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;                                              boundary_values);</div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;     <a class="code" href="namespaceMatrixTools.html">MatrixTools</a>::<a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">apply_boundary_values</a>(boundary_values,</div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;                                        system_matrix,</div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;                                        newton_update,</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;                                        system_rhs);</div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;   }</div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;* </div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160; @endcode</div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;* </div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;*   &lt;a name=&quot;Assemblyviadifferentiationoftheresidualvector&quot;&gt;&lt;/a&gt;  &lt;h5&gt;Assembly via differentiation of the residual vector&lt;/h5&gt;</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;* </div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;* </div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;*  As outlined in the introduction, what we need to do for this <a class="code" href="grid__out_8cc.html#a2cc229a4f1ffc75e83ed269d5f725729">second</a> approach is implement the local contributions   @f$F(<a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a>)^K@f$   from cell   @f$K@f$   to the residual vector, and then let the AD machinery deal with how to compute the derivatives   @f$J(<a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a>)_{ij}^K=\frac{\partial <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>(<a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a>)^K_i}{\partial U_j}@f$   from it.   </div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;*   For the following, recall that @f[</div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>(<a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a>)_i^K \dealcoloneq</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160; \int\limits_K\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+|\nabla</div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160; u|^{2}}} \nabla u \right] \, dV ,</div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160; @f] where   @f$u(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)@f$  .   </div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;*   Let us see how <span class="keyword">this</span> is implemented in practice:</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;* </div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;* </div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;* @code</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;   <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_with_residual_linearization()</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;   {</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;     system_matrix = 0;</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;     system_rhs    = 0;</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;* </div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;* </div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;     <span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>;</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;     <span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;     <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.begin_active());</div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;* </div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;     <span class="keyword">const</span> ScratchData sample_scratch_data(fe,</div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;                                           quadrature_formula,</div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;                                           <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;                                             <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;                                             update_JxW_values);</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;     <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell);</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;* </div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;* </div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;*  We<span class="stringliteral">&#39;ll define up front the AD data structures that we&#39;</span>ll be <span class="keyword">using</span>, utilizing the techniques shown in   @ref step_71 <span class="stringliteral">&quot;step-71&quot;</span>  . In <span class="keyword">this</span> <span class="keywordflow">case</span>, we choose the helper <span class="keyword">class </span>that will automatically compute the linearization of the finite element residual using Sacado forward automatic differentiation <a class="code" href="namespacetypes.html">types</a>. These number <a class="code" href="namespacetypes.html">types</a> can be used to compute first derivatives only. This is exactly what we want, because we know that we&#39;ll only be linearizing the residual, which means that we only need to compute first-order derivatives. The return <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a> from the calculations are to be of type `<a class="code" href="classdouble.html">double</a>`.     </div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;*   We also need an extractor to retrieve some data related to the field solution to the problem.</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;* </div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;* </div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;* @code</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;     <span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1ResidualLinearization.html">Differentiation::AD::ResidualLinearization</a>&lt;</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;       <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca3616da751c767b07051278ed7d81c0dc">Differentiation::AD::NumberTypes::sacado_dfad</a>,</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;       <span class="keywordtype">double</span>&gt;;</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;     <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;* </div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;     <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0);</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;* </div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;* </div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;*  With <span class="keyword">this</span>, let us define the <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba945f3fc449518a73b9f5f32868db466c">lambda</a> <span class="keyword">function</span> that will be used to compute the cell contributions to the Jacobian matrix and the right hand side:</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;* </div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;* </div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;* @code</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;     <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;                                            ScratchData &amp;           scratch_data,</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;                                            CopyData &amp;              copy_data) {</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;       <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       fe_values     = scratch_data.reinit(cell);</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.get_fe().n_dofs_per_cell();</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;* </div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;       <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;       <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;       std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;         copy_data.local_dof_indices[0];</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;       cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;* </div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;* </div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;*  We<span class="stringliteral">&#39;ll now create and initialize an instance of the AD helper class. To do this, we need to specify how many independent variables and dependent variables there are. The independent variables will be the number of local degrees of freedom that our solution vector has, i.e., the number   @f$j@f$   in the per-element representation of the discretized solution vector   @f$u (\mathbf{x})|_K = \sum\limits_{j} U^K_i \varphi_j(\mathbf{x})@f$   that indicates how many solution coefficients are associated with each finite element. In deal.II, this equals   FiniteElement::dofs_per_cell.   The number of dependent variables will be the number of entries in the local residual vector that we will be forming. In this particular problem (like many others that employ the [standard Galerkin method](https://en.wikipedia.org/wiki/Galerkin_method)) the number of local solution coefficients matches the number of local residual equations.</span></div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;<span class="stringliteral">       const unsigned int n_independent_variables = local_dof_indices.size();</span></div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;<span class="stringliteral">       const unsigned int n_dependent_variables   = dofs_per_cell;</span></div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;<span class="stringliteral">       ADHelper ad_helper(n_independent_variables, n_dependent_variables);</span></div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;<span class="stringliteral">*  Next we inform the helper of the values of the solution, i.e., the actual values for   @f$U_j@f$   about which we wish to linearize. As this is done on each element individually, we have to extract the solution coefficients from the global solution vector. In other words, we define all of those coefficients   @f$U_j@f$   where   @f$j@f$   is a local degree of freedom as the independent variables that enter the computation of the vector   @f$F(U)^{K}@f$   (the dependent function).       </span></div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;<span class="stringliteral">*   Then we get the complete set of degree of freedom values as represented by auto-differentiable numbers. The operations performed with these variables are tracked by the AD library from this point until the object goes out of scope. So it is   &lt;em&gt;  precisely these variables  &lt;/em&gt;   with respect to which we will compute derivatives of the residual entries.</span></div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;<span class="stringliteral">       ad_helper.register_dof_values(current_solution, local_dof_indices);</span></div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;<span class="stringliteral">       const std::vector&lt;ADNumberType&gt; &amp;dof_values_ad =</span></div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;<span class="stringliteral">         ad_helper.get_sensitive_dof_values();</span></div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;<span class="stringliteral">*  Then we do some problem specific tasks, the first being to compute all values, (spatial) gradients, and the like based on &quot;sensitive&quot; AD degree of freedom values. In this instance we are retrieving the solution gradients at each quadrature point. Observe that the solution gradients are now sensitive to the values of the degrees of freedom as they use the   @p ADNumberType   as the scalar type and the   @p dof_values_ad   vector provides the local DoF values.</span></div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;<span class="stringliteral">       std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients(</span></div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;<span class="stringliteral">         fe_values.n_quadrature_points);</span></div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;<span class="stringliteral">       fe_values[u_fe].get_function_gradients_from_local_dof_values(</span></div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;<span class="stringliteral">         dof_values_ad, old_solution_gradients);</span></div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;<span class="stringliteral">*  The next variable that we declare will store the cell residual vector contributions. This is rather self-explanatory, save for one &lt;b&gt;very important&lt;/b&gt; detail: Note that each entry in the vector is hand-initialized with a value of zero. This is a   &lt;em&gt;  highly recommended  &lt;/em&gt;   practice, as some AD libraries appear not to safely initialize the internal data structures of these number types. Not doing so could lead to some very hard to understand or detect bugs (appreciate that the author of this program mentions this out of, generally bad, experience). So out of an abundance of caution it&#39;</span>s worthwhile zeroing the <a class="code" href="namespaceAlgorithms_1_1Events.html#a15a12dfdadd39a026d192ad96cb6207b">initial</a> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a> explicitly. After that, apart from a <a class="code" href="namespaceDifferentiation_1_1SD.html#aa55d50a1ffa79c27f9bd9ea104f15158">sign</a> change the residual assembly looks much the same as we saw <span class="keywordflow">for</span> the cell RHS vector before: We <a class="code" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop</a> over all quadrature points, ensure that the coefficient now encodes its dependence on the (sensitive) finite element DoF <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a> by <span class="keyword">using</span> the correct `ADNumberType`, and <span class="keywordflow">finally</span> we <a class="code" href="namespaceinternal.html#a2b3d48efdf7c94da455dc6a3553bab79">assemble</a> the components of the residual vector. For complete clarity, the finite element shape <a class="code" href="namespaceinternal_1_1p4est.html#a4b980c7b4b4d9984e93d73c7d30173ea">functions</a> (and their gradients, etc.) as well as the &quot;JxW&quot; <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a> remain scalar valued, but the   @p coeff   and the    @p old_solution_gradients   at each quadrature <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> are computed in terms of the independent variables.</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;* </div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;* </div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;* @code</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;       <a class="code" href="namespacestd.html">std</a>::vector&lt;ADNumberType&gt; residual_ad(n_dependent_variables,</div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;                                             ADNumberType(0.0));</div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;       for (const <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.quadrature_point_indices())</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;         {</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;           <span class="keyword">const</span> ADNumberType coeff =</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;             1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q]</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;                                     old_solution_gradients[q]);</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;* </div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;           <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.dof_indices())</div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;             {</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;               residual_ad[i] += (fe_values.shape_grad(i, q)   <span class="comment">// \nabla \phi_i</span></div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;                                  coeff                      <span class="comment">// a_n</span></div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;                                  old_solution_gradients[q]) <span class="comment">// u_n</span></div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;                                 fe_values.JxW(q);           <span class="comment">// dx</span></div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;             }</div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;         }</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;* </div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;* </div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;*  Once we have the full cell residual vector computed, we can <span class="keyword">register</span> it with the helper <span class="keyword">class</span>.       </div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;*   Thereafter, we compute the residual <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a> (basically, extracting the real <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a> from what we already computed) and their Jacobian (the linearization of each residual component with respect to all cell DoFs) at the evaluation <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>. For the purposes of assembly into the global linear system, we have to respect the <a class="code" href="namespaceDifferentiation_1_1SD.html#aa55d50a1ffa79c27f9bd9ea104f15158">sign</a> difference between the residual and the RHS contribution: For Newton<span class="stringliteral">&#39;s method, the right hand side vector needs to be equal to thenegative* residual vector.</span></div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;<span class="stringliteral">       ad_helper.register_residual_vector(residual_ad);</span></div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;<span class="stringliteral">       ad_helper.compute_residual(cell_rhs);</span></div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;<span class="stringliteral">       cell_rhs=</span></div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;<span class="stringliteral">-1.0;</span></div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;<span class="stringliteral">       ad_helper.compute_linearization(cell_matrix);</span></div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;<span class="stringliteral">     };</span></div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;<span class="stringliteral">*  The remainder of the function equals what we had previously:</span></div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;<span class="stringliteral">     const auto copier = [dofs_per_cell, this](const CopyData &amp;copy_data) {</span></div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;<span class="stringliteral">       const FullMatrix&lt;double&gt; &amp;cell_matrix = copy_data.matrices[0];</span></div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;<span class="stringliteral">       const Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</span></div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;<span class="stringliteral">       const std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</span></div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;<span class="stringliteral">         copy_data.local_dof_indices[0];</span></div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;<span class="stringliteral">       for (unsigned int i = 0; i &lt; dofs_per_cell; ++i)</span></div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;<span class="stringliteral">         {</span></div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;<span class="stringliteral">           for (unsigned int j = 0; j &lt; dofs_per_cell; ++j)</span></div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;<span class="stringliteral">             system_matrix.add(local_dof_indices[i],</span></div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;<span class="stringliteral">                               local_dof_indices[j],</span></div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;<span class="stringliteral">                               cell_matrix(i, j));</span></div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;<span class="stringliteral">           system_rhs(local_dof_indices[i]) += cell_rhs(i);</span></div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;<span class="stringliteral">         }</span></div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;<span class="stringliteral">     };</span></div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;<span class="stringliteral">     MeshWorker::mesh_loop(dof_handler.active_cell_iterators(),</span></div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;<span class="stringliteral">                           cell_worker,</span></div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;<span class="stringliteral">                           copier,</span></div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;<span class="stringliteral">                           sample_scratch_data,</span></div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;<span class="stringliteral">                           sample_copy_data,</span></div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;<span class="stringliteral">                           MeshWorker::assemble_own_cells);</span></div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;<span class="stringliteral">     hanging_node_constraints.condense(system_matrix);</span></div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;<span class="stringliteral">     hanging_node_constraints.condense(system_rhs);</span></div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;<span class="stringliteral">     std::map&lt;types::global_dof_index, double&gt; boundary_values;</span></div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;<span class="stringliteral">     VectorTools::interpolate_boundary_values(dof_handler,</span></div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;<span class="stringliteral">                                              0,</span></div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;<span class="stringliteral">                                              Functions::ZeroFunction&lt;dim&gt;(),</span></div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;<span class="stringliteral">                                              boundary_values);</span></div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;<span class="stringliteral">     MatrixTools::apply_boundary_values(boundary_values,</span></div><div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;<span class="stringliteral">                                        system_matrix,</span></div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;<span class="stringliteral">                                        newton_update,</span></div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;<span class="stringliteral">                                        system_rhs);</span></div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;<span class="stringliteral">   }</span></div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;<span class="stringliteral">*   &lt;a name=&quot;Assemblyviadifferentiationoftheenergyfunctional&quot;&gt;&lt;/a&gt;  &lt;h5&gt;Assembly via differentiation of the energy functional&lt;/h5&gt;</span></div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;<span class="stringliteral">*  In this third approach, we compute residual and Jacobian as first and second derivatives of the local energy functional @f[</span></div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;<span class="stringliteral"> E\left( U \right)^K</span></div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;<span class="stringliteral"> \dealcoloneq \int\limits_{K} \Psi \left( u \right) \, dV</span></div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;<span class="stringliteral"> \approx \sum\limits_{q}^{n_{\textrm{q-points}}} \Psi \left( u \left(</span></div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;<span class="stringliteral"> \mathbf{X}_{q} \right) \right) \underbrace{\vert J_{q} \vert \times</span></div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;<span class="stringliteral"> W_{q}}_{\text{JxW(q)}}</span></div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;<span class="stringliteral"> @f] with the energy density given by @f[</span></div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;<span class="stringliteral"> \Psi \left( u \right) = \sqrt{1+|\nabla u|^{2}} .</span></div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;<span class="stringliteral"> @f]   </span></div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;<span class="stringliteral">*   Let us again see how this is done:</span></div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;<span class="stringliteral">   template &lt;int dim&gt;</span></div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;<span class="stringliteral">   void MinimalSurfaceProblem&lt;dim&gt;::assemble_system_using_energy_functional()</span></div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;<span class="stringliteral">   {</span></div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;<span class="stringliteral">     system_matrix = 0;</span></div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;<span class="stringliteral">     system_rhs    = 0;</span></div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;<span class="stringliteral">     const unsigned int dofs_per_cell = fe.n_dofs_per_cell();</span></div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;<span class="stringliteral">     using ScratchData      = MeshWorker::ScratchData&lt;dim&gt;;</span></div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;<span class="stringliteral">     using CopyData         = MeshWorker::CopyData&lt;1, 1, 1&gt;;</span></div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;<span class="stringliteral">     using CellIteratorType = decltype(dof_handler.begin_active());</span></div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;<span class="stringliteral">     const ScratchData sample_scratch_data(fe,</span></div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;<span class="stringliteral">                                           quadrature_formula,</span></div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;<span class="stringliteral">                                           update_gradients |</span></div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;<span class="stringliteral">                                             update_quadrature_points |</span></div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;<span class="stringliteral">                                             update_JxW_values);</span></div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;<span class="stringliteral">     const CopyData    sample_copy_data(dofs_per_cell);</span></div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;<span class="stringliteral">*  In this implementation of the assembly process, we choose the helper class that will automatically compute both the residual and its linearization from the cell contribution to an energy functional using nested Sacado forward automatic differentiation types. The selected number types can be used to compute both first and second derivatives. We require this, as the residual defined as the sensitivity of the potential energy with respect to the DoF values (i.e. its gradient). We&#39;</span>ll then need to linearize the residual, implying that <a class="code" href="grid__out_8cc.html#a2cc229a4f1ffc75e83ed269d5f725729">second</a> derivatives of the potential energy must be computed. You might want to compare <span class="keyword">this</span> with the definition of `ADHelper` used <span class="keywordtype">int</span> previous <span class="keyword">function</span>, where we used   `<a class="code" href="classDifferentiation_1_1AD_1_1ResidualLinearization.html">Differentiation::AD::ResidualLinearization&lt;Differentiation::AD::NumberTypes::sacado_dfad,double&gt;</a>`.  </div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;* </div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;* </div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;* @code</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;     <span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1EnergyFunctional.html">Differentiation::AD::EnergyFunctional</a>&lt;</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;       <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>,</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;       <span class="keywordtype">double</span>&gt;;</div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;     <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type;</div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;* </div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;     <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0);</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;* </div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;* </div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;*  Let us then again define the <a class="code" href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba945f3fc449518a73b9f5f32868db466c">lambda</a> <span class="keyword">function</span> that does the integration on a cell.     </div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;*   To initialize an instance of the helper <span class="keyword">class</span>, we now only require that the number of independent variables (that is, the number of degrees of freedom associated with the element solution vector) are known up front. This is because the <a class="code" href="grid__out_8cc.html#a2cc229a4f1ffc75e83ed269d5f725729">second</a>-derivative matrix that results from an energy functional is necessarily square (and also, incidentally, <a class="code" href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a1c0655acd718579199c777967de9eea5">symmetric</a>).</div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;* </div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;* </div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;* @code</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;     <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;                                            ScratchData &amp;           scratch_data,</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;                                            CopyData &amp;              copy_data) {</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;       <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.reinit(cell);</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;* </div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;       <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0];</div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;       <a class="code" href="classVector.html">Vector&lt;double&gt;</a> &amp;                      cell_rhs    = copy_data.vectors[0];</div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;       std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;         copy_data.local_dof_indices[0];</div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;       cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;* </div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = local_dof_indices.size();</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;       ADHelper           ad_helper(n_independent_variables);</div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;* </div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;* </div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;*  Once more, we <span class="keyword">register</span> all cell DoFs <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a> with the helper, followed by extracting the <span class="stringliteral">&quot;sensitive&quot;</span> variant of these <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a> that are to be used in subsequent operations that must be differentiated</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;* </div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;*  -  <a class="code" href="namespaceLAPACKSupport.html#aceda56512460bbad2f9fdb8a3d0e1e51">one</a> of those being the calculation of the solution gradients.</div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;* </div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;* </div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;* @code</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;       ad_helper.register_dof_values(current_solution, local_dof_indices);</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;* </div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;       <span class="keyword">const</span> std::vector&lt;ADNumberType&gt; &amp;dof_values_ad =</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;         ad_helper.get_sensitive_dof_values();</div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;* </div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;       std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients(</div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;         fe_values.n_quadrature_points);</div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;       fe_values[u_fe].get_function_gradients_from_local_dof_values(</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;         dof_values_ad, old_solution_gradients);</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;* </div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160; <span class="keyword">@end</span>code</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;* </div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;*  We next create a variable that stores the cell total energy. Once more we emphasize that we explicitly <a class="code" href="namespaceLAPACKSupport.html#a0d8802698d585eec62a2a54e6387b05b">zero</a>-initialize <span class="keyword">this</span> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a>, thereby ensuring the integrity of the data <span class="keywordflow">for</span> <span class="keyword">this</span> starting value.       </div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;*   The aim <span class="keywordflow">for</span> our approach is then to compute the cell total energy, which is the <a class="code" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a> of the <span class="keyword">internal</span> (due to right hand side <a class="code" href="namespaceinternal_1_1p4est.html#a4b980c7b4b4d9984e93d73c7d30173ea">functions</a>, typically linear in   @f$U@f$  ) and external energies. In <span class="keyword">this</span> particular <span class="keywordflow">case</span>, we have no external energies (e.g., from source terms or Neumann boundary conditions), so we<span class="stringliteral">&#39;ll focus on the internal energy part.       </span></div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;<span class="stringliteral">*   In fact, computing   @f$E(U)^K@f$   is almost trivial, requiring only the following lines:</span></div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;<span class="stringliteral">       ADNumberType energy_ad = ADNumberType(0.0);</span></div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;<span class="stringliteral">       for (const unsigned int q : fe_values.quadrature_point_indices())</span></div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;<span class="stringliteral">         {</span></div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;<span class="stringliteral">           const ADNumberType psi = std::sqrt(1.0 + old_solution_gradients[q]</span></div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;<span class="stringliteral">                                                      old_solution_gradients[q]);</span></div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;<span class="stringliteral">           energy_ad += psi fe_values.JxW(q);</span></div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;<span class="stringliteral">         }</span></div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;<span class="stringliteral">*  After we&#39;</span>ve computed the total energy on <span class="keyword">this</span> cell, we<span class="stringliteral">&#39;ll register it with the helper.  Based on that, we may now compute the desired quantities, namely the residual values and their Jacobian at the evaluation point. As before, the Newton right hand side needs to be the negative of the residual:</span></div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;<span class="stringliteral">       ad_helper.register_energy_functional(energy_ad);</span></div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;<span class="stringliteral">       ad_helper.compute_residual(cell_rhs);</span></div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;<span class="stringliteral">       cell_rhs=</span></div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;<span class="stringliteral">-1.0;</span></div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;<span class="stringliteral">       ad_helper.compute_linearization(cell_matrix);</span></div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;<span class="stringliteral">     };</span></div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;<span class="stringliteral">*  As in the previous two functions, the remainder of the function is as before:</span></div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;<span class="stringliteral">     const auto copier = [dofs_per_cell, this](const CopyData &amp;copy_data) {</span></div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;<span class="stringliteral">       const FullMatrix&lt;double&gt; &amp;cell_matrix = copy_data.matrices[0];</span></div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;<span class="stringliteral">       const Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0];</span></div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;<span class="stringliteral">       const std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices =</span></div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;<span class="stringliteral">         copy_data.local_dof_indices[0];</span></div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;<span class="stringliteral">       for (unsigned int i = 0; i &lt; dofs_per_cell; ++i)</span></div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;<span class="stringliteral">         {</span></div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;<span class="stringliteral">           for (unsigned int j = 0; j &lt; dofs_per_cell; ++j)</span></div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;<span class="stringliteral">             system_matrix.add(local_dof_indices[i],</span></div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;<span class="stringliteral">                               local_dof_indices[j],</span></div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;<span class="stringliteral">                               cell_matrix(i, j));</span></div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;<span class="stringliteral">           system_rhs(local_dof_indices[i]) += cell_rhs(i);</span></div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;<span class="stringliteral">         }</span></div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;<span class="stringliteral">     };</span></div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;<span class="stringliteral">     MeshWorker::mesh_loop(dof_handler.active_cell_iterators(),</span></div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;<span class="stringliteral">                           cell_worker,</span></div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;<span class="stringliteral">                           copier,</span></div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;<span class="stringliteral">                           sample_scratch_data,</span></div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;<span class="stringliteral">                           sample_copy_data,</span></div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;<span class="stringliteral">                           MeshWorker::assemble_own_cells);</span></div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;<span class="stringliteral">     hanging_node_constraints.condense(system_matrix);</span></div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;<span class="stringliteral">     hanging_node_constraints.condense(system_rhs);</span></div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;<span class="stringliteral">     std::map&lt;types::global_dof_index, double&gt; boundary_values;</span></div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;<span class="stringliteral">     VectorTools::interpolate_boundary_values(dof_handler,</span></div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;<span class="stringliteral">                                              0,</span></div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;<span class="stringliteral">                                              Functions::ZeroFunction&lt;dim&gt;(),</span></div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;<span class="stringliteral">                                              boundary_values);</span></div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;<span class="stringliteral">     MatrixTools::apply_boundary_values(boundary_values,</span></div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;<span class="stringliteral">                                        system_matrix,</span></div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;<span class="stringliteral">                                        newton_update,</span></div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;<span class="stringliteral">                                        system_rhs);</span></div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;<span class="stringliteral">   }</span></div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;<span class="stringliteral"> </span></div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;<span class="stringliteral">*   &lt;a name=&quot;MinimalSurfaceProblemsolve&quot;&gt;&lt;/a&gt;  &lt;h4&gt;MinimalSurfaceProblem::solve&lt;/h4&gt;</span></div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;<span class="stringliteral">*  The solve function is the same as is used in   @ref step_15 &quot;step-15&quot;  .</span></div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;<span class="stringliteral">   template &lt;int dim&gt;</span></div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;<span class="stringliteral">   void MinimalSurfaceProblem&lt;dim&gt;::solve()</span></div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;<span class="stringliteral">   {</span></div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;<span class="stringliteral">     SolverControl            solver_control(system_rhs.size(),</span></div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;<span class="stringliteral">                                  system_rhs.l2_norm() 1e-6);</span></div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;<span class="stringliteral">     SolverCG&lt;Vector&lt;double&gt;&gt; solver(solver_control);</span></div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;<span class="stringliteral">     PreconditionSSOR&lt;SparseMatrix&lt;double&gt;&gt; preconditioner;</span></div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;<span class="stringliteral">     preconditioner.initialize(system_matrix, 1.2);</span></div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;<span class="stringliteral">     solver.solve(system_matrix, newton_update, system_rhs, preconditioner);</span></div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;<span class="stringliteral">     hanging_node_constraints.distribute(newton_update);</span></div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;<span class="stringliteral">     const double alpha = determine_step_length();</span></div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;<span class="stringliteral">     current_solution.add(alpha, newton_update);</span></div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;<span class="stringliteral">   }</span></div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;<span class="stringliteral"> </span></div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;<span class="stringliteral">*   &lt;a name=&quot;MinimalSurfaceProblemrefine_mesh&quot;&gt;&lt;/a&gt;  &lt;h4&gt;MinimalSurfaceProblem::refine_mesh&lt;/h4&gt;</span></div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;<span class="stringliteral">*  Nothing has changed since   @ref step_15 &quot;step-15&quot;   with respect to the mesh refinement procedure and transfer of the solution between adapted meshes.</span></div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;<span class="stringliteral">   template &lt;int dim&gt;</span></div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;<span class="stringliteral">   void MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</span></div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;<span class="stringliteral">   {</span></div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;<span class="stringliteral">     Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells());</span></div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;<span class="stringliteral">     KellyErrorEstimator&lt;dim&gt;::estimate(</span></div><div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;<span class="stringliteral">       dof_handler,</span></div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;<span class="stringliteral">       QGauss&lt;dim</span></div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;<span class="stringliteral">- 1&gt;(fe.degree + 1),</span></div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;<span class="stringliteral">       std::map&lt;types::boundary_id, const Function&lt;dim&gt;&gt;(),</span></div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;<span class="stringliteral">       current_solution,</span></div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;<span class="stringliteral">       estimated_error_per_cell);</span></div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;<span class="stringliteral">     GridRefinement::refine_and_coarsen_fixed_number(triangulation,</span></div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;<span class="stringliteral">                                                     estimated_error_per_cell,</span></div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;<span class="stringliteral">                                                     0.3,</span></div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;<span class="stringliteral">                                                     0.03);</span></div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;<span class="stringliteral">     triangulation.prepare_coarsening_and_refinement();</span></div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;<span class="stringliteral">     SolutionTransfer&lt;dim&gt; solution_transfer(dof_handler);</span></div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;<span class="stringliteral">     solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</span></div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;<span class="stringliteral">     triangulation.execute_coarsening_and_refinement();</span></div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;<span class="stringliteral">     dof_handler.distribute_dofs(fe);</span></div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;<span class="stringliteral">     Vector&lt;double&gt; tmp(dof_handler.n_dofs());</span></div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;<span class="stringliteral">     solution_transfer.interpolate(current_solution, tmp);</span></div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;<span class="stringliteral">     current_solution = tmp;</span></div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;<span class="stringliteral">     hanging_node_constraints.clear();</span></div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;<span class="stringliteral">     DoFTools::make_hanging_node_constraints(dof_handler,</span></div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;<span class="stringliteral">                                             hanging_node_constraints);</span></div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;<span class="stringliteral">     hanging_node_constraints.close();</span></div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;<span class="stringliteral">     set_boundary_values();</span></div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;<span class="stringliteral">     setup_system(false);</span></div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;<span class="stringliteral">   }</span></div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;<span class="stringliteral"> </span></div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;<span class="stringliteral">*   &lt;a name=&quot;MinimalSurfaceProblemset_boundary_values&quot;&gt;&lt;/a&gt;  &lt;h4&gt;MinimalSurfaceProblem::set_boundary_values&lt;/h4&gt;</span></div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;<span class="stringliteral">*  The choice of boundary conditions remains identical to   @ref step_15 &quot;step-15&quot;  ...</span></div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;<span class="stringliteral">   template &lt;int dim&gt;</span></div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;<span class="stringliteral">   void MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</span></div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;<span class="stringliteral">   {</span></div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;<span class="stringliteral">     std::map&lt;types::global_dof_index, double&gt; boundary_values;</span></div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;<span class="stringliteral">     VectorTools::interpolate_boundary_values(dof_handler,</span></div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;<span class="stringliteral">                                              0,</span></div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;<span class="stringliteral">                                              BoundaryValues&lt;dim&gt;(),</span></div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;<span class="stringliteral">                                              boundary_values);</span></div><div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;<span class="stringliteral">     for (auto &amp;boundary_value : boundary_values)</span></div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;<span class="stringliteral">       current_solution(boundary_value.first) = boundary_value.second;</span></div><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;<span class="stringliteral">     hanging_node_constraints.distribute(current_solution);</span></div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;<span class="stringliteral">   }</span></div><div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;<span class="stringliteral"> </span></div><div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;<span class="stringliteral">*   &lt;a name=&quot;MinimalSurfaceProblemcompute_residual&quot;&gt;&lt;/a&gt;  &lt;h4&gt;MinimalSurfaceProblem::compute_residual&lt;/h4&gt;</span></div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;<span class="stringliteral">*  ... as does the function used to compute the residual during the solution iteration procedure. One could replace this by differentiation of the energy functional if one really wanted, but for simplicity we here simply copy what we already had in   @ref step_15 &quot;step-15&quot;  .</span></div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;<span class="stringliteral">   template &lt;int dim&gt;</span></div><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;<span class="stringliteral">   double MinimalSurfaceProblem&lt;dim&gt;::compute_residual(const double alpha) const</span></div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;<span class="stringliteral">   {</span></div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;<span class="stringliteral">     Vector&lt;double&gt; residual(dof_handler.n_dofs());</span></div><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;<span class="stringliteral">     Vector&lt;double&gt; evaluation_point(dof_handler.n_dofs());</span></div><div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;<span class="stringliteral">     evaluation_point = current_solution;</span></div><div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;<span class="stringliteral">     evaluation_point.add(alpha, newton_update);</span></div><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;<span class="stringliteral">     const QGauss&lt;dim&gt; quadrature_formula(fe.degree + 1);</span></div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;<span class="stringliteral">     FEValues&lt;dim&gt;     fe_values(fe,</span></div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;<span class="stringliteral">                             quadrature_formula,</span></div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;<span class="stringliteral">                             update_gradients | update_quadrature_points |</span></div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;<span class="stringliteral">                               update_JxW_values);</span></div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;<span class="stringliteral">     const unsigned int dofs_per_cell = fe.n_dofs_per_cell();</span></div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;<span class="stringliteral">     const unsigned int n_q_points    = quadrature_formula.size();</span></div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;<span class="stringliteral">     Vector&lt;double&gt;              cell_residual(dofs_per_cell);</span></div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;<span class="stringliteral">     std::vector&lt;Tensor&lt;1, dim&gt;&gt; gradients(n_q_points);</span></div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;<span class="stringliteral">     std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</span></div><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;<span class="stringliteral">     for (const auto &amp;cell : dof_handler.active_cell_iterators())</span></div><div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;<span class="stringliteral">       {</span></div><div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;<span class="stringliteral">         cell_residual = 0;</span></div><div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;<span class="stringliteral">         fe_values.reinit(cell);</span></div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;<span class="stringliteral">         fe_values.get_function_gradients(evaluation_point, gradients);</span></div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;<span class="stringliteral">         for (unsigned int q = 0; q &lt; n_q_points; ++q)</span></div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;<span class="stringliteral">           {</span></div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;<span class="stringliteral">             const double coeff =</span></div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;<span class="stringliteral">               1.0 / std::sqrt(1.0 + gradients[q] gradients[q]);</span></div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;<span class="stringliteral">             for (unsigned int i = 0; i &lt; dofs_per_cell; ++i)</span></div><div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;<span class="stringliteral">               cell_residual(i)</span></div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;<span class="stringliteral">-= (fe_values.shape_grad(i, q) // \nabla \phi_i</span></div><div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;<span class="stringliteral">                                    coeff                    // a_n</span></div><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;<span class="stringliteral">                                    gradients[q]             // u_n</span></div><div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;<span class="stringliteral">                                    fe_values.JxW(q));       // dx</span></div><div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;<span class="stringliteral">           }</span></div><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;<span class="stringliteral">         cell-&gt;get_dof_indices(local_dof_indices);</span></div><div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;<span class="stringliteral">         for (unsigned int i = 0; i &lt; dofs_per_cell; ++i)</span></div><div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;<span class="stringliteral">           residual(local_dof_indices[i]) += cell_residual(i);</span></div><div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;<span class="stringliteral">       }</span></div><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;<span class="stringliteral">     hanging_node_constraints.condense(residual);</span></div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;<span class="stringliteral">     for (types::global_dof_index i :</span></div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;<span class="stringliteral">          DoFTools::extract_boundary_dofs(dof_handler))</span></div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;<span class="stringliteral">       residual(i) = 0;</span></div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;<span class="stringliteral">     return residual.l2_norm();</span></div><div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;<span class="stringliteral">   }</span></div><div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;<span class="stringliteral"> </span></div><div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;<span class="stringliteral">*   &lt;a name=&quot;MinimalSurfaceProblemdetermine_step_length&quot;&gt;&lt;/a&gt;  &lt;h4&gt;MinimalSurfaceProblem::determine_step_length&lt;/h4&gt;</span></div><div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;<span class="stringliteral">*  The choice of step length (or, under-relaxation factor) for the nonlinear iterations procedure remains fixed at the value chosen and discussed in   @ref step_15 &quot;step-15&quot;  .</span></div><div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;<span class="stringliteral">   template &lt;int dim&gt;</span></div><div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;<span class="stringliteral">   double MinimalSurfaceProblem&lt;dim&gt;::determine_step_length() const</span></div><div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;<span class="stringliteral">   {</span></div><div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;<span class="stringliteral">     return 0.1;</span></div><div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;<span class="stringliteral">   }</span></div><div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;<span class="stringliteral"> </span></div><div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;<span class="stringliteral">*   &lt;a name=&quot;MinimalSurfaceProblemoutput_results&quot;&gt;&lt;/a&gt;  &lt;h4&gt;MinimalSurfaceProblem::output_results&lt;/h4&gt;</span></div><div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;<span class="stringliteral">*  This last function to be called from `run()` outputs the current solution (and the Newton update) in graphical form as a VTU file. It is entirely the same as what has been used in previous tutorials.</span></div><div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;<span class="stringliteral">   template &lt;int dim&gt;</span></div><div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;<span class="stringliteral">   void MinimalSurfaceProblem&lt;dim&gt;::output_results(</span></div><div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;<span class="stringliteral">     const unsigned int refinement_cycle) const</span></div><div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;<span class="stringliteral">   {</span></div><div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;<span class="stringliteral">     DataOut&lt;dim&gt; data_out;</span></div><div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;<span class="stringliteral">     data_out.attach_dof_handler(dof_handler);</span></div><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;<span class="stringliteral">     data_out.add_data_vector(current_solution, &quot;solution&quot;);</span></div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;<span class="stringliteral">     data_out.add_data_vector(newton_update, &quot;update&quot;);</span></div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;<span class="stringliteral">     data_out.build_patches();</span></div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;<span class="stringliteral">     const std::string filename =</span></div><div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;<span class="stringliteral">       &quot;solution-&quot; + Utilities::int_to_string(refinement_cycle, 2) + &quot;.vtu&quot;;</span></div><div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;<span class="stringliteral">     std::ofstream output(filename);</span></div><div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;<span class="stringliteral">     data_out.write_vtu(output);</span></div><div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;<span class="stringliteral">   }</span></div><div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;<span class="stringliteral"> </span></div><div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;<span class="stringliteral">*   &lt;a name=&quot;MinimalSurfaceProblemrun&quot;&gt;&lt;/a&gt;  &lt;h4&gt;MinimalSurfaceProblem::run&lt;/h4&gt;</span></div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;<span class="stringliteral">*  In the run function, most remains the same as was first implemented in   @ref step_15 &quot;step-15&quot;  . The only observable changes are that we can now choose (via the parameter file) what the final acceptable tolerance for the system residual is, and that we can choose which method of assembly we wish to utilize. To make the second choice clear, we output to the console some message which indicates the selection. Since we&#39;</span>re interested in comparing the time taken to <a class="code" href="namespaceinternal.html#a2b3d48efdf7c94da455dc6a3553bab79">assemble</a> <span class="keywordflow">for each</span> of the three methods, we<span class="stringliteral">&#39;ve also added a timer that keeps a track of how much time is spent during assembly. We also track the time taken to solve the linear system, so that we can contrast those numbers to the part of the code which would normally take the longest time to execute.</span></div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;<span class="stringliteral">   template &lt;int dim&gt;</span></div><div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;<span class="stringliteral">   void MinimalSurfaceProblem&lt;dim&gt;::run(const int    formulation,</span></div><div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;<span class="stringliteral">                                        const double tolerance)</span></div><div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;<span class="stringliteral">   {</span></div><div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;<span class="stringliteral">     std::cout &lt;&lt; &quot;******** Assembly approach*******&quot; &lt;&lt; std::endl;</span></div><div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;<span class="stringliteral">     const std::array&lt;std::string, 3&gt; method_descriptions = {</span></div><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;<span class="stringliteral">       {&quot;Unassisted implementation (full hand linearization).&quot;,</span></div><div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;<span class="stringliteral">        &quot;Automated linearization of the finite element residual.&quot;,</span></div><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;<span class="stringliteral">        &quot;Automated computation of finite element residual and linearization using a variational formulation.&quot;}};</span></div><div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;<span class="stringliteral">     AssertIndexRange(formulation, method_descriptions.size());</span></div><div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;<span class="stringliteral">     std::cout &lt;&lt; method_descriptions[formulation] &lt;&lt; std::endl &lt;&lt; std::endl;</span></div><div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;<span class="stringliteral"> </span></div><div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;<span class="stringliteral">     TimerOutput timer(std::cout, TimerOutput::summary, TimerOutput::wall_times);</span></div><div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;<span class="stringliteral">     GridGenerator::hyper_ball(triangulation);</span></div><div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;<span class="stringliteral">     triangulation.refine_global(2);</span></div><div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;<span class="stringliteral">     setup_system( /*first time=*/ true);</span></div><div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;<span class="stringliteral">     set_boundary_values();</span></div><div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;<span class="stringliteral">     double       last_residual_norm = std::numeric_limits&lt;double&gt;::max();</span></div><div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;<span class="stringliteral">     unsigned int refinement_cycle   = 0;</span></div><div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;<span class="stringliteral">     do</span></div><div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;<span class="stringliteral">       {</span></div><div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;<span class="stringliteral">         std::cout &lt;&lt; &quot;Mesh refinement step &quot; &lt;&lt; refinement_cycle &lt;&lt; std::endl;</span></div><div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;<span class="stringliteral">         if (refinement_cycle != 0)</span></div><div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;<span class="stringliteral">           refine_mesh();</span></div><div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;<span class="stringliteral">         std::cout &lt;&lt; &quot;  Initial residual: &quot; &lt;&lt; compute_residual(0) &lt;&lt; std::endl;</span></div><div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;<span class="stringliteral">         for (unsigned int inner_iteration = 0; inner_iteration &lt; 5;</span></div><div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;<span class="stringliteral">              ++inner_iteration)</span></div><div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;<span class="stringliteral">           {</span></div><div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;<span class="stringliteral">             {</span></div><div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;<span class="stringliteral">               TimerOutput::Scope t(timer, &quot;Assemble&quot;);</span></div><div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;<span class="stringliteral">               if (formulation == 0)</span></div><div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;<span class="stringliteral">                 assemble_system_unassisted();</span></div><div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;<span class="stringliteral">               else if (formulation == 1)</span></div><div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;<span class="stringliteral">                 assemble_system_with_residual_linearization();</span></div><div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;<span class="stringliteral">               else if (formulation == 2)</span></div><div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;<span class="stringliteral">                 assemble_system_using_energy_functional();</span></div><div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;<span class="stringliteral">               else</span></div><div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;<span class="stringliteral">                 AssertThrow(false, ExcNotImplemented());</span></div><div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;<span class="stringliteral">             }</span></div><div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;<span class="stringliteral">             last_residual_norm = system_rhs.l2_norm();</span></div><div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;<span class="stringliteral">             {</span></div><div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;<span class="stringliteral">               TimerOutput::Scope t(timer, &quot;Solve&quot;);</span></div><div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;<span class="stringliteral">               solve();</span></div><div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;<span class="stringliteral">             }</span></div><div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;<span class="stringliteral"> </span></div><div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;<span class="stringliteral">             std::cout &lt;&lt; &quot;  Residual: &quot; &lt;&lt; compute_residual(0) &lt;&lt; std::endl;</span></div><div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;<span class="stringliteral">           }</span></div><div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;<span class="stringliteral">         output_results(refinement_cycle);</span></div><div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;<span class="stringliteral">         ++refinement_cycle;</span></div><div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;<span class="stringliteral">         std::cout &lt;&lt; std::endl;</span></div><div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;<span class="stringliteral">       }</span></div><div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;<span class="stringliteral">     while (last_residual_norm &gt; tolerance);</span></div><div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;<span class="stringliteral">   }</span></div><div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;<span class="stringliteral"> } // namespace Step72</span></div><div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;<span class="stringliteral">*   &lt;a name=&quot;Themainfunction&quot;&gt;&lt;/a&gt;  &lt;h4&gt;The main function&lt;/h4&gt;</span></div><div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;<span class="stringliteral">*  Finally the main function. This follows the scheme of most other main functions, with two obvious exceptions:</span></div><div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;<span class="stringliteral">*  - We call   Utilities::MPI::MPI_InitFinalize   in order to set up (via a hidden default parameter) the number of threads using the execution of multithreaded tasks.</span></div><div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;<span class="stringliteral">*  - We also have a few lines dedicates to reading in or initializing the user-defined parameters that will be considered during the execution of the program.</span></div><div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;<span class="stringliteral"> int main(int argc, charargv[])</span></div><div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;<span class="stringliteral"> {</span></div><div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;<span class="stringliteral">   try</span></div><div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;<span class="stringliteral">     {</span></div><div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;<span class="stringliteral">       using namespace Step72;</span></div><div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;<span class="stringliteral">       Utilities::MPI::MPI_InitFinalize mpi_initialization(argc, argv);</span></div><div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;<span class="stringliteral">       std::string prm_file;</span></div><div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;<span class="stringliteral">       if (argc &gt; 1)</span></div><div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;<span class="stringliteral">         prm_file = argv[1];</span></div><div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;<span class="stringliteral">       else</span></div><div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;<span class="stringliteral">         prm_file = &quot;parameters.prm&quot;;</span></div><div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;<span class="stringliteral">       const MinimalSurfaceProblemParameters parameters;</span></div><div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;<span class="stringliteral">       ParameterAcceptor::initialize(prm_file);</span></div><div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;<span class="stringliteral">       MinimalSurfaceProblem&lt;2&gt; minimal_surface_problem_2d;</span></div><div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;<span class="stringliteral">       minimal_surface_problem_2d.run(parameters.formulation,</span></div><div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;<span class="stringliteral">                                      parameters.tolerance);</span></div><div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;<span class="stringliteral">     }</span></div><div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;<span class="stringliteral">   catch (std::exception &amp;exc)</span></div><div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;<span class="stringliteral">     {</span></div><div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;<span class="stringliteral">       std::cerr &lt;&lt; std::endl</span></div><div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;<span class="stringliteral">                 &lt;&lt; std::endl</span></div><div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;<span class="stringliteral">                 &lt;&lt; &quot;----------------------------------------------------&quot;</span></div><div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;<span class="stringliteral">                 &lt;&lt; std::endl;</span></div><div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;<span class="stringliteral">       std::cerr &lt;&lt; &quot;Exception on processing: &quot; &lt;&lt; std::endl</span></div><div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;<span class="stringliteral">                 &lt;&lt; exc.what() &lt;&lt; std::endl</span></div><div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;<span class="stringliteral">                 &lt;&lt; &quot;Aborting!&quot; &lt;&lt; std::endl</span></div><div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;<span class="stringliteral">                 &lt;&lt; &quot;----------------------------------------------------&quot;</span></div><div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;<span class="stringliteral">                 &lt;&lt; std::endl;</span></div><div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;<span class="stringliteral">       return 1;</span></div><div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;<span class="stringliteral">     }</span></div><div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;<span class="stringliteral">   catch (...)</span></div><div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;<span class="stringliteral">     {</span></div><div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;<span class="stringliteral">       std::cerr &lt;&lt; std::endl</span></div><div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;<span class="stringliteral">                 &lt;&lt; std::endl</span></div><div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;<span class="stringliteral">                 &lt;&lt; &quot;----------------------------------------------------&quot;</span></div><div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;<span class="stringliteral">                 &lt;&lt; std::endl;</span></div><div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;<span class="stringliteral">       std::cerr &lt;&lt; &quot;Unknown exception!&quot; &lt;&lt; std::endl</span></div><div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;<span class="stringliteral">                 &lt;&lt; &quot;Aborting!&quot; &lt;&lt; std::endl</span></div><div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;<span class="stringliteral">                 &lt;&lt; &quot;----------------------------------------------------&quot;</span></div><div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;<span class="stringliteral">                 &lt;&lt; std::endl;</span></div><div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;<span class="stringliteral">       return 1;</span></div><div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;<span class="stringliteral">     }</span></div><div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;<span class="stringliteral">   return 0;</span></div><div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;<span class="stringliteral"> }</span></div><div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;<span class="stringliteral"> @endcode</span></div><div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;<span class="stringliteral">* &lt;a name=&quot;Results&quot;&gt;&lt;/a&gt;&lt;h1&gt;Results&lt;/h1&gt;</span></div><div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;<span class="stringliteral">* Since there was no change to the physics of the problem that has first been analyzedin   @ref step_15 &quot;step-15&quot;  , there is nothing to report about that. The only outwardly noticeabledifference between them is that, by default, this program will only run 9 meshrefinement steps (as opposed to   @ref step_15 &quot;step-15&quot;  , which executes 11 refinements).This will be observable in the simulation status that appears between theheader text that prints which assembly method is being used, and the finaltimings. (All timings reported below were obtained in release mode.)</span></div><div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;<span class="stringliteral">* @code</span></div><div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;<span class="stringliteral">Mesh refinement step 0</span></div><div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;<span class="stringliteral">  Initial residual: 1.53143</span></div><div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;<span class="stringliteral">  Residual: 1.08746</span></div><div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;<span class="stringliteral">  Residual: 0.966748</span></div><div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;<span class="stringliteral">  Residual: 0.859602</span></div><div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;<span class="stringliteral">  Residual: 0.766462</span></div><div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;<span class="stringliteral">  Residual: 0.685475</span></div><div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;<span class="stringliteral">...</span></div><div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;<span class="stringliteral">Mesh refinement step 9</span></div><div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;<span class="stringliteral">  Initial residual: 0.00924594</span></div><div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;<span class="stringliteral">  Residual: 0.00831928</span></div><div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;<span class="stringliteral">  Residual: 0.0074859</span></div><div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;<span class="stringliteral">  Residual: 0.0067363</span></div><div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;<span class="stringliteral">  Residual: 0.00606197</span></div><div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;<span class="stringliteral">  Residual: 0.00545529</span></div><div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;<span class="stringliteral">@endcode</span></div><div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;<span class="stringliteral">* So what is interesting for us to compare is how long the assembly process takesfor the three different implementations, and to put that into some greater context.Below is the output for the hand linearization (as computed on a circa 2012four core, eight thread laptop</span></div><div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;<span class="stringliteral">*  -  but we&#39;</span>re only really interested in therelative time between the different implementations):</div><div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;* @code</div><div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;******** Assembly approach*******</div><div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;Unassisted implementation (full hand linearization).</div><div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;* </div><div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;...</div><div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;* </div><div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;+---------------------------------------------+------------+------------+</div><div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;| Total wallclock time elapsed since start    |      35.1s |            |</div><div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;|                                             |            |            |</div><div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;| Section                         | no. calls |  wall time | % of total |</div><div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;+---------------------------------+-----------+------------+------------+</div><div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;| Assemble                        |        50 |      1.56s |       4.5% |</div><div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;| Solve                           |        50 |      30.8s |        88% |</div><div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;+---------------------------------+-----------+------------+------------+</div><div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;<span class="keyword">@end</span>code</div><div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;* And <span class="keywordflow">for</span> the implementation that linearizes the residual in an automatedmanner <span class="keyword">using</span> the Sacado dynamic forward AD number type:</div><div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;* @code</div><div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;******** Assembly approach*******</div><div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;Automated linearization of the finite element residual.</div><div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;* </div><div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;...</div><div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;* </div><div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;+---------------------------------------------+------------+------------+</div><div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;| Total wallclock time elapsed since start    |      40.1s |            |</div><div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;|                                             |            |            |</div><div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;| Section                         | no. calls |  wall time | % of total |</div><div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;+---------------------------------+-----------+------------+------------+</div><div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;| Assemble                        |        50 |       8.8s |        22% |</div><div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;| Solve                           |        50 |      28.6s |        71% |</div><div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;+---------------------------------+-----------+------------+------------+</div><div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;<span class="keyword">@end</span>code</div><div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;* And, lastly, <span class="keywordflow">for</span> the implementation that computes both the residual andits linearization directly from an energy functional (<span class="keyword">using</span> nested Sacadodynamic forward AD <a class="code" href="namespacenumbers.html">numbers</a>):</div><div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;* @code</div><div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;******** Assembly approach*******</div><div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;Automated computation of finite element residual and linearization using a variational formulation.</div><div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160;* </div><div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;...</div><div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;* </div><div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;+---------------------------------------------+------------+------------+</div><div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;| Total wallclock time elapsed since start    |      48.8s |            |</div><div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;|                                             |            |            |</div><div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;| Section                         | no. calls |  wall time | % of total |</div><div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;+---------------------------------+-----------+------------+------------+</div><div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;| Assemble                        |        50 |      16.7s |        34% |</div><div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;| Solve                           |        50 |      29.3s |        60% |</div><div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;+---------------------------------+-----------+------------+------------+</div><div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;@endcode</div><div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;* </div><div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;* It<span class="stringliteral">&#39;s evident that the more work that is passed off to the automatic differentiationframework to perform, the more time is spent during the assembly process. Accumulatedover all refinement steps, using one level of automatic differentiation resultedin   @f$5.65 \times@f$   more computational time being spent in the assembly stage whencompared to unassisted assembly, while assembling the discrete linear system took  @f$10.7 \times@f$   longer when deriving directly from the energy functional.Unsurprisingly, the overall time spent solving the linear system remained unchanged.This means that the proportion of time spent in the solve phase to the assembly phaseshifted significantly as the number of times automated differentiation was performedat the finite element level. For many, this might mean that leveraging higher-orderdifferentiation (at the finite element level) in production code leads to anunacceptable overhead, but it may still be useful during the prototyping phase.A good compromise between the two may, therefore, be the automated linearizationof the finite element residual, which offers a lot of convenience at a measurable,but perhaps not unacceptable, cost. Alternatively, one could considernot re-building the Newton matrix in every step</span></div><div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;<span class="stringliteral">*  -  a topic that isexplored in substantial depth in   @ref step_77 &quot;step-77&quot;  .</span></div><div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;<span class="stringliteral">* Of course, in practice the actual overhead is very much dependent on the problem being evaluated(e.g., how many components there are in the solution, what the nature of the functionbeing differentiated is, etc.). So the exact results presented here should beinterpreted within the context of this scalar problem alone, and when it comes toother problems, some preliminary investigation by the user is certainly warranted.</span></div><div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;<span class="stringliteral">* &lt;a name=&quot;Possibilitiesforextensions&quot;&gt;&lt;/a&gt;&lt;h3&gt; Possibilities for extensions &lt;/h3&gt;</span></div><div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;<span class="stringliteral">* Like   @ref step_71 &quot;step-71&quot;  , there are a few items related to automatic differentiation that couldbe evaluated further:</span></div><div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;<span class="stringliteral">*  - The use of other AD frameworks should be investigated, with the outlook that  alternative implementations may provide performance benefits.</span></div><div class="line"><a name="l01581"></a><span class="lineno"> 1581</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;<span class="stringliteral">*  - It is also worth evaluating AD number types other than those that have been  hard-coded into this tutorial. With regard to twice differentiable types  employed at the finite-element level, mixed differentiation modes (&quot;RAD-FAD&quot;)  should in principle be more computationally efficient than the single  mode (&quot;FAD-FAD&quot;) types employed here. The reason that the RAD-FAD type was not  selected by default is that, at the time of writing, there remain some  bugs in its implementation within the Sacado library that lead to memory leaks.  This is documented in the   @ref auto_symb_diff   module.</span></div><div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;<span class="stringliteral">*  - It might be the case that using reduced precision types (i.e., `float`) as the  scalar types for the AD numbers could render a reduction in computational  expense during assembly. Using `float` as the data type for the  matrix and the residual is not unreasonable, given that the Newton  update is only meant to get us closer to the solution, but not  actuallyto* the solution; as a consequence, it makes sense to  consider using reduced-precision data types for computing these  updates, and then accumulating these updates in a solution vector  that uses the full `double` precision accuracy.</span></div><div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;<span class="stringliteral">*  - One further method of possibly reducing resources during assembly is to frame  the AD implementations as a constitutive model. This would be similar to the  approach adopted in   @ref step_71 &quot;step-71&quot;  , and pushes the starting point for the automatic  differentiation one level higher up the chain of computations. This, in turn,  means that less operations are tracked by the AD library, thereby reducing the  cost of differentiating (even though one would perform the differentiation at  each cell quadrature point).</span></div><div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;<span class="stringliteral">*  -   @ref step_77 &quot;step-77&quot;   is yet another variation of   @ref step_15 &quot;step-15&quot;   that addresses a very  different part of the problem: Line search and whether it is  necessary to re-build the Newton matrix in every nonlinear  iteration. Given that the results above show that using automatic  differentiation comes at a cost, the techniques in   @ref step_77 &quot;step-77&quot;   have the  potential to offset these costs to some degree. It would therefore  be quite interesting to combine the current program with the  techniques in   @ref step_77 &quot;step-77&quot;  . For production codes, this would certainly be  the way to go.</span></div><div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;<span class="stringliteral">* </span></div><div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;<span class="stringliteral"></span></div><div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;<span class="stringliteral">* &lt;a name=&quot;PlainProg&quot;&gt;&lt;/a&gt;&lt;h1&gt; The plain program&lt;/h1&gt;  @include &quot;step-72.cc&quot;  </span></div><div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;<span class="stringliteral">*</span></div><div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;<span class="stringliteral">*/</span></div><div class="ttc" id="group__feaccess_html_ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85"><div class="ttname"><a href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a></div><div class="ttdoc">Transformed quadrature weights. </div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00103">fe_update_flags.h:103</a></div></div>
<div class="ttc" id="namespaceLAPACKSupport_html_a45557450a3c1ae0e74d7ddf12c43bc98a1c0655acd718579199c777967de9eea5"><div class="ttname"><a href="namespaceLAPACKSupport.html#a45557450a3c1ae0e74d7ddf12c43bc98a1c0655acd718579199c777967de9eea5">LAPACKSupport::symmetric</a></div><div class="ttdoc">Matrix is symmetric. </div><div class="ttdef"><b>Definition:</b> <a href="lapack__support_8h_source.html#l00116">lapack_support.h:116</a></div></div>
<div class="ttc" id="group__MeshWorker_html_gad10f528ab87f39fbb0531d24f238b2f3"><div class="ttname"><a href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">MeshWorker::loop</a></div><div class="ttdeci">void loop(ITERATOR begin, typename identity&lt; ITERATOR &gt;::type end, DOFINFO &amp;dinfo, INFOBOX &amp;info, const std::function&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;cell_worker, const std::function&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;boundary_worker, const std::function&lt; void(DOFINFO &amp;, DOFINFO &amp;, typename INFOBOX::CellInfo &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;face_worker, ASSEMBLER &amp;assembler, const LoopControl &amp;lctrl=LoopControl())</div><div class="ttdef"><b>Definition:</b> <a href="loop_8h_source.html#l00449">loop.h:449</a></div></div>
<div class="ttc" id="structMeshWorker_1_1CopyData_html"><div class="ttname"><a href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData</a></div><div class="ttdef"><b>Definition:</b> <a href="copy__data_8h_source.html#l00065">copy_data.h:65</a></div></div>
<div class="ttc" id="namespaceDifferentiation_1_1SD_html_aa55d50a1ffa79c27f9bd9ea104f15158"><div class="ttname"><a href="namespaceDifferentiation_1_1SD.html#aa55d50a1ffa79c27f9bd9ea104f15158">Differentiation::SD::sign</a></div><div class="ttdeci">Expression sign(const Expression &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="symengine__math_8cc_source.html#l00280">symengine_math.cc:280</a></div></div>
<div class="ttc" id="namespaceMatrixTools_html_a9ad0eb7a8662628534586716748d62fb"><div class="ttname"><a href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a></div><div class="ttdeci">void apply_boundary_values(const std::map&lt; types::global_dof_index, number &gt; &amp;boundary_values, SparseMatrix&lt; number &gt; &amp;matrix, Vector&lt; number &gt; &amp;solution, Vector&lt; number &gt; &amp;right_hand_side, const bool eliminate_columns=true)</div><div class="ttdef"><b>Definition:</b> <a href="matrix__tools_8cc_source.html#l00081">matrix_tools.cc:81</a></div></div>
<div class="ttc" id="namespaceMeshWorker_html_ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa"><div class="ttname"><a href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a></div><div class="ttdef"><b>Definition:</b> <a href="assemble__flags_8h_source.html#l00050">assemble_flags.h:50</a></div></div>
<div class="ttc" id="namespaceLAPACKSupport_html_a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003"><div class="ttname"><a href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">LAPACKSupport::matrix</a></div><div class="ttdoc">Contents is actually a matrix. </div><div class="ttdef"><b>Definition:</b> <a href="lapack__support_8h_source.html#l00060">lapack_support.h:60</a></div></div>
<div class="ttc" id="classDynamicSparsityPattern_html"><div class="ttname"><a href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="dynamic__sparsity__pattern_8h_source.html#l00296">dynamic_sparsity_pattern.h:296</a></div></div>
<div class="ttc" id="namespacePhysics_1_1Elasticity_1_1Kinematics_html_a9587d5229555daa5b1fa1ba2f8a40adb"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">Physics::Elasticity::Kinematics::e</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; e(const Tensor&lt; 2, dim, Number &gt; &amp;F)</div></div>
<div class="ttc" id="classVector_html"><div class="ttname"><a href="classVector.html">Vector</a></div><div class="ttdef"><b>Definition:</b> <a href="mapping__q1__eulerian_8h_source.html#l00033">mapping_q1_eulerian.h:33</a></div></div>
<div class="ttc" id="namespaceinternal_html_aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804"><div class="ttname"><a href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">internal::EvaluatorQuantity::value</a></div></div>
<div class="ttc" id="namespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdoc">STL namespace. </div></div>
<div class="ttc" id="namespaceLAPACKSupport_html_aceda56512460bbad2f9fdb8a3d0e1e51"><div class="ttname"><a href="namespaceLAPACKSupport.html#aceda56512460bbad2f9fdb8a3d0e1e51">LAPACKSupport::one</a></div><div class="ttdeci">static const types::blas_int one</div><div class="ttdef"><b>Definition:</b> <a href="lapack__support_8h_source.html#l00198">lapack_support.h:198</a></div></div>
<div class="ttc" id="namespaceLAPACKSupport_html_a3e681d2d74dcf90f6556706d66f81a0d"><div class="ttname"><a href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">LAPACKSupport::U</a></div><div class="ttdeci">static const char U</div><div class="ttdef"><b>Definition:</b> <a href="lapack__support_8h_source.html#l00178">lapack_support.h:178</a></div></div>
<div class="ttc" id="classdouble_html"><div class="ttname"><a href="classdouble.html">double</a></div></div>
<div class="ttc" id="namespaceLocalIntegrators_1_1Advection_html_a8bc7b8136646134f73a4193adefe15f8"><div class="ttname"><a href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">LocalIntegrators::Advection::cell_matrix</a></div><div class="ttdeci">void cell_matrix(FullMatrix&lt; double &gt; &amp;M, const FEValuesBase&lt; dim &gt; &amp;fe, const FEValuesBase&lt; dim &gt; &amp;fetest, const ArrayView&lt; const std::vector&lt; double &gt;&gt; &amp;velocity, const double factor=1.)</div><div class="ttdef"><b>Definition:</b> <a href="advection_8h_source.html#l00063">advection.h:63</a></div></div>
<div class="ttc" id="group__feaccess_html_ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a"><div class="ttname"><a href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a></div><div class="ttdoc">Transformed quadrature points. </div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00097">fe_update_flags.h:97</a></div></div>
<div class="ttc" id="grid__out_8cc_html_a2cc229a4f1ffc75e83ed269d5f725729"><div class="ttname"><a href="grid__out_8cc.html#a2cc229a4f1ffc75e83ed269d5f725729">second</a></div><div class="ttdeci">Point&lt; 2 &gt; second</div><div class="ttdef"><b>Definition:</b> <a href="grid__out_8cc_source.html#l04588">grid_out.cc:4588</a></div></div>
<div class="ttc" id="namespaceDifferentiation_1_1SD_html_a841a7b84dc17bf2ba675522093a97e8ba945f3fc449518a73b9f5f32868db466c"><div class="ttname"><a href="namespaceDifferentiation_1_1SD.html#a841a7b84dc17bf2ba675522093a97e8ba945f3fc449518a73b9f5f32868db466c">Differentiation::SD::OptimizerType::lambda</a></div></div>
<div class="ttc" id="namespacePhysics_1_1Elasticity_1_1Kinematics_html_aa87528a28ad8a95fa89a3876e6f986c8"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">Physics::Elasticity::Kinematics::F</a></div><div class="ttdeci">Tensor&lt; 2, dim, Number &gt; F(const Tensor&lt; 2, dim, Number &gt; &amp;Grad_u)</div></div>
<div class="ttc" id="namespaceMeshWorker_html"><div class="ttname"><a href="namespaceMeshWorker.html">MeshWorker</a></div><div class="ttdef"><b>Definition:</b> <a href="assemble__flags_8h_source.html#l00031">assemble_flags.h:31</a></div></div>
<div class="ttc" id="group__MeshWorker_html_ga76ec61fbd188fb320fe8ca166a79b322"><div class="ttname"><a href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a></div><div class="ttdeci">void mesh_loop(const CellIteratorType &amp;begin, const CellIteratorType &amp;end, const CellWorkerFunctionType &amp;cell_worker, const CopierType &amp;copier, const ScratchData &amp;sample_scratch_data, const CopyData &amp;sample_copy_data, const AssembleFlags flags=assemble_own_cells, const BoundaryWorkerFunctionType &amp;boundary_worker=BoundaryWorkerFunctionType(), const FaceWorkerFunctionType &amp;face_worker=FaceWorkerFunctionType(), const unsigned int queue_length=2 *MultithreadInfo::n_threads(), const unsigned int chunk_size=8)</div><div class="ttdef"><b>Definition:</b> <a href="mesh__loop_8h_source.html#l00230">mesh_loop.h:230</a></div></div>
<div class="ttc" id="classFullMatrix_html"><div class="ttname"><a href="classFullMatrix.html">FullMatrix&lt; double &gt;</a></div></div>
<div class="ttc" id="namespaceThreads_1_1internal_html_a8d237a30d09b13e0b5adbe0fd1dfb188"><div class="ttname"><a href="namespaceThreads_1_1internal.html#a8d237a30d09b13e0b5adbe0fd1dfb188">Threads::internal::call</a></div><div class="ttdeci">void call(const std::function&lt; RT()&gt; &amp;function, internal::return_value&lt; RT &gt; &amp;ret_val)</div><div class="ttdef"><b>Definition:</b> <a href="thread__management_8h_source.html#l00346">thread_management.h:346</a></div></div>
<div class="ttc" id="namespaceFunctions_html"><div class="ttname"><a href="namespaceFunctions.html">Functions</a></div><div class="ttdef"><b>Definition:</b> <a href="flow__function_8h_source.html#l00029">flow_function.h:29</a></div></div>
<div class="ttc" id="classDifferentiation_1_1AD_1_1EnergyFunctional_html"><div class="ttname"><a href="classDifferentiation_1_1AD_1_1EnergyFunctional.html">Differentiation::AD::EnergyFunctional</a></div><div class="ttdef"><b>Definition:</b> <a href="ad__helpers_8h_source.html#l01218">ad_helpers.h:1218</a></div></div>
<div class="ttc" id="namespaceEvaluationFlags_html_a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1"><div class="ttname"><a href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">EvaluationFlags::gradients</a></div><div class="ttdef"><b>Definition:</b> <a href="evaluation__flags_8h_source.html#l00059">evaluation_flags.h:59</a></div></div>
<div class="ttc" id="namespacetypes_html"><div class="ttname"><a href="namespacetypes.html">types</a></div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00033">types.h:33</a></div></div>
<div class="ttc" id="namespaceUtilities_1_1MPI_html_ab544a3bf3301a6dd3e705ee352c5551b"><div class="ttname"><a href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a></div><div class="ttdeci">T sum(const T &amp;t, const MPI_Comm &amp;mpi_communicator)</div></div>
<div class="ttc" id="namespacestd__cxx17_html_aa2fc1031c06af4aea4de90c5a1905473"><div class="ttname"><a href="namespacestd__cxx17.html#aa2fc1031c06af4aea4de90c5a1905473">std_cxx17::apply</a></div><div class="ttdeci">auto apply(F &amp;&amp;fn, Tuple &amp;&amp;t) -&gt; decltype(apply_impl(std::forward&lt; F &gt;(fn), std::forward&lt; Tuple &gt;(t), std::make_index_sequence&lt; std::tuple_size&lt; typename std::remove_reference&lt; Tuple &gt;::type &gt;::value &gt;()))</div><div class="ttdef"><b>Definition:</b> <a href="tuple_8h_source.html#l00036">tuple.h:36</a></div></div>
<div class="ttc" id="namespaceDifferentiation_1_1AD_html_acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7"><div class="ttname"><a href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a></div></div>
<div class="ttc" id="namespaceMatrixTools_html"><div class="ttname"><a href="namespaceMatrixTools.html">MatrixTools</a></div><div class="ttdef"><b>Definition:</b> <a href="matrix__tools_8h_source.html#l00608">matrix_tools.h:608</a></div></div>
<div class="ttc" id="classMeshWorker_1_1ScratchData_html"><div class="ttname"><a href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData</a></div><div class="ttdef"><b>Definition:</b> <a href="scratch__data_8h_source.html#l00194">scratch_data.h:194</a></div></div>
<div class="ttc" id="namespaceVectorTools_html"><div class="ttname"><a href="namespaceVectorTools.html">VectorTools</a></div><div class="ttdef"><b>Definition:</b> <a href="vector__tools_8h_source.html#l00149">vector_tools.h:149</a></div></div>
<div class="ttc" id="structFEValuesExtractors_1_1Scalar_html"><div class="ttname"><a href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></div><div class="ttdef"><b>Definition:</b> <a href="fe__values__extractors_8h_source.html#l00078">fe_values_extractors.h:78</a></div></div>
<div class="ttc" id="namespacePhysics_1_1Elasticity_1_1Kinematics_html_a15728437b942dab0b0042eb06a407d2c"><div class="ttname"><a href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">Physics::Elasticity::Kinematics::d</a></div><div class="ttdeci">SymmetricTensor&lt; 2, dim, Number &gt; d(const Tensor&lt; 2, dim, Number &gt; &amp;F, const Tensor&lt; 2, dim, Number &gt; &amp;dF_dt)</div></div>
<div class="ttc" id="namespaceinternal_html_a2b3d48efdf7c94da455dc6a3553bab79"><div class="ttname"><a href="namespaceinternal.html#a2b3d48efdf7c94da455dc6a3553bab79">internal::assemble</a></div><div class="ttdeci">void assemble(const MeshWorker::DoFInfoBox&lt; dim, DOFINFO &gt; &amp;dinfo, A *assembler)</div><div class="ttdef"><b>Definition:</b> <a href="loop_8h_source.html#l00073">loop.h:73</a></div></div>
<div class="ttc" id="grid__out_8cc_html_a827a345f29da7caeb588b11013869a01"><div class="ttname"><a href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a></div><div class="ttdeci">Point&lt; 2 &gt; first</div><div class="ttdef"><b>Definition:</b> <a href="grid__out_8cc_source.html#l04587">grid_out.cc:4587</a></div></div>
<div class="ttc" id="namespaceAlgorithms_1_1Events_html_a15a12dfdadd39a026d192ad96cb6207b"><div class="ttname"><a href="namespaceAlgorithms_1_1Events.html#a15a12dfdadd39a026d192ad96cb6207b">Algorithms::Events::initial</a></div><div class="ttdeci">const Event initial</div><div class="ttdef"><b>Definition:</b> <a href="event_8cc_source.html#l00065">event.cc:65</a></div></div>
<div class="ttc" id="namespacetypes_html_a3543786f7dc7c57385fc923a6afd5917"><div class="ttname"><a href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></div><div class="ttdeci">unsigned int global_dof_index</div><div class="ttdef"><b>Definition:</b> <a href="types_8h_source.html#l00069">types.h:69</a></div></div>
<div class="ttc" id="namespaceVectorTools_html_af27ac28c698a9ed0199faed50a204538"><div class="ttname"><a href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a></div><div class="ttdeci">void interpolate_boundary_values(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; types::boundary_id, const Function&lt; spacedim, number &gt; *&gt; &amp;function_map, std::map&lt; types::global_dof_index, number &gt; &amp;boundary_values, const ComponentMask &amp;component_mask=ComponentMask())</div></div>
<div class="ttc" id="namespacenumbers_html_a3e24f194a9cb9b6ff4442b8a7a877d4a"><div class="ttname"><a href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a></div><div class="ttdeci">static constexpr double PI</div><div class="ttdef"><b>Definition:</b> <a href="numbers_8h_source.html#l00223">numbers.h:223</a></div></div>
<div class="ttc" id="group__feaccess_html_ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20"><div class="ttname"><a href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="ttdoc">Shape function gradients. </div><div class="ttdef"><b>Definition:</b> <a href="fe__update__flags_8h_source.html#l00068">fe_update_flags.h:68</a></div></div>
<div class="ttc" id="classFunctions_1_1ZeroFunction_html"><div class="ttname"><a href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction</a></div><div class="ttdef"><b>Definition:</b> <a href="function_8h_source.html#l00444">function.h:444</a></div></div>
<div class="ttc" id="classDoFHandler_html_a553ca864aaf70330d9be86bc78f36d1e"><div class="ttname"><a href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a></div><div class="ttdeci">void distribute_dofs(const FiniteElement&lt; dim, spacedim &gt; &amp;fe)</div><div class="ttdef"><b>Definition:</b> <a href="dof__handler_8cc_source.html#l02608">dof_handler.cc:2608</a></div></div>
<div class="ttc" id="classDoFHandler_html"><div class="ttname"><a href="classDoFHandler.html">DoFHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler_8h_source.html#l00184">dof_handler.h:184</a></div></div>
<div class="ttc" id="namespacenumbers_html"><div class="ttname"><a href="namespacenumbers.html">numbers</a></div><div class="ttdef"><b>Definition:</b> <a href="numbers_8h_source.html#l00187">numbers.h:187</a></div></div>
<div class="ttc" id="group__constraints_html_gaf78e864edbfba7e0a7477457bfb96b26"><div class="ttname"><a href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></div><div class="ttdeci">void make_sparsity_pattern(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const AffineConstraints&lt; number &gt; &amp;constraints=AffineConstraints&lt; number &gt;(), const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__sparsity_8cc_source.html#l00064">dof_tools_sparsity.cc:64</a></div></div>
<div class="ttc" id="classFEValues_html"><div class="ttname"><a href="classFEValues.html">FEValues</a></div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2fe_2fe_8h_source.html#l00039">fe.h:39</a></div></div>
<div class="ttc" id="namespaceOpenCASCADE_html_a9509efa83e3b2fa42616fe0623cba696"><div class="ttname"><a href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">OpenCASCADE::point</a></div><div class="ttdeci">Point&lt; spacedim &gt; point(const gp_Pnt &amp;p, const double tolerance=1e-10)</div><div class="ttdef"><b>Definition:</b> <a href="opencascade_2utilities_8cc_source.html#l00188">utilities.cc:188</a></div></div>
<div class="ttc" id="namespaceLAPACKSupport_html_a0d8802698d585eec62a2a54e6387b05b"><div class="ttname"><a href="namespaceLAPACKSupport.html#a0d8802698d585eec62a2a54e6387b05b">LAPACKSupport::zero</a></div><div class="ttdeci">static const types::blas_int zero</div><div class="ttdef"><b>Definition:</b> <a href="lapack__support_8h_source.html#l00193">lapack_support.h:193</a></div></div>
<div class="ttc" id="namespaceEvaluationFlags_html_a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58"><div class="ttname"><a href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">EvaluationFlags::values</a></div><div class="ttdef"><b>Definition:</b> <a href="evaluation__flags_8h_source.html#l00054">evaluation_flags.h:54</a></div></div>
<div class="ttc" id="p4est__wrappers_8cc_html_ace00f2f80d9780ef9aa1007e1c22c6a4"><div class="ttname"><a href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a></div><div class="ttdeci">const ::parallel::distributed::Triangulation&lt; dim, spacedim &gt; * triangulation</div><div class="ttdef"><b>Definition:</b> <a href="p4est__wrappers_8cc_source.html#l00069">p4est_wrappers.cc:69</a></div></div>
<div class="ttc" id="namespaceDifferentiation_1_1AD_html_acc1d0db17ec4125ac4e28f6ad2069b1ca3616da751c767b07051278ed7d81c0dc"><div class="ttname"><a href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca3616da751c767b07051278ed7d81c0dc">Differentiation::AD::NumberTypes::sacado_dfad</a></div></div>
<div class="ttc" id="classDifferentiation_1_1AD_1_1ResidualLinearization_html"><div class="ttname"><a href="classDifferentiation_1_1AD_1_1ResidualLinearization.html">Differentiation::AD::ResidualLinearization</a></div><div class="ttdef"><b>Definition:</b> <a href="ad__helpers_8h_source.html#l01529">ad_helpers.h:1529</a></div></div>
<div class="ttc" id="vectorization_8h_html_ad9b7aa5c50bf9ce988a0f756a3f2baa5"><div class="ttname"><a href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a></div><div class="ttdeci">inline ::VectorizedArray&lt; Number, width &gt; sin(const ::VectorizedArray&lt; Number, width &gt; &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="vectorization_8h_source.html#l05334">vectorization.h:5334</a></div></div>
<div class="ttc" id="namespaceinternal_1_1p4est_html_a4b980c7b4b4d9984e93d73c7d30173ea"><div class="ttname"><a href="namespaceinternal_1_1p4est.html#a4b980c7b4b4d9984e93d73c7d30173ea">internal::p4est::functions</a></div><div class="ttdeci">int(&amp;) functions(const void *v1, const void *v2)</div><div class="ttdef"><b>Definition:</b> <a href="p4est__wrappers_8cc_source.html#l00339">p4est_wrappers.cc:339</a></div></div>
<div class="ttc" id="group__constraints_html_ga3b4ea7dfd313e388d868c4e4aa685799"><div class="ttname"><a href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a></div><div class="ttdeci">void make_hanging_node_constraints(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, AffineConstraints&lt; number &gt; &amp;constraints)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__constraints_8cc_source.html#l01787">dof_tools_constraints.cc:1787</a></div></div>
<div class="ttc" id="vectorization_8h_html_a303f564e3c189251976da401ee2e44fa"><div class="ttname"><a href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a></div><div class="ttdeci">inline ::VectorizedArray&lt; Number, width &gt; sqrt(const ::VectorizedArray&lt; Number, width &gt; &amp;x)</div><div class="ttdef"><b>Definition:</b> <a href="vectorization_8h_source.html#l05442">vectorization.h:5442</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
