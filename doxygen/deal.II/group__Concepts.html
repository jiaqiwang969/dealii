<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/group__Concepts.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Concepts, or expectations on template parameters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Concepts, or expectations on template parameters</div>  </div>
</div><!--header-->
<div class="contents">
<p>有时对一个对象的类型施加约束而不要求它属于一个特定的继承层次是有用的。这些通常在C++社区中被称为 <em> 概念 </em> 。本模块列出了deal.II中常用的概念，并对其意图进行了简要描述。在deal.II中列出类型的约束条件的惯例是在模板中提供概念的名称作为 <code>typename</code> ：例如，矢量的类型取决于底层字段的类型，因此它被定义为模板。 </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Number&gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="classVector.html">Vector</a>;</div></div><!-- fragment --><p> 这里的重点是，你正在创建一个可以存储 <code>Number</code>. 类型元素的向量，但这上面有一些基本假设。例如，deal.II Vector类并不打算仅仅作为一个集合使用（与 <code>std::vector</code> 不同），而是定义了向量空间的操作，如向量的加法，或向量的规范。因此，用户可以为 <code>Number</code> 指定的数据类型必须满足某些条件（即，它必须符合或 "模拟 "一个 "概念"）。具体来说，该类型必须表示代表数学上称为 "场
"的元素的对象（你可以认为是，嗯，"数字"：我们可以加、乘、除、取绝对值的东西，等等）。概念的意义在于描述 <em> 一个类型必须满足哪些条件 </em> 才能在特定的环境中成为有效的模板参数。 本页描述了在整个deal.II中使用的一些概念的这些条件。具体来说，在上面的例子中，下面讨论的 <a class="el" href="group__Concepts.html#ConceptNumber">数字概念 </a> 描述了可以作为向量类的参数的类型。 概念作为C++的语言扩展已经被提议了很久了。它们将允许我们描述一个类或函数具有某些属性，以便成为一个合格的模板参数。例如，它允许我们在C++代码中表达，例如， <a class="el" href="namespaceGridTools.html#a1f49d6a42c3dbabc53a86571e874cc3f">GridTools::find_closest_vertex()</a>, 的第一个参数必须有一个代表实际网格的类型。</p>
<ul>
<li><p class="startli">目前我们只能用文字来描述，见下文。使用C++的概念将允许我们在代码中描述这一点，并且试图用一个对象作为第一参数来调用这样一个函数，但实际上它不是一个网格，这将产生一个编译器错误，使不匹配的情况变得清晰。 不幸的是，这些对C++的建议从未进入任何官方的C++标准；然而，它们被建议用于C++20。一旦我们的绝大多数用户拥有支持这一标准的编译器，我们可能会开始使用它们。 关于这个主题的更多信息可以在<a href="https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)">this wikipedia page</a>找到。</p>
<dl>
<dt class="concepts"><a class="anchor" id="ConceptDoFHandlerType"></a><b>DoFHandlerType</b>。 </dt>
<dd>deal.II包括DoFHandler和 <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> 这两个管理网格上自由度的对象。虽然两者没有任何继承关系，但它们足够相似，许多函数只需要类似于DoFHandler的东西就能正常工作。  </dd>
<dt class="concepts"><a class="anchor" id="ConceptMatrixType"></a><b>MatrixType</b>。 </dt>
<dd><p class="startdd">deal.II中的许多函数和类需要一个知道如何计算矩阵-向量积（成员函数 <code>vmult</code> ）、转置矩阵-向量积（成员函数 <code>Tvmult</code> ）以及 "乘法和加法 " 等效物的对象 <code>vmult_add</code> and <code>Tvmult_add</code> 。有些函数只需要 <code>vmult</code> and <code>Tvmult</code> ，但如果模板需要MatrixType参数的话，一个对象应该实现所有四个成员函数。编写满足这些条件的类是很常见的，所以编写LinearOperator类是为了让事情变得更简单；更多信息请参见 <a class="el" href="group__LAOperators.html">Linear Operators <h3>Linear Operator</h3>
</a> 。 对 <code>MatrixType</code> 的一种看法是，假装它是一个具有如下签名的基类（这几乎就是SparseMatrix提供的接口）。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MatrixType</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> vmult(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> Tvmult(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> vmult_add(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> Tvmult_add(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line">};</div></div><!-- fragment --><p class="enddd">C++中的模板函数不能是虚拟的（这是deal.II中不使用这种方法的主要原因），所以用继承的方式实现这个接口是行不通的，但这仍然是思考这个模板概念的一个好方法。人们可以使用LinearOperator类来实现 <code>vmult_add</code> and <code>Tvmult_add</code> ，而不是手动实现它们。  </p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptMeshType"></a><b>MeshType</b>。 </dt>
<dd>网格可以被认为是顶点和连接点的数组，但一个更有成效的观点是将它们视为<em>collections of cells</em>。在C++中，集合通常被称为<em>containers</em>（典型的容器是 std::vector, std::list, 等），它们的特点是能够对集合中的元素进行迭代。<code>MeshType</code>概念是指任何定义了适当方法（如 <a class="el" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">DoFHandler::begin_active()</a>) 和<code>typedefs</code>（如 <a class="el" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler::active_cell_iterator</a>) ）的容器，用于管理单元的集合。 Triangulation、DoFHandler和 <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> 的实例都可以被视为单元格的容器。事实上，这些类的公共接口中最重要的部分仅仅由获得其元素的迭代器的能力组成。由于接口的这些部分是通用的，也就是说，这些函数在所有的类中都有相同的名字，所以可以编写一些操作，这些操作实际上并不关心它们是在三角化还是在DoF处理对象上工作。例如，在GridTools命名空间中就有大量的例子，强调了网格和DoF处理程序都可以简单地被视为单元格的集合（容器）这一抽象的力量。 另一方面，网格是不同于 std::vector 或 std::list 的非标准容器，因为它们可以以多种方式被切分。例如，我们可以在活动单元的子集上迭代，也可以在所有单元上迭代；同样，单元被组织成层次，我们可以只为一个层次上的单元获得迭代器范围。然而，一般来说，所有实现单元格容器概念的类都使用相同的函数名称来提供相同的功能。 可以用任何一个类来调用的函数通过接受一个模板参数来表示，例如 <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keywordtype">int</span>, <span class="keywordtype">int</span>&gt; <span class="keyword">class </span>MeshType&gt;</div></div><!-- fragment --> 或 <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MeshType&gt;</div></div><!-- fragment --> 满足这个概念的类被统称为 <em> 网格类 </em> 。<code>MeshType</code>的确切定义在很大程度上依赖于库的内部结构，但它可以被概括为具有以下属性的任何类。 <ol>
<li>
一个名为<code>typedef</code>的<code>active_cell_iterator</code>。  </li>
<li>
一个<code>get_triangulation()</code>方法，返回单元格集合的基础几何描述（Triangulation类之一）的引用。如果网格恰好是一个Triangulation，那么网格只是返回一个对其本身的引用。  </li>
<li>
一个方法<code>begin_active()</code>，返回一个指向第一个活动单元的迭代器。  </li>
<li>
一个静态成员值<code>dimension</code>，包含对象所处的维度。  </li>
<li>
一个静态成员值<code>space_dimension</code>，包含对象的维度（例如，一个2D表面在3D环境中会有<code>space_dimension = 2</code>）。  </li>
</ol>
。 </dd>
<dt class="concepts"><a class="anchor" id="ConceptNumber"></a><b>Number</b>。 </dt>
<dd>这个概念描述了作为向量或矩阵条目有意义的标量，这通常是场元素的一些有限精度的近似。典型的例子是 <code>double</code> 和 <code>float</code>, but deal.II supports <code>std::complex&lt;T&gt;</code> 的浮点类型 <code>T</code> 在很多地方也是如此。  </dd>
<dt class="concepts"><a class="anchor" id="ConceptPolynomialType"></a><b>PolynomialType</b>。 </dt>
<dd><p class="startdd">更多信息见 <a class="el" href="group__Polynomials.html">Polynomials and polynomial spaces</a> 中的描述。在某些情况下，任何满足类似于接口的 </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PolynomialType</div><div class="line">{</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> compute (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>            &amp;unit_point,</div><div class="line">                      std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt; &amp;values,</div><div class="line">                      std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt; &amp;grads,</div><div class="line">                      std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;3,dim&gt;</a> &gt; &amp;grad_grads) <span class="keyword">const</span> =0;</div><div class="line">}</div></div><!-- fragment --><p class="enddd">为了实现有限元的目的，可将其视为多项式。  </p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptPreconditionerType"></a><b>PreconditionerType</b>。 </dt>
<dd>这基本上是 <code>MatrixType</code> 的同义词，但通常只要求定义 <code>vmult()</code> and <code>Tvmult()</code> 。大多数时候，定义 <code>Tvmult()</code> 是不必要的。人们应该认为 <code>vmult()</code> 是将线性算子的逆运算应用于向量的一些近似值，而不是线性算子对向量的作用，用于预处理器类。  </dd>
<dt class="concepts"><a class="anchor" id="ConceptRelaxationType"></a><b>RelaxationType</b>。 </dt>
<dd>这是一个能够对多网格方法进行放松的对象。我们可以认为满足这个约束的对象具有以下接口以及 <a class="el" href="group__Concepts.html#ConceptMatrixType">MatrixType </a> 所要求的约束。 <div class="fragment"><div class="line"><span class="keyword">class </span>RelaxationType</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> step(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> Tstep(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line">};</div></div><!-- fragment --> 其中这两个成员函数执行平滑方案的一个步骤（或这种步骤的转置）。换句话说，这些函数执行的操作是 \(u = u - P^{-1} (A u - v)\) 和 \(u = u - P^{-T} (A u - v)\) 。  </dd>
<dt class="concepts"><a class="anchor" id="ConceptSparsityPatternType"></a><b>SparsityPatternType</b>。 </dt>
<dd>几乎所有的函数（除了 <a class="el" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>) 这个明显的例外）都以稀疏性模式为参数，可以采用常规的SparsityPattern或DynamicSparsityPattern，甚至是块状稀疏性模式之一。更多信息见 <a class="el" href="group__Sparsity.html">Sparsity patterns</a> 。  </dd>
<dt class="concepts"><a class="anchor" id="ConceptStreamType"></a><b>StreamType</b>。 </dt>
<dd>在C++中派生新的流类，众所周知是很困难的。为了解决这个问题，一些函数接受一个定义了 <code>operator&lt;&lt;</code> 的参数，这样就可以轻松地输出到任何一种输出流。  </dd>
<dt class="concepts"><a class="anchor" id="ConceptVectorType"></a><b>VectorType</b>。 </dt>
<dd>deal.II支持许多不同的向量类，包括与其他库的向量的绑定。这些与标准库中的向量类似（即它们定义了 <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">begin()</a></code>, <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end()</a></code> , <code>operator[]</code>, and <code>size()</code> ），但也定义了像 <code>add()</code> 这样的数字操作。VectorType的一些例子包括Vector, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>, 和 BlockVector。  </dd>
</dl>
</li>
</ul>
<p>Sometimes imposing constraints on the type of an object without requiring it to belong to a specific inheritance hierarchy is useful. These are usually referred to as <em>concepts</em> in the C++ community. This module lists the concepts commonly used in deal.II with brief descriptions of their intent. The convention in deal.II for listing constraints on a type is to provide the name of the concept as a <code>typename</code> in a template: for example, the type of a <a class="el" href="classVector.html">Vector</a> depends on the type of the underlying field, and so it is defined as a template: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Number&gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="classVector.html">Vector</a>;</div></div><!-- fragment --><p> The point here is that you are creating a vector that can store elements of type <code>Number</code>. But there are some underlying assumptions on this. For example, the deal.II <a class="el" href="classVector.html">Vector</a> class is not intended to be used just as a collection (unlike <code>std::vector</code>) but defines vector space operations such as addition of vectors, or the norm of vectors. Consequently, the data type users can specify for <code>Number</code> must satisfy certain conditions (i.e., it must conform to or "model" a "concept"): Specifically, the type must denote objects that represent the elements of what mathematically call a "field" (which you can think of as, well, "numbers": things we can add, multiply, divide, take the absolute value of, etc). The point of a concept is then to describe <em>what conditions a type must satisfy</em> to be a valid template argument in a given context.</p>
<p>This page describes these conditions for a number of concepts used throughout deal.II. Specifically, in the example above, the <a class="el" href="group__Concepts.html#ConceptNumber">Number concept</a> discussed below describes the types that could be used as argument for the <a class="el" href="classVector.html">Vector</a> class.</p>
<p>Concepts have been proposed as a language extension to C++ for a long time already. They would allow us to describe that a class or function has certain properties in order to be a qualified template argument. For example, it would allow us to express in C++ code that the first argument to, say, <a class="el" href="namespaceGridTools.html#a1f49d6a42c3dbabc53a86571e874cc3f">GridTools::find_closest_vertex()</a>, must have a type that represents an actual mesh &ndash; which we can currently only describe in words, see below. Using C++ concepts would allow us to describe this in code and trying to call such a function with an object as first argument that is not, in fact, a mesh would yield a compiler error that makes the mismatch clear.</p>
<p>Unfortunately, these proposals to C++ have never made it into any official C++ standard; they are proposed for C++20 however. We may start to use them once the vast majority of our users have compilers that support this standard.</p>
<p>More information on the topic can be found at <a href="https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)">this wikipedia page</a>.</p>
<dl>
<dt class="concepts"><a class="anchor" id="ConceptDoFHandlerType"></a><b>DoFHandlerType</b> </dt>
<dd><p class="startdd">deal.II includes both <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> as objects which manage degrees of freedom on a mesh. Though the two do not share any sort of inheritance relationship, they are similar enough that many functions just need something which resembles a <a class="el" href="classDoFHandler.html">DoFHandler</a> to work correctly. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptMatrixType"></a><b>MatrixType</b> </dt>
<dd><p class="startdd">Many functions and classes in deal.II require an object which knows how to calculate matrix-vector products (the member function <code>vmult</code>), transposed matrix-vector products (the member function <code>Tvmult</code>), as well as the `multiply and add' equivalents <code>vmult_add</code> and <code>Tvmult_add</code>. Some functions only require <code>vmult</code> and <code>Tvmult</code>, but an object should implement all four member functions if the template requires a MatrixType argument. Writing classes that satisfy these conditions is a sufficiently common occurrence that the <a class="el" href="classLinearOperator.html">LinearOperator</a> class was written to make things easier; see <a class="el" href="group__LAOperators.html">Linear Operators <h3>Linear Operator</h3>
</a> for more information.</p>
<p>One way to think of <code>MatrixType</code> is to pretend it is a base class with the following signature (this is nearly the interface provided by <a class="el" href="classSparseMatrix.html">SparseMatrix</a>):</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MatrixType</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> vmult(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Tvmult(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> vmult_add(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Tvmult_add(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line">};</div></div><!-- fragment --><p>Template functions in C++ cannot be virtual (which is the main reason why this approach is not used in deal.II), so implementing this interface with inheritance will not work, but it is still a good way to think about this template concept. One can use the <a class="el" href="classLinearOperator.html">LinearOperator</a> class to implement <code>vmult_add</code> and <code>Tvmult_add</code> instead of implementing them manually. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptMeshType"></a><b>MeshType</b> </dt>
<dd><p class="startdd">Meshes can be thought of as arrays of vertices and connectivities, but a more fruitful view is to consider them as <em>collections of cells</em>. In C++, collections are often called <em>containers</em> (typical containers are std::vector, std::list, etc.) and they are characterized by the ability to iterate over the elements of the collection. The <code>MeshType</code> concept refers to any container which defines appropriate methods (such as <a class="el" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">DoFHandler::begin_active()</a>) and <code>typedefs</code> (such as <a class="el" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler::active_cell_iterator</a>) for managing collections of cells.</p>
<p>Instances of <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> may all be considered as containers of cells. In fact, the most important parts of the public interface of these classes consists simply of the ability to get iterators to their elements. Since these parts of the interface are generic, i.e., the functions have the same name in all classes, it is possible to write operations that do not actually care whether they work on a triangulation or a DoF handler object. Examples abound, for example, in the <a class="el" href="namespaceGridTools.html">GridTools</a> namespace, underlining the power of the abstraction that meshes and DoF handlers can all be considered simply as collections (containers) of cells.</p>
<p>On the other hand, meshes are non-standard containers unlike std::vector or std::list in that they can be sliced several ways. For example, one can iterate over the subset of active cells or over all cells; likewise, cells are organized into levels and one can get iterator ranges for only the cells on one level. Generally, however, all classes that implement the containers-of-cells concept use the same function names to provide the same functionality.</p>
<p>Functions that may be called with either class indicate this by accepting a template parameter like </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keywordtype">int</span>, <span class="keywordtype">int</span>&gt; <span class="keyword">class </span>MeshType&gt;</div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MeshType&gt;</div></div><!-- fragment --><p> The classes that satisfy this concept are collectively referred to as <em>mesh classes</em>. The exact definition of <code>MeshType</code> relies a lot on library internals, but it can be summarized as any class with the following properties: </p><ol>
<li>
A <code>typedef</code> named <code>active_cell_iterator</code>.  </li>
<li>
A method <code>get_triangulation()</code> which returns a reference to the underlying geometrical description (one of the <a class="el" href="classTriangulation.html">Triangulation</a> classes) of the collection of cells. If the mesh happens to be a <a class="el" href="classTriangulation.html">Triangulation</a>, then the mesh just returns a reference to itself.  </li>
<li>
A method <code>begin_active()</code> which returns an iterator pointing to the first active cell.  </li>
<li>
A static member value <code>dimension</code> containing the dimension in which the object lives.  </li>
<li>
A static member value <code>space_dimension</code> containing the dimension of the object (e.g., a 2D surface in a 3D setting would have <code>space_dimension = 2</code>).  </li>
</ol>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptNumber"></a><b>Number</b> </dt>
<dd><p class="startdd">This concept describes scalars which make sense as vector or matrix entries, which is usually some finite precision approximation of a field element. The canonical examples are <code>double</code> and <code>float</code>, but deal.II supports <code>std::complex&lt;T&gt;</code> for floating point type <code>T</code> in many places as well. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptPolynomialType"></a><b>PolynomialType</b> </dt>
<dd><p class="startdd">See the description in <a class="el" href="group__Polynomials.html">Polynomials and polynomial spaces</a> for more information. In some contexts, anything that satisfies the interface resembling </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PolynomialType</div><div class="line">{</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> compute (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>            &amp;unit_point,</div><div class="line">                        std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt; &amp;values,</div><div class="line">                        std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt; &amp;grads,</div><div class="line">                        std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;3,dim&gt;</a> &gt; &amp;grad_grads) <span class="keyword">const</span> =0;</div><div class="line">}</div></div><!-- fragment --><p>may be considered as a polynomial for the sake of implementing finite elements. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptPreconditionerType"></a><b>PreconditionerType</b> </dt>
<dd><p class="startdd">This is essentially a synonym for <code>MatrixType</code>, but usually only requires that <code>vmult()</code> and <code>Tvmult()</code> be defined. Most of the time defining <code>Tvmult()</code> is not necessary. One should think of <code>vmult()</code> as applying some approximation of the inverse of a linear operator to a vector, instead of the action of a linear operator to a vector, for the preconditioner classes. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptRelaxationType"></a><b>RelaxationType</b> </dt>
<dd><p class="startdd">This is an object capable of relaxation for multigrid methods. One can think of an object satisfying this constraint as having the following interface as well as the constraints required by <a class="el" href="group__Concepts.html#ConceptMatrixType">MatrixType</a>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>RelaxationType</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> step(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Tstep(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line">};</div></div><!-- fragment --><p> where these two member functions perform one step (or the transpose of such a step) of the smoothing scheme. In other words, the operations performed by these functions are \(u = u - P^{-1} (A u - v)\) and \(u = u - P^{-T} (A u - v)\). </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptSparsityPatternType"></a><b>SparsityPatternType</b> </dt>
<dd><p class="startdd">Almost all functions (with the notable exception of <a class="el" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>) which take a sparsity pattern as an argument can take either a regular <a class="el" href="classSparsityPattern.html">SparsityPattern</a> or a <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>, or even one of the block sparsity patterns. See <a class="el" href="group__Sparsity.html">Sparsity patterns</a> for more information. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptStreamType"></a><b>StreamType</b> </dt>
<dd><p class="startdd">Deriving new stream classes in C++ is well-known to be difficult. To get around this, some functions accept a parameter which defines <code>operator&lt;&lt;</code>, which allows for easy output to any kind of output stream. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptVectorType"></a><b>VectorType</b> </dt>
<dd><p class="startdd">deal.II supports many different vector classes, including bindings to vectors in other libraries. These are similar to standard library vectors (i.e., they define <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">begin()</a></code>, <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end()</a></code>, <code>operator[]</code>, and <code>size()</code>) but also define numerical operations like <code>add()</code>. Some examples of VectorType include <a class="el" href="classVector.html">Vector</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>, and <a class="el" href="classBlockVector.html">BlockVector</a>. </p>
<p class="enddd"></p>
</dd>
</dl>
<p>Sometimes imposing constraints on the type of an object without requiring it to belong to a specific inheritance hierarchy is useful. These are usually referred to as <em> concepts </em> in the C++ community. This module lists the concepts commonly used in deal.II with brief descriptions of their intent. The convention in deal.II for listing constraints on a type is to provide the name of the concept as a <code>typename</code> in a template: for example, the type of a <a class="el" href="classVector.html">Vector</a> depends on the type of the underlying field, and so it is defined as a template:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Number&gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="classVector.html">Vector</a>;</div></div><!-- fragment --><p> The point here is that you are creating a vector that can store elements of type <code>Number</code>. But there are some underlying assumptions on this. For example, the deal.II <a class="el" href="classVector.html">Vector</a> class is not intended to be used just as a collection (unlike <code>std::vector</code> ) but defines vector space operations such as addition of vectors, or the norm of vectors. Consequently, the data type users can specify for <code>Number</code> must satisfy certain conditions (i.e., it must conform to or "model" a "concept"): Specifically, the type must denote objects that represent the elements of what mathematically call a "field" (which you can think of as, well, "numbers": things we can add, multiply, divide, take the absolute value of, etc). The point of a concept is then to describe <em> what conditions a type must satisfy </em> to be a valid template argument in a given context. This page describes these conditions for a number of concepts used throughout deal.II. Specifically, in the example above, the <a class="el" href="group__Concepts.html#ConceptNumber">Number concept</a> discussed below describes the types that could be used as argument for the <a class="el" href="classVector.html">Vector</a> class. Concepts have been proposed as a language extension to C++ for a long time already. They would allow us to describe that a class or function has certain properties in order to be a qualified template argument. For example, it would allow us to express in C++ code that the first argument to, say, <a class="el" href="namespaceGridTools.html#a1f49d6a42c3dbabc53a86571e874cc3f">GridTools::find_closest_vertex()</a>, must have a type that represents an actual mesh</p>
<ul>
<li>which we can currently only describe in words, see below. Using C++ concepts would allow us to describe this in code and trying to call such a function with an object as first argument that is not, in fact, a mesh would yield a compiler error that makes the mismatch clear. Unfortunately, these proposals to C++ have never made it into any official C++ standard; they are proposed for C++20 however. We may start to use them once the vast majority of our users have compilers that support this standard. More information on the topic can be found at <a href="https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)">this wikipedia page</a>.</li>
</ul>
<dl>
<dt class="concepts"><a class="anchor" id="ConceptDoFHandlerType"></a><b>DoFHandlerType</b> </dt>
<dd>deal.II includes both <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> as objects which manage degrees of freedom on a mesh. Though the two do not share any sort of inheritance relationship, they are similar enough that many functions just need something which resembles a <a class="el" href="classDoFHandler.html">DoFHandler</a> to work correctly.  </dd>
<dt class="concepts"><a class="anchor" id="ConceptMatrixType"></a><b>MatrixType</b> </dt>
<dd><p class="startdd">Many functions and classes in deal.II require an object which knows how to calculate matrix-vector products (the member function <code>vmult</code> ), transposed matrix-vector products (the member function <code>Tvmult</code> ), as well as the `multiply and add' equivalents <code>vmult_add</code> and <code>Tvmult_add</code> . Some functions only require <code>vmult</code> and <code>Tvmult</code> , but an object should implement all four member functions if the template requires a MatrixType argument. Writing classes that satisfy these conditions is a sufficiently common occurrence that the <a class="el" href="classLinearOperator.html">LinearOperator</a> class was written to make things easier; see <a class="el" href="group__LAOperators.html">Linear Operators <h3>Linear Operator</h3>
</a> for more information. One way to think of <code>MatrixType</code> is to pretend it is a base class with the following signature (this is nearly the interface provided by <a class="el" href="classSparseMatrix.html">SparseMatrix</a>):</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MatrixType</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> vmult(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> Tvmult(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> vmult_add(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> Tvmult_add(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line">};</div></div><!-- fragment --><p class="enddd">Template functions in C++ cannot be virtual (which is the main reason why this approach is not used in deal.II), so implementing this interface with inheritance will not work, but it is still a good way to think about this template concept. One can use the <a class="el" href="classLinearOperator.html">LinearOperator</a> class to implement <code>vmult_add</code> and <code>Tvmult_add</code> instead of implementing them manually.  </p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptMeshType"></a><b>MeshType</b> </dt>
<dd><p class="startdd">Meshes can be thought of as arrays of vertices and connectivities, but a more fruitful view is to consider them as <em>collections of cells</em>. In C++, collections are often called <em>containers</em> (typical containers are std::vector, std::list, etc.) and they are characterized by the ability to iterate over the elements of the collection. The <code>MeshType</code> concept refers to any container which defines appropriate methods (such as <a class="el" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">DoFHandler::begin_active()</a>) and <code>typedefs</code> (such as <a class="el" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler::active_cell_iterator</a>) for managing collections of cells. Instances of <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> may all be considered as containers of cells. In fact, the most important parts of the public interface of these classes consists simply of the ability to get iterators to their elements. Since these parts of the interface are generic, i.e., the functions have the same name in all classes, it is possible to write operations that do not actually care whether they work on a triangulation or a DoF handler object. Examples abound, for example, in the <a class="el" href="namespaceGridTools.html">GridTools</a> namespace, underlining the power of the abstraction that meshes and DoF handlers can all be considered simply as collections (containers) of cells. On the other hand, meshes are non-standard containers unlike std::vector or std::list in that they can be sliced several ways. For example, one can iterate over the subset of active cells or over all cells; likewise, cells are organized into levels and one can get iterator ranges for only the cells on one level. Generally, however, all classes that implement the containers-of-cells concept use the same function names to provide the same functionality. Functions that may be called with either class indicate this by accepting a template parameter like</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keywordtype">int</span>, <span class="keywordtype">int</span>&gt; <span class="keyword">class </span>MeshType&gt;</div></div><!-- fragment --><p> or</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MeshType&gt;</div></div><!-- fragment --><p> The classes that satisfy this concept are collectively referred to as <em> mesh classes </em> . The exact definition of <code>MeshType</code> relies a lot on library internals, but it can be summarized as any class with the following properties: </p><ol>
<li>
A <code>typedef</code> named <code>active_cell_iterator</code>.  </li>
<li>
A method <code>get_triangulation()</code> which returns a reference to the underlying geometrical description (one of the <a class="el" href="classTriangulation.html">Triangulation</a> classes) of the collection of cells. If the mesh happens to be a <a class="el" href="classTriangulation.html">Triangulation</a>, then the mesh just returns a reference to itself.  </li>
<li>
A method <code>begin_active()</code> which returns an iterator pointing to the first active cell.  </li>
<li>
A static member value <code>dimension</code> containing the dimension in which the object lives.  </li>
<li>
A static member value <code>space_dimension</code> containing the dimension of the object (e.g., a 2D surface in a 3D setting would have <code>space_dimension = 2</code>).  </li>
</ol>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptNumber"></a><b>Number</b> </dt>
<dd>This concept describes scalars which make sense as vector or matrix entries, which is usually some finite precision approximation of a field element. The canonical examples are <code>double</code> and <code>float</code>, but deal.II supports <code>std::complex&lt;T&gt;</code> for floating point type <code>T</code> in many places as well.  </dd>
<dt class="concepts"><a class="anchor" id="ConceptPolynomialType"></a><b>PolynomialType</b> </dt>
<dd><p class="startdd">See the description in <a class="el" href="group__Polynomials.html">Polynomials and polynomial spaces</a> for more information. In some contexts, anything that satisfies the interface resembling</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PolynomialType</div><div class="line">{</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> compute (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>            &amp;unit_point,</div><div class="line">                      std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt; &amp;values,</div><div class="line">                      std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt; &amp;grads,</div><div class="line">                      std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;3,dim&gt;</a> &gt; &amp;grad_grads) <span class="keyword">const</span> =0;</div><div class="line">}</div></div><!-- fragment --><p class="enddd">may be considered as a polynomial for the sake of implementing finite elements.  </p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptPreconditionerType"></a><b>PreconditionerType</b> </dt>
<dd>This is essentially a synonym for <code>MatrixType</code> , but usually only requires that <code>vmult()</code> and <code>Tvmult()</code> be defined. Most of the time defining <code>Tvmult()</code> is not necessary. One should think of <code>vmult()</code> as applying some approximation of the inverse of a linear operator to a vector, instead of the action of a linear operator to a vector, for the preconditioner classes.  </dd>
<dt class="concepts"><a class="anchor" id="ConceptRelaxationType"></a><b>RelaxationType</b> </dt>
<dd><p class="startdd">This is an object capable of relaxation for multigrid methods. One can think of an object satisfying this constraint as having the following interface as well as the constraints required by <a class="el" href="group__Concepts.html#ConceptMatrixType">MatrixType</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>RelaxationType</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> step(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> Tstep(VectorType &amp;u, <span class="keyword">const</span> VectorType &amp;v) <span class="keyword">const</span> =0;</div><div class="line">};</div></div><!-- fragment --><p> where these two member functions perform one step (or the transpose of such a step) of the smoothing scheme. In other words, the operations performed by these functions are \(u = u - P^{-1} (A u - v)\) and \(u = u - P^{-T} (A u - v)\) .  </p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptSparsityPatternType"></a><b>SparsityPatternType</b> </dt>
<dd>Almost all functions (with the notable exception of <a class="el" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>) which take a sparsity pattern as an argument can take either a regular <a class="el" href="classSparsityPattern.html">SparsityPattern</a> or a <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>, or even one of the block sparsity patterns. See <a class="el" href="group__Sparsity.html">Sparsity patterns</a> for more information.  </dd>
<dt class="concepts"><a class="anchor" id="ConceptStreamType"></a><b>StreamType</b> </dt>
<dd>Deriving new stream classes in C++ is well-known to be difficult. To get around this, some functions accept a parameter which defines <code>operator&lt;&lt;</code> , which allows for easy output to any kind of output stream.  </dd>
<dt class="concepts"><a class="anchor" id="ConceptVectorType"></a><b>VectorType</b> </dt>
<dd>deal.II supports many different vector classes, including bindings to vectors in other libraries. These are similar to standard library vectors (i.e., they define <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">begin()</a></code>, <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end()</a></code> , <code>operator[]</code>, and <code>size()</code> ) but also define numerical operations like <code>add()</code> . Some examples of VectorType include <a class="el" href="classVector.html">Vector</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>, and <a class="el" href="classBlockVector.html">BlockVector</a>.  </dd>
</dl>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
