<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_2.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-2 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-2 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_1.html">step-1</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Sparsity"> Sparsity </a>
        <li><a href="#Howdegreesoffreedomareenumerated"> How degrees of freedom are enumerated </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Meshgeneration">Mesh generation</a>
        <li><a href="#CreationofaDoFHandler">Creation of a DoFHandler</a>
        <li><a href="#RenumberingofDoFs">Renumbering of DoFs</a>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.9.html">video lecture 9</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p>After we have created a grid in the previous example, we now show how to define degrees of freedom on this mesh. For this example, we will use the lowest order ( \(Q_1\)) finite elements, for which the degrees of freedom are associated with the vertices of the mesh. Later examples will demonstrate higher order elements where degrees of freedom are not necessarily associated with vertices any more, but can be associated with edges, faces, or cells.</p>
<p>The term "degree of freedom" is commonly used in the finite element community to indicate two slightly different, but related things. The first is that we'd like to represent the finite element solution as a linear combination of shape functions, in the form \(u_h(\mathbf x) = \sum_{j=0}^{N-1} U_j \varphi_j(\mathbf x)\). Here, \(U_j\) is a vector of expansion coefficients. Because we don't know their values yet (we will compute them as the solution of a linear or nonlinear system), they are called "unknowns" or "degrees of freedom". The second meaning of the term can be explained as follows: A mathematical description of finite element problems is often to say that we are looking for a finite dimensional function \(u_h \in V_h\) that satisfies some set of equations (e.g. \(a(u_h,\varphi_h)=(f,\varphi_h)\) for all test functions \(\varphi_h\in V_h\)). In other words, all we say here that the solution needs to lie in some space \(V_h\). However, to actually solve this problem on a computer we need to choose a basis of this space; this is the set of shape functions \(\varphi_j(\mathbf x)\) we have used above in the expansion of \(u_h(\mathbf x)\) with coefficients \(U_j\). There are of course many bases of the space \(V_h\), but we will specifically choose the one that is described by the finite element functions that are traditionally defined locally on the cells of the mesh. Describing "degrees of freedom" in this context requires us to simply <em>enumerate</em> the basis functions of the space \(V_h\). For \(Q_1\) elements this means simply enumerating the vertices of the mesh in some way, but for higher order elements, one also has to enumerate the shape functions that are associated with edges, faces, or cell interiors of the mesh. In other words, the enumeration of degrees of freedom is an entirely separate thing from the indices we use for vertices. The class that provides this enumeration of the basis functions of \(V_h\) is called <a class="el" href="classDoFHandler.html">DoFHandler</a>.</p>
<p>Defining degrees of freedom ("DoF"s in short) on a mesh is a rather simple task, since the library does all the work for you. Essentially, all you have to do is create a finite element object (from one of the many finite element classes deal.II already has, see for example the <a class="el" href="group__fe.html">Finite element space descriptions</a> documentation) and give it to a <a class="el" href="classDoFHandler.html">DoFHandler</a> object through the <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a> function ("distributing DoFs" is the term we use to describe the process of <em>enumerating</em> the basis functions as discussed above). The <a class="el" href="classDoFHandler.html">DoFHandler</a> is a class that knows which degrees of freedom live where, i.e., it can answer questions like "how many degrees of freedom are there globally" and "on this cell, give me the global indices of the shape functions that
live here". This is the sort of information you need when determining how big your system matrix should be, and when copying the contributions of a single cell into the global matrix.</p>
<p><a class="anchor" id="Sparsity"></a></p><h3>Sparsity </h3>
<p>The next step would then be to compute a matrix and right hand side corresponding to a particular differential equation using this finite element and mesh. We will keep this step for the <a class="el" href="step_3.html">step-3</a> program and rather talk about one practical aspect of a finite element program, namely that finite element matrices are always very sparse: almost all entries in these matrices are zero.</p>
<p>To be more precise, we say that a matrix is sparse if the number of nonzero entries <em>per row</em> in the matrix is bounded by a number that is independent of the overall number of degrees of freedom. For example, the simple 5-point stencil of a finite difference approximation of the Laplace equation leads to a sparse matrix since the number of nonzero entries per row is five, and therefore independent of the total size of the matrix. For more complicated problems &ndash; say, the Stokes problem of <a class="el" href="step_22.html">step-22</a> &ndash; and in particular in 3d, the number of entries per row may be several hundred. But the important point is that this number is independent of the overall size of the problem: If you refine the mesh, the maximal number of unknowns per row remains the same.</p>
<p>Sparsity is one of the distinguishing feature of the finite element method compared to, say, approximating the solution of a partial differential equation using a Taylor expansion and matching coefficients, or using a Fourier basis.</p>
<p>In practical terms, it is the sparsity of matrices that enables us to solve problems with millions or billions of unknowns. To understand this, note that a matrix with \(N\) rows, each with a fixed upper bound for the number of nonzero entries, requires \({\cal O}(N)\) memory locations for storage, and a matrix-vector multiplication also requires only \({\cal O}(N)\) operations. Consequently, if we had a linear solver that requires only a fixed number of matrix-vector multiplications to come up with the solution of a linear system with this matrix, then we would have a solver that can find the values of all \(N\) unknowns with optimal complexity, i.e., with a total of \({\cal O}(N)\) operations. It is clear that this wouldn't be possible if the matrix were not sparse (because then the number of entries in the matrix would have to be \({\cal O}(N^s)\) with some \(s&gt;1\), and doing a fixed number of matrix-vector products would take \({\cal O}(N^s)\) operations), but it also requires very specialized solvers such as multigrid methods to satisfy the requirement that the solution requires only a fixed number of matrix-vector multiplications. We will frequently look at the question of what solver to use in the remaining programs of this tutorial.</p>
<p>The sparsity is generated by the fact that finite element shape functions are defined <em>locally</em> on individual cells, rather than globally, and that the local differential operators in the bilinear form only couple shape functions whose support overlaps. (The "support" of a function is the area where it is nonzero. For the finite element method, the support of a shape function is generally the cells adjacent to the vertex, edge, or face it is defined on.) In other words, degrees of freedom \(i\) and \(j\) that are not defined on the same cell do not overlap, and consequently the matrix entry \(A_{ij}\) will be zero. (In some cases such as the Discontinuous Galerkin method, shape functions may also connect to neighboring cells through face integrals. But finite element methods do not generally couple shape functions beyond the immediate neighbors of a cell on which the function is defined.)</p>
<p><a class="anchor" id="Howdegreesoffreedomareenumerated"></a></p><h3>How degrees of freedom are enumerated </h3>
<p>By default, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class enumerates degrees of freedom on a mesh in a rather random way; consequently, the sparsity pattern is also not optimized for any particular purpose. To show this, the code below will demonstrate a simple way to output the "sparsity pattern" that corresponds to a <a class="el" href="classDoFHandler.html">DoFHandler</a>, i.e., an object that represents all of the potentially nonzero elements of a matrix one may build when discretizing a partial differential equation on a mesh and its <a class="el" href="classDoFHandler.html">DoFHandler</a>. This lack of structure in the sparsity pattern will be apparent from the pictures we show below.</p>
<p>For most applications and algorithms, the exact way in which degrees of freedom are numbered does not matter. For example, the Conjugate Gradient method we use to solve linear systems does not care. On the other hand, some algorithms do care: in particular, some preconditioners such as SSOR will work better if they can walk through degrees of freedom in a particular order, and it would be nice if we could just sort them in such a way that SSOR can iterate through them from zero to \(N\) in this order. Other examples include computing incomplete LU or Cholesky factorizations, or if we care about the block structure of matrices (see <a class="el" href="step_20.html">step-20</a> for an example). deal.II therefore has algorithms that can re-enumerate degrees of freedom in particular ways in namespace <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a>. Renumbering can be thought of as choosing a different, permuted basis of the finite element space. The sparsity pattern and matrices that result from this renumbering are therefore also simply a permutation of rows and columns compared to the ones we would get without explicit renumbering.</p>
<p>In the program below, we will use the algorithm of Cuthill and McKee to do so. We will show the sparsity pattern for both the original enumeration of degrees of freedom and of the renumbered version below, in the <a href="#Results">results section</a>.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>The first few includes are just like in the previous program, so do not require additional comments:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div></div><!-- fragment --><p>However, the next file is new. We need this include file for the association of degrees of freedom ("DoF"s) to vertices, lines, and cells:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div></div><!-- fragment --><p>The following include contains the description of the bilinear finite element, including the facts that it has one degree of freedom on each vertex of the triangulation, but none on faces and none in the interior of the cells.</p>
<p>(In fact, the file contains the description of Lagrange elements in general, i.e. also the quadratic, cubic, etc versions, and not only for 2d but also 1d and 3d.)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div></div><!-- fragment --><p>In the following file, several tools for manipulating degrees of freedom can be found:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div></div><!-- fragment --><p>We will use a sparse matrix to visualize the pattern of nonzero entries resulting from the distribution of degrees of freedom on the grid. That class can be found here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div></div><!-- fragment --><p>We will also need to use an intermediate sparsity pattern structure, which is found in this file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div></div><!-- fragment --><p>We will want to use a special algorithm to renumber degrees of freedom. It is declared here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div></div><!-- fragment --><p>And this is again needed for C++ output:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>Finally, as in <a class="el" href="step_1.html">step-1</a>, we import the deal.II namespace into the global scope:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Meshgeneration"></a> </p><h3>Mesh generation</h3>
<p>This is the function that produced the circular grid in the previous <a class="el" href="step_1.html">step-1</a> example program with fewer refinements steps. The sole difference is that it returns the grid it produces via its argument.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> make_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1, 0);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>   inner_radius = 0.5, outer_radius = 1.0;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">    triangulation, <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius, 5);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; step &lt; 3; ++step)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center =</div><div class="line">              <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(cell-&gt;vertex(v));</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(distance_from_center - inner_radius) &lt;=</div><div class="line">                1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * inner_radius)</div><div class="line">              {</div><div class="line">                cell-&gt;set_refine_flag();</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="CreationofaDoFHandler"></a> </p><h3>Creation of a <a class="el" href="classDoFHandler.html">DoFHandler</a></h3>
<p>Up to now, we only have a grid, i.e. some geometrical (the position of the vertices) and some topological information (how vertices are connected to lines, and lines to cells, as well as which cells neighbor which other cells). To use numerical algorithms, one needs some logic information in addition to that: we would like to associate degree of freedom numbers to each vertex (or line, or cell, in case we were using higher order elements) to later generate matrices and vectors which describe a finite element field on the triangulation.</p>
<p>This function shows how to do this. The object to consider is the <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> class template. Before we do so, however, we first need something that describes how many degrees of freedom are to be associated to each of these objects. Since this is one aspect of the definition of a finite element space, the finite element base class stores this information. In the present context, we therefore create an object of the derived class <code><a class="el" href="classFE__Q.html">FE_Q</a></code> that describes Lagrange elements. Its constructor takes one argument that states the polynomial degree of the element, which here is one (indicating a bi-linear element); this then corresponds to one degree of freedom for each vertex, while there are none on lines and inside the quadrilateral. A value of, say, three given to the constructor would instead give us a bi-cubic element with one degree of freedom per vertex, two per line, and four inside the cell. In general, <code><a class="el" href="classFE__Q.html">FE_Q</a></code> denotes the family of continuous elements with complete polynomials (i.e. tensor-product polynomials) up to the specified order.</p>
<p>We first need to create an object of this class and then pass it on to the <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object to allocate storage for the degrees of freedom (in deal.II lingo: we <em>distribute degrees of freedom</em>).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> distribute_dofs(<a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> finite_element(1);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(finite_element);</div></div><!-- fragment --><p>Now that we have associated a degree of freedom with a global number to each vertex, we wonder how to visualize this? There is no simple way to directly visualize the DoF number associated with each vertex. However, such information would hardly ever be truly important, since the numbering itself is more or less arbitrary. There are more important factors, of which we will demonstrate one in the following.</p>
<p>Associated with each vertex of the triangulation is a shape function. Assume we want to solve something like Laplace's equation, then the different matrix entries will be the integrals over the gradient of each pair of such shape functions. Obviously, since the shape functions are nonzero only on the cells adjacent to the vertex they are associated with, matrix entries will be nonzero only if the supports of the shape functions associated to that column and row numbers intersect. This is only the case for adjacent shape functions, and therefore only for adjacent vertices. Now, since the vertices are numbered more or less randomly by the above function (<a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a>), the pattern of nonzero entries in the matrix will be somewhat ragged, and we will take a look at it now.</p>
<p>First we have to create a structure which we use to store the places of nonzero elements. This can then later be used by one or more sparse matrix objects that store the values of the entries in the locations stored by this sparsity pattern. The class that stores the locations is the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> class. As it turns out, however, this class has some drawbacks when we try to fill it right away: its data structures are set up in such a way that we need to have an estimate for the maximal number of entries we may wish to have in each row. In two space dimensions, reasonable values for this estimate are available through the <a class="el" href="classDoFHandler.html#a198c25ff9747d228eb9afa998e716f18">DoFHandler::max_couplings_between_dofs()</a> function, but in three dimensions the function almost always severely overestimates the true number, leading to a lot of wasted memory, sometimes too much for the machine used, even if the unused memory can be released immediately after computing the sparsity pattern. In order to avoid this, we use an intermediate object of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> that uses a different internal data structure and that we can later copy into the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object without much overhead. (Some more information on these data structures can be found in the <a class="el" href="group__Sparsity.html">Sparsity patterns</a> module.) In order to initialize this intermediate data structure, we have to give it the size of the matrix, which in our case will be square with as many rows and columns as there are degrees of freedom on the grid:</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dynamic_sparsity_pattern(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                                dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div></div><!-- fragment --><p>We then fill this object with the places where nonzero elements will be located given the present numbering of degrees of freedom:</p>
<div class="fragment"><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dynamic_sparsity_pattern);</div></div><!-- fragment --><p>Now we are ready to create the actual sparsity pattern that we could later use for our matrix. It will just contain the data already assembled in the <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dynamic_sparsity_pattern);</div></div><!-- fragment --><p>With this, we can now write the results to a file :</p>
<div class="fragment"><div class="line">std::ofstream out(<span class="stringliteral">&quot;sparsity_pattern1.svg&quot;</span>);</div><div class="line">sparsity_pattern.<a class="code" href="classSparsityPatternBase.html#a226ebb78284e9c60ddda8e3ae6779d60">print_svg</a>(out);</div></div><!-- fragment --><p>The result is stored in an <code>.svg</code> file, where each nonzero entry in the matrix corresponds with a red square in the image. The output will be shown below.</p>
<p>If you look at it, you will note that the sparsity pattern is symmetric. This should not come as a surprise, since we have not given the <code><a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></code> any information that would indicate that our bilinear form may couple shape functions in a non-symmetric way. You will also note that it has several distinct region, which stem from the fact that the numbering starts from the coarsest cells and moves on to the finer ones; since they are all distributed symmetrically around the origin, this shows up again in the sparsity pattern.</p>
<div class="fragment"><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="RenumberingofDoFs"></a> </p><h3>Renumbering of DoFs</h3>
<p>In the sparsity pattern produced above, the nonzero entries extended quite far off from the diagonal. For some algorithms, for example for incomplete LU decompositions or Gauss-Seidel preconditioners, this is unfavorable, and we will show a simple way how to improve this situation.</p>
<p>Remember that for an entry \((i,j)\) in the matrix to be nonzero, the supports of the shape functions i and j needed to intersect (otherwise in the integral, the integrand would be zero everywhere since either the one or the other shape function is zero at some point). However, the supports of shape functions intersected only if they were adjacent to each other, so in order to have the nonzero entries clustered around the diagonal (where \(i\) equals \(j\)), we would like to have adjacent shape functions to be numbered with indices (DoF numbers) that differ not too much.</p>
<p>This can be accomplished by a simple front marching algorithm, where one starts at a given vertex and gives it the index zero. Then, its neighbors are numbered successively, making their indices close to the original one. Then, their neighbors, if not yet numbered, are numbered, and so on.</p>
<p>One algorithm that adds a little bit of sophistication along these lines is the one by Cuthill and McKee. We will use it in the following function to renumber the degrees of freedom such that the resulting sparsity pattern is more localized around the diagonal. The only interesting part of the function is the first call to <code><a class="el" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a></code>, the rest is essentially as before:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> renumber_dofs(<a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dynamic_sparsity_pattern(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                                  dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  std::ofstream out(<span class="stringliteral">&quot;sparsity_pattern2.svg&quot;</span>);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPatternBase.html#a226ebb78284e9c60ddda8e3ae6779d60">print_svg</a>(out);</div><div class="line">}</div></div><!-- fragment --><p>Again, the output is shown below. Note that the nonzero entries are clustered far better around the diagonal than before. This effect is even more distinguished for larger matrices (the present one has 1260 rows and columns, but large matrices often have several 100,000s).</p>
<p>It is worth noting that the <code><a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a></code> class offers a number of other algorithms as well to renumber degrees of freedom. For example, it would of course be ideal if all couplings were in the lower or upper triangular part of a matrix, since then solving the linear system would amount to only forward or backward substitution. This is of course unachievable for symmetric sparsity patterns, but in some special situations involving transport equations, this is possible by enumerating degrees of freedom from the inflow boundary along streamlines to the outflow boundary. Not surprisingly, <code><a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a></code> also has algorithms for this.</p>
<p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>Finally, this is the main program. The only thing it does is to allocate and create the triangulation, then create a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object and associate it to the triangulation, and finally call above two functions on it:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  make_grid(triangulation);</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler(triangulation);</div><div class="line"></div><div class="line">  distribute_dofs(dof_handler);</div><div class="line">  renumber_dofs(dof_handler);</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The program has, after having been run, produced two sparsity patterns. We can visualize them by opening the <code>.svg</code> files in a web browser.</p>
<p>The results then look like this (every point denotes an entry which might be nonzero; of course the fact whether the entry actually is zero or not depends on the equation under consideration, but the indicated positions in the matrix tell us which shape functions can and which can't couple when discretizing a local, i.e. differential, equation): </p><table style="width:60%" align="center">
<tr>
<td><div class="image">
<object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-2.sparsity-1.svg"></object>
</div>
 </td><td><div class="image">
<object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-2.sparsity-2.svg"></object>
</div>
  </td></tr>
</table>
<p>The different regions in the left picture, indicated by kinks in the lines and single dots on the left and top, represent the degrees of freedom on the different refinement levels of the triangulation. As can be seen in the right picture, the sparsity pattern is much better clustered around the main diagonal of the matrix after renumbering. Although this might not be apparent, the number of nonzero entries is the same in both pictures, of course.</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>Just as with <a class="el" href="step_1.html">step-1</a>, you may want to play with the program a bit to familiarize yourself with deal.II. For example, in the <code>distribute_dofs</code> function, we use linear finite elements (that's what the argument "1" to the <a class="el" href="classFE__Q.html">FE_Q</a> object is). Explore how the sparsity pattern changes if you use higher order elements, for example cubic or quintic ones (by using 3 and 5 as the respective arguments).</p>
<p>You could also explore how the sparsity pattern changes by refining the mesh. You will see that not only the size of the matrix changes, but also its bandwidth (the distance from the diagonal of those nonzero elements of the matrix that are farthest away from the diagonal), though the ratio of bandwidth to size typically shrinks, i.e. the matrix clusters more around the diagonal.</p>
<p>Another idea of experiments would be to try other renumbering strategies than Cuthill-McKee from the <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace and see how they affect the sparsity pattern.</p>
<p>You can also visualize the output using <a href="http://www.gnuplot.info/">GNUPLOT</a> (one of the simpler visualization programs; maybe not the easiest to use since it is command line driven, but also universally available on all Linux and other Unix-like systems) by changing from <code>print_svg()</code> to <code>print_gnuplot()</code> in <code>distribute_dofs()</code> and <code>renumber_dofs()</code>: </p><div class="fragment"><div class="line">examples/step-2&gt; <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a></div><div class="line"></div><div class="line">        G <a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a> <a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a> P <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a> <a class="code" href="namespaceLAPACKSupport.html#ae4c4142bb80d7e6e5214c37fac73e1da">O</a> <a class="code" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T</a></div><div class="line">        Version 3.7 patchlevel 3</div><div class="line">        last modified Thu Dec 12 13:00:00 GMT 2002</div><div class="line">        System: Linux 2.6.11.4-21.10-<span class="keywordflow">default</span></div><div class="line"></div><div class="line">        Copyright(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>) 1986 - 1993, 1998 - 2002</div><div class="line">        Thomas Williams, Colin Kelley and many others</div><div class="line"></div><div class="line">        Type `help` to access the on-line reference manual</div><div class="line">        The <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a> FAQ is available from</div><div class="line">        http:<span class="comment">//www.gnuplot.info/gnuplot-faq.html</span></div><div class="line"></div><div class="line">        Send comments and requests <span class="keywordflow">for</span> help to &lt;info-<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>@dartmouth.edu&gt;</div><div class="line">        Send bugs, suggestions and mods to &lt;bug-<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>@dartmouth.edu&gt;</div><div class="line"></div><div class="line"></div><div class="line">Terminal type <span class="keyword">set</span> to <span class="stringliteral">&#39;x11&#39;</span></div><div class="line"><a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>&gt; <span class="keyword">set</span> style data points</div><div class="line"><a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>&gt; plot <span class="stringliteral">&quot;sparsity_pattern.1&quot;</span></div></div><!-- fragment --><p>Another practice based on <a href="http://www.gnuplot.info/">GNUPLOT</a> is trying to print out the mesh with locations and numbering of the support points. For that, you need to include header files for <a class="el" href="classGridOut.html">GridOut</a> and <a class="el" href="classMappingQ1.html">MappingQ1</a>. The code for this is: </p><div class="fragment"><div class="line">std::ofstream out(<span class="stringliteral">&quot;gnuplot.gpl&quot;</span>);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;plot &#39;-&#39; using 1:2 with lines, &quot;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;&#39;-&#39; with labels point pt 2 offset 1,1&quot;</span></div><div class="line">    &lt;&lt; std::endl;</div><div class="line"><a class="code" href="classGridOut.html">GridOut</a>().<a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">write_gnuplot</a> (triangulation, out);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line">std::map&lt;types::global_dof_index, Point&lt;dim&gt; &gt; support_points;</div><div class="line"><a class="code" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a> (<a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>(),</div><div class="line">                                      dof_handler,</div><div class="line">                                      support_points);</div><div class="line"><a class="code" href="namespaceDoFTools.html#a1747081ebc1846a5b9ca3aa4bc2ee73d">DoFTools::write_gnuplot_dof_support_point_info</a>(out,</div><div class="line">                                               support_points);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p> After we run the code, we get a file called gnuplot.gpl. To view this file, we can run the following code in the command line: </p><div class="fragment"><div class="line"><a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a> -p <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>.gpl</div></div><!-- fragment --><p>. With that, you will get a picture similar to </p><div class="image">
<img src="support_point_dofs1.png" alt="support_point_dofs1.png"/>
</div>
<p> depending on the mesh you are looking at. For more information, see <a class="el" href="namespaceDoFTools.html#a1747081ebc1846a5b9ca3aa4bc2ee73d">DoFTools::write_gnuplot_dof_support_point_info</a>.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, University of Heidelberg, 1999</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> make_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1, 0);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>   inner_radius = 0.5, outer_radius = 1.0;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">    triangulation, <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius, 5);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; step &lt; 3; ++step)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center =</div><div class="line">              <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(cell-&gt;vertex(v));</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(distance_from_center - inner_radius) &lt;=</div><div class="line">                1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * inner_radius)</div><div class="line">              {</div><div class="line">                cell-&gt;set_refine_flag();</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> distribute_dofs(<a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> finite_element(1);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(finite_element);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dynamic_sparsity_pattern(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                                  dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  std::ofstream out(<span class="stringliteral">&quot;sparsity_pattern1.svg&quot;</span>);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPatternBase.html#a226ebb78284e9c60ddda8e3ae6779d60">print_svg</a>(out);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> renumber_dofs(<a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dynamic_sparsity_pattern(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                                  dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  std::ofstream out(<span class="stringliteral">&quot;sparsity_pattern2.svg&quot;</span>);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPatternBase.html#a226ebb78284e9c60ddda8e3ae6779d60">print_svg</a>(out);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  make_grid(triangulation);</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler(triangulation);</div><div class="line"></div><div class="line">  distribute_dofs(dof_handler);</div><div class="line">  renumber_dofs(dof_handler);</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_1.html">step-1</a> . <table class="tutorial"
 width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#Sparsity"> Sparsity </a><a href="#Sparsity"> Sparsity </a>
 <li><a href="#Howdegreesoffreedomareenumerated"> How degrees of freedom are
 enumerated </a><a href="#Howdegreesoffreedomareenumerated"> How degrees of
 freedom are enumerated </a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Meshgeneration">Mesh generation</a><a
 href="#Meshgeneration">Mesh generation</a>
 <li><a href="#CreationofaDoFHandler">Creation of a DoFHandler</a><a
 href="#CreationofaDoFHandler">Creation of a DoFHandler</a>
 <li><a href="#RenumberingofDoFs">Renumbering of DoFs</a><a
 href="#RenumberingofDoFs">Renumbering of DoFs</a>
 <li><a href="#Themainfunction">The main function</a><a
 href="#Themainfunction">The main function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#Possibilitiesforextensions"> Possibilities for extensions
 </a><a href="#Possibilitiesforextensions"> Possibilities for extensions
 </a>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.9.html">video lecture 9</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.) After we have created a grid in the previous example, we now show howto define degrees of freedom on this mesh. For this example, wewill use the lowest order ( \(Q_1\) ) finite elements, for which the degreesof freedom are associated with the vertices of the mesh. Laterexamples will demonstrate higher order elements where degrees of freedom arenot necessarily associated with vertices any more, but can be associatedwith edges, faces, or cells. The term "degree of freedom" is commonly used in the finite element communityto indicate two slightly different, but related things. The first is that we'dlike to represent the finite element solution as a linear combination of shapefunctions, in the form \(u_h(\mathbf x) = \sum_{j=0}^{N-1} U_j \varphi_j(\mathbf x)\) . Here, \(U_j\) is a vector of expansion coefficients. Because we don't knowtheir values yet (we will compute them as the solution of a linear ornonlinear system), they are called "unknowns" or "degrees of freedom". Thesecond meaning of the term can be explained as follows: A mathematicaldescription of finite element problems is often to say that we are looking fora finite dimensional function \(u_h \in V_h\) that satisfies some set of equations(e.g. \(a(u_h,\varphi_h)=(f,\varphi_h)\) for all test functions \(\varphi_h\in V_h\) ). In other words, all we say here that the solution needs to lie in somespace \(V_h\) . However, to actually solve this problem on a computer we need tochoose a basis of this space; this is the set of shape functions \(\varphi_j(\mathbf x)\) we have used above in the expansion of \(u_h(\mathbf x)\) with coefficients \(U_j\) . There are of course many bases of the space \(V_h\) ,but we will specifically choose the one that is described by the finiteelement functions that are traditionally defined locally on the cells of themesh. Describing "degrees of freedom" in this context requires us to simply<em>enumerate</em> the basis functions of the space \(V_h\) . For \(Q_1\) elementsthis means simply enumerating the vertices of the mesh in some way, but forhigher order elements, one also has to enumerate the shape functions that areassociated with edges, faces, or cell interiors of the mesh. In other words,the enumeration of degrees of freedom is an entirely separate thing from theindices we use for vertices. The class thatprovides this enumeration of the basis functions of \(V_h\) is called <a class="el" href="classDoFHandler.html">DoFHandler</a>. <a class="anchor" id="Sparsity"></a><h3>Sparsity </h3>
</dd></dl>
<p>The next step would then be to compute a matrix and right hand sidecorresponding to a particular differential equation using this finite elementand mesh. We will keep this step for the <a class="el" href="step_3.html">step-3</a> program and rather talk aboutone practical aspect of a finite element program, namely that finite elementmatrices are always very sparse: almost all entries in thesematrices are zero. To be more precise, we say that a matrix is sparseif the number of nonzero entries <em>per row</em> in the matrix isbounded by a number that is independent of the overall number of degrees offreedom. For example, the simple 5-point stencil of a finite differenceapproximation of the Laplace equation leads to a sparse matrix since thenumber of nonzero entries per row is five, and therefore independent of thetotal size of the matrix. For more complicated problems</p>
<ul>
<li>say, the Stokesproblem of <a class="el" href="step_22.html">step-22</a></li>
<li>and in particular in 3d, the number of entries per rowmay be several hundred. But the important point is that this number isindependent of the overall size of the problem: If you refine the mesh, themaximal number of unknowns per row remains the same. Sparsity is one of the distinguishing feature ofthe finite element method compared to, say, approximating the solution of apartial differential equation using a Taylor expansion and matchingcoefficients, or using a Fourier basis. In practical terms, it is the sparsity of matrices that enables us to solveproblems with millions or billions of unknowns. To understand this, note thata matrix with \(N\) rows, each with a fixed upper bound for the number ofnonzero entries, requires \({\cal O}(N)\) memory locations for storage, and amatrix-vector multiplication also requires only \({\cal O}(N)\) operations. Consequently, if we had a linear solver that requires only a fixednumber of matrix-vector multiplications to come up with the solution of alinear system with this matrix, then we would have a solver that can find thevalues of all \(N\) unknowns with optimal complexity, i.e., with a total of \({\cal O}(N)\) operations. It is clear that this wouldn't be possible if thematrix were not sparse (because then the number of entries in the matrix wouldhave to be \({\cal O}(N^s)\) with some \(s&gt;1\) , and doing a fixed number ofmatrix-vector products would take \({\cal O}(N^s)\) operations),but it also requires very specialized solvers such asmultigrid methods to satisfy the requirement that the solution requires only afixed number of matrix-vector multiplications. We will frequently look at thequestion of what solver to use in the remaining programs of this tutorial. The sparsity is generated by the fact that finite element shapefunctions are defined <em>locally</em> on individual cells, rather thanglobally, and that the local differential operators in the bilinearform only couple shape functions whose support overlaps. (The "support" ofa function is the area where it is nonzero. For the finite element method,the support of a shape function is generally the cells adjacent to the vertex,edge, or face it is defined on.) In other words, degrees of freedom \(i\) and \(j\) that are not defined on the same cell do not overlap, and consequentlythe matrix entry \(A_{ij}\) will be zero. (In some cases suchas the Discontinuous Galerkin method, shape functions may also connectto neighboring cells through face integrals. But finite elementmethods do not generally couple shape functions beyond the immediateneighbors of a cell on which the function is defined.)</li>
</ul>
<p><a class="anchor" id="Howdegreesoffreedomareenumerated"></a></p><h3>How degrees of freedom are enumerated </h3>
<p>By default, the <a class="el" href="classDoFHandler.html">DoFHandler</a> class enumerates degrees of freedom on a mesh in arather random way; consequently, the sparsity pattern is also notoptimized for any particular purpose. To show this, the code below willdemonstrate a simple way to output the "sparsity pattern" that corresponds toa <a class="el" href="classDoFHandler.html">DoFHandler</a>, i.e., an object that represents all of the potentially nonzeroelements of a matrix one may build when discretizing a partial differentialequation on a mesh and its <a class="el" href="classDoFHandler.html">DoFHandler</a>. This lack of structure in the sparsitypattern will be apparent from the pictures we show below. For most applications and algorithms, the exact way in which degrees of freedomare numbered does not matter. For example, the Conjugate Gradient method weuse to solve linear systems does not care. On the other hand,some algorithms do care: in particular, some preconditioners such as SSORwill work better if they can walk through degrees of freedom in a particularorder, and it would be nice if we could just sort them in such a way thatSSOR can iterate through them from zero to \(N\) in this order. Other examplesinclude computing incomplete LU or Cholesky factorizations, or if we careabout the block structure of matrices (see <a class="el" href="step_20.html">step-20</a> for an example).deal.II therefore has algorithms that can re-enumerate degrees of freedomin particular ways in namespace <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a>. Renumbering can be thoughtof as choosing a different, permuted basis of the finite element space. Thesparsity pattern and matrices that result from this renumbering are thereforealso simply a permutation of rows and columns compared to the ones we wouldget without explicit renumbering. In the program below, we will use the algorithm of Cuthill and McKee to doso. We will show the sparsity pattern for both the original enumeration ofdegrees of freedom and of the renumbered version below,in the <a href="#Results">results section</a>.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>The first few includes are just like in the previous program, so do not require additional comments:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div></div><!-- fragment --><p>However, the next file is new. We need this include file for the association of degrees of freedom ("DoF"s) to vertices, lines, and cells:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div></div><!-- fragment --><p>The following include contains the description of the bilinear finite element, including the facts that it has one degree of freedom on each vertex of the triangulation, but none on faces and none in the interior of the cells.</p>
<p>(In fact, the file contains the description of Lagrange elements in general, i.e. also the quadratic, cubic, etc versions, and not only for 2d but also 1d and 3d.)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div></div><!-- fragment --><p>In the following file, several tools for manipulating degrees of freedom can be found:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div></div><!-- fragment --><p>We will use a sparse matrix to visualize the pattern of nonzero entries resulting from the distribution of degrees of freedom on the grid. That class can be found here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div></div><!-- fragment --><p>We will also need to use an intermediate sparsity pattern structure, which is found in this file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div></div><!-- fragment --><p>We will want to use a special algorithm to renumber degrees of freedom. It is declared here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div></div><!-- fragment --><p>And this is again needed for C++ output:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>Finally, as in <a class="el" href="step_1.html">step-1</a> , we import the deal.II namespace into the global scope:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Meshgeneration"></a> </p><h3>Mesh generation</h3>
<p>This is the function that produced the circular grid in the previous <a class="el" href="step_1.html">step-1</a> example program with fewer refinements steps. The sole difference is that it returns the grid it produces via its argument.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> make_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1, 0);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>   inner_radius = 0.5, outer_radius = 1.0;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">  triangulation, <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius, 5);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; step &lt; 3; ++step)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center =</div><div class="line">            <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(cell-&gt;vertex(v));</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(distance_from_center</div><div class="line"></div><div class="line">- inner_radius) &lt;=</div><div class="line">              1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 inner_radius)</div><div class="line">            {</div><div class="line">              cell-&gt;set_refine_flag();</div><div class="line">              <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="CreationofaDoFHandler"></a> </p><h3>Creation of a <a class="el" href="classDoFHandler.html">DoFHandler</a></h3>
<p>Up to now, we only have a grid, i.e. some geometrical (the position of the vertices) and some topological information (how vertices are connected to lines, and lines to cells, as well as which cells neighbor which other cells). To use numerical algorithms, one needs some logic information in addition to that: we would like to associate degree of freedom numbers to each vertex (or line, or cell, in case we were using higher order elements) to later generate matrices and vectors which describe a finite element field on the triangulation.</p>
<p>This function shows how to do this. The object to consider is the <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> class template. Before we do so, however, we first need something that describes how many degrees of freedom are to be associated to each of these objects. Since this is one aspect of the definition of a finite element space, the finite element base class stores this information. In the present context, we therefore create an object of the derived class <code><a class="el" href="classFE__Q.html">FE_Q</a></code> that describes Lagrange elements. Its constructor takes one argument that states the polynomial degree of the element, which here is one (indicating a bi-linear element); this then corresponds to one degree of freedom for each vertex, while there are none on lines and inside the quadrilateral. A value of, say, three given to the constructor would instead give us a bi-cubic element with one degree of freedom per vertex, two per line, and four inside the cell. In general, <code><a class="el" href="classFE__Q.html">FE_Q</a></code> denotes the family of continuous elements with complete polynomials (i.e. tensor-product polynomials) up to the specified order.</p>
<p>We first need to create an object of this class and then pass it on to the <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object to allocate storage for the degrees of freedom (in deal.II lingo: we <em>distribute degrees of freedom</em>).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> distribute_dofs(<a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line"><span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> finite_element(1);</div><div class="line">dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(finite_element);</div></div><!-- fragment --><p>Now that we have associated a degree of freedom with a global number to each vertex, we wonder how to visualize this? There is no simple way to directly visualize the DoF number associated with each vertex. However, such information would hardly ever be truly important, since the numbering itself is more or less arbitrary. There are more important factors, of which we will demonstrate one in the following. Associated with each vertex of the triangulation is a shape function. Assume we want to solve something like Laplace's equation, then the different matrix entries will be the integrals over the gradient of each pair of such shape functions. Obviously, since the shape functions are nonzero only on the cells adjacent to the vertex they are associated with, matrix entries will be nonzero only if the supports of the shape functions associated to that column and row numbers intersect. This is only the case for adjacent shape functions, and therefore only for adjacent vertices. Now, since the vertices are numbered more or less randomly by the above function (<a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a>), the pattern of nonzero entries in the matrix will be somewhat ragged, and we will take a look at it now. First we have to create a structure which we use to store the places of nonzero elements. This can then later be used by one or more sparse matrix objects that store the values of the entries in the locations stored by this sparsity pattern. The class that stores the locations is the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> class. As it turns out, however, this class has some drawbacks when we try to fill it right away: its data structures are set up in such a way that we need to have an estimate for the maximal number of entries we may wish to have in each row. In two space dimensions, reasonable values for this estimate are available through the <a class="el" href="classDoFHandler.html#a198c25ff9747d228eb9afa998e716f18">DoFHandler::max_couplings_between_dofs()</a> function, but in three dimensions the function almost always severely overestimates the true number, leading to a lot of wasted memory, sometimes too much for the machine used, even if the unused memory can be released immediately after computing the sparsity pattern. In order to avoid this, we use an intermediate object of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> that uses a different internal data structure and that we can later copy into the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object without much overhead. (Some more information on these data structures can be found in the <a class="el" href="group__Sparsity.html">Sparsity patterns</a> module.) In order to initialize this intermediate data structure, we have to give it the size of the matrix, which in our case will be square with as many rows and columns as there are degrees of freedom on the grid:</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dynamic_sparsity_pattern(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                                dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div></div><!-- fragment --><p>We then fill this object with the places where nonzero elements will be located given the present numbering of degrees of freedom:</p>
<div class="fragment"><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dynamic_sparsity_pattern);</div></div><!-- fragment --><p>Now we are ready to create the actual sparsity pattern that we could later use for our matrix. It will just contain the data already assembled in the <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dynamic_sparsity_pattern);</div></div><!-- fragment --><p>With this, we can now write the results to a file :</p>
<div class="fragment"><div class="line">std::ofstream out(<span class="stringliteral">&quot;sparsity_pattern1.svg&quot;</span>);</div><div class="line">sparsity_pattern.<a class="code" href="classSparsityPatternBase.html#a226ebb78284e9c60ddda8e3ae6779d60">print_svg</a>(out);</div></div><!-- fragment --><p>The result is stored in an <code>.svg</code> file, where each nonzero entry in the matrix corresponds with a red square in the image. The output will be shown below. If you look at it, you will note that the sparsity pattern is symmetric. This should not come as a surprise, since we have not given the <code><a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></code> any information that would indicate that our bilinear form may couple shape functions in a non-symmetric way. You will also note that it has several distinct region, which stem from the fact that the numbering starts from the coarsest cells and moves on to the finer ones; since they are all distributed symmetrically around the origin, this shows up again in the sparsity pattern.</p>
<div class="fragment"><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="RenumberingofDoFs"></a> </p><h3>Renumbering of DoFs</h3>
<p>In the sparsity pattern produced above, the nonzero entries extended quite far off from the diagonal. For some algorithms, for example for incomplete LU decompositions or Gauss-Seidel preconditioners, this is unfavorable, and we will show a simple way how to improve this situation.</p>
<p>Remember that for an entry \((i,j)\) in the matrix to be nonzero, the supports of the shape functions i and j needed to intersect (otherwise in the integral, the integrand would be zero everywhere since either the one or the other shape function is zero at some point). However, the supports of shape functions intersected only if they were adjacent to each other, so in order to have the nonzero entries clustered around the diagonal (where \(i\) equals \(j\) ), we would like to have adjacent shape functions to be numbered with indices (DoF numbers) that differ not too much.</p>
<p>This can be accomplished by a simple front marching algorithm, where one starts at a given vertex and gives it the index zero. Then, its neighbors are numbered successively, making their indices close to the original one. Then, their neighbors, if not yet numbered, are numbered, and so on.</p>
<p>One algorithm that adds a little bit of sophistication along these lines is the one by Cuthill and McKee. We will use it in the following function to renumber the degrees of freedom such that the resulting sparsity pattern is more localized around the diagonal. The only interesting part of the function is the first call to <code><a class="el" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a></code> , the rest is essentially as before:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> renumber_dofs(<a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line"><a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(dof_handler);</div><div class="line"></div><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dynamic_sparsity_pattern(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                                dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dynamic_sparsity_pattern);</div><div class="line"></div><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">std::ofstream out(<span class="stringliteral">&quot;sparsity_pattern2.svg&quot;</span>);</div><div class="line">sparsity_pattern.<a class="code" href="classSparsityPatternBase.html#a226ebb78284e9c60ddda8e3ae6779d60">print_svg</a>(out);</div><div class="line">}</div></div><!-- fragment --><p>Again, the output is shown below. Note that the nonzero entries are clustered far better around the diagonal than before. This effect is even more distinguished for larger matrices (the present one has 1260 rows and columns, but large matrices often have several 100,000s).</p>
<p>It is worth noting that the <code><a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a></code> class offers a number of other algorithms as well to renumber degrees of freedom. For example, it would of course be ideal if all couplings were in the lower or upper triangular part of a matrix, since then solving the linear system would amount to only forward or backward substitution. This is of course unachievable for symmetric sparsity patterns, but in some special situations involving transport equations, this is possible by enumerating degrees of freedom from the inflow boundary along streamlines to the outflow boundary. Not surprisingly, <code><a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a></code> also has algorithms for this.</p>
<p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>Finally, this is the main program. The only thing it does is to allocate and create the triangulation, then create a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object and associate it to the triangulation, and finally call above two functions on it:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">make_grid(triangulation);</div><div class="line"></div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler(triangulation);</div><div class="line"></div><div class="line">distribute_dofs(dof_handler);</div><div class="line">renumber_dofs(dof_handler);</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The program has, after having been run, produced two sparsitypatterns. We can visualize them by opening the <code>.svg</code> files in a web browser. The results then look like this (every point denotes an entry whichmight be nonzero; of course the fact whether the entry actually iszero or not depends on the equation under consideration, but theindicated positions in the matrix tell us which shape functions canand which can't couple when discretizing a local, i.e. differential,equation): </p><table style="width:60%" align="center">
<tr>
<td><div class="image">
<object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-2.sparsity-1.svg"></object>
</div>
 </td><td><div class="image">
<object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-2.sparsity-2.svg"></object>
</div>
  </td></tr>
</table>
<p>The different regions in the left picture, indicated by kinks in the lines andsingle dots on the left and top, represent the degrees offreedom on the different refinement levels of the triangulation. Ascan be seen in the right picture, the sparsity pattern is much betterclustered around the main diagonal of the matrix afterrenumbering. Although this might not be apparent, the number ofnonzero entries is the same in both pictures, of course.</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>Just as with <a class="el" href="step_1.html">step-1</a> , you may want to play with the program a bit tofamiliarize yourself with deal.II. For example, in the <code>distribute_dofs</code> function, we use linear finite elements(that's what the argument "1" to the <a class="el" href="classFE__Q.html">FE_Q</a> object is). Explore how thesparsity pattern changes if you use higher order elements, for examplecubic or quintic ones (by using 3 and 5 as the respective arguments). You could also explore how the sparsity pattern changes by refiningthe mesh. You will see that not only the size of the matrixchanges, but also its bandwidth (the distance from the diagonal ofthose nonzero elements of the matrix that are farthest away from thediagonal), though the ratio of bandwidth to size typically shrinks,i.e. the matrix clusters more around the diagonal. Another idea of experiments would be to try other renumberingstrategies than Cuthill-McKee from the <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace and see howthey affect the sparsity pattern. You can also visualize the output using <a href="http://www.gnuplot.info/">GNUPLOT</a> (one of the simpler visualizationprograms; maybe not the easiest to use since it is command line driven, butalso universally available on all Linux and other Unix-like systems) by changing from <code>print_svg()</code> to <code>print_gnuplot()</code> in <code>distribute_dofs()</code> and <code>renumber_dofs()</code> : </p><div class="fragment"><div class="line">examples/step-2&gt; <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a></div><div class="line"></div><div class="line">     G <a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a> <a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a> P <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a> <a class="code" href="namespaceLAPACKSupport.html#ae4c4142bb80d7e6e5214c37fac73e1da">O</a> <a class="code" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T</a></div><div class="line">     Version 3.7 patchlevel 3</div><div class="line">     last modified Thu Dec 12 13:00:00 GMT 2002</div><div class="line">     System: Linux 2.6.11.4-21.10-<span class="keywordflow">default</span></div><div class="line"></div><div class="line">     Copyright(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>) 1986</div><div class="line"></div><div class="line">- 1993, 1998</div><div class="line"></div><div class="line">- 2002</div><div class="line">     Thomas Williams, Colin Kelley and many others</div><div class="line"></div><div class="line">     Type `help` to access the on-line reference manual</div><div class="line">     The <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a> FAQ is available from</div><div class="line">     http:<span class="comment">//www.gnuplot.info/gnuplot-faq.html</span></div><div class="line"></div><div class="line">     Send comments and requests <span class="keywordflow">for</span> help to &lt;info-<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>@dartmouth.edu&gt;</div><div class="line">     Send bugs, suggestions and mods to &lt;bug-<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>@dartmouth.edu&gt;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">Terminal type <span class="keyword">set</span> to <span class="stringliteral">&#39;x11&#39;</span></div><div class="line"><a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>&gt; <span class="keyword">set</span> style data points</div><div class="line"><a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>&gt; plot <span class="stringliteral">&quot;sparsity_pattern.1&quot;</span></div></div><!-- fragment --><p>Another practice based on<a href="http://www.gnuplot.info/">GNUPLOT</a> is trying toprint out the mesh with locations and numbering of the supportpoints. For that, you need to include header files for <a class="el" href="classGridOut.html">GridOut</a> and MappingQ1.The code for this is: </p><div class="fragment"><div class="line">std::ofstream out(<span class="stringliteral">&quot;gnuplot.gpl&quot;</span>);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;plot &#39;-&#39; using 1:2 with lines, &quot;</span></div><div class="line">   &lt;&lt; <span class="stringliteral">&quot;&#39;-&#39; with labels point pt 2 offset 1,1&quot;</span></div><div class="line">   &lt;&lt; std::endl;</div><div class="line"><a class="code" href="classGridOut.html">GridOut</a>().<a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">write_gnuplot</a> (triangulation, out);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line">std::map&lt;types::global_dof_index, Point&lt;dim&gt; &gt; support_points;</div><div class="line"><a class="code" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a> (<a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>(),</div><div class="line">                                     dof_handler,</div><div class="line">                                     support_points);</div><div class="line"><a class="code" href="namespaceDoFTools.html#a1747081ebc1846a5b9ca3aa4bc2ee73d">DoFTools::write_gnuplot_dof_support_point_info</a>(out,</div><div class="line">                                              support_points);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p> After we run the code, we get a file called gnuplot.gpl. To view thisfile, we can run the following code in the command line: </p><div class="fragment"><div class="line"><a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a></div><div class="line"></div><div class="line">-p <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>.gpl</div></div><!-- fragment --><p>.With that, you will get a picture similar to </p><div class="image">
<img src="support_point_dofs1.png" alt="support_point_dofs1.png"/>
<div class="caption">
depending on the mesh you are looking at. For more information, see DoFTools::write_gnuplot_dof_support_point_info.</div></div>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, University of Heidelberg, 1999</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> make_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1, 0);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>   inner_radius = 0.5, outer_radius = 1.0;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">    triangulation, <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius, 5);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; step &lt; 3; ++step)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center =</div><div class="line">              <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(cell-&gt;vertex(v));</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(distance_from_center - inner_radius) &lt;=</div><div class="line">                1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * inner_radius)</div><div class="line">              {</div><div class="line">                cell-&gt;set_refine_flag();</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> distribute_dofs(<a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> finite_element(1);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(finite_element);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dynamic_sparsity_pattern(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                                  dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  std::ofstream out(<span class="stringliteral">&quot;sparsity_pattern1.svg&quot;</span>);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPatternBase.html#a226ebb78284e9c60ddda8e3ae6779d60">print_svg</a>(out);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> renumber_dofs(<a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dynamic_sparsity_pattern(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                                  dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  std::ofstream out(<span class="stringliteral">&quot;sparsity_pattern2.svg&quot;</span>);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPatternBase.html#a226ebb78284e9c60ddda8e3ae6779d60">print_svg</a>(out);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  make_grid(triangulation);</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler(triangulation);</div><div class="line"></div><div class="line">  distribute_dofs(dof_handler);</div><div class="line">  renumber_dofs(dof_handler);</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_1.html">step-1</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Sparsity"> Sparsity </a>
        <li><a href="#Howdegreesoffreedomareenumerated"> How degrees of freedom are enumerated </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Meshgeneration">Mesh generation</a>
        <li><a href="#CreationofaDoFHandler">Creation of a DoFHandler</a>
        <li><a href="#RenumberingofDoFs">Renumbering of DoFs</a>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-2/doc/intro.dox</p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.9.html">video lecture 9</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<p>在前面的例子中，我们已经创建了一个网格，现在我们展示如何在这个网格上定义自由度。在这个例子中，我们将使用最低阶（ \(Q_1\) ）的有限元，自由度与网格的顶点相关联。以后的例子将展示更高阶的元素，自由度不一定与顶点相关，但可以与边、面或单元相关。</p>
<p>术语 "自由度 "在有限元界通常用来表示两个略有不同但相关的事情。首先是我们希望将有限元解表示为形状函数的线性组合，形式为 \(u_h(\mathbf x) = \sum_{j=0}^{N-1} U_j \varphi_j(\mathbf x)\) 。这里， \(U_j\) 是一个膨胀系数的向量。因为我们还不知道它们的值（我们将计算它们作为线性或非线性系统的解），它们被称为 "未知数 "或 "自由度"。该术语的第二个含义可以解释如下。对有限元问题的数学描述通常是说，我们正在寻找一个满足某些方程组的有限维函数 \(u_h \in V_h\) （例如， \(a(u_h,\varphi_h)=(f,\varphi_h)\) 为所有测试函数 \(\varphi_h\in V_h\) ）。换句话说，我们在这里说的是，解决方案需要位于某个空间 \(V_h\) 中。然而，为了在计算机上实际解决这个问题，我们需要选择这个空间的一个基；这就是我们在上面用系数 \(U_j\) 对 \(u_h(\mathbf x)\) 进行展开的形状函数 \(\varphi_j(\mathbf x)\) 的集合。当然，空间 \(V_h\) 的基数有很多，但我们将特别选择由传统上在网格单元上局部定义的有限元函数描述的基数。在这种情况下描述 "自由度 "需要我们简单地 <em>enumerate</em> 空间的基函数 \(V_h\) 。对于 \(Q_1\) 元素，这意味着简单地以某种方式列举网格的顶点，但对于高阶元素，还必须列举与网格的边、面或单元内部相关的形状函数。换句话说，自由度的枚举是完全独立于我们用于顶点的索引的。提供这种列举 \(V_h\) 的基础函数的类被称为DoFHandler。</p>
<p>在网格上定义自由度（简称 "DoF"）是一个相当简单的任务，因为这个库为你做了所有的工作。基本上，你所要做的就是创建一个有限元对象（从deal.II已有的众多有限元类中选取，例如参见 <a class="el" href="group__fe.html">Finite element space descriptions</a> 文档），并通过 <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a> 函数将其交给DoFHandler对象（"分配DoF "是我们用来描述上文讨论的<em>enumerating</em>基函数过程的术语）。DoFHandler是一个知道哪些自由度住在哪里的类，也就是说，它可以回答 "全局有多少自由度 "和 "在这个单元上，给我住在这里的形状函数的全局索引 "这样的问题。当你决定你的系统矩阵应该有多大时，以及当把单个单元的贡献复制到全局矩阵时，你需要这种信息。</p>
<p><a class="anchor" id="Sparsity"></a></p><h3>Sparsity </h3>
<p>然后，下一步将是利用这个有限元和网格计算与特定微分方程对应的矩阵和右手。我们将为第三步程序保留这一步骤，而是谈论有限元程序的一个实际问题，即有限元矩阵总是非常稀疏的：这些矩阵中的几乎所有条目都是零。</p>
<p>更准确地说，如果一个矩阵中的非零项<em>per row</em>的数量与整个自由度的数量无关，我们就说该矩阵是稀疏的。例如，拉普拉斯方程的有限差分近似的简单5点模版导致了一个稀疏矩阵，因为每行的非零条目数是5，因此与矩阵的总大小无关。对于更复杂的问题&ndash;比如说步骤22的斯托克斯问题&ndash;特别是在三维中，每行的条目数可能是几百个。但重要的一点是，这个数字与问题的总体大小无关：如果你细化网格，每行未知数的最大数量保持不变。</p>
<p>与使用泰勒扩展和匹配系数来逼近偏微分方程的解，或使用傅里叶基相比，稀疏性是有限元方法的一个突出特点。</p>
<p>在实践中，正是由于矩阵的稀疏性，使我们能够解决有数百万或数十亿未知数的问题。为了理解这一点，请注意，一个有 \(N\) 行的矩阵，每个非零项的数量都有固定的上限，需要 \({\cal O}(N)\) 个内存位置来存储，而矩阵-向量乘法也只需要 \({\cal O}(N)\) 次操作。因此，如果我们有一个线性求解器，只需要固定数量的矩阵向量乘法就能得出这个矩阵的线性系统的解，那么我们就会有一个能以最佳复杂度找到所有 \(N\) 未知数的值的求解器，也就是说，总共只需要 \({\cal O}(N)\) 次操作。很明显，如果矩阵不是稀疏的，这是不可能的（因为那样的话，矩阵中的条目数必须是 \({\cal O}(N^s)\) 与一些 \(s&gt;1\) ，做固定数量的矩阵-向量乘积将需要 \({\cal O}(N^s)\) 次操作），但这也需要非常专业的求解器，如多网格方法，以满足求解只需要固定数量的矩阵-向量乘法的要求。我们将在本教程的剩余程序中经常研究使用什么求解器的问题。</p>
<p>稀疏性是由以下事实产生的：有限元形状函数是在单个单元上定义的<em>locally</em>，而不是全局的，并且双线性形式中的局部微分算子只对支持度重叠的形状函数进行耦合。一个函数的 "支持 "是指它的非零区域。对于有限元方法，形状函数的支持通常是指与它所定义的顶点、边或面相邻的单元。)换句话说，自由度 \(i\) 和 \(j\) 如果不是定义在同一个单元上，就不会重叠，因此，矩阵条目 \(A_{ij}\) 将为零。 (在某些情况下，如非连续加尔金法，形状函数也可以通过面积分连接到相邻的单元。但是有限元方法一般不会将形状函数与定义了该函数的单元的近邻相联系）。)</p>
<p><a class="anchor" id="Howdegreesoffreedomareenumerated"></a></p><h3>How degrees of freedom are enumerated </h3>
<p>默认情况下，DoFHandler类以一种相当随机的方式枚举网格上的自由度；因此，稀疏度模式也没有为任何特定的目的进行优化。为了说明这一点，下面的代码将演示一个简单的方法来输出对应于DoFHandler的 "稀疏模式"，即一个对象代表了在网格上离散偏微分方程时可能建立的矩阵的所有潜在非零元素及其DoFHandler。这种缺乏结构的疏散模式将从我们下面展示的图片中显现出来。</p>
<p>对于大多数应用和算法来说，自由度的确切编号方式并不重要。例如，我们用来解决线性系统的共轭梯度方法并不关心。另一方面，有些算法确实关心：特别是一些预处理程序，如SSOR，如果它们能以特定的顺序走过自由度，就能更好地工作，如果我们能以这样的方式排序，使SSOR能以这样的顺序从零到 \(N\) 迭代它们，那就太好了。其他的例子包括计算不完整的LU或Cholesky分解，或者如果我们关心矩阵的块状结构（见步骤20的例子）。因此，deal.II在命名空间DoFRenumbering中有一些算法可以以特定的方式重新列举自由度。重新编号可以被认为是选择了一个不同的、经排列的有限元空间的基础。因此，这种重新编号所产生的稀疏模式和矩阵与我们没有明确的重新编号所得到的相比，也只是行和列的排列组合。</p>
<p>在下面的程序中，我们将使用Cuthill和McKee的算法来完成。我们将在<a href="#Results">results section</a>中展示原始自由度列举和下面重新编号的版本的稀疏模式。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>The first few includes are just like in the previous program, so do not require additional comments:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div></div><!-- fragment --><p>However, the next file is new. We need this include file for the association of degrees of freedom ("DoF"s) to vertices, lines, and cells:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div></div><!-- fragment --><p>The following include contains the description of the bilinear finite element, including the facts that it has one degree of freedom on each vertex of the triangulation, but none on faces and none in the interior of the cells.</p>
<p>(In fact, the file contains the description of Lagrange elements in general, i.e. also the quadratic, cubic, etc versions, and not only for 2d but also 1d and 3d.)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div></div><!-- fragment --><p>In the following file, several tools for manipulating degrees of freedom can be found:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div></div><!-- fragment --><p>We will use a sparse matrix to visualize the pattern of nonzero entries resulting from the distribution of degrees of freedom on the grid. That class can be found here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div></div><!-- fragment --><p>We will also need to use an intermediate sparsity pattern structure, which is found in this file :</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div></div><!-- fragment --><p>We will want to use a special algorithm to renumber degrees of freedom. It is declared here:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div></div><!-- fragment --><p>And this is again needed for C++ output:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div></div><!-- fragment --><p>Finally, as in <a class="el" href="step_1.html">step-1</a>, we import the deal.II namespace into the global scope:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Meshgeneration"></a> </p><h3>Mesh generation</h3>
<p>This is the function that produced the circular grid in the previous <a class="el" href="step_1.html">step-1</a> example program with fewer refinements steps. The sole difference is that it returns the grid it produces via its argument.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> make_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1, 0);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>   inner_radius = 0.5, outer_radius = 1.0;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">    triangulation, <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius, 5);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; step &lt; 3; ++step)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center =</div><div class="line">              <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(cell-&gt;vertex(v));</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(distance_from_center - inner_radius) &lt;=</div><div class="line">                1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * inner_radius)</div><div class="line">              {</div><div class="line">                cell-&gt;set_refine_flag();</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="CreationofaDoFHandler"></a> </p><h3>Creation of a <a class="el" href="classDoFHandler.html">DoFHandler</a></h3>
<p>Up to now, we only have a grid, i.e. some geometrical (the position of the vertices) and some topological information (how vertices are connected to lines, and lines to cells, as well as which cells neighbor which other cells). To use numerical algorithms, one needs some logic information in addition to that: we would like to associate degree of freedom numbers to each vertex (or line, or cell, in case we were using higher order elements) to later generate matrices and vectors which describe a finite element field on the triangulation.</p>
<p>This function shows how to do this. The object to consider is the <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> class template. Before we do so, however, we first need something that describes how many degrees of freedom are to be associated to each of these objects. Since this is one aspect of the definition of a finite element space, the finite element base class stores this information. In the present context, we therefore create an object of the derived class <code><a class="el" href="classFE__Q.html">FE_Q</a></code> that describes Lagrange elements. Its constructor takes one argument that states the polynomial degree of the element, which here is one (indicating a bi-linear element); this then corresponds to one degree of freedom for each vertex, while there are none on lines and inside the quadrilateral. A value of, say, three given to the constructor would instead give us a bi-cubic element with one degree of freedom per vertex, two per line, and four inside the cell. In general, <code><a class="el" href="classFE__Q.html">FE_Q</a></code> denotes the family of continuous elements with complete polynomials (i.e. tensor-product polynomials) up to the specified order.</p>
<p>We first need to create an object of this class and then pass it on to the <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object to allocate storage for the degrees of freedom (in deal.II lingo: we <em>distribute degrees of freedom</em>).</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> distribute_dofs(<a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> finite_element(1);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(finite_element);</div></div><!-- fragment --><p>Now that we have associated a degree of freedom with a global number to each vertex, we wonder how to visualize this? There is no simple way to directly visualize the DoF number associated with each vertex. However, such information would hardly ever be truly important, since the numbering itself is more or less arbitrary. There are more important factors, of which we will demonstrate one in the following.</p>
<p>Associated with each vertex of the triangulation is a shape function. Assume we want to solve something like Laplace's equation, then the different matrix entries will be the integrals over the gradient of each pair of such shape functions. Obviously, since the shape functions are nonzero only on the cells adjacent to the vertex they are associated with, matrix entries will be nonzero only if the supports of the shape functions associated to that column and row numbers intersect. This is only the case for adjacent shape functions, and therefore only for adjacent vertices. Now, since the vertices are numbered more or less randomly by the above function (<a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a>), the pattern of nonzero entries in the matrix will be somewhat ragged, and we will take a look at it now.</p>
<p>First we have to create a structure which we use to store the places of nonzero elements. This can then later be used by one or more sparse matrix objects that store the values of the entries in the locations stored by this sparsity pattern. The class that stores the locations is the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> class. As it turns out, however, this class has some drawbacks when we try to fill it right away: its data structures are set up in such a way that we need to have an estimate for the maximal number of entries we may wish to have in each row. In two space dimensions, reasonable values for this estimate are available through the <a class="el" href="classDoFHandler.html#a198c25ff9747d228eb9afa998e716f18">DoFHandler::max_couplings_between_dofs()</a> function, but in three dimensions the function almost always severely overestimates the true number, leading to a lot of wasted memory, sometimes too much for the machine used, even if the unused memory can be released immediately after computing the sparsity pattern. In order to avoid this, we use an intermediate object of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> that uses a different internal data structure and that we can later copy into the <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object without much overhead. (Some more information on these data structures can be found in the <a class="el" href="group__Sparsity.html">Sparsity patterns</a> module.) In order to initialize this intermediate data structure, we have to give it the size of the matrix, which in our case will be square with as many rows and columns as there are degrees of freedom on the grid:</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dynamic_sparsity_pattern(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                                dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div></div><!-- fragment --><p>We then fill this object with the places where nonzero elements will be located given the present numbering of degrees of freedom:</p>
<div class="fragment"><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dynamic_sparsity_pattern);</div></div><!-- fragment --><p>Now we are ready to create the actual sparsity pattern that we could later use for our matrix. It will just contain the data already assembled in the <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dynamic_sparsity_pattern);</div></div><!-- fragment --><p>With this, we can now write the results to a file :</p>
<div class="fragment"><div class="line">std::ofstream out(<span class="stringliteral">&quot;sparsity_pattern1.svg&quot;</span>);</div><div class="line">sparsity_pattern.<a class="code" href="classSparsityPatternBase.html#a226ebb78284e9c60ddda8e3ae6779d60">print_svg</a>(out);</div></div><!-- fragment --><p>The result is stored in an <code>.svg</code> file, where each nonzero entry in the matrix corresponds with a red square in the image. The output will be shown below.</p>
<p>If you look at it, you will note that the sparsity pattern is symmetric. This should not come as a surprise, since we have not given the <code><a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></code> any information that would indicate that our bilinear form may couple shape functions in a non-symmetric way. You will also note that it has several distinct region, which stem from the fact that the numbering starts from the coarsest cells and moves on to the finer ones; since they are all distributed symmetrically around the origin, this shows up again in the sparsity pattern.</p>
<div class="fragment"><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="RenumberingofDoFs"></a> </p><h3>Renumbering of DoFs</h3>
<p>In the sparsity pattern produced above, the nonzero entries extended quite far off from the diagonal. For some algorithms, for example for incomplete LU decompositions or Gauss-Seidel preconditioners, this is unfavorable, and we will show a simple way how to improve this situation.</p>
<p>Remember that for an entry \((i,j)\) in the matrix to be nonzero, the supports of the shape functions i and j needed to intersect (otherwise in the integral, the integrand would be zero everywhere since either the one or the other shape function is zero at some point). However, the supports of shape functions intersected only if they were adjacent to each other, so in order to have the nonzero entries clustered around the diagonal (where \(i\) equals \(j\)), we would like to have adjacent shape functions to be numbered with indices (DoF numbers) that differ not too much.</p>
<p>This can be accomplished by a simple front marching algorithm, where one starts at a given vertex and gives it the index zero. Then, its neighbors are numbered successively, making their indices close to the original one. Then, their neighbors, if not yet numbered, are numbered, and so on.</p>
<p>One algorithm that adds a little bit of sophistication along these lines is the one by Cuthill and McKee. We will use it in the following function to renumber the degrees of freedom such that the resulting sparsity pattern is more localized around the diagonal. The only interesting part of the function is the first call to <code><a class="el" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a></code>, the rest is essentially as before:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> renumber_dofs(<a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dynamic_sparsity_pattern(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                                  dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  std::ofstream out(<span class="stringliteral">&quot;sparsity_pattern2.svg&quot;</span>);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPatternBase.html#a226ebb78284e9c60ddda8e3ae6779d60">print_svg</a>(out);</div><div class="line">}</div></div><!-- fragment --><p>Again, the output is shown below. Note that the nonzero entries are clustered far better around the diagonal than before. This effect is even more distinguished for larger matrices (the present one has 1260 rows and columns, but large matrices often have several 100,000s).</p>
<p>It is worth noting that the <code><a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a></code> class offers a number of other algorithms as well to renumber degrees of freedom. For example, it would of course be ideal if all couplings were in the lower or upper triangular part of a matrix, since then solving the linear system would amount to only forward or backward substitution. This is of course unachievable for symmetric sparsity patterns, but in some special situations involving transport equations, this is possible by enumerating degrees of freedom from the inflow boundary along streamlines to the outflow boundary. Not surprisingly, <code><a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a></code> also has algorithms for this.</p>
<p><a class="anchor" id="Themainfunction"></a> </p><h3>The main function</h3>
<p>Finally, this is the main program. The only thing it does is to allocate and create the triangulation, then create a <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> object and associate it to the triangulation, and finally call above two functions on it:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  make_grid(triangulation);</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler(triangulation);</div><div class="line"></div><div class="line">  distribute_dofs(dof_handler);</div><div class="line">  renumber_dofs(dof_handler);</div><div class="line">}</div></div><!-- fragment --><p> examples/step-2/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>该程序运行后，产生了两个稀疏模式。我们可以通过在网络浏览器中打开 <code>.svg</code> 文件来可视化它们。</p>
<p>结果是这样的（每一个点都表示一个可能为非零的条目；当然，这个条目是否真的为零取决于所考虑的方程，但矩阵中的指示位置告诉我们，在离散化局部，即微分方程时，哪些形状函数可以，哪些不可以耦合）。 </p><table style="width:60%" align="center">
<tr>
<td><div class="image">
<object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-2.sparsity-1.svg"></object>
</div>
 </td><td><div class="image">
<object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-2.sparsity-2.svg"></object>
</div>
  </td></tr>
</table>
<p>左图中的不同区域，由线条中的扭结和左边和上面的单点表示，代表了三角法不同细化层次上的自由度。 从右图中可以看出，重新编号后，稀疏模式在矩阵的主对角线附近的聚类情况要好得多。虽然这可能不明显，但两张图片中非零项的数量当然是一样的。</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>就像第1步一样，你可能想在程序中玩一下，熟悉一下deal.II。例如，在 <code>distribute_dofs</code> 函数中，我们使用线性有限元（FE_Q对象的参数 "1 "就是如此）。探索一下如果你使用高阶元素，例如立方或五元元素（使用3和5作为各自的参数），稀疏模式会有什么变化。</p>
<p>你也可以通过细化网格来探索稀疏性模式的变化。你会发现，不仅矩阵的大小会发生变化，其带宽（矩阵中离对角线最远的那些非零元素与对角线的距离）也会发生变化，不过带宽与大小的比例通常会缩小，也就是说，矩阵在对角线周围聚集得更多。</p>
<p>实验的另一个想法是尝试DoFRenumbering命名空间中除Cuthill-McKee之外的其他重新编号策略，看看它们如何影响稀疏性模式。</p>
<p>你也可以使用<a href="http://www.gnuplot.info/">GNUPLOT</a>（较简单的可视化程序之一；也许不是最容易使用的，因为它是命令行驱动的，但在所有Linux和其他类似Unix的系统上也是普遍可用的）通过改变 <code>print_svg()</code> to <code>print_gnuplot()</code> in <code>distribute_dofs()</code> and <code>renumber_dofs()</code> 来使输出可视化。</p>
<div class="fragment"><div class="line">examples/step-2&gt; <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a></div><div class="line"></div><div class="line"></div><div class="line">        G <a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a> <a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a> P <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a> <a class="code" href="namespaceLAPACKSupport.html#ae4c4142bb80d7e6e5214c37fac73e1da">O</a> <a class="code" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T</a></div><div class="line">        Version 3.7 patchlevel 3</div><div class="line">        last modified Thu Dec 12 13:00:00 GMT 2002</div><div class="line">        System: Linux 2.6.11.4-21.10-<span class="keywordflow">default</span></div><div class="line"></div><div class="line"></div><div class="line">        Copyright(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>) 1986 - 1993, 1998 - 2002</div><div class="line">        Thomas Williams, Colin Kelley and many others</div><div class="line"></div><div class="line"></div><div class="line">        Type `help` to access the on-line reference manual</div><div class="line">        The <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a> FAQ is available from</div><div class="line">        http:<span class="comment">//www.gnuplot.info/gnuplot-faq.html</span></div><div class="line"></div><div class="line"></div><div class="line">        Send comments and requests <span class="keywordflow">for</span> help to &lt;info-<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>@dartmouth.edu&gt;</div><div class="line">        Send bugs, suggestions and mods to &lt;bug-<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>@dartmouth.edu&gt;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">Terminal type <span class="keyword">set</span> to <span class="stringliteral">&#39;x11&#39;</span></div><div class="line"><a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>&gt; <span class="keyword">set</span> style data points</div><div class="line"><a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>&gt; plot <span class="stringliteral">&quot;sparsity_pattern.1&quot;</span></div></div><!-- fragment --><p>另一个基于<a href="http://www.gnuplot.info/">GNUPLOT</a>的做法是尝试打印出带有支撑点位置和编号的网格。为此，你需要包含GridOut和MappingQ1的头文件。这方面的代码是。</p>
<div class="fragment"><div class="line">std::ofstream out(<span class="stringliteral">&quot;gnuplot.gpl&quot;</span>);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;plot &#39;-&#39; using 1:2 with lines, &quot;</span></div><div class="line">    &lt;&lt; <span class="stringliteral">&quot;&#39;-&#39; with labels point pt 2 offset 1,1&quot;</span></div><div class="line">    &lt;&lt; std::endl;</div><div class="line"><a class="code" href="classGridOut.html">GridOut</a>().<a class="code" href="classGridOut.html#ad114b5e2e6105f5a269b1599cc53d27e">write_gnuplot</a> (triangulation, out);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> dim = 2;</div><div class="line">std::map&lt;types::global_dof_index, Point&lt;dim&gt; &gt; support_points;</div><div class="line"><a class="code" href="namespaceDoFTools.html#a5514e4f59ea659f63953d62ca429eaff">DoFTools::map_dofs_to_support_points</a> (<a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a>(),</div><div class="line">                                      dof_handler,</div><div class="line">                                      support_points);</div><div class="line"><a class="code" href="namespaceDoFTools.html#a1747081ebc1846a5b9ca3aa4bc2ee73d">DoFTools::write_gnuplot_dof_support_point_info</a>(out,</div><div class="line">                                               support_points);</div><div class="line">out &lt;&lt; <span class="stringliteral">&quot;e&quot;</span> &lt;&lt; std::endl;</div></div><!-- fragment --><p>在我们运行该代码后，我们得到了一个名为gnuplot.gpl的文件。要查看这个文件，我们可以在命令行中运行以下代码。</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a> -p <a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1a025233c1a8124e5521952c7c7cd78df1">gnuplot</a>.gpl</div></div><!-- fragment --><p>.有了这个，你会得到一个类似于 </p><div class="image">
<img src="support_point_dofs1.png" alt="support_point_dofs1.png"/>
<div class="caption">
的图片，这取决于你正在看的网格。更多信息，见 DoFTools::write_gnuplot_dof_support_point_info. 。</div></div>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 1999 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, University of Heidelberg, 1999</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__renumbering_8h.html">deal.II/dofs/dof_renumbering.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> make_grid(<a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> &amp;triangulation)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>(1, 0);</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>   inner_radius = 0.5, outer_radius = 1.0;</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a>(</div><div class="line">    triangulation, <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius, 5);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step = 0; step &lt; 3; ++step)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> v : cell-&gt;vertex_indices())</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> distance_from_center =</div><div class="line">              <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>.<a class="code" href="classPoint.html#a3df8e6ab311dab9337c8d7b039c7b815">distance</a>(cell-&gt;vertex(v));</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (<a class="code" href="namespaceDifferentiation_1_1SD.html#a592560ee80355620422a86087f11b9df">std::fabs</a>(distance_from_center - inner_radius) &lt;=</div><div class="line">                1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-6 * inner_radius)</div><div class="line">              {</div><div class="line">                cell-&gt;set_refine_flag();</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">      triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> distribute_dofs(<a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;2&gt;</a> finite_element(1);</div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(finite_element);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dynamic_sparsity_pattern(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                                  dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  std::ofstream out(<span class="stringliteral">&quot;sparsity_pattern1.svg&quot;</span>);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPatternBase.html#a226ebb78284e9c60ddda8e3ae6779d60">print_svg</a>(out);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> renumber_dofs(<a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> &amp;dof_handler)</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a>(dof_handler);</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dynamic_sparsity_pattern(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>(),</div><div class="line">                                                  dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a> sparsity_pattern;</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">copy_from</a>(dynamic_sparsity_pattern);</div><div class="line"></div><div class="line">  std::ofstream out(<span class="stringliteral">&quot;sparsity_pattern2.svg&quot;</span>);</div><div class="line">  sparsity_pattern.<a class="code" href="classSparsityPatternBase.html#a226ebb78284e9c60ddda8e3ae6779d60">print_svg</a>(out);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  make_grid(triangulation);</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;2&gt;</a> dof_handler(triangulation);</div><div class="line"></div><div class="line">  distribute_dofs(dof_handler);</div><div class="line">  renumber_dofs(dof_handler);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
