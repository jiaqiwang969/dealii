<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_36.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-36 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-36 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_4.html">step-4</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#EigenvaluesandDirichletboundaryconditions">Eigenvalues and Dirichlet boundary conditions</a>
        <li><a href="#Implementationdetails">Implementation details</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeEigenvalueProblemcodeclasstemplate">The <code>EigenvalueProblem</code> class template</a>
        <li><a href="#ImplementationofthecodeEigenvalueProblemcodeclass">Implementation of the <code>EigenvalueProblem</code> class</a>
      <ul>
        <li><a href="#EigenvalueProblemEigenvalueProblem">EigenvalueProblem::EigenvalueProblem</a>
        <li><a href="#EigenvalueProblemmake_grid_and_dofs">EigenvalueProblem::make_grid_and_dofs</a>
        <li><a href="#EigenvalueProblemassemble_system">EigenvalueProblem::assemble_system</a>
        <li><a href="#EigenvalueProblemsolve">EigenvalueProblem::solve</a>
        <li><a href="#EigenvalueProblemoutput_results">EigenvalueProblem::output_results</a>
        <li><a href="#EigenvalueProblemrun">EigenvalueProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Runningtheproblem">Running the problem</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em>This program was contributed by Toby D. Young and Wolfgang Bangerth. </em></p>
<p><a class="anchor" id="Preamble"></a> <a class="anchor" id="Preamble"></a></p><h1>Preamble</h1>
<p>The problem we want to solve in this example is an eigenspectrum problem. Eigenvalue problems appear in a wide context of problems, for example in the computation of electromagnetic standing waves in cavities, vibration modes of drum membranes, or oscillations of lakes and estuaries. One of the most enigmatic applications is probably the computation of stationary or quasi-static wave functions in quantum mechanics. The latter application is what we would like to investigate here, though the general techniques outlined in this program are of course equally applicable to the other applications above.</p>
<p>Eigenspectrum problems have the general form </p><p class="formulaDsp">
\begin{align*} L \Psi &amp;= \varepsilon \Psi \qquad &amp;&amp;\text{in}\ \Omega\quad, \\ \Psi &amp;= 0 &amp;&amp;\text{on}\ \partial\Omega\quad, \end{align*}
</p>
<p> where the Dirichlet boundary condition on \(\Psi=\Psi(\mathbf x)\) could also be replaced by Neumann or Robin conditions; \(L\) is an operator that generally also contains differential operators.</p>
<p>Under suitable conditions, the above equations have a set of solutions \(\Psi_\ell,\varepsilon_\ell\), \(\ell\in {\cal I}\), where \(\cal I\) can be a finite or infinite set (and in the latter case it may be a discrete or sometimes at least in part a continuous set). In either case, let us note that there is no longer just a single solution, but a set of solutions (the various eigenfunctions and corresponding eigenvalues) that we want to compute. The problem of numerically finding all eigenvalues (eigenfunctions) of such eigenvalue problems is a formidable challenge. In fact, if the set \(\cal I\) is infinite, the challenge is of course intractable. Most of the time however we are really only interested in a small subset of these values (functions); and fortunately, the interface to the SLEPc library that we will use for this tutorial program allows us to select which portion of the eigenspectrum and how many solutions we want to solve for.</p>
<p>In this program, the eigenspectrum solvers we use are classes provided by deal.II that wrap around the linear algebra implementation of the <a href="http://www.grycap.upv.es/slepc/" target="_top">SLEPc</a> library; SLEPc itself builds on the <a href="http://www.mcs.anl.gov/petsc/" target="_top">PETSc</a> library for linear algebra contents.</p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The basic equation of stationary quantum mechanics is the Schr√∂dinger equation which models the motion of particles in an external potential \(V(\mathbf x)\). The particle is described by a wave function \(\Psi(\mathbf x)\) that satisfies a relation of the (nondimensionalized) form </p><p class="formulaDsp">
\begin{align*} [-\Delta + V(\mathbf x)] \Psi(\mathbf x) &amp;= \varepsilon \Psi(\mathbf x) \qquad &amp;&amp;\text{in}\ \Omega\quad, \\ \Psi &amp;= 0 &amp;&amp;\text{on}\ \partial\Omega\quad. \end{align*}
</p>
<p> As a consequence, this particle can only exist in a certain number of eigenstates that correspond to the energy eigenvalues \(\varepsilon_\ell\) admitted as solutions of this equation. The orthodox (Copenhagen) interpretation of quantum mechanics posits that, if a particle has energy \(\varepsilon_\ell\) then the probability of finding it at location \(\mathbf x\) is proportional to \(|\Psi_\ell(\mathbf x)|^2\) where \(\Psi_\ell\) is the eigenfunction that corresponds to this eigenvalue.</p>
<p>In order to numerically find solutions to this equation, i.e. a set of pairs of eigenvalues/eigenfunctions, we use the usual finite element approach of multiplying the equation from the left with test functions, integrating by parts, and searching for solutions in finite dimensional spaces by approximating \(\Psi(\mathbf x)\approx\Psi_h(\mathbf x)=\sum_{j}\phi_j(\mathbf x)\tilde\psi_j\), where \(\tilde\psi\) is a vector of expansion coefficients. We then immediately arrive at the following equation that discretizes the continuous eigenvalue problem: </p><p class="formulaDsp">
\[ \sum_j [(\nabla\phi_i, \nabla\phi_j)+(V(\mathbf x)\phi_i,\phi_j)] \tilde{\psi}_j = \varepsilon_h \sum_j (\phi_i, \phi_j) \tilde{\psi}_j\quad. \]
</p>
<p> In matrix and vector notation, this equation then reads: </p><p class="formulaDsp">
\[ A \tilde{\Psi} = \varepsilon_h M \tilde{\Psi} \quad, \]
</p>
<p> where \(A\) is the stiffness matrix arising from the differential operator \(L\), and \(M\) is the mass matrix. The solution to the eigenvalue problem is an eigenspectrum \(\varepsilon_{h,\ell}\), with associated eigenfunctions \(\Psi_\ell=\sum_j \phi_j\tilde{\psi}_j\).</p>
<p><a class="anchor" id="EigenvaluesandDirichletboundaryconditions"></a></p><h3>Eigenvalues and Dirichlet boundary conditions</h3>
<p>In this program, we use Dirichlet boundary conditions for the wave function \(\Psi\). What this means, from the perspective of a finite element code, is that only the interior degrees of freedom are real degrees of <em>freedom</em>: the ones on the boundary are not free but are forced to have a zero value, after all. On the other hand, the finite element method gains much of its power and simplicity from the fact that we just do the same thing on every cell, without having to think too much about where a cell is, whether it bounds on a less refined cell and consequently has a hanging node, or is adjacent to the boundary. All such checks would make the assembly of finite element linear systems unbearably difficult to write and even more so to read.</p>
<p>Consequently, of course, when you distribute degrees of freedom with your <a class="el" href="classDoFHandler.html">DoFHandler</a> object, you don't care whether some of the degrees of freedom you enumerate are at a Dirichlet boundary. They all get numbers. We just have to take care of these degrees of freedom at a later time when we apply boundary values. There are two basic ways of doing this (either using <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a> <em>after</em> assembling the linear system, or using <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> <em>during</em> assembly; see the <a class="el" href="group__constraints.html">constraints module</a> for more information), but both result in the same: a linear system that has a total number of rows equal to the number of <em>all</em> degrees of freedom, including those that lie on the boundary. However, degrees of freedom that are constrained by Dirichlet conditions are separated from the rest of the linear system by zeroing out the corresponding row and column, putting a single positive entry on the diagonal, and the corresponding Dirichlet value on the right hand side.</p>
<p>If you assume for a moment that we had renumbered degrees of freedom in such a way that all of those on the Dirichlet boundary come last, then the linear system we would get when solving a regular PDE with a right hand side would look like this: </p><p class="formulaDsp">
\begin{align*} \begin{pmatrix} A_i &amp; 0 \\ 0 &amp; D_b \end{pmatrix} \begin{pmatrix} U_i \\ U_b \end{pmatrix} = \begin{pmatrix} F_i \\ F_b \end{pmatrix}. \end{align*}
</p>
<p> Here, subscripts \(i\) and \(b\) correspond to interior and boundary degrees of freedom, respectively. The interior degrees of freedom satisfy the linear system \(A_i U_i=F_i\) which yields the correct solution in the interior, and boundary values are determined by \(U_b = D_b^{-1} F_b\) where \(D_b\) is a diagonal matrix that results from the process of eliminating boundary degrees of freedom, and \(F_b\) is chosen in such a way that \(U_{b,j}=D_{b,jj}^{-1} F_{b,j}\) has the correct boundary values for every boundary degree of freedom \(j\). (For the curious, the entries of the matrix \(D_b\) result from adding modified local contributions to the global matrix where for the local matrices the diagonal elements, if non-zero, are set to their absolute value; otherwise, they are set to the average of absolute values of the diagonal. This process guarantees that the entries of \(D_b\) are positive and of a size comparable to the rest of the diagonal entries, ensuring that the resulting matrix does not incur unreasonable losses of accuracy due to roundoff involving matrix entries of drastically different size. The actual values that end up on the diagonal are difficult to predict and you should treat them as arbitrary and unpredictable, but positive.)</p>
<p>For "regular" linear systems, this all leads to the correct solution. On the other hand, for eigenvalue problems, this is not so trivial. There, eliminating boundary values affects both matrices \(A\) and \(M\) that we will solve with in the current tutorial program. After elimination of boundary values, we then receive an eigenvalue problem that can be partitioned like this: </p><p class="formulaDsp">
\begin{align*} \begin{pmatrix} A_i &amp; 0 \\ 0 &amp; D_A \end{pmatrix} \begin{pmatrix} \tilde\Psi_i \\ \tilde\Psi_b \end{pmatrix} = \epsilon_h \begin{pmatrix} M_i &amp; 0 \\ 0 &amp; D_M \end{pmatrix} \begin{pmatrix} \tilde\Psi_i \\ \tilde\Psi_b \end{pmatrix}. \end{align*}
</p>
<p> This form makes it clear that there are two sets of eigenvalues: the ones we care about, and spurious eigenvalues from the separated problem </p><p class="formulaDsp">
\[ D_A \tilde \Psi_b = \epsilon_h D_M \Psi_b. \]
</p>
<p> These eigenvalues are spurious since they result from an eigenvalue system that operates only on boundary nodes &ndash; nodes that are not real degrees of <em>freedom</em>. Of course, since the two matrices \(D_A,D_M\) are diagonal, we can exactly quantify these spurious eigenvalues: they are \(\varepsilon_{h,j}=D_{A,jj}/D_{M,jj}\) (where the indices \(j\) corresponds exactly to the degrees of freedom that are constrained by Dirichlet boundary values).</p>
<p>So how does one deal with them? The fist part is to recognize when our eigenvalue solver finds one of them. To this end, the program computes and prints an interval within which these eigenvalues lie, by computing the minimum and maximum of the expression \(\varepsilon_{h,j}=D_{A,jj}/D_{M,jj}\) over all constrained degrees of freedom. In the program below, this already suffices: we find that this interval lies outside the set of smallest eigenvalues and corresponding eigenfunctions we are interested in and compute, so there is nothing we need to do here.</p>
<p>On the other hand, it may happen that we find that one of the eigenvalues we compute in this program happens to be in this interval, and in that case we would not know immediately whether it is a spurious or a true eigenvalue. In that case, one could simply scale the diagonal elements of either matrix after computing the two matrices, thus shifting them away from the frequency of interest in the eigen-spectrum. This can be done by using the following code, making sure that all spurious eigenvalues are exactly equal to \(1.234\cdot 10^5\): </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.n_dofs(); ++i)</div><div class="line">  <span class="keywordflow">if</span> (constraints.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(i))</div><div class="line">    {</div><div class="line">      stiffness_matrix.set(i, i, 1.234e5);</div><div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.set(i, i, 1);</div><div class="line">    }</div></div><!-- fragment --><p> However, this strategy is not pursued here as the spurious eigenvalues we get from our program as-is happen to be greater than the lowest five that we will calculate and are interested in.</p>
<p><a class="anchor" id="Implementationdetails"></a></p><h3>Implementation details</h3>
<p>The program below is essentially just a slightly modified version of <a class="el" href="step_4.html">step-4</a>. The things that are different are the following:</p>
<ul>
<li>
<p class="startli">The main class (named <code>EigenvalueProblem</code>) now no longer has a single solution vector, but a whole set of vectors for the various eigenfunctions we want to compute. Moreover, the <code>main</code> function, which has the top-level control over everything here, initializes and finalizes the interface to SLEPc and PETSc simultaneously via <code>SlepcInitialize</code> and <code>SlepFinalize</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">We use PETSc matrices and vectors as in <a class="el" href="step_17.html">step-17</a> and <a class="el" href="step_18.html">step-18</a> since that is what the SLEPc eigenvalue solvers require.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The function <code>EigenvalueProblem::solve</code> is entirely different from anything seen so far in the tutorial, as it does not just solve a linear system but actually solves the eigenvalue problem. It is built on the SLEPc library, and more immediately on the deal.II SLEPc wrappers in the class <a class="el" href="classSLEPcWrappers_1_1SolverKrylovSchur.html">SLEPcWrappers::SolverKrylovSchur</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">We use the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class to describe a few input parameters, such as the exact form of the potential \(V({\mathbf x})\), the number of global refinement steps of the mesh, or the number of eigenvalues we want to solve for. We could go much further with this but stop at making only a few of the things that one could select at run time actual input file parameters. In order to see what could be done in this regard, take a look at <a class="el" href="step_29.html">step-29</a> and <a class="el" href="step_33.html">step-33</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">We use the <a class="el" href="classFunctionParser.html">FunctionParser</a> class to make the potential \(V(\mathbf x)\) a run-time parameter that can be specified in the input file as a formula.</p>
<p class="endli"></p>
</li>
</ul>
<p>The rest of the program follows in a pretty straightforward way from <a class="el" href="step_4.html">step-4</a>.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>As mentioned in the introduction, this program is essentially only a slightly revised version of <a class="el" href="step_4.html">step-4</a>. As a consequence, most of the following include files are as used there, or at least as used already in previous tutorial programs:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function__parser_8h.html">deal.II/base/function_parser.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div></div><!-- fragment --><p><a class="el" href="classIndexSet.html">IndexSet</a> is used to set the size of each <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div></div><!-- fragment --><p>PETSc appears here because SLEPc depends on this library:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div></div><!-- fragment --><p>And then we need to actually import the interfaces for solvers that SLEPc provides:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="slepc__solver_8h.html">deal.II/lac/slepc_solver.h</a>&gt;</span></div></div><!-- fragment --><p>We also need some standard C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>Finally, as in previous programs, we import all the deal.II class and function names into the namespace into which everything in this program will go:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step36</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeEigenvalueProblemcodeclasstemplate"></a> </p><h3>The <code>EigenvalueProblem</code> class template</h3>
<p>Following is the class declaration for the main class template. It looks pretty much exactly like what has already been shown in <a class="el" href="step_4.html">step-4</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>EigenvalueProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>         make_grid_and_dofs();</div><div class="line">  <span class="keywordtype">void</span>         assemble_system();</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> solve();</div><div class="line">  <span class="keywordtype">void</span>         output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div></div><!-- fragment --><p>With these exceptions: For our eigenvalue problem, we need both a stiffness matrix for the left hand side as well as a mass matrix for the right hand side. We also need not just one solution function, but a whole set of these for the eigenfunctions we want to compute, along with the corresponding eigenvalues:</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix</a>             stiffness_matrix, <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">std::vector&lt;PETScWrappers::MPI::Vector&gt; eigenfunctions;</div><div class="line">std::vector&lt;double&gt;                     <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>;</div></div><!-- fragment --><p>And then we need an object that will store several run-time parameters that we will specify in an input file :</p>
<div class="fragment"><div class="line"><a class="code" href="classParameterHandler.html">ParameterHandler</a> parameters;</div></div><!-- fragment --><p>Finally, we will have an object that contains "constraints" on our degrees of freedom. This could include hanging node constraints if we had adaptively refined meshes (which we don't have in the current program). Here, we will store the constraints for boundary nodes \(U_i=0\).</p>
<div class="fragment"><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeEigenvalueProblemcodeclass"></a> </p><h3>Implementation of the <code>EigenvalueProblem</code> class</h3>
<p><a class="anchor" id="EigenvalueProblemEigenvalueProblem"></a> </p><h4>EigenvalueProblem::EigenvalueProblem</h4>
<p>First up, the constructor. The main new part is handling the run-time input parameters. We need to declare their existence first, and then read their values from the input file whose name is specified as an argument to this function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">EigenvalueProblem&lt;dim&gt;::EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file)</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{</div></div><!-- fragment --><p>TODO investigate why the minimum number of refinement steps required to obtain the correct eigenvalue degeneracies is 6</p>
<div class="fragment"><div class="line">  parameters.declare_entry(</div><div class="line">    <span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 20),</div><div class="line">    <span class="stringliteral">&quot;The number of times the 1-cell coarse mesh should &quot;</span></div><div class="line">    <span class="stringliteral">&quot;be refined globally for our computations.&quot;</span>);</div><div class="line">  parameters.declare_entry(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>,</div><div class="line">                           <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">                           <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 100),</div><div class="line">                           <span class="stringliteral">&quot;The number of eigenvalues/eigenfunctions &quot;</span></div><div class="line">                           <span class="stringliteral">&quot;to be computed.&quot;</span>);</div><div class="line">  parameters.declare_entry(<span class="stringliteral">&quot;Potential&quot;</span>,</div><div class="line">                           <span class="stringliteral">&quot;0&quot;</span>,</div><div class="line">                           <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                           <span class="stringliteral">&quot;A functional description of the potential.&quot;</span>);</div><div class="line"></div><div class="line">  parameters.parse_input(prm_file);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemmake_grid_and_dofs"></a> </p><h4>EigenvalueProblem::make_grid_and_dofs</h4>
<p>The next function creates a mesh on the domain \([-1,1]^d\), refines it as many times as the input file calls for, and then attaches a <a class="el" href="classDoFHandler.html">DoFHandler</a> to it and initializes the matrices and vectors to their correct sizes. We also build the constraints that correspond to the boundary values \(u|_{\partial\Omega}=0\).</p>
<p>For the matrices, we use the PETSc wrappers. These have the ability to allocate memory as necessary as non-zero entries are added. This seems inefficient: we could as well first compute the sparsity pattern, initialize the matrices with it, and as we then insert entries we can be sure that we do not need to re-allocate memory and free the one used previously. One way to do that would be to use code like this: </p><div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></div><div class="line">   dsp (dof_handler.n_dofs(),</div><div class="line">        dof_handler.n_dofs());</div><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">dsp.compress ();</div><div class="line">stiffness_matrix.reinit (dsp);</div><div class="line"><a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit (dsp);</div></div><!-- fragment --> </div><p> instead of the two <code><a class="el" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit()</a></code> calls for the stiffness and mass matrices below.</p>
<p>This doesn't quite work, unfortunately. The code above may lead to a few entries in the non-zero pattern to which we only ever write zero entries; most notably, this holds true for off-diagonal entries for those rows and columns that belong to boundary nodes. This shouldn't be a problem, but for whatever reason, PETSc's ILU preconditioner, which we use to solve linear systems in the eigenvalue solver, doesn't like these extra entries and aborts with an error message.</p>
<p>In the absence of any obvious way to avoid this, we simply settle for the second best option, which is have PETSc allocate memory as necessary. That said, since this is not a time critical part, this whole affair is of no further importance.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::make_grid_and_dofs()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(</div><div class="line">    parameters.get_integer(<span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>));</div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a>(dof_handler, constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">  stiffness_matrix.reinit(dof_handler.n_dofs(),</div><div class="line">                          dof_handler.n_dofs(),</div><div class="line">                          dof_handler.max_couplings_between_dofs());</div><div class="line">  <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(dof_handler.n_dofs(),</div><div class="line">                     dof_handler.n_dofs(),</div><div class="line">                     dof_handler.max_couplings_between_dofs());</div></div><!-- fragment --><p>The next step is to take care of the eigenspectrum. In this case, the outputs are eigenvalues and eigenfunctions, so we set the size of the list of eigenfunctions and eigenvalues to be as large as we asked for in the input file. When using a <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>, the <a class="el" href="classVector.html">Vector</a> is initialized using an <a class="el" href="classIndexSet.html">IndexSet</a>. <a class="el" href="classIndexSet.html">IndexSet</a> is used not only to resize the <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> but it also associates an index in the <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> with a degree of freedom (see <a class="el" href="step_40.html">step-40</a> for a more detailed explanation). The function <a class="el" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set()</a> creates an <a class="el" href="classIndexSet.html">IndexSet</a> where every valid index is part of the set. Note that this program can only be run sequentially and will throw an exception if used in parallel.</p>
<div class="fragment"><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> eigenfunction_index_set = dof_handler.locally_owned_dofs();</div><div class="line">  eigenfunctions.resize(</div><div class="line">    parameters.get_integer(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>));</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">    eigenfunctions[i].<a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(eigenfunction_index_set, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>.resize(eigenfunctions.size());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemassemble_system"></a> </p><h4>EigenvalueProblem::assemble_system</h4>
<p>Here, we assemble the global stiffness and mass matrices from local contributions \(A^K_{ij} = \int_K \nabla\varphi_i(\mathbf x) \cdot \nabla\varphi_j(\mathbf x) + V(\mathbf x)\varphi_i(\mathbf x)\varphi_j(\mathbf x)\) and \(M^K_{ij} = \int_K \varphi_i(\mathbf x)\varphi_j(\mathbf x)\) respectively. This function should be immediately familiar if you've seen previous tutorial programs. The only thing new would be setting up an object that described the potential \(V(\mathbf x)\) using the expression that we got from the input file. We then need to evaluate this object at the quadrature points on each cell. If you've seen how to evaluate function objects (see, for example the coefficient in <a class="el" href="step_5.html">step-5</a>), the code here will also look rather familiar.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_stiffness_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div><div class="line">  potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div><div class="line">                       parameters.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div><div class="line">                       <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; potential_values(n_q_points);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      cell_stiffness_matrix = 0;</div><div class="line">      cell_mass_matrix      = 0;</div><div class="line"></div><div class="line">      potential.<a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                           potential_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              cell_stiffness_matrix(i, j) +=           </div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *    </div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)    </div><div class="line">                 +                                     </div><div class="line">                 potential_values[q_point] *           </div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * </div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)   </div><div class="line">                 ) *                                   </div><div class="line">                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);                </div><div class="line"></div><div class="line">              cell_mass_matrix(i, j) +=              </div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * </div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)   </div><div class="line">                 ) *                                 </div><div class="line">                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);              </div><div class="line">            }</div></div><!-- fragment --><p>Now that we have the local matrix contributions, we transfer them into the global objects and take care of zero boundary constraints:</p>
<div class="fragment"><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_stiffness_matrix,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         stiffness_matrix);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_mass_matrix,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div><div class="line">}</div></div><!-- fragment --><p>At the end of the function, we tell PETSc that the matrices have now been fully assembled and that the sparse matrix representation can now be compressed as no more entries will be added:</p>
<div class="fragment"><div class="line">stiffness_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"><a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div></div><!-- fragment --><p>Before leaving the function, we calculate spurious eigenvalues, introduced to the system by zero Dirichlet constraints. As discussed in the introduction, the use of Dirichlet boundary conditions coupled with the fact that the degrees of freedom located at the boundary of the domain remain part of the linear system we solve, introduces a number of spurious eigenvalues. Below, we output the interval within which they all lie to ensure that we can ignore them should they show up in our computations.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">         max_spurious_eigenvalue = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.n_dofs(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (constraints.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(i))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> ev         = stiffness_matrix(i, i) / <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>(i, i);</div><div class="line">        min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_spurious_eigenvalue, ev);</div><div class="line">        max_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_spurious_eigenvalue, ev);</div><div class="line">      }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Spurious eigenvalues are all in the interval &quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; min_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;,&quot;</span></div><div class="line">            &lt;&lt; max_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemsolve"></a> </p><h4>EigenvalueProblem::solve</h4>
<p>This is the key new functionality of the program. Now that the system is set up, here is a good time to actually solve the problem: As with other examples this is done using a "solve" routine. Essentially, it works as in other programs: you set up a <a class="el" href="classSolverControl.html">SolverControl</a> object that describes the accuracy to which we want to solve the linear systems, and then we select the kind of solver we want. Here we choose the Krylov-Schur solver of SLEPc, a pretty fast and robust choice for this kind of problem:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> EigenvalueProblem&lt;dim&gt;::solve()</div><div class="line">{</div></div><!-- fragment --><p>We start here, as we normally do, by assigning convergence control we want:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(dof_handler.n_dofs(), 1e-9);</div><div class="line"><a class="code" href="classSLEPcWrappers_1_1SolverKrylovSchur.html">SLEPcWrappers::SolverKrylovSchur</a> eigensolver(solver_control);</div></div><!-- fragment --><p>Before we actually solve for the eigenfunctions and -values, we have to also select which set of eigenvalues to solve for. Lets select those eigenvalues and corresponding eigenfunctions with the smallest real part (in fact, the problem we solve here is symmetric and so the eigenvalues are purely real). After that, we can actually let SLEPc do its work:</p>
<div class="fragment"><div class="line">eigensolver.set_which_eigenpairs(EPS_SMALLEST_REAL);</div><div class="line"></div><div class="line">eigensolver.set_problem_type(EPS_GHEP);</div><div class="line"></div><div class="line">eigensolver.solve(stiffness_matrix,</div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>,</div><div class="line">                  <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>,</div><div class="line">                  eigenfunctions,</div><div class="line">                  eigenfunctions.size());</div></div><!-- fragment --><p>The output of the call above is a set of vectors and values. In eigenvalue problems, the eigenfunctions are only determined up to a constant that can be fixed pretty arbitrarily. Knowing nothing about the origin of the eigenvalue problem, SLEPc has no other choice than to normalize the eigenvectors to one in the \(l_2\) (vector) norm. Unfortunately this norm has little to do with any norm we may be interested from a eigenfunction perspective: the \(L_2(\Omega)\) norm, or maybe the \(L_\infty(\Omega)\) norm.</p>
<p>Let us choose the latter and rescale eigenfunctions so that they have \(\|\phi_i(\mathbf x)\|_{L^\infty(\Omega)}=1\) instead of \(\|\Phi\|_{l_2}=1\) (where \(\phi_i\) is the \(i\)th eigen<em>function</em> and \(\Phi_i\) the corresponding vector of nodal values). For the \(Q_1\) elements chosen here, we know that the maximum of the function \(\phi_i(\mathbf x)\) is attained at one of the nodes, so \(\max_{\mathbf x}\phi_i(\mathbf x)=\max_j (\Phi_i)_j\), making the normalization in the \(L_\infty\) norm trivial. Note that this doesn't work as easily if we had chosen \(Q_k\) elements with \(k&gt;1\): there, the maximum of a function does not necessarily have to be attained at a node, and so \(\max_{\mathbf x}\phi_i(\mathbf x)\ge\max_j (\Phi_i)_j\) (although the equality is usually nearly true).</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">  eigenfunctions[i] /= eigenfunctions[i].<a class="code" href="classTensor.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a>();</div></div><!-- fragment --><p>Finally return the number of iterations it took to converge:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">return</span> solver_control.last_step();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemoutput_results"></a> </p><h4>EigenvalueProblem::output_results</h4>
<p>This is the last significant function of this program. It uses the <a class="el" href="classDataOut.html">DataOut</a> class to generate graphical output from the eigenfunctions for later visualization. It works as in many of the other tutorial programs.</p>
<p>The whole collection of functions is then output as a single VTK file.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(eigenfunctions[i],</div><div class="line">                             std::string(<span class="stringliteral">&quot;eigenfunction_&quot;</span>) +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i));</div></div><!-- fragment --><p>The only thing worth discussing may be that because the potential is specified as a function expression in the input file, it would be nice to also have it as a graphical representation along with the eigenfunctions. The process to achieve this is relatively straightforward: we build an object that represents \(V(\mathbf x)\) and then we interpolate this continuous function onto the finite element space. The result we also attach to the <a class="el" href="classDataOut.html">DataOut</a> object for visualization.</p>
<div class="fragment"><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> projected_potential(dof_handler.n_dofs());</div><div class="line">  {</div><div class="line">    <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div><div class="line">    potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div><div class="line">                         parameters.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div><div class="line">                         <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, potential, projected_potential);</div><div class="line">  }</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(projected_potential, <span class="stringliteral">&quot;interpolated_potential&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;eigenvectors.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemrun"></a> </p><h4>EigenvalueProblem::run</h4>
<p>This is the function which has the top-level control over everything. It is almost exactly the same as in <a class="el" href="step_4.html">step-4</a>:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">EigenvalueProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    assemble_system();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations = solve();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solver converged in &quot;</span> &lt;&lt; n_iterations &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    output_results();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>.size(); ++i)</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;      Eigenvalue &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>[i]</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step36</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step36;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div></div><!-- fragment --><p>This program can only be run in serial. Otherwise, throw an exception.</p>
<div class="fragment"><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                <span class="stringliteral">&quot;This program can only be run in serial, use ./step-36&quot;</span>));</div><div class="line"></div><div class="line">  EigenvalueProblem&lt;2&gt; problem(<span class="stringliteral">&quot;step-36.prm&quot;</span>);</div><div class="line">  problem.run();</div><div class="line">}</div></div><!-- fragment --><p>All the while, we are watching out if any exceptions should have been generated. If that is so, we panic...</p>
<div class="fragment"><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div></div><!-- fragment --><p>If no exceptions are thrown, then we tell the program to stop monkeying around and exit nicely:</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;   Job done.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Runningtheproblem"></a></p><h3>Running the problem</h3>
<p>The problem's input is parameterized by an input file <code>step-36.prm</code> which could, for example, contain the following text:</p>
<div class="fragment"><div class="line"><span class="keyword">set</span> Global mesh refinement steps         = 5</div><div class="line"><span class="keyword">set</span> Number of <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>/eigenfunctions = 5</div><div class="line"><span class="keyword">set</span> Potential                            = 0</div></div><!-- fragment --><p>Here, the potential is zero inside the domain, and we know that the eigenvalues are given by \(\lambda_{(mn)}=\frac{\pi^2}{4}(m^2+n^2)\) where \(m,n\in{\mathbb N^+}\). Eigenfunctions are sines and cosines with \(m\) and \(n\) periods in \(x\) and \(y\) directions. This matches the output our program generates: </p><div class="fragment"><div class="line">examples/step-36&gt; make <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a></div><div class="line">============================ Running step-36</div><div class="line">   Number of active cells:       1024</div><div class="line">   Number of degrees of freedom: 1089</div><div class="line">   Solver converged in 67 iterations.</div><div class="line"></div><div class="line">      Eigenvalue 0 : 4.93877</div><div class="line">      Eigenvalue 1 : 12.3707</div><div class="line">      Eigenvalue 2 : 12.3707</div><div class="line">      Eigenvalue 3 : 19.8027</div><div class="line">      Eigenvalue 4 : 24.837</div><div class="line"></div><div class="line">   Job done.  </div></div><!-- fragment --><p> These eigenvalues are exactly the ones that correspond to pairs \((m,n)=(1,1)\), \((1,2)\) and \((2,1)\), \((2,2)\), and \((3,1)\). A visualization of the corresponding eigenfunctions would look like this:</p>
<table width="80%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.0.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.1.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.2.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.3.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.4.png"/>
</div>
 </td><td></td></tr>
</table>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>It is always worth playing a few games in the playground! So here goes with a few suggestions:</p>
<ul>
<li>
<p class="startli">The potential used above (called the <em>infinite well</em> because it is a flat potential surrounded by infinitely high walls) is interesting because it allows for analytically known solutions. Apart from that, it is rather boring, however. That said, it is trivial to play around with the potential by just setting it to something different in the input file. For example, let us assume that we wanted to work with the following potential in 2d: </p><p class="formulaDsp">
\[ V(x,y) = \left\{ \begin{array}{ll} -100 &amp; \text{if}\ \sqrt{x^2+y^2}&lt;\frac 34 \ \text{and} \ xy&gt;0 \\ -5 &amp; \text{if}\ \sqrt{x^2+y^2}&lt;\frac 34 \ \text{and} \ xy\le 0 \\ 0 &amp; \text{otherwise} \end{array} \right.\quad. \]
</p>
<p> In other words, the potential is -100 in two sectors of a circle of radius 0.75, -5 in the other two sectors, and zero outside the circle. We can achieve this by using the following in the input file : </p><div class="fragment"><div class="line"><span class="keyword">set</span> Potential = <span class="keywordflow">if</span> (x^2 + y^2 &lt; 0.75^2, <span class="keywordflow">if</span> (x*y &gt; 0, -100, -5), 0)</div></div><!-- fragment --><p> If in addition we also increase the mesh refinement by one level, we get the following results: </p><div class="fragment"><div class="line">examples/step-36&gt; make run</div><div class="line">============================ Running step-36</div><div class="line">   Number of active cells:       4096</div><div class="line">   Number of degrees of freedom: 4225</div><div class="line"></div><div class="line">   Eigenvalue 0 : -74.2562</div><div class="line">   Eigenvalue 1 : -72.7322</div><div class="line">   Eigenvalue 2 : -42.7406</div><div class="line">   Eigenvalue 3 : -42.2232</div><div class="line">   Eigenvalue 4 : -37.0744</div></div><!-- fragment --><p>The output file also contains an interpolated version of the potential, which looks like this (note that as expected the lowest few eigenmodes have probability densities \(|\Psi(\mathbf x)|^2\) that are significant only where the potential is the lowest, i.e. in the top right and bottom left sector of inner circle of the potential):</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.potential.png"/>
</div>
<p>The first five eigenfunctions are now like this:</p>
<table width="80%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.0.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.1.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.2.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.3.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.4.png"/>
</div>
 </td><td></td></tr>
</table>
<p class="endli"></p>
</li>
<li>
<p class="startli">In our derivation of the problem we have assumed that the particle is confined to a domain \(\Omega\) and that at the boundary of this domain its probability \(|\Psi|^2\) of being is zero. This is equivalent to solving the eigenvalue problem on all of \({\mathbb R}^d\) and assuming that the energy potential is finite only inside a region \(\Omega\) and infinite outside. It is relatively easy to show that \(|\Psi(\mathbf x)|^2\) at all locations \(\mathbf x\) where \(V(\mathbf x)=\infty\). So the question is what happens if our potential is not of this form, i.e. there is no bounded domain outside of which the potential is infinite? In that case, it may be worth to just consider a very large domain at the boundary of which \(V(\mathbf x)\) is at least very large, if not infinite. Play around with a few cases like this and explore how the spectrum and eigenfunctions change as we make the computational region larger and larger.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">What happens if we investigate the simple harmonic oscillator problem \(V(\mathbf x)=c|\mathbf x|^2\)? This potential is exactly of the form discussed in the previous paragraph and has hyper spherical symmetry. One may want to use a large spherical domain with a large outer radius, to approximate the whole-space problem (say, by invoking <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The plots above show the wave function \(\Psi(\mathbf x)\), but the physical quantity of interest is actually the probability density \(|\Psi(\mathbf x)|^2\) for the particle to be at location \(\mathbf x\). Some visualization programs can compute derived quantities from the data in an input file, but we can also do so right away when creating the output file. The facility to do that is the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> class that can be used in conjunction with the <a class="el" href="classDataOut.html">DataOut</a> class. Examples of how this can be done can be found in <a class="el" href="step_29.html">step-29</a> and <a class="el" href="step_33.html">step-33</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">What happens if the particle in the box has internal degrees of freedom? For example, if the particle were a spin- \(1/2\) particle? In that case, we may want to start solving a vector-valued problem instead.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Our implementation of the deal.II library here uses the <a class="el" href="namespacePETScWrappers.html">PETScWrappers</a> and <a class="el" href="namespaceSLEPcWrappers.html">SLEPcWrappers</a> and is suitable for running on serial machine architecture. However, for larger grids and with a larger number of degrees-of-freedom, we may want to run our application on parallel architectures. A parallel implementation of the above code can be particularly useful here since the generalized eigenspectrum problem is somewhat more expensive to solve than the standard problems considered in most of the earlier tutorials. Fortunately, modifying the above program to be MPI compliant is a relatively straightforward procedure. A sketch of how this can be done can be found in <a class="el" href="step_17.html">step-17</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Finally, there are alternatives to using the SLEPc eigenvalue solvers. deal.II has interfaces to one of them, ARPACK (see <a href="../../external-libs/arpack.html">the ARPACK configuration page</a> for setup instructions), implemented in the <a class="el" href="classArpackSolver.html">ArpackSolver</a> class. Here is a short and quick overview of what one would need to change to use it, provided you have a working installation of ARPACK and deal.II has been configured properly for it (see the deal.II <a href="../../readme.html" target="body">README</a> file):</p>
<p>First, in order to use the ARPACK interfaces, we can go back to using standard deal.II matrices and vectors, so we start by replacing the PETSc and SLEPc headers </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="slepc__solver_8h.html">deal.II/lac/slepc_solver.h</a>&gt;</span></div></div><!-- fragment --><p> with these: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="arpack__solver_8h.html">deal.II/lac/arpack_solver.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/compressed_sparsity_pattern.h&gt;</span></div></div><!-- fragment --><p> ARPACK allows complex eigenvalues, so we will also need </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;complex&gt;</span></div></div><!-- fragment --><p>Secondly, we switch back to the deal.II matrix and vector definitions in the main class: </p><div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a>                     sparsity_pattern;</div><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>                stiffness_matrix, <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">std::vector&lt;Vector&lt;double&gt; &gt;        eigenfunctions;</div><div class="line">std::vector&lt;std::complex&lt;double&gt;&gt;   <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>;</div></div><!-- fragment --><p> and initialize them as usual in <code>make_grid_and_dofs()</code>: </p><div class="fragment"><div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a> (dof_handler.n_dofs(),</div><div class="line">                         dof_handler.n_dofs(),</div><div class="line">                         dof_handler.max_couplings_between_dofs());</div><div class="line"></div><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> (dof_handler, sparsity_pattern);</div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">condense</a> (sparsity_pattern);</div><div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress</a>();</div><div class="line"></div><div class="line">stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a> (sparsity_pattern);</div><div class="line">mass_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a> (sparsity_pattern);</div></div><!-- fragment --><p class="endli">For solving the eigenvalue problem with ARPACK, we finally need to modify <code>solve()</code>: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> EigenvalueProblem&lt;dim&gt;::solve ()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (dof_handler.n_dofs(), 1e-9);</div><div class="line"></div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> inverse;</div><div class="line">  inverse.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a> (stiffness_matrix);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_arnoldi_vectors = 2*eigenvalues.size() + 2;</div><div class="line">  <a class="code" href="structArpackSolver_1_1AdditionalData.html">ArpackSolver::AdditionalData</a> additional_data(num_arnoldi_vectors);</div><div class="line"></div><div class="line">  <a class="code" href="classArpackSolver.html">ArpackSolver</a> eigensolver (solver_control, additional_data);</div><div class="line">  eigensolver.solve (stiffness_matrix,</div><div class="line">                     mass_matrix,</div><div class="line">                     inverse,</div><div class="line">                     eigenvalues,</div><div class="line">                     eigenfunctions,</div><div class="line">                     eigenvalues.size());</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;eigenfunctions.size(); ++i)</div><div class="line">    eigenfunctions[i] /= eigenfunctions[i].<a class="code" href="classTensor.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a> ();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> solver_control.last_step ();</div><div class="line">}</div></div><!-- fragment --><p> Note how we have used an exact decomposition (using <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>) as a preconditioner to ARPACK. </p>
</li>
</ul>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2009 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Toby D. Young, Polish Academy of Sciences,</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function__parser_8h.html">deal.II/base/function_parser.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="slepc__solver_8h.html">deal.II/lac/slepc_solver.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step36</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>EigenvalueProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span>         make_grid_and_dofs();</div><div class="line">    <span class="keywordtype">void</span>         assemble_system();</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> solve();</div><div class="line">    <span class="keywordtype">void</span>         output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix</a>             stiffness_matrix, <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">    std::vector&lt;PETScWrappers::MPI::Vector&gt; eigenfunctions;</div><div class="line">    std::vector&lt;double&gt;                     <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638ad91ede5cc912c10676843bf58fa60636">eigenvalues</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> parameters;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  EigenvalueProblem&lt;dim&gt;::EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file)</div><div class="line">    : fe(1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">  {</div><div class="line">    parameters.declare_entry(</div><div class="line">      <span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 20),</div><div class="line">      <span class="stringliteral">&quot;The number of times the 1-cell coarse mesh should &quot;</span></div><div class="line">      <span class="stringliteral">&quot;be refined globally for our computations.&quot;</span>);</div><div class="line">    parameters.declare_entry(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>,</div><div class="line">                             <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">                             <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 100),</div><div class="line">                             <span class="stringliteral">&quot;The number of eigenvalues/eigenfunctions &quot;</span></div><div class="line">                             <span class="stringliteral">&quot;to be computed.&quot;</span>);</div><div class="line">    parameters.declare_entry(<span class="stringliteral">&quot;Potential&quot;</span>,</div><div class="line">                             <span class="stringliteral">&quot;0&quot;</span>,</div><div class="line">                             <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                             <span class="stringliteral">&quot;A functional description of the potential.&quot;</span>);</div><div class="line"></div><div class="line">    parameters.parse_input(prm_file);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::make_grid_and_dofs()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(</div><div class="line">      parameters.get_integer(<span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>));</div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a>(dof_handler, constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">    stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(dof_handler.n_dofs(),</div><div class="line">                            dof_handler.n_dofs(),</div><div class="line">                            dof_handler.max_couplings_between_dofs());</div><div class="line">    mass_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(dof_handler.n_dofs(),</div><div class="line">                       dof_handler.n_dofs(),</div><div class="line">                       dof_handler.max_couplings_between_dofs());</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> eigenfunction_index_set = dof_handler.locally_owned_dofs();</div><div class="line">    eigenfunctions.resize(</div><div class="line">      parameters.get_integer(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>));</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">      eigenfunctions[i].<a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(eigenfunction_index_set, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    eigenvalues.resize(eigenfunctions.size());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_stiffness_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div><div class="line">    potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div><div class="line">                         parameters.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div><div class="line">                         <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; potential_values(n_q_points);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        cell_stiffness_matrix = 0;</div><div class="line">        cell_mass_matrix      = 0;</div><div class="line"></div><div class="line">        potential.<a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             potential_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                cell_stiffness_matrix(i, j) +=           </div><div class="line">                  (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *    </div><div class="line">                     fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)    </div><div class="line">                   +                                     </div><div class="line">                   potential_values[q_point] *           </div><div class="line">                     fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * </div><div class="line">                     fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)   </div><div class="line">                   ) *                                   </div><div class="line">                  fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);                </div><div class="line"></div><div class="line">                cell_mass_matrix(i, j) +=              </div><div class="line">                  (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * </div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)   </div><div class="line">                   ) *                                 </div><div class="line">                  fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);              </div><div class="line">              }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_stiffness_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               stiffness_matrix);</div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_mass_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               mass_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    stiffness_matrix.<a class="code" href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    mass_matrix.<a class="code" href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">           max_spurious_eigenvalue = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.n_dofs(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (constraints.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(i))</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> ev         = stiffness_matrix(i, i) / <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>(i, i);</div><div class="line">          min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_spurious_eigenvalue, ev);</div><div class="line">          max_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_spurious_eigenvalue, ev);</div><div class="line">        }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Spurious eigenvalues are all in the interval &quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; min_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;,&quot;</span></div><div class="line">              &lt;&lt; max_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> EigenvalueProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(dof_handler.n_dofs(), 1e-9);</div><div class="line">    <a class="code" href="classSLEPcWrappers_1_1SolverKrylovSchur.html">SLEPcWrappers::SolverKrylovSchur</a> eigensolver(solver_control);</div><div class="line"></div><div class="line">    eigensolver.set_which_eigenpairs(EPS_SMALLEST_REAL);</div><div class="line"></div><div class="line">    eigensolver.set_problem_type(EPS_GHEP);</div><div class="line"></div><div class="line">    eigensolver.solve(stiffness_matrix,</div><div class="line">                      mass_matrix,</div><div class="line">                      eigenvalues,</div><div class="line">                      eigenfunctions,</div><div class="line">                      eigenfunctions.size());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">      eigenfunctions[i] /= eigenfunctions[i].<a class="code" href="tensor_8h.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> solver_control.last_step();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(eigenfunctions[i],</div><div class="line">                               std::string(<span class="stringliteral">&quot;eigenfunction_&quot;</span>) +</div><div class="line">                                 <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i));</div><div class="line"></div><div class="line">    Vector&lt;double&gt; projected_potential(dof_handler.n_dofs());</div><div class="line">    {</div><div class="line">      <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div><div class="line">      potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div><div class="line">                           parameters.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div><div class="line">                           <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, potential, projected_potential);</div><div class="line">    }</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(projected_potential, <span class="stringliteral">&quot;interpolated_potential&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;eigenvectors.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">EigenvalueProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    assemble_system();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations = solve();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solver converged in &quot;</span> &lt;&lt; n_iterations &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    output_results();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenvalues.size(); ++i)</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;      Eigenvalue &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; eigenvalues[i]</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step36</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step36;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-36&quot;</span>));</div><div class="line"></div><div class="line">      EigenvalueProblem&lt;2&gt; problem(<span class="stringliteral">&quot;step-36.prm&quot;</span>);</div><div class="line">      problem.run();</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;   Job done.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_4.html">step-4</a> . <table class="tutorial"
 width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#EigenvaluesandDirichletboundaryconditions">Eigenvalues and
 Dirichlet boundary conditions</a><a
 href="#EigenvaluesandDirichletboundaryconditions">Eigenvalues and Dirichlet
 boundary conditions</a>
 <li><a href="#Implementationdetails">Implementation details</a><a
 href="#Implementationdetails">Implementation details</a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Includefiles">Include files</a><a
 href="#Includefiles">Include files</a>
 <li><a href="#ThecodeEigenvalueProblemcodeclasstemplate">The
 <code>EigenvalueProblem</code> class template</a><a
 href="#ThecodeEigenvalueProblemcodeclasstemplate">The
 <code>EigenvalueProblem</code> class template</a>
 <li><a
 href="#ImplementationofthecodeEigenvalueProblemcodeclass">Implementation of
 the <code>EigenvalueProblem</code> class</a><a
 href="#ImplementationofthecodeEigenvalueProblemcodeclass">Implementation of
 the <code>EigenvalueProblem</code> class</a>
 <ul>
 <li><a
 href="#EigenvalueProblemEigenvalueProblem">EigenvalueProblem::EigenvalueProblem</a><a
 href="#EigenvalueProblemEigenvalueProblem">EigenvalueProblem::EigenvalueProblem</a>
 <li><a
 href="#EigenvalueProblemmake_grid_and_dofs">EigenvalueProblem::make_grid_and_dofs</a><a
 href="#EigenvalueProblemmake_grid_and_dofs">EigenvalueProblem::make_grid_and_dofs</a>
 <li><a
 href="#EigenvalueProblemassemble_system">EigenvalueProblem::assemble_system</a><a
 href="#EigenvalueProblemassemble_system">EigenvalueProblem::assemble_system</a>
 <li><a href="#EigenvalueProblemsolve">EigenvalueProblem::solve</a><a
 href="#EigenvalueProblemsolve">EigenvalueProblem::solve</a>
 <li><a
 href="#EigenvalueProblemoutput_results">EigenvalueProblem::output_results</a><a
 href="#EigenvalueProblemoutput_results">EigenvalueProblem::output_results</a>
 <li><a href="#EigenvalueProblemrun">EigenvalueProblem::run</a><a
 href="#EigenvalueProblemrun">EigenvalueProblem::run</a>
 </ul>
 <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a><a
 href="#Thecodemaincodefunction">The <code>main</code> function</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#Runningtheproblem">Running the problem</a><a
 href="#Runningtheproblem">Running the problem</a>
 <li><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <br />
 <em>This program was contributed by Toby D. Young and Wolfgang Bangerth. </em> <a class="anchor" id="Preamble"></a><a class="anchor" id="Preamble"></a></p><h1>Preamble</h1>
<p>The problem we want to solve in this example is an eigenspectrumproblem. Eigenvalue problems appear in a wide context of problems, forexample in the computation of electromagnetic standing waves incavities, vibration modes of drum membranes, or oscillations of lakesand estuaries. One of the most enigmatic applications is probably thecomputation of stationary or quasi-static wave functions in quantummechanics. The latter application is what we would like to investigatehere, though the general techniques outlined in this program are ofcourse equally applicable to the other applications above. Eigenspectrum problems have the general form </p><p class="formulaDsp">
\begin{align*} L \Psi &amp;= \varepsilon \Psi \qquad &amp;&amp;\text{in}\ \Omega\quad, \\ \Psi &amp;= 0 &amp;&amp;\text{on}\ \partial\Omega\quad, \end{align*}
</p>
<p> where the Dirichlet boundary condition on \(\Psi=\Psi(\mathbf x)\) could also bereplaced by Neumann or Robin conditions; \(L\) is an operator that generallyalso contains differential operators. Under suitable conditions, the above equations have a set of solutions \(\Psi_\ell,\varepsilon_\ell\) , \(\ell\in {\cal I}\) , where \(\cal I\) canbe a finite or infinite set (and in the latter case it may be a discrete orsometimes at least in part a continuous set). In either case, let us note thatthere isno longer just a single solution, but a set of solutions (the variouseigenfunctions and corresponding eigenvalues) that we want tocompute. The problem of numerically finding all eigenvalues(eigenfunctions) of such eigenvalue problems is a formidablechallenge. In fact, if the set \(\cal I\) is infinite, the challenge isof course intractable. Most of the time however we are really onlyinterested in a small subset of these values (functions); andfortunately, the interface to the SLEPc library that we will use forthis tutorial program allows us to select which portion of theeigenspectrum and how many solutions we want to solve for. In this program, the eigenspectrum solvers we use are classes providedby deal.II that wrap around the linear algebra implementation of the<a href="http://www.grycap.upv.es/slepc/" target="_top">SLEPc</a>library; SLEPc itself builds on the <a href="http://www.mcs.anl.gov/petsc/" target="_top">PETSc</a> libraryfor linear algebra contents. <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The basic equation of stationary quantum mechanics is theSchr√∂dinger equation which models the motion of particles in anexternal potential \(V(\mathbf x)\) . The particle is described by a wavefunction \(\Psi(\mathbf x)\) that satisfies a relation of the(nondimensionalized) form </p><p class="formulaDsp">
\begin{align*} [-\Delta + V(\mathbf x)] \Psi(\mathbf x) &amp;= \varepsilon \Psi(\mathbf x) \qquad &amp;&amp;\text{in}\ \Omega\quad, \\ \Psi &amp;= 0 &amp;&amp;\text{on}\ \partial\Omega\quad. \end{align*}
</p>
<p> As a consequence, this particle can only exist in a certain number ofeigenstates that correspond to the energy eigenvalues \(\varepsilon_\ell\) admitted as solutions of this equation. Theorthodox (Copenhagen) interpretation of quantum mechanics posits that, if aparticle has energy \(\varepsilon_\ell\) then the probability of findingit at location \(\mathbf x\) is proportional to \(|\Psi_\ell(\mathbf x)|^2\) where \(\Psi_\ell\) is the eigenfunction that corresponds to thiseigenvalue. In order to numerically find solutions to this equation, i.e. a set ofpairs of eigenvalues/eigenfunctions, we use the usual finite elementapproach of multiplying the equation from the left with test functions,integrating by parts, and searching for solutions in finitedimensional spaces by approximating \(\Psi(\mathbf x)\approx\Psi_h(\mathbf x)=\sum_{j}\phi_j(\mathbf x)\tilde\psi_j\) ,where \(\tilde\psi\) is a vector of expansion coefficients. We thenimmediately arrive at the following equation that discretizes thecontinuous eigenvalue problem: </p><p class="formulaDsp">
\[ \sum_j [(\nabla\phi_i, \nabla\phi_j)+(V(\mathbf x)\phi_i,\phi_j)] \tilde{\psi}_j = \varepsilon_h \sum_j (\phi_i, \phi_j) \tilde{\psi}_j\quad. \]
</p>
<p> Inmatrix and vector notation, this equation then reads: </p><p class="formulaDsp">
\[ A \tilde{\Psi} = \varepsilon_h M \tilde{\Psi} \quad, \]
</p>
<p> where \(A\) isthe stiffness matrix arising from the differential operator \(L\) , and \(M\) is the mass matrix. The solution to the eigenvalue problem is aneigenspectrum \(\varepsilon_{h,\ell}\) , with associated eigenfunctions \(\Psi_\ell=\sum_j \phi_j\tilde{\psi}_j\) .</p>
<p><a class="anchor" id="EigenvaluesandDirichletboundaryconditions"></a></p><h3>Eigenvalues and Dirichlet boundary conditions</h3>
<p>In this program, we use Dirichlet boundary conditions for the wavefunction \(\Psi\) . What this means, from the perspective of a finiteelement code, is that only the interior degrees of freedom are realdegrees of <em>freedom</em>: the ones on the boundary are not free butare forced to have a zero value, after all. On the other hand, thefinite element method gains much of its power and simplicity fromthe fact that we just do the same thing on every cell, withouthaving to think too much about where a cell is, whether it boundson a less refined cell and consequently has a hanging node, or isadjacent to the boundary. All such checks would make the assemblyof finite element linear systems unbearably difficult to write andeven more so to read. Consequently, of course, when you distribute degrees of freedom withyour <a class="el" href="classDoFHandler.html">DoFHandler</a> object, you don't care whether some of the degreesof freedom you enumerate are at a Dirichlet boundary. They all getnumbers. We just have to take care of these degrees of freedom at alater time when we apply boundary values. There are two basic waysof doing this (either using <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a> <em>after</em> assembling the linear system, or using <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> <em>during</em> assembly;see the <a class="el" href="group__constraints.html">constraints module</a> for more information),but both result in the same: a linear system that has a totalnumber of rows equal to the number of <em>all</em> degrees of freedom,including those that lie on the boundary. However, degrees offreedom that are constrained by Dirichlet conditions are separatedfrom the rest of the linear system by zeroing out the correspondingrow and column, putting a single positive entry on the diagonal,and the corresponding Dirichlet value on the right hand side. If you assume for a moment that we had renumbered degrees of freedomin such a way that all of those on the Dirichlet boundary come last,then the linear system we would get when solving a regular PDE witha right hand side would look like this: </p><p class="formulaDsp">
\begin{align*} \begin{pmatrix} A_i &amp; 0 \\ 0 &amp; D_b \end{pmatrix} \begin{pmatrix} U_i \\ U_b \end{pmatrix} = \begin{pmatrix} F_i \\ F_b \end{pmatrix}. \end{align*}
</p>
<p> Here, subscripts \(i\) and \(b\) correspond to interior and boundarydegrees of freedom, respectively. The interior degrees of freedomsatisfy the linear system \(A_i U_i=F_i\) which yields the correctsolution in the interior, and boundary values are determined by \(U_b = D_b^{-1} F_b\) where \(D_b\) is a diagonal matrix that resultsfrom the process of eliminating boundary degrees of freedom, and \(F_b\) is chosen in such a way that \(U_{b,j}=D_{b,jj}^{-1} F_{b,j}\) has the correct boundary values for every boundary degree of freedom \(j\) . (For the curious, the entries of thematrix \(D_b\) result from adding modified local contributions to theglobal matrix where for the local matrices the diagonal elements, if non-zero,are set to their absolute value; otherwise, they are set to the average ofabsolute values of the diagonal. This process guarantees that the entriesof \(D_b\) are positive and of a size comparable to the rest of the diagonalentries, ensuring that the resulting matrix does not incur unreasonablelosses of accuracy due to roundoff involving matrix entries of drasticallydifferent size. The actual values that end up on the diagonal are difficultto predict and you should treat them as arbitrary and unpredictable, butpositive.) For "regular" linear systems, this all leads to the correct solution.On the other hand, for eigenvalue problems, this is not so trivial.There, eliminating boundary values affects both matrices \(A\) and \(M\) that we will solve with in the current tutorial program.After elimination of boundary values, we then receive an eigenvalueproblem that can be partitioned like this: </p><p class="formulaDsp">
\begin{align*} \begin{pmatrix} A_i &amp; 0 \\ 0 &amp; D_A \end{pmatrix} \begin{pmatrix} \tilde\Psi_i \\ \tilde\Psi_b \end{pmatrix} = \epsilon_h \begin{pmatrix} M_i &amp; 0 \\ 0 &amp; D_M \end{pmatrix} \begin{pmatrix} \tilde\Psi_i \\ \tilde\Psi_b \end{pmatrix}. \end{align*}
</p>
<p> This form makes it clear that there are two sets of eigenvalues:the ones we care about, and spurious eigenvalues from theseparated problem </p><p class="formulaDsp">
\[ D_A \tilde \Psi_b = \epsilon_h D_M \Psi_b. \]
</p>
<p> eigenvalues are spurious since they result from an eigenvaluesystem that operates only on boundary nodes</p>
<ul>
<li>nodes that are notreal degrees of <em>freedom</em>.Of course, since the two matrices \(D_A,D_M\) are diagonal, we canexactly quantify these spurious eigenvalues: they are \(\varepsilon_{h,j}=D_{A,jj}/D_{M,jj}\) (where the indices \(j\) corresponds exactly to the degrees of freedom that are constrainedby Dirichlet boundary values). So how does one deal with them? The fist part is to recognize when oureigenvalue solver finds one of them. To this end, the program computesand prints an interval within which these eigenvalues lie, by computingthe minimum and maximum of the expression \(\varepsilon_{h,j}=D_{A,jj}/D_{M,jj}\) over all constrained degrees of freedom. In the program below, thisalready suffices: we find that this interval lies outside the set ofsmallest eigenvalues and corresponding eigenfunctions we are interestedin and compute, so there is nothing we need to do here. On the other hand, it may happen that we find that one of the eigenvalueswe compute in this program happens to be in this interval, and in thatcase we would not know immediately whether it is a spurious or a trueeigenvalue. In that case, one could simply scale the diagonal elements ofeither matrix after computing the two matrices,thus shifting them away from the frequency of interest in the eigen-spectrum.This can be done by using the following code, making sure that all spuriouseigenvalues are exactly equal to \(1.234\cdot 10^5\) : <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.n_dofs(); ++i)</div><div class="line">  <span class="keywordflow">if</span> (constraints.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(i))</div><div class="line">    {</div><div class="line">      stiffness_matrix.<a class="code" href="classSparseMatrix.html#a3e77fcfbd1fa3ac83ef4ff2951b24ce3">set</a>(i, i, 1.234e5);</div><div class="line">      mass_matrix.<a class="code" href="classSparseMatrix.html#a3e77fcfbd1fa3ac83ef4ff2951b24ce3">set</a>(i, i, 1);</div><div class="line">    }</div></div><!-- fragment --> However, this strategy is not pursued here as the spurious eigenvalueswe get from our program as-is happen to be greater than the lowestfive that we will calculate and are interested in.</li>
</ul>
<p><a class="anchor" id="Implementationdetails"></a></p><h3>Implementation details</h3>
<p>The program below is essentially just a slightly modified version of <a class="el" href="step_4.html">step-4</a> . The things that are different are the following: </p><ul>
<li>
The main class (named <code>EigenvalueProblem</code> ) now nolonger has a single solution vector, but a whole set of vectors forthe various eigenfunctions we want to compute. Moreover, the <code>main</code> function, which has the top-level control overeverything here, initializes and finalizes the interface to SLEPc andPETSc simultaneously via <code>SlepcInitialize</code> and <code>SlepFinalize</code> .  </li>
<li>
We use PETSc matrices and vectors as in <a class="el" href="step_17.html">step-17</a> and <a class="el" href="step_18.html">step-18</a> since that is what the SLEPc eigenvalue solversrequire.  </li>
<li>
The function <code>EigenvalueProblem::solve</code> is entirelydifferent from anything seen so far in the tutorial, as it does notjust solve a linear system but actually solves the eigenvalue problem.It is built on the SLEPc library, and more immediately on the deal.IISLEPc wrappers in the class <a class="el" href="classSLEPcWrappers_1_1SolverKrylovSchur.html">SLEPcWrappers::SolverKrylovSchur</a>. </li>
<li>
We use the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class to describe a few inputparameters, such as the exact form of the potential \(V({\mathbf x})\) , the number of global refinement steps of the mesh,or the number of eigenvalues we want to solve for. We could go muchfurther with this but stop at making only a few of the things that onecould select at run time actual input file parameters. In order to seewhat could be done in this regard, take a look at <a class="el" href="step_29.html">step_29 </a>step-29"  " and <a class="el" href="step_33.html">step-33</a> .  </li>
<li>
We use the <a class="el" href="classFunctionParser.html">FunctionParser</a> class to make the potential \(V(\mathbf x)\) a run-time parameter that can be specified in the input file as aformula.  </li>
</ul>
<p>The rest of the program follows in a pretty straightforward way from <a class="el" href="step_4.html">step-4</a> .</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>As mentioned in the introduction, this program is essentially only a slightly revised version of <a class="el" href="step_4.html">step-4</a> . As a consequence, most of the following include files are as used there, or at least as used already in previous tutorial programs:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function__parser_8h.html">deal.II/base/function_parser.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div></div><!-- fragment --><p><a class="el" href="classIndexSet.html">IndexSet</a> is used to set the size of each <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div></div><!-- fragment --><p>PETSc appears here because SLEPc depends on this library:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div></div><!-- fragment --><p>And then we need to actually import the interfaces for solvers that SLEPc provides:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="slepc__solver_8h.html">deal.II/lac/slepc_solver.h</a>&gt;</span></div></div><!-- fragment --><p>We also need some standard C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>Finally, as in previous programs, we import all the deal.II class and function names into the namespace into which everything in this program will go:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step36</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeEigenvalueProblemcodeclasstemplate"></a> </p><h3>The <code>EigenvalueProblem</code> class template</h3>
<p>Following is the class declaration for the main class template. It looks pretty much exactly like what has already been shown in <a class="el" href="step_4.html">step-4</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>EigenvalueProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>         make_grid_and_dofs();</div><div class="line">  <span class="keywordtype">void</span>         assemble_system();</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> solve();</div><div class="line">  <span class="keywordtype">void</span>         output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div></div><!-- fragment --><p>With these exceptions: For our eigenvalue problem, we need both a stiffness matrix for the left hand side as well as a mass matrix for the right hand side. We also need not just one solution function, but a whole set of these for the eigenfunctions we want to compute, along with the corresponding eigenvalues:</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix</a>             stiffness_matrix, <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">std::vector&lt;PETScWrappers::MPI::Vector&gt; eigenfunctions;</div><div class="line">std::vector&lt;double&gt;                     <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>;</div></div><!-- fragment --><p>And then we need an object that will store several run-time parameters that we will specify in an input file :</p>
<div class="fragment"><div class="line"><a class="code" href="classParameterHandler.html">ParameterHandler</a> parameters;</div></div><!-- fragment --><p>Finally, we will have an object that contains "constraints" on our degrees of freedom. This could include hanging node constraints if we had adaptively refined meshes (which we don't have in the current program). Here, we will store the constraints for boundary nodes \(U_i=0\) .</p>
<div class="fragment"><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeEigenvalueProblemcodeclass"></a> </p><h3>Implementation of the <code>EigenvalueProblem</code> class</h3>
<p><a class="anchor" id="EigenvalueProblemEigenvalueProblem"></a> </p><h4>EigenvalueProblem::EigenvalueProblem</h4>
<p>First up, the constructor. The main new part is handling the run-time input parameters. We need to declare their existence first, and then read their values from the input file whose name is specified as an argument to this function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">EigenvalueProblem&lt;dim&gt;::EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file)</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{</div></div><!-- fragment --><p>TODO investigate why the minimum number of refinement steps required to obtain the correct eigenvalue degeneracies is 6</p>
<div class="fragment"><div class="line">  parameters.declare_entry(</div><div class="line">    <span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 20),</div><div class="line">    <span class="stringliteral">&quot;The number of times the 1-cell coarse mesh should &quot;</span></div><div class="line">    <span class="stringliteral">&quot;be refined globally for our computations.&quot;</span>);</div><div class="line">  parameters.declare_entry(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>,</div><div class="line">                           <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">                           <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 100),</div><div class="line">                           <span class="stringliteral">&quot;The number of eigenvalues/eigenfunctions &quot;</span></div><div class="line">                           <span class="stringliteral">&quot;to be computed.&quot;</span>);</div><div class="line">  parameters.declare_entry(<span class="stringliteral">&quot;Potential&quot;</span>,</div><div class="line">                           <span class="stringliteral">&quot;0&quot;</span>,</div><div class="line">                           <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                           <span class="stringliteral">&quot;A functional description of the potential.&quot;</span>);</div><div class="line"></div><div class="line">  parameters.parse_input(prm_file);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemmake_grid_and_dofs"></a> </p><h4>EigenvalueProblem::make_grid_and_dofs</h4>
<p>The next function creates a mesh on the domain \([-1,1]^d\) , refines it as many times as the input file calls for, and then attaches a <a class="el" href="classDoFHandler.html">DoFHandler</a> to it and initializes the matrices and vectors to their correct sizes. We also build the constraints that correspond to the boundary values \(u|_{\partial\Omega}=0\) . For the matrices, we use the PETSc wrappers. These have the ability to allocate memory as necessary as non-zero entries are added. This seems inefficient: we could as well first compute the sparsity pattern, initialize the matrices with it, and as we then insert entries we can be sure that we do not need to re-allocate memory and free the one used previously. One way to do that would be to use code like this: </p><div class="CodeFragmentInTutorialComment"></div><div class="CodeFragmentInTutorialComment"><div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></div><div class="line">   dsp (dof_handler.n_dofs(),</div><div class="line">        dof_handler.n_dofs());</div><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">dsp.compress ();</div><div class="line">stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a> (dsp);</div><div class="line">mass_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a> (dsp);</div></div><!-- fragment --></div><div class="CodeFragmentInTutorialComment"> </div><p> instead of the two <code><a class="el" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit()</a></code> calls for the stiffness and mass matrices below. This doesn't quite work, unfortunately. The code above may lead to a few entries in the non-zero pattern to which we only ever write zero entries; most notably, this holds true for off-diagonal entries for those rows and columns that belong to boundary nodes. This shouldn't be a problem, but for whatever reason, PETSc's ILU preconditioner, which we use to solve linear systems in the eigenvalue solver, doesn't like these extra entries and aborts with an error message. In the absence of any obvious way to avoid this, we simply settle for the second best option, which is have PETSc allocate memory as necessary. That said, since this is not a time critical part, this whole affair is of no further importance.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::make_grid_and_dofs()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation,</div><div class="line"></div><div class="line">-1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(</div><div class="line">    parameters.get_integer(<span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>));</div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a>(dof_handler, constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">  stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(dof_handler.n_dofs(),</div><div class="line">                          dof_handler.n_dofs(),</div><div class="line">                          dof_handler.max_couplings_between_dofs());</div><div class="line">  mass_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(dof_handler.n_dofs(),</div><div class="line">                     dof_handler.n_dofs(),</div><div class="line">                     dof_handler.max_couplings_between_dofs());</div></div><!-- fragment --><p>The next step is to take care of the eigenspectrum. In this case, the outputs are eigenvalues and eigenfunctions, so we set the size of the list of eigenfunctions and eigenvalues to be as large as we asked for in the input file. When using a <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>, the <a class="el" href="classVector.html">Vector</a> is initialized using an <a class="el" href="classIndexSet.html">IndexSet</a>. <a class="el" href="classIndexSet.html">IndexSet</a> is used not only to resize the <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> but it also associates an index in the <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> with a degree of freedom (see <a class="el" href="step_40.html">step-40</a> for a more detailed explanation). The function <a class="el" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set()</a> creates an <a class="el" href="classIndexSet.html">IndexSet</a> where every valid index is part of the set. Note that this program can only be run sequentially and will throw an exception if used in parallel.</p>
<div class="fragment"><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> eigenfunction_index_set = dof_handler.locally_owned_dofs();</div><div class="line">  eigenfunctions.resize(</div><div class="line">    parameters.get_integer(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>));</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">    eigenfunctions[i].<a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(eigenfunction_index_set, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  eigenvalues.resize(eigenfunctions.size());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemassemble_system"></a> </p><h4>EigenvalueProblem::assemble_system</h4>
<p>Here, we assemble the global stiffness and mass matrices from local contributions \(A^K_{ij} = \int_K \nabla\varphi_i(\mathbf x) \cdot \nabla\varphi_j(\mathbf x) + V(\mathbf x)\varphi_i(\mathbf x)\varphi_j(\mathbf x)\) and \(M^K_{ij} = \int_K \varphi_i(\mathbf x)\varphi_j(\mathbf x)\) respectively. This function should be immediately familiar if you've seen previous tutorial programs. The only thing new would be setting up an object that described the potential \(V(\mathbf x)\) using the expression that we got from the input file. We then need to evaluate this object at the quadrature points on each cell. If you've seen how to evaluate function objects (see, for example the coefficient in <a class="el" href="step_5.html">step-5</a> ), the code here will also look rather familiar.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_stiffness_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div><div class="line">  potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div><div class="line">                       parameters.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div><div class="line">                       <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; potential_values(n_q_points);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      cell_stiffness_matrix = 0;</div><div class="line">      cell_mass_matrix      = 0;</div><div class="line"></div><div class="line">      potential.<a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                           potential_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              cell_stiffness_matrix(i, j) +=</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point)</div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)</div><div class="line">                 +</div><div class="line">                 potential_values[q_point]</div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point)</div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)</div><div class="line">                 )</div><div class="line">                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line"></div><div class="line">              cell_mass_matrix(i, j) +=</div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point)</div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)</div><div class="line">                 )</div><div class="line">                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);</div><div class="line">            }</div></div><!-- fragment --><p>Now that we have the local matrix contributions, we transfer them into the global objects and take care of zero boundary constraints:</p>
<div class="fragment"><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_stiffness_matrix,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         stiffness_matrix);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_mass_matrix,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         mass_matrix);</div><div class="line">}</div></div><!-- fragment --><p>At the end of the function, we tell PETSc that the matrices have now been fully assembled and that the sparse matrix representation can now be compressed as no more entries will be added:</p>
<div class="fragment"><div class="line">stiffness_matrix.<a class="code" href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">mass_matrix.<a class="code" href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div></div><!-- fragment --><p>Before leaving the function, we calculate spurious eigenvalues, introduced to the system by zero Dirichlet constraints. As discussed in the introduction, the use of Dirichlet boundary conditions coupled with the fact that the degrees of freedom located at the boundary of the domain remain part of the linear system we solve, introduces a number of spurious eigenvalues. Below, we output the interval within which they all lie to ensure that we can ignore them should they show up in our computations.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">         max_spurious_eigenvalue =</div><div class="line"></div><div class="line">-<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.n_dofs(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (constraints.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(i))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> ev         = stiffness_matrix(i, i) / <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>(i, i);</div><div class="line">        min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_spurious_eigenvalue, ev);</div><div class="line">        max_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_spurious_eigenvalue, ev);</div><div class="line">      }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Spurious eigenvalues are all in the interval &quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; min_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;,&quot;</span></div><div class="line">            &lt;&lt; max_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemsolve"></a> </p><h4>EigenvalueProblem::solve</h4>
<p>This is the key new functionality of the program. Now that the system is set up, here is a good time to actually solve the problem: As with other examples this is done using a "solve" routine. Essentially, it works as in other programs: you set up a <a class="el" href="classSolverControl.html">SolverControl</a> object that describes the accuracy to which we want to solve the linear systems, and then we select the kind of solver we want. Here we choose the Krylov-Schur solver of SLEPc, a pretty fast and robust choice for this kind of problem:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> EigenvalueProblem&lt;dim&gt;::solve()</div><div class="line">{</div></div><!-- fragment --><p>We start here, as we normally do, by assigning convergence control we want:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(dof_handler.n_dofs(), 1e-9);</div><div class="line"><a class="code" href="classSLEPcWrappers_1_1SolverKrylovSchur.html">SLEPcWrappers::SolverKrylovSchur</a> eigensolver(solver_control);</div></div><!-- fragment --><p>Before we actually solve for the eigenfunctions and</p>
<ul>
<li>alues, we have to also select which set of eigenvalues to solve for. Lets select those eigenvalues and corresponding eigenfunctions with the smallest real part (in fact, the problem we solve here is symmetric and so the eigenvalues are purely real). After that, we can actually let SLEPc do its work:</li>
</ul>
<div class="fragment"><div class="line">eigensolver.set_which_eigenpairs(EPS_SMALLEST_REAL);</div><div class="line"></div><div class="line">eigensolver.set_problem_type(EPS_GHEP);</div><div class="line"></div><div class="line">eigensolver.solve(stiffness_matrix,</div><div class="line">                  mass_matrix,</div><div class="line">                  eigenvalues,</div><div class="line">                  eigenfunctions,</div><div class="line">                  eigenfunctions.size());</div></div><!-- fragment --><p>The output of the call above is a set of vectors and values. In eigenvalue problems, the eigenfunctions are only determined up to a constant that can be fixed pretty arbitrarily. Knowing nothing about the origin of the eigenvalue problem, SLEPc has no other choice than to normalize the eigenvectors to one in the \(l_2\) (vector) norm. Unfortunately this norm has little to do with any norm we may be interested from a eigenfunction perspective: the \(L_2(\Omega)\) norm, or maybe the \(L_\infty(\Omega)\) norm. Let us choose the latter and rescale eigenfunctions so that they have \(\|\phi_i(\mathbf x)\|_{L^\infty(\Omega)}=1\) instead of \(\|\Phi\|_{l_2}=1\) (where \(\phi_i\) is the \(i\) th eigen<em>function</em> and \(\Phi_i\) the corresponding vector of nodal values). For the \(Q_1\) elements chosen here, we know that the maximum of the function \(\phi_i(\mathbf x)\) is attained at one of the nodes, so \(\max_{\mathbf x}\phi_i(\mathbf x)=\max_j (\Phi_i)_j\) , making the normalization in the \(L_\infty\) norm trivial. Note that this doesn't work as easily if we had chosen \(Q_k\) elements with \(k&gt;1\) : there, the maximum of a function does not necessarily have to be attained at a node, and so \(\max_{\mathbf x}\phi_i(\mathbf x)\ge\max_j (\Phi_i)_j\) (although the equality is usually nearly true).</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">  eigenfunctions[i] /= eigenfunctions[i].<a class="code" href="classTensor.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a>();</div></div><!-- fragment --><p>Finally return the number of iterations it took to converge:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">return</span> solver_control.last_step();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemoutput_results"></a> </p><h4>EigenvalueProblem::output_results</h4>
<p>This is the last significant function of this program. It uses the <a class="el" href="classDataOut.html">DataOut</a> class to generate graphical output from the eigenfunctions for later visualization. It works as in many of the other tutorial programs. The whole collection of functions is then output as a single VTK file.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(eigenfunctions[i],</div><div class="line">                             std::string(<span class="stringliteral">&quot;eigenfunction_&quot;</span>) +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i));</div></div><!-- fragment --><p>The only thing worth discussing may be that because the potential is specified as a function expression in the input file, it would be nice to also have it as a graphical representation along with the eigenfunctions. The process to achieve this is relatively straightforward: we build an object that represents \(V(\mathbf x)\) and then we interpolate this continuous function onto the finite element space. The result we also attach to the <a class="el" href="classDataOut.html">DataOut</a> object for visualization.</p>
<div class="fragment"><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> projected_potential(dof_handler.n_dofs());</div><div class="line">  {</div><div class="line">    <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div><div class="line">    potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div><div class="line">                         parameters.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div><div class="line">                         <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, potential, projected_potential);</div><div class="line">  }</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(projected_potential, <span class="stringliteral">&quot;interpolated_potential&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;eigenvectors.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemrun"></a> </p><h4>EigenvalueProblem::run</h4>
<p>This is the function which has the top-level control over everything. It is almost exactly the same as in <a class="el" href="step_4.html">step-4</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">EigenvalueProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  make_grid_and_dofs();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">            &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  assemble_system();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations = solve();</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Solver converged in &quot;</span> &lt;&lt; n_iterations &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">            &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  output_results();</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenvalues.size(); ++i)</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;      Eigenvalue &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; eigenvalues[i]</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">}</div><div class="line">} <span class="comment">// namespace Step36</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv)</div><div class="line">{</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">    <span class="keyword">using namespace </span>Step36;</div><div class="line"></div><div class="line">    <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div></div><!-- fragment --><p>This program can only be run in serial. Otherwise, throw an exception.</p>
<div class="fragment"><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                <span class="stringliteral">&quot;This program can only be run in serial, use ./step-36&quot;</span>));</div><div class="line"></div><div class="line">  EigenvalueProblem&lt;2&gt; problem(<span class="stringliteral">&quot;step-36.prm&quot;</span>);</div><div class="line">  problem.run();</div><div class="line">}</div></div><!-- fragment --><p>All the while, we are watching out if any exceptions should have been generated. If that is so, we panic...</p>
<div class="fragment"><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div></div><!-- fragment --><p>If no exceptions are thrown, then we tell the program to stop monkeying around and exit nicely:</p>
<div class="fragment"><div class="line">std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;   Job done.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Runningtheproblem"></a></p><h3>Running the problem</h3>
<p>The problem's input is parameterized by an input file <code>step-36.prm</code> which could, for example, contain the following text: </p><div class="fragment"><div class="line"><span class="keyword">set</span> Global mesh refinement steps         = 5</div><div class="line"><span class="keyword">set</span> Number of eigenvalues/eigenfunctions = 5</div><div class="line"><span class="keyword">set</span> Potential                            = 0</div></div><!-- fragment --><p>Here, the potential is zero inside the domain, and we know that theeigenvalues are given by \(\lambda_{(mn)}=\frac{\pi^2}{4}(m^2+n^2)\) where \(m,n\in{\mathbb N^+}\) . Eigenfunctions are sines and cosines with \(m\) and \(n\) periods in \(x\) and \(y\) directions. This matches the output our programgenerates: </p><div class="fragment"><div class="line">examples/step-36&gt; make run</div><div class="line">============================ Running step-36</div><div class="line">Number of active cells:       1024</div><div class="line">Number of degrees of freedom: 1089</div><div class="line">Solver converged in 67 iterations.</div><div class="line"></div><div class="line">   Eigenvalue 0 : 4.93877</div><div class="line">   Eigenvalue 1 : 12.3707</div><div class="line">   Eigenvalue 2 : 12.3707</div><div class="line">   Eigenvalue 3 : 19.8027</div><div class="line">   Eigenvalue 4 : 24.837</div><div class="line"></div><div class="line">Job done.  </div></div><!-- fragment --><p> These eigenvalues are exactly the ones thatcorrespond to pairs \((m,n)=(1,1)\) , \((1,2)\) and \((2,1)\) , \((2,2)\) , and \((3,1)\) . A visualization of the corresponding eigenfunctions wouldlook like this: </p><table width="80%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.0.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.1.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.2.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.3.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.4.png"/>
</div>
 </td><td></td></tr>
</table>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>It is always worth playing a few games in the playground! So here goeswith a few suggestions: </p><ul>
<li>
<p class="startli">The potential used above (called the <em>infinite well</em> becauseit is a flat potential surrounded by infinitely high walls) isinteresting because it allows for analytically known solutions. Apartfrom that, it is rather boring, however. That said, it is trivial toplay around with the potential by just setting it to somethingdifferent in the input file. For example, let us assume that we wantedto work with the following potential in2d: </p><p class="formulaDsp">
\[ V(x,y) = \left\{ \begin{array}{ll} -100 &amp; \text{if}\ \sqrt{x^2+y^2}&lt;\frac 34 \ \text{and} \ xy&gt;0 \\ -5 &amp; \text{if}\ \sqrt{x^2+y^2}&lt;\frac 34 \ \text{and} \ xy\le 0 \\ 0 &amp; \text{otherwise} \end{array} \right.\quad. \]
</p>
<p> other words, the potential is</p>
<ul>
<li>00 in two sectors of a circle of radius0.75,</li>
<li>in the other two sectors, and zero outside the circle. We can achievethis by using the following in the input file : <div class="fragment"><div class="line"><span class="keyword">set</span> Potential = <span class="keywordflow">if</span> (x^2 + y^2 &lt; 0.75^2, <span class="keywordflow">if</span> (x*y &gt; 0,</div><div class="line"></div><div class="line">-100,</div><div class="line"></div><div class="line">-5), 0)</div></div><!-- fragment --> If in addition we also increase the mesh refinement by one level, we get thefollowing results: <div class="fragment"><div class="line">examples/step-36&gt; make run</div><div class="line">============================ Running step-36</div><div class="line">Number of active cells:       4096</div><div class="line">Number of degrees of freedom: 4225</div><div class="line"></div><div class="line">Eigenvalue 0 :</div><div class="line"></div><div class="line">-74.2562</div><div class="line">Eigenvalue 1 :</div><div class="line"></div><div class="line">-72.7322</div><div class="line">Eigenvalue 2 :</div><div class="line"></div><div class="line">-42.7406</div><div class="line">Eigenvalue 3 :</div><div class="line"></div><div class="line">-42.2232</div><div class="line">Eigenvalue 4 :</div><div class="line"></div><div class="line">-37.0744</div></div><!-- fragment --></li>
</ul>
<p class="endli">The output file also contains an interpolated version of the potential, whichlooks like this (note that as expected the lowest few eigenmodes haveprobability densities \(|\Psi(\mathbf x)|^2\) that are significant only where thepotential is the lowest, i.e. in the top right and bottom left sector of innercircle of the potential): </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.potential.png"/>
</div>
<p> The first five eigenfunctions are now like this: </p><table width="80%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.0.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.1.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.2.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.3.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.4.png"/>
</div>
 </td><td></td></tr>
</table>
</li>
<li>
In our derivation of the problem we have assumed that theparticle is confined to a domain \(\Omega\) and that at the boundary ofthis domain its probability \(|\Psi|^2\) of being is zero. This isequivalent to solving the eigenvalue problem on all of \({\mathbb R}^d\) and assuming that the energy potential is finite only inside a region \(\Omega\) and infinite outside. It is relatively easy to show that \(|\Psi(\mathbf x)|^2\) at all locations \(\mathbf x\) where \(V(\mathbf x)=\infty\) . So the question is what happens if our potential is not ofthis form, i.e. there is no bounded domain outside of which thepotential is infinite? In that case, it may be worth to just considera very large domain at the boundary of which \(V(\mathbf x)\) is atleast very large, if not infinite. Play around with a few cases likethis and explore how the spectrum and eigenfunctions change as we makethe computational region larger and larger. </li>
<li>
What happens if we investigate the simple harmonic oscillatorproblem \(V(\mathbf x)=c|\mathbf x|^2\) ? This potential is exactly ofthe form discussed in the previous paragraph and has hyper sphericalsymmetry. One may want to use a large spherical domain with a largeouter radius, to approximate the whole-space problem (say, by invoking <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>). </li>
<li>
The plots above show the wave function \(\Psi(\mathbf x)\) , but thephysical quantity of interest is actually the probability density \(|\Psi(\mathbf x)|^2\) for the particle to be at location \(\mathbf x\) .Some visualization programs can compute derived quantities from the data inan input file, but we can also do so right away when creating the outputfile. The facility to do that is the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> class that canbe used in conjunction with the <a class="el" href="classDataOut.html">DataOut</a> class. Examples of how thiscan be done can be found in <a class="el" href="step_29.html">step-29</a> and <a class="el" href="step_33.html">step-33</a> . </li>
<li>
What happens if the particle in the box has internal degrees offreedom? For example, if the particle were a spin- \(1/2\) particle? Inthat case, we may want to start solving a vector-valued probleminstead. </li>
<li>
Our implementation of the deal.II library here uses thePETScWrappers and <a class="el" href="namespaceSLEPcWrappers.html">SLEPcWrappers</a> and is suitable for running on serialmachine architecture. However, for larger grids and with a largernumber of degrees-of-freedom, we may want to run our application onparallel architectures. A parallel implementation of the above codecan be particularly useful here since the generalized eigenspectrumproblem is somewhat more expensive to solve than the standard problemsconsidered in most of the earlier tutorials. Fortunately, modifying the aboveprogram to be MPI compliant is a relatively straightforwardprocedure. A sketch of how this can be done can be found in <a class="el" href="step_17.html">step_17 </a>step-17"  ". </li>
<li>
<p class="startli">Finally, there are alternatives to using the SLEPc eigenvaluesolvers. deal.II has interfaces to one of them, ARPACK (see <a href="../../external-libs/arpack.html">the ARPACK configuration page</a> forsetup instructions), implemented in the <a class="el" href="classArpackSolver.html">ArpackSolver</a> class. Here is a short andquick overview of what one would need to change to use it, provided you have aworking installation of ARPACK and deal.II has been configured properly for it(see the deal.II <a href="../../readme.html" target="body">README</a> file): First, in order to use the ARPACK interfaces, we can go back to using standarddeal.II matrices and vectors, so we start by replacing the PETSc and SLEPcheaders </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="slepc__solver_8h.html">deal.II/lac/slepc_solver.h</a>&gt;</span></div></div><!-- fragment --><p> with these: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="arpack__solver_8h.html">deal.II/lac/arpack_solver.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/compressed_sparsity_pattern.h&gt;</span></div></div><!-- fragment --><p> ARPACK allows complex eigenvalues, so we will also need </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;complex&gt;</span></div></div><!-- fragment --><p>Secondly, we switch back to the deal.II matrix and vector definitions in themain class: </p><div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a>                     sparsity_pattern;</div><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>                stiffness_matrix, <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">std::vector&lt;Vector&lt;double&gt; &gt;        eigenfunctions;</div><div class="line">std::vector&lt;std::complex&lt;double&gt;&gt;   <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>;</div></div><!-- fragment --><p> and initialize them as usual in <code>make_grid_and_dofs()</code> : </p><div class="fragment"><div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a> (dof_handler.n_dofs(),</div><div class="line">                         dof_handler.n_dofs(),</div><div class="line">                         dof_handler.max_couplings_between_dofs());</div><div class="line"></div><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> (dof_handler, sparsity_pattern);</div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">condense</a> (sparsity_pattern);</div><div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress</a>();</div><div class="line"></div><div class="line">stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a> (sparsity_pattern);</div><div class="line">mass_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a> (sparsity_pattern);</div></div><!-- fragment --><p class="endli">For solving the eigenvalue problem with ARPACK, we finally need to modify <code>solve()</code> : </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> EigenvalueProblem&lt;dim&gt;::solve ()</div><div class="line">{</div><div class="line"> <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (dof_handler.n_dofs(), 1e-9);</div><div class="line"></div><div class="line"> <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> inverse;</div><div class="line"> inverse.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a> (stiffness_matrix);</div><div class="line"></div><div class="line"> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_arnoldi_vectors = 2*eigenvalues.size() + 2;</div><div class="line"> <a class="code" href="structArpackSolver_1_1AdditionalData.html">ArpackSolver::AdditionalData</a> additional_data(num_arnoldi_vectors);</div><div class="line"></div><div class="line"> <a class="code" href="classArpackSolver.html">ArpackSolver</a> eigensolver (solver_control, additional_data);</div><div class="line"> eigensolver.solve (stiffness_matrix,</div><div class="line">                    mass_matrix,</div><div class="line">                    inverse,</div><div class="line">                    eigenvalues,</div><div class="line">                    eigenfunctions,</div><div class="line">                    eigenvalues.size());</div><div class="line"></div><div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;eigenfunctions.size(); ++i)</div><div class="line">   eigenfunctions[i] /= eigenfunctions[i].<a class="code" href="classTensor.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a> ();</div><div class="line"></div><div class="line"> <span class="keywordflow">return</span> solver_control.last_step ();</div><div class="line">}</div></div><!-- fragment --><p> Note how we have used an exact decomposition (using <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>) as apreconditioner to ARPACK. </p>
</li>
</ul>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2009 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Toby D. Young, Polish Academy of Sciences,</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function__parser_8h.html">deal.II/base/function_parser.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="slepc__solver_8h.html">deal.II/lac/slepc_solver.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step36</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>EigenvalueProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span>         make_grid_and_dofs();</div><div class="line">    <span class="keywordtype">void</span>         assemble_system();</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> solve();</div><div class="line">    <span class="keywordtype">void</span>         output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix</a>             stiffness_matrix, <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">    std::vector&lt;PETScWrappers::MPI::Vector&gt; eigenfunctions;</div><div class="line">    std::vector&lt;double&gt;                     <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638ad91ede5cc912c10676843bf58fa60636">eigenvalues</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> parameters;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  EigenvalueProblem&lt;dim&gt;::EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file)</div><div class="line">    : fe(1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">  {</div><div class="line">    parameters.declare_entry(</div><div class="line">      <span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 20),</div><div class="line">      <span class="stringliteral">&quot;The number of times the 1-cell coarse mesh should &quot;</span></div><div class="line">      <span class="stringliteral">&quot;be refined globally for our computations.&quot;</span>);</div><div class="line">    parameters.declare_entry(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>,</div><div class="line">                             <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">                             <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 100),</div><div class="line">                             <span class="stringliteral">&quot;The number of eigenvalues/eigenfunctions &quot;</span></div><div class="line">                             <span class="stringliteral">&quot;to be computed.&quot;</span>);</div><div class="line">    parameters.declare_entry(<span class="stringliteral">&quot;Potential&quot;</span>,</div><div class="line">                             <span class="stringliteral">&quot;0&quot;</span>,</div><div class="line">                             <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                             <span class="stringliteral">&quot;A functional description of the potential.&quot;</span>);</div><div class="line"></div><div class="line">    parameters.parse_input(prm_file);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::make_grid_and_dofs()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(</div><div class="line">      parameters.get_integer(<span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>));</div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a>(dof_handler, constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">    stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(dof_handler.n_dofs(),</div><div class="line">                            dof_handler.n_dofs(),</div><div class="line">                            dof_handler.max_couplings_between_dofs());</div><div class="line">    mass_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(dof_handler.n_dofs(),</div><div class="line">                       dof_handler.n_dofs(),</div><div class="line">                       dof_handler.max_couplings_between_dofs());</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> eigenfunction_index_set = dof_handler.locally_owned_dofs();</div><div class="line">    eigenfunctions.resize(</div><div class="line">      parameters.get_integer(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>));</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">      eigenfunctions[i].<a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(eigenfunction_index_set, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    eigenvalues.resize(eigenfunctions.size());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_stiffness_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div><div class="line">    potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div><div class="line">                         parameters.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div><div class="line">                         <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; potential_values(n_q_points);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        cell_stiffness_matrix = 0;</div><div class="line">        cell_mass_matrix      = 0;</div><div class="line"></div><div class="line">        potential.<a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             potential_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                cell_stiffness_matrix(i, j) +=           </div><div class="line">                  (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *    </div><div class="line">                     fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)    </div><div class="line">                   +                                     </div><div class="line">                   potential_values[q_point] *           </div><div class="line">                     fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * </div><div class="line">                     fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)   </div><div class="line">                   ) *                                   </div><div class="line">                  fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);                </div><div class="line"></div><div class="line">                cell_mass_matrix(i, j) +=              </div><div class="line">                  (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * </div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)   </div><div class="line">                   ) *                                 </div><div class="line">                  fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);              </div><div class="line">              }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_stiffness_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               stiffness_matrix);</div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_mass_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               mass_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    stiffness_matrix.<a class="code" href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    mass_matrix.<a class="code" href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">           max_spurious_eigenvalue = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.n_dofs(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (constraints.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(i))</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> ev         = stiffness_matrix(i, i) / <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>(i, i);</div><div class="line">          min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_spurious_eigenvalue, ev);</div><div class="line">          max_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_spurious_eigenvalue, ev);</div><div class="line">        }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Spurious eigenvalues are all in the interval &quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; min_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;,&quot;</span></div><div class="line">              &lt;&lt; max_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> EigenvalueProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(dof_handler.n_dofs(), 1e-9);</div><div class="line">    <a class="code" href="classSLEPcWrappers_1_1SolverKrylovSchur.html">SLEPcWrappers::SolverKrylovSchur</a> eigensolver(solver_control);</div><div class="line"></div><div class="line">    eigensolver.set_which_eigenpairs(EPS_SMALLEST_REAL);</div><div class="line"></div><div class="line">    eigensolver.set_problem_type(EPS_GHEP);</div><div class="line"></div><div class="line">    eigensolver.solve(stiffness_matrix,</div><div class="line">                      mass_matrix,</div><div class="line">                      eigenvalues,</div><div class="line">                      eigenfunctions,</div><div class="line">                      eigenfunctions.size());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">      eigenfunctions[i] /= eigenfunctions[i].<a class="code" href="tensor_8h.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> solver_control.last_step();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(eigenfunctions[i],</div><div class="line">                               std::string(<span class="stringliteral">&quot;eigenfunction_&quot;</span>) +</div><div class="line">                                 <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i));</div><div class="line"></div><div class="line">    Vector&lt;double&gt; projected_potential(dof_handler.n_dofs());</div><div class="line">    {</div><div class="line">      <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div><div class="line">      potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div><div class="line">                           parameters.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div><div class="line">                           <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, potential, projected_potential);</div><div class="line">    }</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(projected_potential, <span class="stringliteral">&quot;interpolated_potential&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;eigenvectors.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">EigenvalueProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    assemble_system();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations = solve();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solver converged in &quot;</span> &lt;&lt; n_iterations &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    output_results();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenvalues.size(); ++i)</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;      Eigenvalue &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; eigenvalues[i]</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step36</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step36;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-36&quot;</span>));</div><div class="line"></div><div class="line">      EigenvalueProblem&lt;2&gt; problem(<span class="stringliteral">&quot;step-36.prm&quot;</span>);</div><div class="line">      problem.run();</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;   Job done.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_4.html">step-4</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#EigenvaluesandDirichletboundaryconditions">Eigenvalues and Dirichlet boundary conditions</a>
        <li><a href="#Implementationdetails">Implementation details</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeEigenvalueProblemcodeclasstemplate">The <code>EigenvalueProblem</code> class template</a>
        <li><a href="#ImplementationofthecodeEigenvalueProblemcodeclass">Implementation of the <code>EigenvalueProblem</code> class</a>
      <ul>
        <li><a href="#EigenvalueProblemEigenvalueProblem">EigenvalueProblem::EigenvalueProblem</a>
        <li><a href="#EigenvalueProblemmake_grid_and_dofs">EigenvalueProblem::make_grid_and_dofs</a>
        <li><a href="#EigenvalueProblemassemble_system">EigenvalueProblem::assemble_system</a>
        <li><a href="#EigenvalueProblemsolve">EigenvalueProblem::solve</a>
        <li><a href="#EigenvalueProblemoutput_results">EigenvalueProblem::output_results</a>
        <li><a href="#EigenvalueProblemrun">EigenvalueProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Runningtheproblem">Running the problem</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-36/doc/intro.dox</p>
<p><br />
</p>
<p><em>This program was contributed by Toby D. Young and Wolfgang Bangerth. </em></p>
<p><a class="anchor" id="Preamble"></a></p>
<p><a class="anchor" id="Preamble"></a></p><h1>Preamble</h1>
<p>Âú®Ëøô‰∏™‰æãÂ≠ê‰∏≠ÔºåÊàë‰ª¨Ë¶ÅËß£ÂÜ≥ÁöÑÈóÆÈ¢òÊòØ‰∏Ä‰∏™ÁâπÂæÅË∞±ÈóÆÈ¢ò„ÄÇÁâπÂæÅÂÄºÈóÆÈ¢òÂá∫Áé∞Âú®ÂπøÊ≥õÁöÑÈóÆÈ¢òËÉåÊôØ‰∏≠Ôºå‰æãÂ¶ÇÂú®ËÆ°ÁÆóËÖî‰Ωì‰∏≠ÁöÑÁîµÁ£ÅÈ©ªÊ≥¢„ÄÅÈºìËÜúÁöÑÊåØÂä®Ê®°ÂºèÊàñÊπñÊ≥äÂíåÊ≤≥Âè£ÁöÑÊåØËç°‰∏≠„ÄÇÊúÄÁ•ûÁßòÁöÑÂ∫îÁî®‰πã‰∏ÄÂèØËÉΩÊòØÈáèÂ≠êÂäõÂ≠¶‰∏≠ÈùôÊ≠¢ÊàñÂáÜÈùôÊ≠¢Ê≥¢ÂáΩÊï∞ÁöÑËÆ°ÁÆó„ÄÇÂêé‰∏ÄÁßçÂ∫îÁî®ÊòØÊàë‰ª¨Âú®Ê≠§ÊÉ≥Á†îÁ©∂ÁöÑÔºåÂ∞ΩÁÆ°Êú¨ÊñπÊ°à‰∏≠Ê¶ÇËø∞ÁöÑ‰∏ÄËà¨ÊäÄÊúØÂΩìÁÑ∂ÂêåÊ†∑ÈÄÇÁî®‰∫é‰∏äËø∞ÂÖ∂‰ªñÂ∫îÁî®„ÄÇ</p>
<p>EigenspectrumÈóÆÈ¢òÁöÑ‰∏ÄËà¨ÂΩ¢ÂºèÊòØ</p>
<p class="formulaDsp">
\begin{align*} L \Psi &amp;= \varepsilon \Psi \qquad &amp;&amp;\text{in}\ \Omega\quad, \\ \Psi &amp;= 0 &amp;&amp;\text{on}\ \partial\Omega\quad, \end{align*}
</p>
<p>ÂÖ∂‰∏≠ \(\Psi=\Psi(\mathbf x)\) ‰∏äÁöÑËø™ÈáåÂàáÁâπËæπÁïåÊù°‰ª∂‰πüÂèØ‰ª•Áî®ËØ∫‰ºäÊõºÊàñÁΩóÂÆæÊù°‰ª∂‰ª£ÊõøÔºõ \(L\) ÊòØ‰∏Ä‰∏™ÁÆóÂ≠êÔºå‰∏ÄËà¨‰πüÂåÖÂê´ÂæÆÂàÜÁÆóÂ≠ê„ÄÇ</p>
<p>Âú®ÈÄÇÂΩìÁöÑÊù°‰ª∂‰∏ãÔºå‰∏äËø∞ÊñπÁ®ãÊúâ‰∏ÄÁªÑËß£ \(\Psi_\ell,\varepsilon_\ell\) , \(\ell\in {\cal I}\) ÔºåÂÖ∂‰∏≠ \(\cal I\) ÂèØ‰ª•ÊòØ‰∏Ä‰∏™ÊúâÈôêÁöÑÊàñÊó†ÈôêÁöÑÈõÜÂêàÔºàÂú®Âêé‰∏ÄÁßçÊÉÖÂÜµ‰∏ãÔºåÂÆÉÂèØËÉΩÊòØ‰∏Ä‰∏™Á¶ªÊï£ÁöÑÊàñÊúâÊó∂Ëá≥Â∞ëÊòØÈÉ®ÂàÜËøûÁª≠ÁöÑÈõÜÂêàÔºâ„ÄÇÂú®Ëøô‰∏§ÁßçÊÉÖÂÜµ‰∏ãÔºåËÆ©Êàë‰ª¨Ê≥®ÊÑèÂà∞ÔºåÊàë‰ª¨Ë¶ÅËÆ°ÁÆóÁöÑ‰∏çÂÜçÂè™ÊòØ‰∏Ä‰∏™Âçï‰∏ÄÁöÑËß£ÂÜ≥ÊñπÊ°àÔºåËÄåÊòØ‰∏ÄÁªÑËß£ÂÜ≥ÊñπÊ°àÔºàÂêÑÁßçÁâπÂæÅÂáΩÊï∞ÂíåÁõ∏Â∫îÁöÑÁâπÂæÅÂÄºÔºâ„ÄÇ‰ªéÊï∞Â≠ó‰∏äÂØªÊâæËøôÁ±ªÁâπÂæÅÂÄºÈóÆÈ¢òÁöÑÊâÄÊúâÁâπÂæÅÂÄºÔºàÁâπÂæÅÂáΩÊï∞ÔºâÁöÑÈóÆÈ¢òÊòØ‰∏Ä‰∏™Ëâ∞Â∑®ÁöÑÊåëÊàò„ÄÇ‰∫ãÂÆû‰∏äÔºåÂ¶ÇÊûúÈõÜÂêà \(\cal I\) ÊòØÊó†ÈôêÁöÑÔºåËøô‰∏™ÊåëÊàòÂΩìÁÑ∂ÊòØÈöæ‰ª•Ëß£ÂÜ≥ÁöÑ„ÄÇ ÁÑ∂ËÄåÔºåÂ§ßÂ§öÊï∞Êó∂ÂÄôÔºåÊàë‰ª¨ÂÆûÈôÖ‰∏äÂè™ÂØπËøô‰∫õÂÄºÔºàÂáΩÊï∞ÔºâÁöÑ‰∏ÄÂ∞èÈÉ®ÂàÜÊÑüÂÖ¥Ë∂£ÔºõÂπ∏ËøêÁöÑÊòØÔºåÊàë‰ª¨Â∞ÜÂú®Ëøô‰∏™ÊïôÁ®ãÁ®ãÂ∫è‰∏≠‰ΩøÁî®ÁöÑSLEPcÂ∫ìÁöÑÊé•Âè£ÂÖÅËÆ∏Êàë‰ª¨ÈÄâÊã©ÁâπÂæÅË∞±ÁöÑÂì™‰∏ÄÈÉ®ÂàÜÂíåÊàë‰ª¨ÊÉ≥Ë¶ÅËß£ÂÜ≥ÁöÑÂ§öÂ∞ë‰∏™Ëß£ÂÜ≥ÊñπÊ°à„ÄÇ</p>
<p>Âú®Ëøô‰∏™Á®ãÂ∫è‰∏≠ÔºåÊàë‰ª¨‰ΩøÁî®ÁöÑeigenspectrumÊ±ÇËß£Âô®ÊòØÁî±deal.IIÊèê‰æõÁöÑÁ±ªÔºåÂõ¥Áªï<a href="http://www.grycap.upv.es/slepc/" target="_top">SLEPc</a>Â∫ìÁöÑÁ∫øÊÄß‰ª£Êï∞ÂÆûÁé∞ÔºõSLEPcÊú¨Ë∫´Âª∫Á´ãÂú®<a href="http://www.mcs.anl.gov/petsc/" target="_top">PETSc</a>Â∫ìÁöÑÁ∫øÊÄß‰ª£Êï∞ÂÜÖÂÆπ‰πã‰∏ä„ÄÇ</p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>ÈùôÊ≠¢ÁöÑÈáèÂ≠êÂäõÂ≠¶ÁöÑÂü∫Êú¨ÊñπÁ®ãÊòØËñõÂÆöË∞îÊñπÁ®ãÔºåÂÆÉÊ®°ÊãüÁ≤íÂ≠êÂú®Â§ñÈÉ®Âäø‰∏≠ÁöÑËøêÂä® \(V(\mathbf x)\) „ÄÇÁ≤íÂ≠êÁî±‰∏Ä‰∏™Ê≥¢ÂáΩÊï∞ \(\Psi(\mathbf x)\) ÊèèËø∞ÔºåÂÆÉÊª°Ë∂≥‰∏Ä‰∏™ÔºàÈùûÁª¥Â∫¶ÂåñÔºâÂΩ¢ÂºèÁöÑÂÖ≥Á≥ª</p>
<p class="formulaDsp">
\begin{align*} [-\Delta + V(\mathbf x)] \Psi(\mathbf x) &amp;= \varepsilon \Psi(\mathbf x) \qquad &amp;&amp;\text{in}\ \Omega\quad, \\ \Psi &amp;= 0 &amp;&amp;\text{on}\ \partial\Omega\quad. \end{align*}
</p>
<p>Âõ†Ê≠§ÔºåËøô‰∏™Á≤íÂ≠êÂè™ËÉΩÂ≠òÂú®‰∫é‰∏ÄÂÆöÊï∞ÈáèÁöÑÁâπÂæÅÊÄÅ‰∏≠ÔºåËøô‰∫õÁâπÂæÅÊÄÅÂØπÂ∫î‰∫é‰Ωú‰∏∫ËØ•ÊñπÁ®ãËß£ÁöÑËÉΩÈáèÁâπÂæÅÂÄº \(\varepsilon_\ell\) „ÄÇÈáèÂ≠êÂäõÂ≠¶ÁöÑÊ≠£ÁªüÔºàÂì•Êú¨ÂìàÊ†πÔºâËß£ÈáäËÆ§‰∏∫ÔºåÂ¶ÇÊûú‰∏Ä‰∏™Á≤íÂ≠êÂÖ∑ÊúâËÉΩÈáè \(\varepsilon_\ell\) ÔºåÈÇ£‰πàÂú®‰ΩçÁΩÆ \(\mathbf x\) ÊâæÂà∞ÂÆÉÁöÑÊ¶ÇÁéá‰∏é \(|\Psi_\ell(\mathbf x)|^2\) ÊàêÊ≠£ÊØîÔºåÂÖ∂‰∏≠ \(\Psi_\ell\) ÊòØÂØπÂ∫î‰∫éËøô‰∏™ÁâπÂæÅÂÄºÁöÑÁâπÂæÅÂáΩÊï∞„ÄÇ</p>
<p>‰∏∫‰∫ÜÂú®Êï∞ÂÄº‰∏äÊâæÂà∞Ëøô‰∏™ÊñπÁ®ãÁöÑËß£ÔºåÂç≥‰∏ÄÁªÑÊàêÂØπÁöÑÁâπÂæÅÂÄº/ÁâπÂæÅÂáΩÊï∞ÔºåÊàë‰ª¨‰ΩøÁî®ÈÄöÂ∏∏ÁöÑÊúâÈôêÂÖÉÊñπÊ≥ïÔºåÂ∞ÜÂ∑¶ËæπÁöÑÊñπÁ®ã‰∏éÊµãËØïÂáΩÊï∞Áõ∏‰πòÔºåÈÄöËøáÈÉ®ÂàÜÁßØÂàÜÔºåÂú®ÊúâÈôêÁª¥Á©∫Èó¥‰∏≠ÈÄöËøáËøë‰ºº \(\Psi(\mathbf x)\approx\Psi_h(\mathbf x)=\sum_{j}\phi_j(\mathbf x)\tilde\psi_j\) ÂØªÊâæËß£ÔºåÂÖ∂‰∏≠ \(\tilde\psi\) ÊòØ‰∏Ä‰∏™Êâ©Â±ïÁ≥ªÊï∞ÁöÑÁü¢Èáè„ÄÇÁÑ∂ÂêéÔºåÊàë‰ª¨Á´ãÂç≥ÂæóÂá∫‰ª•‰∏ãÊñπÁ®ãÔºåÂ∞ÜËøûÁª≠ÁâπÂæÅÂÄºÈóÆÈ¢òÁ¶ªÊï£ÂåñÔºö </p><p class="formulaDsp">
\[ \sum_j [(\nabla\phi_i, \nabla\phi_j)+(V(\mathbf x)\phi_i,\phi_j)] \tilde{\psi}_j = \varepsilon_h \sum_j (\phi_i, \phi_j) \tilde{\psi}_j\quad. \]
</p>
<p> Âú®Áü©ÈòµÂíåÁü¢ÈáèÁ¨¶Âè∑‰∏≠ÔºåËøô‰∏™ÊñπÁ®ãÁÑ∂ÂêéËØª‰Ωú„ÄÇ </p><p class="formulaDsp">
\[ A \tilde{\Psi} = \varepsilon_h M \tilde{\Psi} \quad, \]
</p>
<p> ÂÖ∂‰∏≠ \(A\) ÊòØÁî±ÂæÆÂàÜÁÆóÂ≠ê \(L\) ‰∫ßÁîüÁöÑÂàöÂ∫¶Áü©ÈòµÔºåËÄå \(M\) ÊòØË¥®ÈáèÁü©Èòµ„ÄÇÁâπÂæÅÂÄºÈóÆÈ¢òÁöÑËß£ÂÜ≥ÊñπÊ°àÊòØ‰∏Ä‰∏™ÁâπÂæÅË∞± \(\varepsilon_{h,\ell}\) Ôºå‰ª•ÂèäÁõ∏ÂÖ≥ÁöÑÁâπÂæÅÂáΩÊï∞ \(\Psi_\ell=\sum_j \phi_j\tilde{\psi}_j\) „ÄÇ</p>
<p><a class="anchor" id="EigenvaluesandDirichletboundaryconditions"></a></p><h3>Eigenvalues and Dirichlet boundary conditions</h3>
<p>Âú®Ëøô‰∏™Á®ãÂ∫è‰∏≠ÔºåÊàë‰ª¨ÂØπÊ≥¢ÂáΩÊï∞ \(\Psi\) ‰ΩøÁî®‰∫ÜDirichletËæπÁïåÊù°‰ª∂„ÄÇ‰ªéÊúâÈôêÂÖÉ‰ª£Á†ÅÁöÑËßíÂ∫¶Êù•ÁúãÔºåËøôÊÑèÂë≥ÁùÄÂè™ÊúâÂÜÖÈÉ®ÁöÑËá™Áî±Â∫¶ÊòØ<em>freedom</em>ÁöÑÂÆûÊï∞Â∫¶ÔºöËæπÁïå‰∏äÁöÑËá™Áî±Â∫¶‰∏çÊòØËá™Áî±ÁöÑÔºå‰ΩÜÊØïÁ´üÊòØË¢´Ëø´Êúâ‰∏Ä‰∏™Èõ∂ÂÄº„ÄÇÂè¶‰∏ÄÊñπÈù¢ÔºåÊúâÈôêÂÖÉÊñπÊ≥ïÁöÑÂäõÈáèÂíåÁÆÄÂçïÊÄß‰∏ªË¶ÅÊù•Ëá™‰∫éÊàë‰ª¨Âè™ÊòØÂú®ÊØè‰∏™ÂçïÂÖÉ‰∏äÂÅöÂêåÊ†∑ÁöÑ‰∫ãÊÉÖÔºåËÄå‰∏çÈúÄË¶ÅËøáÂ§öËÄÉËôë‰∏Ä‰∏™ÂçïÂÖÉÂú®Âì™ÈáåÔºåÂÆÉÊòØÂê¶Âú®‰∏Ä‰∏™‰∏çÂ§™Á≤æÁªÜÁöÑÂçïÂÖÉ‰∏äÔºåÂõ†Ê≠§Êúâ‰∏Ä‰∏™ÊÇ¨ÊåÇÁöÑËäÇÁÇπÔºåÊàñËÄÖ‰∏éËæπÁïåÁõ∏ÈÇª„ÄÇÊâÄÊúâËøô‰∫õÊ£ÄÊü•ÈÉΩ‰ºö‰ΩøÊúâÈôêÂÖÉÁ∫øÊÄßÁ≥ªÁªüÁöÑÁªÑË£ÖÂèòÂæóÈöæ‰ª•ÂøçÂèóÔºåÁîöËá≥Êõ¥ÈöæÈòÖËØª„ÄÇ</p>
<p>Âõ†Ê≠§ÔºåÂΩìÁÑ∂ÔºåÂΩì‰Ω†Áî®DoFHandlerÂØπË±°ÂàÜÈÖçËá™Áî±Â∫¶Êó∂Ôºå‰Ω†Âπ∂‰∏çÂÖ≥ÂøÉ‰Ω†Âàó‰∏æÁöÑ‰∏Ä‰∫õËá™Áî±Â∫¶ÊòØÂê¶Â§Ñ‰∫éËø™ÈáåÂàáÁâπËæπÁïå„ÄÇ‰ªñ‰ª¨ÈÉΩ‰ºöÂæóÂà∞Êï∞Â≠ó„ÄÇÊàë‰ª¨Âè™ÈúÄË¶ÅÂú®‰ª•ÂêéÂ∫îÁî®ËæπÁïåÂÄºÁöÑÊó∂ÂÄôÁÖßÈ°æÂà∞Ëøô‰∫õËá™Áî±Â∫¶„ÄÇÊúâ‰∏§ÁßçÂü∫Êú¨ÁöÑÊñπÊ≥ïÔºàË¶Å‰πà‰ΩøÁî® <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a> <em>after</em>Ë£ÖÈÖçÁ∫øÊÄßÁ≥ªÁªüÔºåË¶Å‰πà‰ΩøÁî® <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> <em>during</em>Ë£ÖÈÖçÔºõÊõ¥Â§ö‰ø°ÊÅØËßÅ <a class="el" href="group__constraints.html">Á∫¶ÊùüÊ®°Âùó</a>ÔºâÔºå‰ΩÜ‰∏§ËÄÖÁöÑÁªìÊûúÈÉΩ‰∏ÄÊ†∑Ôºö‰∏Ä‰∏™Á∫øÊÄßÁ≥ªÁªüÁöÑÊÄªË°åÊï∞Á≠â‰∫é<em>all</em>Ëá™Áî±Â∫¶ÁöÑÊï∞ÈáèÔºåÂåÖÊã¨ÈÇ£‰∫õ‰Ωç‰∫éËæπÁïåÁöÑËá™Áî±Â∫¶„ÄÇÁÑ∂ËÄåÔºåÂèóËø™ÈáåÂ∏åÁâπÊù°‰ª∂Á∫¶ÊùüÁöÑËá™Áî±Â∫¶‰∏éÁ∫øÊÄßÁ≥ªÁªüÁöÑÂÖ∂‰ªñÈÉ®ÂàÜÂàÜÂºÄÔºåÊñπÊ≥ïÊòØÂ∞ÜÁõ∏Â∫îÁöÑË°åÂíåÂàóÊ∏ÖÈõ∂ÔºåÂú®ÂØπËßíÁ∫ø‰∏äÊîæ‰∏Ä‰∏™Ê≠£Êù°ÁõÆÔºåÂπ∂Âú®Âè≥ÊâãËæπÊîæÁõ∏Â∫îÁöÑËø™ÈáåÂ∏åÁâπÂÄº„ÄÇ</p>
<p>Â¶ÇÊûú‰Ω†ÊöÇÊó∂ÂÅáËÆæÊàë‰ª¨Â∞ÜËá™Áî±Â∫¶ÈáçÊñ∞ÁºñÂè∑Ôºå‰ΩøËø™ÈáåÂàáÁâπËæπÁïå‰∏äÁöÑÊâÄÊúâËá™Áî±Â∫¶ÊéíÂú®ÊúÄÂêéÔºåÈÇ£‰πàÊàë‰ª¨Âú®Ê±ÇËß£‰∏Ä‰∏™ÊúâÂè≥ÊâãËæπÁöÑÂ∏∏ËßÑPDEÊó∂ÂæóÂà∞ÁöÑÁ∫øÊÄßÁ≥ªÁªüÂ∞ÜÊòØËøôÊ†∑ÁöÑ„ÄÇ</p>
<p class="formulaDsp">
\begin{align*} \begin{pmatrix} A_i &amp; 0 \\ 0 &amp; D_b \end{pmatrix} \begin{pmatrix} U_i \\ U_b \end{pmatrix} = \begin{pmatrix} F_i \\ F_b \end{pmatrix}. \end{align*}
</p>
<p>ËøôÈáåÔºå‰∏ãÊ†á \(i\) Âíå \(b\) ÂàÜÂà´ÂØπÂ∫î‰∫éÂÜÖÈÉ®ÂíåËæπÁïåËá™Áî±Â∫¶„ÄÇÂÜÖÈÉ®Ëá™Áî±Â∫¶Êª°Ë∂≥Á∫øÊÄßÁ≥ªÁªü \(A_i U_i=F_i\) ÔºåÂú®ÂÜÖÈÉ®‰∫ßÁîüÊ≠£Á°ÆÁöÑËß£ÔºåËæπÁïåÂÄºÁî± \(U_b = D_b^{-1} F_b\) ÂÜ≥ÂÆöÔºåÂÖ∂‰∏≠ \(D_b\) ÊòØ‰∏Ä‰∏™ÂØπËßíÁü©ÈòµÔºåÁî±Ê∂àÈô§ËæπÁïåËá™Áî±Â∫¶ÁöÑËøáÁ®ã‰∫ßÁîüÔºå \(F_b\) ÊòØ‰ª•ËøôÊ†∑ÁöÑÊñπÂºèÈÄâÊã©ÁöÑÔºö \(U_{b,j}=D_{b,jj}^{-1} F_{b,j}\) ÂØπÊØè‰∏™ËæπÁïåËá™Áî±Â∫¶ \(j\) ÈÉΩÊúâÊ≠£Á°ÆÁöÑËæπÁïåÂÄº„ÄÇ ÂØπ‰∫éÂ•ΩÂ•áÁöÑ‰∫∫Êù•ËØ¥ÔºåÁü©Èòµ \(D_b\) ÁöÑÊù°ÁõÆÊòØÂ∞Ü‰øÆÊîπÂêéÁöÑÂ±ÄÈÉ®Ë¥°ÁåÆÂä†ÂÖ•ÂÖ®Â±ÄÁü©ÈòµÁöÑÁªìÊûúÔºåÂØπ‰∫éÂ±ÄÈÉ®Áü©ÈòµÔºåÂ¶ÇÊûúÈùûÈõ∂ÔºåÂØπËßíÁ∫øÂÖÉÁ¥†Ë¢´ËÆæÁΩÆ‰∏∫ÂÖ∂ÁªùÂØπÂÄºÔºõÂê¶ÂàôÔºåÂÆÉ‰ª¨Ë¢´ËÆæÁΩÆ‰∏∫ÂØπËßíÁ∫øÁöÑÁªùÂØπÂÄºÁöÑÂπ≥ÂùáÂÄº„ÄÇËøô‰∏™ËøáÁ®ã‰øùËØÅ‰∫Ü \(D_b\) ÁöÑÊù°ÁõÆÊòØÊ≠£ÁöÑÔºåÂπ∂‰∏îÂ§ßÂ∞è‰∏éÂØπËßíÁ∫øÁöÑÂÖ∂‰ªñÊù°ÁõÆÁõ∏ÂΩìÔºåÁ°Æ‰øùÊâÄ‰∫ßÁîüÁöÑÁü©Èòµ‰∏ç‰ºöÂõ†‰∏∫Ê∂âÂèäÂà∞Â§ßÂ∞èËø•ÂºÇÁöÑÁü©ÈòµÊù°ÁõÆÁöÑËàçÂÖ•ËÄå‰∫ßÁîü‰∏çÂêàÁêÜÁöÑÁ≤æÂ∫¶ÊçüÂ§±„ÄÇÊúÄÁªàÂá∫Áé∞Âú®ÂØπËßíÁ∫ø‰∏äÁöÑÂÆûÈôÖÊï∞ÂÄºÊòØÂæàÈöæÈ¢ÑÊµãÁöÑÔºå‰Ω†Â∫îËØ•ÊääÂÆÉ‰ª¨ÂΩì‰Ωú‰ªªÊÑèÁöÑ„ÄÅ‰∏çÂèØÈ¢ÑÊµãÁöÑÔºå‰ΩÜÂç¥ÊòØÊ≠£ÁöÑ„ÄÇ)</p>
<p>ÂØπ‰∫é "Â∏∏ËßÑ "ÁöÑÁ∫øÊÄßÁ≥ªÁªüÔºåËøô‰∏ÄÂàáÈÉΩÂØºËá¥‰∫ÜÊ≠£Á°ÆÁöÑËß£ÂÜ≥ÊñπÊ°à„ÄÇÂè¶‰∏ÄÊñπÈù¢ÔºåÂØπ‰∫éÁâπÂæÅÂÄºÈóÆÈ¢òÔºåËøôÂ∞±‰∏çÈÇ£‰πàÁÆÄÂçï‰∫Ü„ÄÇÂú®ÈÇ£ÈáåÔºåÊ∂àÈô§ËæπÁïåÂÄº‰ºöÂΩ±ÂìçÂà∞Êàë‰ª¨Âú®ÂΩìÂâçÊïôÁ®ãÁ®ãÂ∫è‰∏≠Ë¶ÅËß£ÂÜ≥ÁöÑÁü©Èòµ \(A\) Âíå \(M\) „ÄÇÊ∂àÈô§ËæπÁïåÂÄºÂêéÔºåÊàë‰ª¨Â∞±‰ºöÂæóÂà∞‰∏Ä‰∏™ÂèØ‰ª•ËøôÊ†∑ÂàíÂàÜÁöÑÁâπÂæÅÂÄºÈóÆÈ¢ò„ÄÇ</p>
<p class="formulaDsp">
\begin{align*} \begin{pmatrix} A_i &amp; 0 \\ 0 &amp; D_A \end{pmatrix} \begin{pmatrix} \tilde\Psi_i \\ \tilde\Psi_b \end{pmatrix} = \epsilon_h \begin{pmatrix} M_i &amp; 0 \\ 0 &amp; D_M \end{pmatrix} \begin{pmatrix} \tilde\Psi_i \\ \tilde\Psi_b \end{pmatrix}. \end{align*}
</p>
<p>ËøôÁßçÂΩ¢ÂºèÊ∏ÖÊ•öÂú∞Ë°®ÊòéÔºåÊúâ‰∏§ÁªÑÁâπÂæÅÂÄºÔºöÊàë‰ª¨ÂÖ≥ÂøÉÁöÑÈÇ£‰∫õÔºå‰ª•ÂèäÊù•Ëá™ÂàÜÁ¶ªÈóÆÈ¢òÁöÑËôöÂÅáÁâπÂæÅÂÄº„ÄÇ</p>
<p class="formulaDsp">
\[ D_A \tilde \Psi_b = \epsilon_h D_M \Psi_b. \]
</p>
<p>Ëøô‰∫õÁâπÂæÅÂÄºÊòØËôöÂÅáÁöÑÔºåÂõ†‰∏∫ÂÆÉ‰ª¨ÊòØÁî±‰∏Ä‰∏™Âè™Âú®ËæπÁïåËäÇÁÇπ‰∏äÊìç‰ΩúÁöÑÁâπÂæÅÂÄºÁ≥ªÁªü‰∫ßÁîüÁöÑ&ndash;Ëøô‰∫õËäÇÁÇπ‰∏çÊòØ<em>freedom</em>ÁöÑÂÆûÊï∞Â∫¶„ÄÇÂΩìÁÑ∂ÔºåÁî±‰∫é‰∏§‰∏™Áü©Èòµ \(D_A,D_M\) ÊòØÂØπËßíÁ∫øÔºåÊàë‰ª¨ÂèØ‰ª•ÂáÜÁ°ÆÂú∞ÈáèÂåñËøô‰∫õËôöÂÅáÁöÑÁâπÂæÅÂÄºÔºöÂÆÉ‰ª¨ÊòØ \(\varepsilon_{h,j}=D_{A,jj}/D_{M,jj}\) ÔºàÂÖ∂‰∏≠ÊåáÊï∞ \(j\) Ê≠£Â•ΩÂØπÂ∫î‰∫éÂèóËø™ÈáåÂàáÁâπËæπÁïåÂÄºÁ∫¶ÊùüÁöÑËá™Áî±Â∫¶Ôºâ„ÄÇ</p>
<p>ÈÇ£‰πàÔºåÂ¶Ç‰ΩïÂ§ÑÁêÜËøô‰∫õÈóÆÈ¢òÂë¢ÔºüÁ¨¨‰∏ÄÈÉ®ÂàÜÊòØËØÜÂà´Êàë‰ª¨ÁöÑÁâπÂæÅÂÄºÊ±ÇËß£Âô®‰ΩïÊó∂ÊâæÂà∞ÂÖ∂‰∏≠‰∏Ä‰∏™„ÄÇ‰∏∫Ê≠§ÔºåÁ®ãÂ∫èÈÄöËøáËÆ°ÁÆóÊâÄÊúâÂèóÈôêËá™Áî±Â∫¶‰∏äË°®ËææÂºè \(\varepsilon_{h,j}=D_{A,jj}/D_{M,jj}\) ÁöÑÊúÄÂ∞èÂíåÊúÄÂ§ßÔºåËÆ°ÁÆóÂπ∂ÊâìÂç∞Âá∫Ëøô‰∫õÁâπÂæÅÂÄºÊâÄÂú®ÁöÑÂå∫Èó¥„ÄÇÂú®‰∏ãÈù¢ÁöÑÁ®ãÂ∫è‰∏≠ÔºåËøôÂ∑≤ÁªèË∂≥Â§ü‰∫ÜÔºöÊàë‰ª¨ÂèëÁé∞Ëøô‰∏™Âå∫Èó¥‰Ωç‰∫éÊàë‰ª¨ÊÑüÂÖ¥Ë∂£Âπ∂ËÆ°ÁÆóÁöÑÊúÄÂ∞èÁâπÂæÅÂÄºÂíåÁõ∏Â∫îÁöÑÁâπÂæÅÂáΩÊï∞ÁöÑÈõÜÂêà‰πãÂ§ñÔºåÊâÄ‰ª•ËøôÈáåÊàë‰ª¨‰∏çÈúÄË¶ÅÂÅö‰ªÄ‰πà„ÄÇ</p>
<p>Âè¶‰∏ÄÊñπÈù¢ÔºåÊàë‰ª¨ÂèØËÉΩ‰ºöÂèëÁé∞Êàë‰ª¨Âú®Ëøô‰∏™Á®ãÂ∫è‰∏≠ËÆ°ÁÆóÁöÑ‰∏Ä‰∏™ÁâπÂæÅÂÄºÊÅ∞Â•ΩÂú®Ëøô‰∏™Âå∫Èó¥ÂÜÖÔºåÂú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºåÊàë‰ª¨‰∏ç‰ºöÁ´ãÂç≥Áü•ÈÅìÂÆÉÊòØ‰∏Ä‰∏™ËôöÂÅáÁöÑËøòÊòØ‰∏Ä‰∏™ÁúüÊ≠£ÁöÑÁâπÂæÅÂÄº„ÄÇÂú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºåÊàë‰ª¨ÂèØ‰ª•Âú®ËÆ°ÁÆóÂÆå‰∏§‰∏™Áü©ÈòµÂêéÁÆÄÂçïÂú∞Áº©ÊîæÂÖ∂‰∏≠‰∏Ä‰∏™Áü©ÈòµÁöÑÂØπËßíÁ∫øÂÖÉÁ¥†Ôºå‰ªéËÄåÂ∞ÜÂÆÉ‰ª¨‰ªéÁâπÂæÅË∞±ÁöÑÊÑüÂÖ¥Ë∂£ÁöÑÈ¢ëÁéá‰∏äÁßªÂºÄ„ÄÇËøôÂèØ‰ª•ÈÄöËøá‰ΩøÁî®‰ª•‰∏ã‰ª£Á†ÅÊù•ÂÆåÊàêÔºåÁ°Æ‰øùÊâÄÊúâÂÅáÁöÑÁâπÂæÅÂÄºÈÉΩÊ≠£Â•ΩÁ≠â‰∫é \(1.234\cdot 10^5\) „ÄÇ</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.n_dofs(); ++i)</div><div class="line">  <span class="keywordflow">if</span> (constraints.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(i))</div><div class="line">    {</div><div class="line">      stiffness_matrix.<a class="code" href="classSparseMatrix.html#a3e77fcfbd1fa3ac83ef4ff2951b24ce3">set</a>(i, i, 1.234e5);</div><div class="line">      mass_matrix.<a class="code" href="classSparseMatrix.html#a3e77fcfbd1fa3ac83ef4ff2951b24ce3">set</a>(i, i, 1);</div><div class="line">    }</div></div><!-- fragment --><p>ÁÑ∂ËÄåÔºåËøôÈáåÊ≤°ÊúâÈááÁî®ËøôÁßçÁ≠ñÁï•ÔºåÂõ†‰∏∫Êàë‰ª¨‰ªéÁ®ãÂ∫è‰∏≠ÂæóÂà∞ÁöÑËôöÂÅáÁâπÂæÅÂÄºÊÅ∞Â•ΩÂ§ß‰∫éÊàë‰ª¨Â∞ÜËÆ°ÁÆóÁöÑÂíåÊÑüÂÖ¥Ë∂£ÁöÑÊúÄ‰ΩéÁöÑ‰∫î‰∏™„ÄÇ</p>
<p><a class="anchor" id="Implementationdetails"></a></p><h3>Implementation details</h3>
<p>‰∏ãÈù¢ÁöÑÁ®ãÂ∫èÂÆûË¥®‰∏äÂè™ÊòØÊ≠•È™§4ÁöÑ‰∏Ä‰∏™Á®çÂä†‰øÆÊîπÁöÑÁâàÊú¨„ÄÇÊúâÊâÄ‰∏çÂêåÁöÑÊòØ‰ª•‰∏ãÂá†ÁÇπ„ÄÇ</p>
<ul>
<li>
<p class="startli">‰∏ªÁ±ªÔºàÂêç‰∏∫ <code>EigenvalueProblem</code> ÔºâÁé∞Âú®‰∏çÂÜçÊúâÂçï‰∏ÄÁöÑËß£ÂêëÈáèÔºåËÄåÊòØÊúâ‰∏ÄÊï¥Â•óÊàë‰ª¨ÊÉ≥Ë¶ÅËÆ°ÁÆóÁöÑÂêÑÁßçÁâπÂæÅÂáΩÊï∞ÁöÑÂêëÈáè„ÄÇÊ≠§Â§ñÔºå <code>main</code> ÂáΩÊï∞ÂØπËøôÈáåÁöÑ‰∏ÄÂàáÈÉΩÊúâÈ°∂Â±ÇÊéßÂà∂ÔºåÂÆÉÈÄöËøá <code>SlepcInitialize</code> Âíå <code>SlepFinalize</code> ÂêåÊó∂ÂàùÂßãÂåñÂíåÊúÄÁªàÁ°ÆÂÆöSLEPcÂíåPETScÁöÑÊé•Âè£„ÄÇ </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Êàë‰ª¨Âú®Ê≠•È™§17ÂíåÊ≠•È™§18‰∏≠‰ΩøÁî®PETScÁü©ÈòµÂíåÂêëÈáèÔºåÂõ†‰∏∫ËøôÊòØSLEPcÁâπÂæÅÂÄºÊ±ÇËß£Âô®ÊâÄË¶ÅÊ±ÇÁöÑ„ÄÇ </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">ÂáΩÊï∞ <code>EigenvalueProblem::solve</code> ‰∏éÊïôÁ®ã‰∏≠ËøÑ‰ªä‰∏∫Ê≠¢ÊâÄËßÅÁöÑ‰ªª‰ΩïÂáΩÊï∞ÈÉΩÂÆåÂÖ®‰∏çÂêåÔºåÂõ†‰∏∫ÂÆÉ‰∏çÂè™ÊòØÊ±ÇËß£‰∏Ä‰∏™Á∫øÊÄßÁ≥ªÁªüÔºåËÄåÊòØÂÆûÈôÖÊ±ÇËß£ÁâπÂæÅÂÄºÈóÆÈ¢ò„ÄÇÂÆÉÂª∫Á´ãÂú®SLEPcÂ∫ì‰∏äÔºåÊõ¥Áõ¥Êé•ÁöÑÊòØÂª∫Á´ãÂú®Á±ª <a class="el" href="classSLEPcWrappers_1_1SolverKrylovSchur.html">SLEPcWrappers::SolverKrylovSchur</a>. ÁöÑdeal.II SLEPcÂåÖË£ÖÂô®‰∏ä„ÄÇ</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Êàë‰ª¨‰ΩøÁî®ParameterHandlerÁ±ªÊù•ÊèèËø∞‰∏Ä‰∫õËæìÂÖ•ÂèÇÊï∞ÔºåÂ¶ÇÂäøÁöÑÁ°ÆÂàáÂΩ¢Âºè \(V({\mathbf x})\) ÔºåÁΩëÊ†ºÁöÑÂÖ®Â±ÄÁªÜÂåñÊ≠•Êï∞ÔºåÊàñÊàë‰ª¨Ë¶ÅËß£ÂÜ≥ÁöÑÁâπÂæÅÂÄºÁöÑÊï∞Èáè„ÄÇÊàë‰ª¨ÂèØ‰ª•Âú®ËøôÊñπÈù¢ÂÅöÂæóÊõ¥Â§öÔºå‰ΩÜÂè™Èôê‰∫éÂú®ËøêË°åÊó∂ÈÄâÊã©‰∏Ä‰∫õÂÆûÈôÖÁöÑËæìÂÖ•Êñá‰ª∂ÂèÇÊï∞„ÄÇ‰∏∫‰∫ÜÁúãÁúãÂú®ËøôÊñπÈù¢ÂèØ‰ª•ÂÅö‰ªÄ‰πàÔºåÁúãÁúã <a class="el" href="step_29.html">Ê≠•È™§-29 </a>ÂíåÊ≠•È™§-33„ÄÇ </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Êàë‰ª¨‰ΩøÁî®FunctionParserÁ±ª‰ΩøÊΩúÂú® \(V(\mathbf x)\) ÁöÑËøêË°åÊó∂ÂèÇÊï∞ÔºåÂèØ‰ª•Âú®ËæìÂÖ•Êñá‰ª∂‰∏≠ÊåáÂÆö‰∏∫ÂÖ¨Âºè„ÄÇ </p>
<p class="endli"></p>
</li>
</ul>
<p>Á®ãÂ∫èÁöÑÂÖ∂‰ΩôÈÉ®ÂàÜ‰ª•‰∏ÄÁßçÁõ∏ÂΩìÁõ¥Êé•ÁöÑÊñπÂºè‰ªéÁ¨¨4Ê≠•ÂºÄÂßã„ÄÇ</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>As mentioned in the introduction, this program is essentially only a slightly revised version of <a class="el" href="step_4.html">step-4</a>. As a consequence, most of the following include files are as used there, or at least as used already in previous tutorial programs:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function__parser_8h.html">deal.II/base/function_parser.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div></div><!-- fragment --><p><a class="el" href="classIndexSet.html">IndexSet</a> is used to set the size of each <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div></div><!-- fragment --><p>PETSc appears here because SLEPc depends on this library:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div></div><!-- fragment --><p>And then we need to actually import the interfaces for solvers that SLEPc provides:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="slepc__solver_8h.html">deal.II/lac/slepc_solver.h</a>&gt;</span></div></div><!-- fragment --><p>We also need some standard C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div></div><!-- fragment --><p>Finally, as in previous programs, we import all the deal.II class and function names into the namespace into which everything in this program will go:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step36</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeEigenvalueProblemcodeclasstemplate"></a> </p><h3>The <code>EigenvalueProblem</code> class template</h3>
<p>Following is the class declaration for the main class template. It looks pretty much exactly like what has already been shown in <a class="el" href="step_4.html">step-4</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>EigenvalueProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file);</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span>         make_grid_and_dofs();</div><div class="line">  <span class="keywordtype">void</span>         assemble_system();</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> solve();</div><div class="line">  <span class="keywordtype">void</span>         output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div></div><!-- fragment --><p>With these exceptions: For our eigenvalue problem, we need both a stiffness matrix for the left hand side as well as a mass matrix for the right hand side. We also need not just one solution function, but a whole set of these for the eigenfunctions we want to compute, along with the corresponding eigenvalues:</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix</a>             stiffness_matrix, <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">std::vector&lt;PETScWrappers::MPI::Vector&gt; eigenfunctions;</div><div class="line">std::vector&lt;double&gt;                     <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>;</div></div><!-- fragment --><p>And then we need an object that will store several run-time parameters that we will specify in an input file :</p>
<div class="fragment"><div class="line"><a class="code" href="classParameterHandler.html">ParameterHandler</a> parameters;</div></div><!-- fragment --><p>Finally, we will have an object that contains "constraints" on our degrees of freedom. This could include hanging node constraints if we had adaptively refined meshes (which we don't have in the current program). Here, we will store the constraints for boundary nodes \(U_i=0\).</p>
<div class="fragment"><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeEigenvalueProblemcodeclass"></a> </p><h3>Implementation of the <code>EigenvalueProblem</code> class</h3>
<p><a class="anchor" id="EigenvalueProblemEigenvalueProblem"></a> </p><h4>EigenvalueProblem::EigenvalueProblem</h4>
<p>First up, the constructor. The main new part is handling the run-time input parameters. We need to declare their existence first, and then read their values from the input file whose name is specified as an argument to this function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">EigenvalueProblem&lt;dim&gt;::EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file)</div><div class="line">  : fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">{</div></div><!-- fragment --><p>TODO investigate why the minimum number of refinement steps required to obtain the correct eigenvalue degeneracies is 6</p>
<div class="fragment"><div class="line">  parameters.declare_entry(</div><div class="line">    <span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 20),</div><div class="line">    <span class="stringliteral">&quot;The number of times the 1-cell coarse mesh should &quot;</span></div><div class="line">    <span class="stringliteral">&quot;be refined globally for our computations.&quot;</span>);</div><div class="line">  parameters.declare_entry(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>,</div><div class="line">                           <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">                           <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 100),</div><div class="line">                           <span class="stringliteral">&quot;The number of eigenvalues/eigenfunctions &quot;</span></div><div class="line">                           <span class="stringliteral">&quot;to be computed.&quot;</span>);</div><div class="line">  parameters.declare_entry(<span class="stringliteral">&quot;Potential&quot;</span>,</div><div class="line">                           <span class="stringliteral">&quot;0&quot;</span>,</div><div class="line">                           <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                           <span class="stringliteral">&quot;A functional description of the potential.&quot;</span>);</div><div class="line"></div><div class="line">  parameters.parse_input(prm_file);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemmake_grid_and_dofs"></a> </p><h4>EigenvalueProblem::make_grid_and_dofs</h4>
<p>The next function creates a mesh on the domain \([-1,1]^d\), refines it as many times as the input file calls for, and then attaches a <a class="el" href="classDoFHandler.html">DoFHandler</a> to it and initializes the matrices and vectors to their correct sizes. We also build the constraints that correspond to the boundary values \(u|_{\partial\Omega}=0\).</p>
<p>For the matrices, we use the PETSc wrappers. These have the ability to allocate memory as necessary as non-zero entries are added. This seems inefficient: we could as well first compute the sparsity pattern, initialize the matrices with it, and as we then insert entries we can be sure that we do not need to re-allocate memory and free the one used previously. One way to do that would be to use code like this: </p><div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></div><div class="line">   dsp (dof_handler.n_dofs(),</div><div class="line">        dof_handler.n_dofs());</div><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div><div class="line">dsp.compress ();</div><div class="line">stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a> (dsp);</div><div class="line">mass_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a> (dsp);</div></div><!-- fragment --> </div><p> instead of the two <code><a class="el" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit()</a></code> calls for the stiffness and mass matrices below.</p>
<p>This doesn't quite work, unfortunately. The code above may lead to a few entries in the non-zero pattern to which we only ever write zero entries; most notably, this holds true for off-diagonal entries for those rows and columns that belong to boundary nodes. This shouldn't be a problem, but for whatever reason, PETSc's ILU preconditioner, which we use to solve linear systems in the eigenvalue solver, doesn't like these extra entries and aborts with an error message.</p>
<p>In the absence of any obvious way to avoid this, we simply settle for the second best option, which is have PETSc allocate memory as necessary. That said, since this is not a time critical part, this whole affair is of no further importance.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::make_grid_and_dofs()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(</div><div class="line">    parameters.get_integer(<span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>));</div><div class="line">  dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a>(dof_handler, constraints);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">  stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(dof_handler.n_dofs(),</div><div class="line">                          dof_handler.n_dofs(),</div><div class="line">                          dof_handler.max_couplings_between_dofs());</div><div class="line">  mass_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(dof_handler.n_dofs(),</div><div class="line">                     dof_handler.n_dofs(),</div><div class="line">                     dof_handler.max_couplings_between_dofs());</div></div><!-- fragment --><p>The next step is to take care of the eigenspectrum. In this case, the outputs are eigenvalues and eigenfunctions, so we set the size of the list of eigenfunctions and eigenvalues to be as large as we asked for in the input file. When using a <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>, the <a class="el" href="classVector.html">Vector</a> is initialized using an <a class="el" href="classIndexSet.html">IndexSet</a>. <a class="el" href="classIndexSet.html">IndexSet</a> is used not only to resize the <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> but it also associates an index in the <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> with a degree of freedom (see <a class="el" href="step_40.html">step-40</a> for a more detailed explanation). The function <a class="el" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set()</a> creates an <a class="el" href="classIndexSet.html">IndexSet</a> where every valid index is part of the set. Note that this program can only be run sequentially and will throw an exception if used in parallel.</p>
<div class="fragment"><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> eigenfunction_index_set = dof_handler.locally_owned_dofs();</div><div class="line">  eigenfunctions.resize(</div><div class="line">    parameters.get_integer(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>));</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">    eigenfunctions[i].<a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(eigenfunction_index_set, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">  eigenvalues.resize(eigenfunctions.size());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemassemble_system"></a> </p><h4>EigenvalueProblem::assemble_system</h4>
<p>Here, we assemble the global stiffness and mass matrices from local contributions \(A^K_{ij} = \int_K \nabla\varphi_i(\mathbf x) \cdot \nabla\varphi_j(\mathbf x) + V(\mathbf x)\varphi_i(\mathbf x)\varphi_j(\mathbf x)\) and \(M^K_{ij} = \int_K \varphi_i(\mathbf x)\varphi_j(\mathbf x)\) respectively. This function should be immediately familiar if you've seen previous tutorial programs. The only thing new would be setting up an object that described the potential \(V(\mathbf x)\) using the expression that we got from the input file. We then need to evaluate this object at the quadrature points on each cell. If you've seen how to evaluate function objects (see, for example the coefficient in <a class="el" href="step_5.html">step-5</a>), the code here will also look rather familiar.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_stiffness_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div><div class="line">  potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div><div class="line">                       parameters.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div><div class="line">                       <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; potential_values(n_q_points);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">      cell_stiffness_matrix = 0;</div><div class="line">      cell_mass_matrix      = 0;</div><div class="line"></div><div class="line">      potential.<a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                           potential_values);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">            {</div><div class="line">              cell_stiffness_matrix(i, j) +=           </div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *    </div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)    </div><div class="line">                 +                                     </div><div class="line">                 potential_values[q_point] *           </div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * </div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)   </div><div class="line">                 ) *                                   </div><div class="line">                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);                </div><div class="line"></div><div class="line">              cell_mass_matrix(i, j) +=              </div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * </div><div class="line">                 fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)   </div><div class="line">                 ) *                                 </div><div class="line">                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);              </div><div class="line">            }</div></div><!-- fragment --><p>Now that we have the local matrix contributions, we transfer them into the global objects and take care of zero boundary constraints:</p>
<div class="fragment"><div class="line">  cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_stiffness_matrix,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         stiffness_matrix);</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_mass_matrix,</div><div class="line">                                         local_dof_indices,</div><div class="line">                                         mass_matrix);</div><div class="line">}</div></div><!-- fragment --><p>At the end of the function, we tell PETSc that the matrices have now been fully assembled and that the sparse matrix representation can now be compressed as no more entries will be added:</p>
<div class="fragment"><div class="line">stiffness_matrix.<a class="code" href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">mass_matrix.<a class="code" href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div></div><!-- fragment --><p>Before leaving the function, we calculate spurious eigenvalues, introduced to the system by zero Dirichlet constraints. As discussed in the introduction, the use of Dirichlet boundary conditions coupled with the fact that the degrees of freedom located at the boundary of the domain remain part of the linear system we solve, introduces a number of spurious eigenvalues. Below, we output the interval within which they all lie to ensure that we can ignore them should they show up in our computations.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">         max_spurious_eigenvalue = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.n_dofs(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (constraints.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(i))</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> ev         = stiffness_matrix(i, i) / <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>(i, i);</div><div class="line">        min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_spurious_eigenvalue, ev);</div><div class="line">        max_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_spurious_eigenvalue, ev);</div><div class="line">      }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Spurious eigenvalues are all in the interval &quot;</span></div><div class="line">            &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; min_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;,&quot;</span></div><div class="line">            &lt;&lt; max_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemsolve"></a> </p><h4>EigenvalueProblem::solve</h4>
<p>This is the key new functionality of the program. Now that the system is set up, here is a good time to actually solve the problem: As with other examples this is done using a "solve" routine. Essentially, it works as in other programs: you set up a <a class="el" href="classSolverControl.html">SolverControl</a> object that describes the accuracy to which we want to solve the linear systems, and then we select the kind of solver we want. Here we choose the Krylov-Schur solver of SLEPc, a pretty fast and robust choice for this kind of problem:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> EigenvalueProblem&lt;dim&gt;::solve()</div><div class="line">{</div></div><!-- fragment --><p>We start here, as we normally do, by assigning convergence control we want:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(dof_handler.n_dofs(), 1e-9);</div><div class="line"><a class="code" href="classSLEPcWrappers_1_1SolverKrylovSchur.html">SLEPcWrappers::SolverKrylovSchur</a> eigensolver(solver_control);</div></div><!-- fragment --><p>Before we actually solve for the eigenfunctions and -values, we have to also select which set of eigenvalues to solve for. Lets select those eigenvalues and corresponding eigenfunctions with the smallest real part (in fact, the problem we solve here is symmetric and so the eigenvalues are purely real). After that, we can actually let SLEPc do its work:</p>
<div class="fragment"><div class="line">eigensolver.set_which_eigenpairs(EPS_SMALLEST_REAL);</div><div class="line"></div><div class="line">eigensolver.set_problem_type(EPS_GHEP);</div><div class="line"></div><div class="line">eigensolver.solve(stiffness_matrix,</div><div class="line">                  mass_matrix,</div><div class="line">                  eigenvalues,</div><div class="line">                  eigenfunctions,</div><div class="line">                  eigenfunctions.size());</div></div><!-- fragment --><p>The output of the call above is a set of vectors and values. In eigenvalue problems, the eigenfunctions are only determined up to a constant that can be fixed pretty arbitrarily. Knowing nothing about the origin of the eigenvalue problem, SLEPc has no other choice than to normalize the eigenvectors to one in the \(l_2\) (vector) norm. Unfortunately this norm has little to do with any norm we may be interested from a eigenfunction perspective: the \(L_2(\Omega)\) norm, or maybe the \(L_\infty(\Omega)\) norm.</p>
<p>Let us choose the latter and rescale eigenfunctions so that they have \(\|\phi_i(\mathbf x)\|_{L^\infty(\Omega)}=1\) instead of \(\|\Phi\|_{l_2}=1\) (where \(\phi_i\) is the \(i\)th eigen<em>function</em> and \(\Phi_i\) the corresponding vector of nodal values). For the \(Q_1\) elements chosen here, we know that the maximum of the function \(\phi_i(\mathbf x)\) is attained at one of the nodes, so \(\max_{\mathbf x}\phi_i(\mathbf x)=\max_j (\Phi_i)_j\), making the normalization in the \(L_\infty\) norm trivial. Note that this doesn't work as easily if we had chosen \(Q_k\) elements with \(k&gt;1\): there, the maximum of a function does not necessarily have to be attained at a node, and so \(\max_{\mathbf x}\phi_i(\mathbf x)\ge\max_j (\Phi_i)_j\) (although the equality is usually nearly true).</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">  eigenfunctions[i] /= eigenfunctions[i].<a class="code" href="classTensor.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a>();</div></div><!-- fragment --><p>Finally return the number of iterations it took to converge:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">return</span> solver_control.last_step();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemoutput_results"></a> </p><h4>EigenvalueProblem::output_results</h4>
<p>This is the last significant function of this program. It uses the <a class="el" href="classDataOut.html">DataOut</a> class to generate graphical output from the eigenfunctions for later visualization. It works as in many of the other tutorial programs.</p>
<p>The whole collection of functions is then output as a single VTK file.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(eigenfunctions[i],</div><div class="line">                             std::string(<span class="stringliteral">&quot;eigenfunction_&quot;</span>) +</div><div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i));</div></div><!-- fragment --><p>The only thing worth discussing may be that because the potential is specified as a function expression in the input file, it would be nice to also have it as a graphical representation along with the eigenfunctions. The process to achieve this is relatively straightforward: we build an object that represents \(V(\mathbf x)\) and then we interpolate this continuous function onto the finite element space. The result we also attach to the <a class="el" href="classDataOut.html">DataOut</a> object for visualization.</p>
<div class="fragment"><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> projected_potential(dof_handler.n_dofs());</div><div class="line">  {</div><div class="line">    <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div><div class="line">    potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div><div class="line">                         parameters.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div><div class="line">                         <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, potential, projected_potential);</div><div class="line">  }</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(projected_potential, <span class="stringliteral">&quot;interpolated_potential&quot;</span>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  std::ofstream output(<span class="stringliteral">&quot;eigenvectors.vtk&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemrun"></a> </p><h4>EigenvalueProblem::run</h4>
<p>This is the function which has the top-level control over everything. It is almost exactly the same as in <a class="el" href="step_4.html">step-4</a>:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">EigenvalueProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    assemble_system();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations = solve();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solver converged in &quot;</span> &lt;&lt; n_iterations &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    output_results();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenvalues.size(); ++i)</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;      Eigenvalue &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; eigenvalues[i]</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step36</span></div></div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step36;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div></div><!-- fragment --><p>This program can only be run in serial. Otherwise, throw an exception.</p>
<div class="fragment"><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                <span class="stringliteral">&quot;This program can only be run in serial, use ./step-36&quot;</span>));</div><div class="line"></div><div class="line">  EigenvalueProblem&lt;2&gt; problem(<span class="stringliteral">&quot;step-36.prm&quot;</span>);</div><div class="line">  problem.run();</div><div class="line">}</div></div><!-- fragment --><p>All the while, we are watching out if any exceptions should have been generated. If that is so, we panic...</p>
<div class="fragment"><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div></div><!-- fragment --><p>If no exceptions are thrown, then we tell the program to stop monkeying around and exit nicely:</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;   Job done.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-36/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Runningtheproblem"></a></p><h3>Running the problem</h3>
<p>ËØ•ÈóÆÈ¢òÁöÑËæìÂÖ•Áî±‰∏Ä‰∏™ËæìÂÖ•Êñá‰ª∂ <code>step-36.prm</code> ËÆæÂÆöÂèÇÊï∞Ôºå‰æãÂ¶ÇÔºåËØ•Êñá‰ª∂ÂèØ‰ª•ÂåÖÂê´‰ª•‰∏ãÊñáÊú¨„ÄÇ</p>
<div class="fragment"><div class="line"><span class="keyword">set</span> Global mesh refinement steps         = 5</div><div class="line"><span class="keyword">set</span> Number of eigenvalues/eigenfunctions = 5</div><div class="line"><span class="keyword">set</span> Potential                            = 0</div></div><!-- fragment --><p>ËøôÈáåÔºåÂüüÂÜÖÁîµÂäø‰∏∫Èõ∂ÔºåÊàë‰ª¨Áü•ÈÅìÁâπÂæÅÂÄºÁî± \(\lambda_{(mn)}=\frac{\pi^2}{4}(m^2+n^2)\) ÁªôÂá∫ÔºåÂÖ∂‰∏≠ \(m,n\in{\mathbb N^+}\) „ÄÇÁâπÂæÅÂáΩÊï∞ÊòØÊ≠£Âº¶Âíå‰ΩôÂº¶ÔºåÂú® \(m\) Âíå \(n\) ÊñπÂêëÁöÑÂë®Êúü‰∏∫ \(x\) Âíå \(y\) „ÄÇËøô‰∏éÊàë‰ª¨ÁöÑÁ®ãÂ∫è‰∫ßÁîüÁöÑËæìÂá∫Áõ∏ÂåπÈÖç„ÄÇ</p>
<div class="fragment"><div class="line">examples/step-36&gt; make run</div><div class="line">============================ Running step-36</div><div class="line">   Number of active cells:       1024</div><div class="line">   Number of degrees of freedom: 1089</div><div class="line">   Solver converged in 67 iterations.</div><div class="line"></div><div class="line"></div><div class="line">      Eigenvalue 0 : 4.93877</div><div class="line">      Eigenvalue 1 : 12.3707</div><div class="line">      Eigenvalue 2 : 12.3707</div><div class="line">      Eigenvalue 3 : 19.8027</div><div class="line">      Eigenvalue 4 : 24.837</div><div class="line"></div><div class="line"></div><div class="line">   Job done.  </div></div><!-- fragment --><p> Ëøô‰∫õÁâπÂæÅÂÄºÊ≠£ÊòØÂØπÂ∫î‰∫é \((m,n)=(1,1)\) „ÄÅ \((1,2)\) Âíå \((2,1)\) „ÄÅ \((2,2)\) Âíå \((3,1)\) Á≠âÂØπ„ÄÇÁõ∏Â∫îÁöÑÁâπÂæÅÊñπÁ®ãÁöÑÂèØËßÜÂåñÁúãËµ∑Êù•ÊòØËøôÊ†∑ÁöÑ„ÄÇ</p>
<table width="80%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.0.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.1.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.2.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.3.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.4.png"/>
</div>
 </td><td></td></tr>
</table>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>Âú®ÊìçÂú∫‰∏äÁé©Âá†‰∏™Ê∏∏ÊàèÊÄªÊòØÂÄºÂæóÁöÑ!ÊâÄ‰ª•ËøôÈáåÊúâÂá†‰∏™Âª∫ËÆÆ„ÄÇ</p>
<ul>
<li>
<p class="startli">‰∏äÈù¢‰ΩøÁî®ÁöÑÂäøÔºàÁß∞‰∏∫<em>infinite well</em>ÔºåÂõ†‰∏∫ÂÆÉÊòØ‰∏Ä‰∏™Áî±Êó†ÈôêÈ´òÁöÑÂ¢ôÂåÖÂõ¥ÁöÑÂπ≥Âù¶ÂäøÔºâÂæàÊúâË∂£ÔºåÂõ†‰∏∫ÂÆÉÂÖÅËÆ∏ÊúâÂàÜÊûê‰∏äÂ∑≤Áü•ÁöÑËß£ÂÜ≥ÊñπÊ°à„ÄÇÁÑ∂ËÄåÔºåÈô§Ê≠§‰πãÂ§ñÔºåÂÆÉÊòØÁõ∏ÂΩìÊó†ËÅäÁöÑ„ÄÇ‰πüÂ∞±ÊòØËØ¥ÔºåÈÄöËøáÂú®ËæìÂÖ•Êñá‰ª∂‰∏≠ËÆæÁΩÆ‰∏çÂêåÁöÑÂäøÊù•Áé©ÂºÑËøô‰∏™ÂäøÊòØÂæàÂÆπÊòìÁöÑ„ÄÇ‰æãÂ¶ÇÔºåËÆ©Êàë‰ª¨ÂÅáËÆæÊàë‰ª¨ÊÉ≥Âú®2d‰∏≠‰ΩøÁî®‰ª•‰∏ãÂäø„ÄÇ</p>
<p class="formulaDsp">
\[ V(x,y) = \left\{ \begin{array}{ll} -100 &amp; \text{if}\ \sqrt{x^2+y^2}&lt;\frac 34 \ \text{and} \ xy&gt;0 \\ -5 &amp; \text{if}\ \sqrt{x^2+y^2}&lt;\frac 34 \ \text{and} \ xy\le 0 \\ 0 &amp; \text{otherwise} \end{array} \right.\quad. \]
</p>
<p>Êç¢Âè•ËØùËØ¥ÔºåÂú®ÂçäÂæÑ‰∏∫0.75ÁöÑÂúÜÁöÑ‰∏§‰∏™ÊâáÈù¢‰∏≠ÔºåÁîµ‰Ωç‰∏∫-100ÔºåÂú®Âè¶Â§ñ‰∏§‰∏™ÊâáÈù¢‰∏≠‰∏∫-5ÔºåËÄåÂú®ÂúÜÂ§ñ‰∏∫Èõ∂„ÄÇÊàë‰ª¨ÂèØ‰ª•ÈÄöËøáÂú®ËæìÂÖ•Êñá‰ª∂‰∏≠‰ΩøÁî®‰ª•‰∏ãÂÜÖÂÆπÊù•ÂÆûÁé∞Ëøô‰∏ÄÁÇπ„ÄÇ</p>
<div class="fragment"><div class="line"><span class="keyword">set</span> Potential = <span class="keywordflow">if</span> (x^2 + y^2 &lt; 0.75^2, <span class="keywordflow">if</span> (x*y &gt; 0, -100, -5), 0)</div></div><!-- fragment --><p>Ê≠§Â§ñÔºåÂ¶ÇÊûúÊàë‰ª¨ËøòÂ∞ÜÁΩëÊ†ºÁªÜÂåñÁ®ãÂ∫¶ÊèêÈ´ò‰∏ÄÁ∫ßÔºåÊàë‰ª¨‰ºöÂæóÂà∞‰ª•‰∏ãÁªìÊûú„ÄÇ</p>
<div class="fragment"><div class="line">examples/step-36&gt; make run</div><div class="line">============================ Running step-36</div><div class="line">   Number of active cells:       4096</div><div class="line">   Number of degrees of freedom: 4225</div><div class="line"></div><div class="line"></div><div class="line">   Eigenvalue 0 : -74.2562</div><div class="line">   Eigenvalue 1 : -72.7322</div><div class="line">   Eigenvalue 2 : -42.7406</div><div class="line">   Eigenvalue 3 : -42.2232</div><div class="line">   Eigenvalue 4 : -37.0744</div></div><!-- fragment --><p>ËæìÂá∫Êñá‰ª∂ËøòÂåÖÂê´‰∏Ä‰∏™ÂÜÖÊèíÁöÑÂäøÁöÑÁâàÊú¨ÔºåÁúãËµ∑Êù•ÂÉèËøôÊ†∑ÔºàÊ≥®ÊÑèÔºåÊ≠£Â¶ÇÈ¢ÑÊúüÁöÑÈÇ£Ê†∑ÔºåÊúÄ‰ΩéÁöÑÂá†‰∏™ÁâπÂæÅÊ®°ÂºèÁöÑÊ¶ÇÁéáÂØÜÂ∫¶ \(|\Psi(\mathbf x)|^2\) Âè™ÊúâÂú®ÂäøÊúÄ‰ΩéÁöÑÂú∞ÊñπÊâçÊòØÊòæËëóÁöÑÔºåÂç≥Âú®ÂäøÁöÑÂÜÖÂúàÁöÑÂè≥‰∏äËßíÂíåÂ∑¶‰∏ãËßíÈÉ®ÂàÜÔºâ„ÄÇ</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.potential.png"/>
</div>
<p>Ââç‰∫î‰∏™ÁâπÂæÅÂáΩÊï∞Áé∞Âú®ÊòØËøôÊ†∑ÁöÑ„ÄÇ</p>
<table width="80%">
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.0.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.1.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.2.png"/>
</div>
  </td></tr>
<tr>
<td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.3.png"/>
</div>
 </td><td><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.4.png"/>
</div>
 </td><td></td></tr>
</table>
<p class="endli"></p>
</li>
<li>
<p class="startli">Âú®Êàë‰ª¨ÂØπÈóÆÈ¢òÁöÑÊé®ÂØº‰∏≠ÔºåÊàë‰ª¨ÂÅáËÆæÁ≤íÂ≠êË¢´ÈôêÂà∂Âú®‰∏Ä‰∏™Âüü \(\Omega\) ‰∏≠ÔºåÂπ∂‰∏îÂú®Ëøô‰∏™ÂüüÁöÑËæπÁïåÂ§ÑÔºåÂÆÉÁöÑÊ¶ÇÁéá \(|\Psi|^2\) ‰∏∫Èõ∂„ÄÇËøôÁõ∏ÂΩì‰∫éËß£ÂÜ≥ÊâÄÊúâ \({\mathbb R}^d\) ‰∏äÁöÑÁâπÂæÅÂÄºÈóÆÈ¢òÔºåÂπ∂ÂÅáËÆæËÉΩÈáèÂäøÂè™Âú® \(\Omega\) Âå∫ÂüüÂÜÖÊòØÊúâÈôêÁöÑÔºåËÄåÂú®Âå∫ÂüüÂ§ñÊòØÊó†ÈôêÁöÑ„ÄÇÊØîËæÉÂÆπÊòìÁöÑÊòØÔºåÂú® \(|\Psi(\mathbf x)|^2\) ÁöÑÊâÄÊúâ‰ΩçÁΩÆ \(\mathbf x\) Ôºå \(V(\mathbf x)=\infty\) „ÄÇÈÇ£‰πàÈóÆÈ¢òÊù•‰∫ÜÔºåÂ¶ÇÊûúÊàë‰ª¨ÁöÑÂäø‰∏çÊòØËøôÁßçÂΩ¢ÂºèÁöÑÔºåÂç≥Ê≤°Êúâ‰∏Ä‰∏™ÂäøÊòØÊó†ÈôêÁöÑÊúâÁïåÂüüÔºå‰ºöÂèëÁîü‰ªÄ‰πàÔºüÂú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºåÂèØËÉΩÂÄºÂæóÂè™ËÄÉËôë‰∏Ä‰∏™ÈùûÂ∏∏Â§ßÁöÑËæπÁïåÂüüÔºåÂÖ∂‰∏≠ \(V(\mathbf x)\) Âç≥‰Ωø‰∏çÊòØÊó†ÈôêÁöÑÔºå‰πüËá≥Â∞ëÊòØÈùûÂ∏∏Â§ßÁöÑ„ÄÇÂú®ËøôÊ†∑ÁöÑÊÉÖÂÜµ‰∏ãÁé©‰∏ÄÁé©ÔºåÊé¢Á¥¢‰∏Ä‰∏ãÂΩìÊàë‰ª¨‰ΩøËÆ°ÁÆóÂå∫ÂüüË∂äÊù•Ë∂äÂ§ßÊó∂ÔºåÈ¢ëË∞±ÂíåÁâπÂæÅÂáΩÊï∞Â¶Ç‰ΩïÂèòÂåñ„ÄÇ</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Â¶ÇÊûúÊàë‰ª¨Á†îÁ©∂ÁÆÄÂçïÁöÑË∞êÊ≥¢ÊåØËç°Âô®ÈóÆÈ¢ò \(V(\mathbf x)=c|\mathbf x|^2\) ‰ºöÊÄéÊ†∑ÔºüËøô‰∏™ÂäøÊ≠£ÊòØ‰∏ä‰∏ÄÊÆµÊâÄËÆ®ËÆ∫ÁöÑÂΩ¢ÂºèÔºåÂÖ∑ÊúâË∂ÖÁêÉÈù¢ÂØπÁß∞ÊÄß„ÄÇ‰∫∫‰ª¨ÂèØËÉΩÊÉ≥Áî®‰∏Ä‰∏™Â§ßÁöÑÂ§ñÂçäÂæÑÁöÑÁêÉÈù¢ÂüüÔºåÊù•Ëøë‰ºº‰∫éÂÖ®Á©∫Èó¥ÈóÆÈ¢òÔºà‰æãÂ¶ÇÔºåÈÄöËøáÂºïÁî® <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">‰∏äÈù¢ÁöÑÂõæÊòæÁ§∫‰∫ÜÊ≥¢ÂáΩÊï∞ \(\Psi(\mathbf x)\) Ôºå‰ΩÜÊÑüÂÖ¥Ë∂£ÁöÑÁâ©ÁêÜÈáèÂÆûÈôÖ‰∏äÊòØÁ≤íÂ≠êÂ§Ñ‰∫é‰ΩçÁΩÆ \(|\Psi(\mathbf x)|^2\) ÁöÑÊ¶ÇÁéáÂØÜÂ∫¶„ÄÇ‰∏Ä‰∫õÂèØËßÜÂåñÁ®ãÂ∫èÂèØ‰ª•‰ªéËæìÂÖ•Êñá‰ª∂‰∏≠ÁöÑÊï∞ÊçÆËÆ°ÁÆóÂá∫Ë°çÁîüÈáèÔºå‰ΩÜÊàë‰ª¨‰πüÂèØ‰ª•Âú®ÂàõÂª∫ËæìÂá∫Êñá‰ª∂Êó∂Á´ãÂç≥ËøôÊ†∑ÂÅö„ÄÇËøôÊ†∑ÂÅöÁöÑÂ∑•ÂÖ∑ÊòØDataPostprocessorÁ±ªÔºåÂèØ‰ª•ÂíåDataOutÁ±ª‰∏ÄËµ∑‰ΩøÁî®„ÄÇÂ¶Ç‰ΩïÂÅöÂà∞Ëøô‰∏ÄÁÇπÁöÑ‰æãÂ≠êÂèØ‰ª•Âú®Ê≠•È™§29ÂíåÊ≠•È™§33‰∏≠ÊâæÂà∞„ÄÇ</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Â¶ÇÊûúÁõíÂ≠êÈáåÁöÑÁ≤íÂ≠êÊúâÁöÑÂÜÖÈÉ®Ëá™Áî±Â∫¶‰ºöÊÄéÊ†∑Ôºü‰æãÂ¶ÇÔºåÂ¶ÇÊûúËØ•Á≤íÂ≠êÊòØ‰∏Ä‰∏™Ëá™Êóã- \(1/2\) Á≤íÂ≠êÔºüÂú®ËøôÁßçÊÉÖÂÜµ‰∏ãÔºåÊàë‰ª¨ÂèØËÉΩË¶ÅÂºÄÂßãËß£ÂÜ≥‰∏Ä‰∏™Áü¢ÈáèÂÄºÁöÑÈóÆÈ¢òÔºåËÄå‰∏çÊòØ„ÄÇ</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Êàë‰ª¨ËøôÈáåÁöÑdeal.IIÂ∫ìÁöÑÂÆûÁé∞‰ΩøÁî®PETScWrappersÂíåSLEPcWrappersÔºåÈÄÇÂêàÂú®‰∏≤Ë°åÊú∫Âô®Êû∂ÊûÑ‰∏äËøêË°å„ÄÇÁÑ∂ËÄåÔºåÂØπ‰∫éÊõ¥Â§ßÁöÑÁΩëÊ†ºÂíåÊõ¥Â§öÁöÑËá™Áî±Â∫¶ÔºåÊàë‰ª¨ÂèØËÉΩÂ∏åÊúõÂú®Âπ∂Ë°åÊû∂ÊûÑ‰∏äËøêË°åÊàë‰ª¨ÁöÑÂ∫îÁî®Á®ãÂ∫è„ÄÇ‰∏äËø∞‰ª£Á†ÅÁöÑÂπ∂Ë°åÂÆûÁé∞Âú®ËøôÈáåÂèØËÉΩÁâπÂà´ÊúâÁî®ÔºåÂõ†‰∏∫Âπø‰πâÁöÑÁâπÂæÅË∞±ÈóÆÈ¢òÊØîÂâçÈù¢Â§ßÂ§öÊï∞ÊïôÁ®ã‰∏≠ËÄÉËôëÁöÑÊ†áÂáÜÈóÆÈ¢òÁöÑËß£ÂÜ≥ÊàêÊú¨Êõ¥È´ò„ÄÇÂπ∏ËøêÁöÑÊòØÔºå‰øÆÊîπ‰∏äËø∞Á®ãÂ∫è‰ΩøÂÖ∂Á¨¶ÂêàMPIÊ†áÂáÜÊòØ‰∏Ä‰∏™Áõ∏ÂØπÁÆÄÂçïÁöÑËøáÁ®ã„ÄÇÂÖ≥‰∫éÂ¶Ç‰ΩïÂÅöÂà∞Ëøô‰∏ÄÁÇπÁöÑÁÆÄÂõæÂèØ‰ª•Âú® <a class="el" href="step_17.html">step-17 </a>‰∏≠ÊâæÂà∞„ÄÇ</p>
<p>deal.IIÊúâ‰∏éÂÖ∂‰∏≠‰πã‰∏ÄARPACKÔºàËßÅ<a href="../../external-libs/arpack.html">the ARPACK configuration page</a>ÁöÑËÆæÁΩÆËØ¥ÊòéÔºâÁöÑÊé•Âè£ÔºåÂú®ArpackSolverÁ±ª‰∏≠ÂÆûÁé∞„ÄÇ‰∏ãÈù¢ÊòØ‰∏Ä‰∏™ÁÆÄÁü≠ÁöÑ„ÄÅÂø´ÈÄüÁöÑÊ¶ÇËø∞ÔºåËØ¥Êòé‰ΩøÁî®ÂÆÉÈúÄË¶ÅÊîπÂèò‰ªÄ‰πàÔºåÂâçÊèêÊòØ‰Ω†Êúâ‰∏Ä‰∏™Â∑•‰ΩúÁöÑARPACKÂÆâË£ÖÔºåÂπ∂‰∏îdeal.IIÂ∑≤Áªè‰∏∫ÂÆÉÊ≠£Á°ÆÈÖçÁΩÆ‰∫ÜÔºàËßÅdeal.II <a href="../../readme.html" target="body">README</a>Êñá‰ª∂Ôºâ„ÄÇ</p>
<p>È¶ñÂÖàÔºå‰∏∫‰∫Ü‰ΩøÁî®ARPACKÊé•Âè£ÔºåÊàë‰ª¨ÂèØ‰ª•ÂõûÂà∞‰ΩøÁî®Ê†áÂáÜÁöÑdeal.IIÁü©ÈòµÂíåÂêëÈáèÔºåÊâÄ‰ª•Êàë‰ª¨È¶ñÂÖàÊõøÊç¢PETScÂíåSLEPcÂ§¥Êñá‰ª∂</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="slepc__solver_8h.html">deal.II/lac/slepc_solver.h</a>&gt;</span></div></div><!-- fragment --><p>‰∏éËøô‰∫õ„ÄÇ</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="arpack__solver_8h.html">deal.II/lac/arpack_solver.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;deal.II/lac/compressed_sparsity_pattern.h&gt;</span></div></div><!-- fragment --><p>ARPACKÂÖÅËÆ∏Â§çÊùÇÁöÑÁâπÂæÅÂÄºÔºåÊâÄ‰ª•Êàë‰ª¨ËøòÈúÄË¶Å</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;complex&gt;</span></div></div><!-- fragment --><p>ÂÖ∂Ê¨°ÔºåÊàë‰ª¨Âú®‰∏ªÁ±ª‰∏≠ÂàáÊç¢Âõûdeal.IIÁü©ÈòµÂíåÂêëÈáèÂÆö‰πâ„ÄÇ</p>
<div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a>                     sparsity_pattern;</div><div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>                stiffness_matrix, <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">std::vector&lt;Vector&lt;double&gt; &gt;        eigenfunctions;</div><div class="line">std::vector&lt;std::complex&lt;double&gt;&gt;   <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>;</div></div><!-- fragment --><p>Âπ∂ÊåâÁÖßÊÉØ‰æãÂØπÂÆÉ‰ª¨ËøõË°åÂàùÂßãÂåñ <code>make_grid_and_dofs()</code> „ÄÇ</p>
<div class="fragment"><div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#ae5dbc8f57d46b8d15170f753613436e1">reinit</a> (dof_handler.n_dofs(),</div><div class="line">                         dof_handler.n_dofs(),</div><div class="line">                         dof_handler.max_couplings_between_dofs());</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> (dof_handler, sparsity_pattern);</div><div class="line">constraints.<a class="code" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">condense</a> (sparsity_pattern);</div><div class="line">sparsity_pattern.<a class="code" href="classSparsityPattern.html#ad15d36e4bfe7c97b55d155541e723284">compress</a>();</div><div class="line"></div><div class="line"></div><div class="line">stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a> (sparsity_pattern);</div><div class="line">mass_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a> (sparsity_pattern);</div></div><!-- fragment --><p>‰∏∫‰∫ÜÁî®ARPACKËß£ÂÜ≥ÁâπÂæÅÂÄºÈóÆÈ¢òÔºåÊàë‰ª¨ÊúÄÂêéÈúÄË¶Å‰øÆÊîπ <code>solve()</code> „ÄÇ</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> EigenvalueProblem&lt;dim&gt;::solve ()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (dof_handler.n_dofs(), 1e-9);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> inverse;</div><div class="line">  inverse.<a class="code" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a> (stiffness_matrix);</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_arnoldi_vectors = 2*eigenvalues.size() + 2;</div><div class="line">  <a class="code" href="structArpackSolver_1_1AdditionalData.html">ArpackSolver::AdditionalData</a> additional_data(num_arnoldi_vectors);</div><div class="line"></div><div class="line"></div><div class="line">  <a class="code" href="classArpackSolver.html">ArpackSolver</a> eigensolver (solver_control, additional_data);</div><div class="line">  eigensolver.solve (stiffness_matrix,</div><div class="line">                     mass_matrix,</div><div class="line">                     inverse,</div><div class="line">                     eigenvalues,</div><div class="line">                     eigenfunctions,</div><div class="line">                     eigenvalues.size());</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;eigenfunctions.size(); ++i)</div><div class="line">    eigenfunctions[i] /= eigenfunctions[i].<a class="code" href="classTensor.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a> ();</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> solver_control.last_step ();</div><div class="line">}</div></div><!-- fragment --><p class="endli">ËØ∑Ê≥®ÊÑèÊàë‰ª¨ÊòØÂ¶Ç‰Ωï‰ΩøÁî®Á≤æÁ°ÆÂàÜËß£Ôºà‰ΩøÁî®SparseDirectUMFPACKÔºâ‰Ωú‰∏∫ARPACKÁöÑÈ¢ÑÂ§ÑÁêÜÁ®ãÂ∫èÁöÑ„ÄÇ </p>
</li>
</ul>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2009 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Authors: Toby D. Young, Polish Academy of Sciences,</span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function__parser_8h.html">deal.II/base/function_parser.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="slepc__solver_8h.html">deal.II/lac/slepc_solver.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step36</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>EigenvalueProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file);</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span>         make_grid_and_dofs();</div><div class="line">    <span class="keywordtype">void</span>         assemble_system();</div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> solve();</div><div class="line">    <span class="keywordtype">void</span>         output_results() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div><div class="line"></div><div class="line">    <a class="code" href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix</a>             stiffness_matrix, <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div><div class="line">    std::vector&lt;PETScWrappers::MPI::Vector&gt; eigenfunctions;</div><div class="line">    std::vector&lt;double&gt;                     <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638ad91ede5cc912c10676843bf58fa60636">eigenvalues</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> parameters;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  EigenvalueProblem&lt;dim&gt;::EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file)</div><div class="line">    : fe(1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">  {</div><div class="line">    parameters.declare_entry(</div><div class="line">      <span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>,</div><div class="line">      <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 20),</div><div class="line">      <span class="stringliteral">&quot;The number of times the 1-cell coarse mesh should &quot;</span></div><div class="line">      <span class="stringliteral">&quot;be refined globally for our computations.&quot;</span>);</div><div class="line">    parameters.declare_entry(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>,</div><div class="line">                             <span class="stringliteral">&quot;5&quot;</span>,</div><div class="line">                             <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 100),</div><div class="line">                             <span class="stringliteral">&quot;The number of eigenvalues/eigenfunctions &quot;</span></div><div class="line">                             <span class="stringliteral">&quot;to be computed.&quot;</span>);</div><div class="line">    parameters.declare_entry(<span class="stringliteral">&quot;Potential&quot;</span>,</div><div class="line">                             <span class="stringliteral">&quot;0&quot;</span>,</div><div class="line">                             <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div><div class="line">                             <span class="stringliteral">&quot;A functional description of the potential.&quot;</span>);</div><div class="line"></div><div class="line">    parameters.parse_input(prm_file);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::make_grid_and_dofs()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation, -1, 1);</div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(</div><div class="line">      parameters.get_integer(<span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>));</div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a>(dof_handler, constraints);</div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div><div class="line"></div><div class="line">    stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(dof_handler.n_dofs(),</div><div class="line">                            dof_handler.n_dofs(),</div><div class="line">                            dof_handler.max_couplings_between_dofs());</div><div class="line">    mass_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(dof_handler.n_dofs(),</div><div class="line">                       dof_handler.n_dofs(),</div><div class="line">                       dof_handler.max_couplings_between_dofs());</div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> eigenfunction_index_set = dof_handler.locally_owned_dofs();</div><div class="line">    eigenfunctions.resize(</div><div class="line">      parameters.get_integer(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>));</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">      eigenfunctions[i].<a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(eigenfunction_index_set, MPI_COMM_WORLD);</div><div class="line"></div><div class="line">    eigenvalues.resize(eigenfunctions.size());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_stiffness_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div><div class="line">    potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div><div class="line">                         parameters.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div><div class="line">                         <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; potential_values(n_q_points);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">        cell_stiffness_matrix = 0;</div><div class="line">        cell_mass_matrix      = 0;</div><div class="line"></div><div class="line">        potential.<a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(),</div><div class="line">                             potential_values);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; n_q_points; ++q_point)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">              {</div><div class="line">                cell_stiffness_matrix(i, j) +=           </div><div class="line">                  (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q_point) *    </div><div class="line">                     fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q_point)    </div><div class="line">                   +                                     </div><div class="line">                   potential_values[q_point] *           </div><div class="line">                     fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * </div><div class="line">                     fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)   </div><div class="line">                   ) *                                   </div><div class="line">                  fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);                </div><div class="line"></div><div class="line">                cell_mass_matrix(i, j) +=              </div><div class="line">                  (fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, q_point) * </div><div class="line">                   fe_values.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, q_point)   </div><div class="line">                   ) *                                 </div><div class="line">                  fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q_point);              </div><div class="line">              }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line"></div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_stiffness_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               stiffness_matrix);</div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_mass_matrix,</div><div class="line">                                               local_dof_indices,</div><div class="line">                                               mass_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    stiffness_matrix.<a class="code" href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line">    mass_matrix.<a class="code" href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>);</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(),</div><div class="line">           max_spurious_eigenvalue = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dof_handler.n_dofs(); ++i)</div><div class="line">      <span class="keywordflow">if</span> (constraints.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(i))</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> ev         = stiffness_matrix(i, i) / <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>(i, i);</div><div class="line">          min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeb244a97c0c9e9e7ca4765e096f0badc">std::min</a>(min_spurious_eigenvalue, ev);</div><div class="line">          max_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(max_spurious_eigenvalue, ev);</div><div class="line">        }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Spurious eigenvalues are all in the interval &quot;</span></div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; min_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;,&quot;</span></div><div class="line">              &lt;&lt; max_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> EigenvalueProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(dof_handler.n_dofs(), 1e-9);</div><div class="line">    <a class="code" href="classSLEPcWrappers_1_1SolverKrylovSchur.html">SLEPcWrappers::SolverKrylovSchur</a> eigensolver(solver_control);</div><div class="line"></div><div class="line">    eigensolver.set_which_eigenpairs(EPS_SMALLEST_REAL);</div><div class="line"></div><div class="line">    eigensolver.set_problem_type(EPS_GHEP);</div><div class="line"></div><div class="line">    eigensolver.solve(stiffness_matrix,</div><div class="line">                      mass_matrix,</div><div class="line">                      eigenvalues,</div><div class="line">                      eigenfunctions,</div><div class="line">                      eigenfunctions.size());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">      eigenfunctions[i] /= eigenfunctions[i].<a class="code" href="tensor_8h.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> solver_control.last_step();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenfunctions.size(); ++i)</div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(eigenfunctions[i],</div><div class="line">                               std::string(<span class="stringliteral">&quot;eigenfunction_&quot;</span>) +</div><div class="line">                                 <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(i));</div><div class="line"></div><div class="line">    Vector&lt;double&gt; projected_potential(dof_handler.n_dofs());</div><div class="line">    {</div><div class="line">      <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div><div class="line">      potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div><div class="line">                           parameters.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div><div class="line">                           <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, potential, projected_potential);</div><div class="line">    }</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(projected_potential, <span class="stringliteral">&quot;interpolated_potential&quot;</span>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    std::ofstream output(<span class="stringliteral">&quot;eigenvectors.vtk&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">EigenvalueProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    make_grid_and_dofs();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div><div class="line">              &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    assemble_system();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations = solve();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solver converged in &quot;</span> &lt;&lt; n_iterations &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    output_results();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; eigenvalues.size(); ++i)</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;      Eigenvalue &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; eigenvalues[i]</div><div class="line">                &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step36</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line">      <span class="keyword">using namespace </span>Step36;</div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div><div class="line"></div><div class="line"></div><div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div><div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div><div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-36&quot;</span>));</div><div class="line"></div><div class="line">      EigenvalueProblem&lt;2&gt; problem(<span class="stringliteral">&quot;step-36.prm&quot;</span>);</div><div class="line">      problem.run();</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;   Job done.&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
