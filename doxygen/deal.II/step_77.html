<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_77.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-77 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-77 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_15.html">step-15</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#HowdealIIinterfaceswithKINSOL"> How deal.II interfaces with KINSOL </a>
        <li><a href="#Detailsoftheimplementation"> Details of the implementation </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclasstemplate">The <code>MinimalSurfaceProblem</code> class template</a>
        <li><a href="#Boundarycondition">Boundary condition</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclassimplementation">The <code>MinimalSurfaceProblem</code> class implementation</a>
      <ul>
        <li><a href="#Constructorandsetupfunctions">Constructor and set up functions</a>
        <li><a href="#AssemblingandfactorizingtheJacobianmatrix">Assembling and factorizing the Jacobian matrix</a>
        <li><a href="#Computingtheresidualvector">Computing the residual vector</a>
        <li><a href="#SolvinglinearsystemswiththeJacobianmatrix">Solving linear systems with the Jacobian matrix</a>
        <li><a href="#Refiningthemeshsettingboundaryvaluesandgeneratinggraphicaloutput">Refining the mesh, setting boundary values, and generating graphical output</a>
        <li><a href="#Therunfunctionandtheoveralllogicoftheprogram">The run() function and the overall logic of the program</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em> This program was contributed by Wolfgang Bangerth, Colorado State University.</em></p>
<p><em>This material is based upon work partially supported by National Science Foundation grants OAC-1835673, DMS-1821210, and EAR-1925595; and by the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-1550901 and The University of California-Davis. </em> <br />
</p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The <a class="el" href="step_15.html">step-15</a> program solved the following, nonlinear equation describing the minimal surface problem: </p><p class="formulaDsp">
\begin{align*} -\nabla \cdot \left( \frac{1}{\sqrt{1+|\nabla u|^{2}}}\nabla u \right) &amp;= 0 \qquad \qquad &amp;&amp;\textrm{in} ~ \Omega \\ u&amp;=g \qquad\qquad &amp;&amp;\textrm{on} ~ \partial \Omega. \end{align*}
</p>
<p> <a class="el" href="step_15.html">step-15</a> uses a Newton method, and Newton's method works by repeatedly solving a <em>linearized</em> problem for an update \(\delta u_k\) &ndash; called the "search direction" &ndash;, computing a "step length" \(\alpha_k\), and then combining them to compute the new guess for the solution via </p><p class="formulaDsp">
\begin{align*} u_{k+1} = u_k + \alpha_k \, \delta u_k. \end{align*}
</p>
<p>In the course of the discussions in <a class="el" href="step_15.html">step-15</a>, we found that it is awkward to compute the step length, and so just settled for simple choice: Always choose \(\alpha_k=0.1\). This is of course not efficient: We know that we can only realize Newton's quadratic convergence rate if we eventually are able to choose \(\alpha_k=1\), though we may have to choose it smaller for the first few iterations where we are still too far away to use this long a step length.</p>
<p>Among the goals of this program is therefore to address this shortcoming. Since line search algorithms are not entirely trivial to implement, one does as one should do anyway: Import complicated functionality from an external library. To this end, we will make use of the interfaces deal.II has to one of the big nonlinear solver packages, namely the <a href="https://computing.llnl.gov/projects/sundials/kinsol">KINSOL</a> sub-package of the <a href="https://computing.llnl.gov/projects/sundials">SUNDIALS</a> suite. SUNDIALS is, at its heart, a package meant to solve complex ordinary differential equations (ODEs) and differential-algebraic equations (DAEs), and the deal.II interfaces allow for this via the classes in the <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> namespace: Notably the <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a> and <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a> classes. But, because that is an important step in the solution of ODEs and DAEs with implicit methods, SUNDIALS also has a solver for nonlinear problems called KINSOL, and deal.II has an interface to it in the form of the <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a> class. This is what we will use for the solution of our problem.</p>
<p>But SUNDIALS isn't just a convenient way for us to avoid writing a line search algorithm. In general, the solution of nonlinear problems is quite expensive, and one typically wants to save as much compute time as possible. One way one can achieve this is as follows: The algorithm in <a class="el" href="step_15.html">step-15</a> discretizes the problem and then in every iteration solves a linear system of the form </p><p class="formulaDsp">
\begin{align*} J_k \, \delta U_k = -F_k \end{align*}
</p>
<p> where \(F_k\) is the residual vector computed using the current vector of nodal values \(U_k\), \(J_k\) is its derivative (called the "Jacobian"), and \(\delta U_k\) is the update vector that corresponds to the function \(\delta u_k\) mentioned above. The construction of \(J_k,F_k\) has been thoroughly discussed in <a class="el" href="step_15.html">step-15</a>, as has the way to solve the linear system in each Newton iteration. So let us focus on another aspect of the nonlinear solution procedure: Computing \(F_k\) is expensive, and assembling the matrix \(J_k\) even more so. Do we actually need to do that in every iteration? It turns out that in many applications, this is not actually necessary: These methods often converge even if we replace \(J_k\) by an approximation \(\tilde J_k\) and solve </p><p class="formulaDsp">
\begin{align*} \tilde J_k \, \widetilde{\delta U}_k = -F_k \end{align*}
</p>
<p> instead, then update </p><p class="formulaDsp">
\begin{align*} U_{k+1} = U_k + \alpha_k \, \widetilde{\delta U}_k. \end{align*}
</p>
<p> This may require an iteration or two more because our update \(\widetilde{\delta U}_k\) is not quite as good as \(\delta U_k\), but it may still be a win because we don't have to assemble \(J_k\) quite as often.</p>
<p>What kind of approximation \(\tilde J_k\) would we like for \(J_k\)? Theory says that as \(U_k\) converges to the exact solution \(U^\ast\), we need to ensure that \(\tilde J_k\) needs to converge to \(J^\ast = \nabla F(U^\ast)\). In particular, since \(J_k\rightarrow J^\ast\), a valid choice is \(\tilde J_k = J_k\). But so is choosing \(\tilde J_k = J_k\) every, say, fifth iteration \(k=0,5,10,\ldots\) and for the other iterations, we choose \(\tilde J_k\) equal to the last computed \(J_{k&#39;}\). This is what we will do here: we will just re-use \(\tilde J_{k-1}\) from the previous iteration, which may again be what we had used in the iteration before that, \(\tilde J_{k-2}\).</p>
<p>This scheme becomes even more interesting if, for the solution of the linear system with \(J_k\), we don't just have to assemble a matrix, but also compute a good preconditioner. For example, if we were to use a sparse LU decomposition via the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class, or used a geometric or algebraic multigrid. In those cases, we would also not have to update the preconditioner, whose computation may have taken about as long or longer than the assembly of the matrix in the first place. Indeed, with this mindset, we should probably think about using the <em>best</em> preconditioner we can think of, even though their construction is typically quite expensive: We will hope to amortize the cost of computing this preconditioner by applying it to more than one just one linear solve.</p>
<p>The big question is, of course: By what criterion do we decide whether we can get away with the approximation \(\tilde J_k\) based on a previously computed Jacobian matrix \(J_{k-s}\) that goes back \(s\) steps, or whether we need to &ndash; at least in this iteration &ndash; actually re-compute the Jacobian \(J_k\) and the corresponding preconditioner? This is, like the issue with line search, one that requires a non-trivial amount of code that monitors the convergence of the overall algorithm. We <em>could</em> implement these sorts of things ourselves, but we probably <em>shouldn't</em>: KINSOL already does that for us. It will tell our code when to "update" the Jacobian matrix.</p>
<p>One last consideration if we were to use an iterative solver instead of the sparse direct one mentioned above: Not only is it possible to get away with replacing \(J_k\) by some approximation \(\tilde J_k\) when solving for the update \(\delta U_k\), but one can also ask whether it is necessary to solve the linear system </p><p class="formulaDsp">
\begin{align*} \tilde J_k \widetilde{\delta U}_k = -F_k \end{align*}
</p>
<p> to high accuracy. The thinking goes like this: While our current solution \(U_k\) is still far away from \(U^\ast\), why would we solve this linear system particularly accurately? The update \(U_{k+1}=U_k + \widetilde{\delta U}_k\) is likely still going to be far away from the exact solution, so why spend much time on solving the linear system to great accuracy? This is the kind of thinking that underlies algorithms such as the "Eisenstat-Walker trick" <b>[eiwa96]</b> in which one is given a tolerance to which the linear system above in iteration \(k\) has to be solved, with this tolerance dependent on the progress in the overall nonlinear solver. As before, one could try to implement this oneself, but KINSOL already provides this kind of information for us &ndash; though we will not use it in this program since we use a direct solver that requires no solver tolerance and just solves the linear system exactly up to round-off.</p>
<p>As a summary of all of these considerations, we could say the following: There is no need to reinvent the wheel. Just like deal.II provides a vast amount of finite-element functionality, SUNDIALS' KINSOL package provides a vast amount of nonlinear solver functionality, and we better use it.</p>
<p><a class="anchor" id="HowdealIIinterfaceswithKINSOL"></a></p><h3>How deal.II interfaces with KINSOL </h3>
<p>KINSOL, like many similar packages, works in a pretty abstract way. At its core, it sees a nonlinear problem of the form </p><p class="formulaDsp">
\begin{align*} F(U) = 0 \end{align*}
</p>
<p> and constructs a sequence of iterates \(U_k\) which, in general, are vectors of the same length as the vector returned by the function \(F\). To do this, there are a few things it needs from the user:</p><ul>
<li>A way to resize a given vector to the correct size.</li>
<li>A way to evaluate, for a given vector \(U\), the function \(F(U)\). This function is generally called the "residual" operation because the goal is of course to find a point \(U^\ast\) for which \(F(U^\ast)=0\); if \(F(U)\) returns a nonzero vector, then this is the <a href="https://en.wikipedia.org/wiki/Residual_(numerical_analysis)">"residual"</a> (i.e., the "rest", or whatever is "left over"). The function that will do this is in essence the same as the computation of the right hand side vector in <a class="el" href="step_15.html">step-15</a>, but with an important difference: There, the right hand side denoted the <em>negative</em> of the residual, so we have to switch a sign.</li>
<li>A way to compute the matrix \(J_k\) if that is necessary in the current iteration, along with possibly a preconditioner or other data structures (e.g., a sparse decomposition via <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> if that's what we choose to use to solve a linear system). This operation will generally be called the "setup" operation.</li>
<li>A way to solve a linear system \(\tilde J_k x = b\) with whatever matrix \(\tilde J_k\) was last computed. This operation will generally be called the "solve" operation.</li>
</ul>
<p>All of these operations need to be provided to KINSOL by <a href="https://en.cppreference.com/w/cpp/utility/functional/function">std::function</a> objects that take the appropriate set of arguments and that generally return an integer that indicates success (a zero return value) or failure (a nonzero return value). Specifically, the objects we will access are the <a class="el" href="classSUNDIALS_1_1KINSOL.html#abdccb7a76e27cd9948048fdd03949380">SUNDIALS::KINSOL::reinit_vector</a>, <a class="el" href="classSUNDIALS_1_1KINSOL.html#aa791c6b63d41c8e7b12ec227e224c72a">SUNDIALS::KINSOL::residual</a>, <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">SUNDIALS::KINSOL::setup_jacobian</a>, and <a class="el" href="classSUNDIALS_1_1KINSOL.html#a388cbc77068ac53927b0b8b3e055a423">SUNDIALS::KINSOL::solve_jacobian_system</a> member variables. (See the documentation of these variables for their details.) In our implementation, we will use <a href="https://en.cppreference.com/w/cpp/language/lambda">lambda functions</a> to implement these "callbacks" that in turn can call member functions; KINSOL will then call these callbacks whenever its internal algorithms think it is useful.</p>
<p><a class="anchor" id="Detailsoftheimplementation"></a></p><h3>Details of the implementation </h3>
<p>The majority of the code of this tutorial program is as in <a class="el" href="step_15.html">step-15</a>, and we will not comment on it in much detail. There is really just one aspect one has to pay some attention to, namely how to compute \(F(U)\) given a vector \(U\) on the one hand, and \(J(U)\) given a vector \(U\) separately. At first, this seems trivial: We just take the <code>assemble_system()</code> function and in the one case throw out all code that deals with the matrix and in the other case with the right hand side vector. There: Problem solved.</p>
<p>But it isn't quite as simple. That's because the two are not independent if we have nonzero Dirichlet boundary values, as we do here. The linear system we want to solve contains both interior and boundary degrees of freedom, and when eliminating those degrees of freedom from those that are truly "free", using for example <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a>, we need to know the matrix when assembling the right hand side vector.</p>
<p>Of course, this completely contravenes the original intent: To <em>not</em> assemble the matrix if we can get away without it. We solve this problem as follows:</p><ul>
<li>We set the starting guess for the solution vector, \(U_0\), to one where boundary degrees of freedom already have their correct values.</li>
<li>This implies that all updates can have zero updates for these degrees of freedom, and we can build both residual vectors \(F(U_k)\) and Jacobian matrices \(J_k\) that corresponds to linear systems whose solutions are zero in these vector components. For this special case, the assembly of matrix and right hand side vectors is independent, and can be broken into separate functions.</li>
</ul>
<p>There is an assumption here that whenever KINSOL asks for a linear solver with the (approximation of the) Jacobian, that this will be for for an update \(\delta U\) (which has zero boundary values), a multiple of which will be added to the solution (which already has the right boundary values). This may not be true and if so, we might have to rethink our approach. That said, it turns out that in practice this is exactly what KINSOL does when using a Newton method, and so our approach is successful.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>This program starts out like most others with well known include files. Compared to the <a class="el" href="step_15.html">step-15</a> program from which most of what we do here is copied, the only difference is the include of the header files from which we import the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class and the actual interface to KINSOL:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinsol_8h.html">deal.II/sundials/kinsol.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step77</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclasstemplate"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class template</h3>
<p>Similarly, the main class of this program is essentially a copy of the one in <a class="el" href="step_15.html">step-15</a>. The class does, however, split the computation of the Jacobian (system) matrix (and its factorization using a direct solver) and residual into separate functions for the reasons outlined in the introduction. For the same reason, the class also has a pointer to a factorization of the Jacobian matrix that is reset every time we update the Jacobian matrix.</p>
<p>(If you are wondering why the program uses a direct object for the Jacobian matrix but a pointer for the factorization: Every time KINSOL requests that the Jacobian be updated, we can simply write <code>jacobian_matrix=0;</code> to reset it to an empty matrix that we can then fill again. On the other hand, the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class does not have any way to throw away its content or to replace it with a new factorization, and so we use a pointer: We just throw away the whole object and create a new one whenever we have a new Jacobian matrix to factor.)</p>
<p>Finally, the class has a timer variable that we will use to assess how long the different parts of the program take so that we can assess whether KINSOL's tendency to not rebuild the matrix and its factorization makes sense. We will discuss this in the "Results" section below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MinimalSurfaceProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">  <span class="keywordtype">void</span> solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">             Vector&lt;double&gt; &amp;      solution,</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">double</span>          tolerance);</div><div class="line">  <span class="keywordtype">void</span> refine_mesh();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line">  <span class="keywordtype">void</span> set_boundary_values();</div><div class="line">  <span class="keywordtype">void</span> compute_and_factorize_jacobian(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point);</div><div class="line">  <span class="keywordtype">void</span> compute_residual(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                        Vector&lt;double&gt; &amp;      residual);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                      sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt;                 jacobian_matrix;</div><div class="line">  std::unique_ptr&lt;SparseDirectUMFPACK&gt; jacobian_matrix_factorization;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; current_solution;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Boundarycondition"></a> </p><h3>Boundary condition</h3>
<p>The classes implementing boundary values are a copy from <a class="el" href="step_15.html">step-15</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 * numbers::PI * (p[0] + p[1]));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclassimplementation"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class implementation</h3>
<p><a class="anchor" id="Constructorandsetupfunctions"></a> </p><h4>Constructor and set up functions</h4>
<p>The following few functions are also essentially copies of what <a class="el" href="step_15.html">step-15</a> already does, and so there is little to discuss.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">  : dof_handler(triangulation)</div><div class="line">  , fe(1)</div><div class="line">  , computing_timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;set up&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (initial_step)</div><div class="line">    {</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">      current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">      hanging_node_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                              hanging_node_constraints);</div><div class="line">      hanging_node_constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  jacobian_matrix.reinit(sparsity_pattern);</div><div class="line">  jacobian_matrix_factorization.reset();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="AssemblingandfactorizingtheJacobianmatrix"></a> </p><h4>Assembling and factorizing the Jacobian matrix</h4>
<p>The following function is then responsible for assembling and factorizing the Jacobian matrix. The first half of the function is in essence the <code>assemble_system()</code> function of <a class="el" href="step_15.html">step-15</a>, except that it does not deal with also forming a right hand side vector (i.e., the residual) since we do not always have to do these operations at the same time.</p>
<p>We put the whole assembly functionality into a code block enclosed by curly braces so that we can use a <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> variable to measure how much time is spent in this code block, excluding everything that happens in this function after the matching closing brace <code>}</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_and_factorize_jacobian(</div><div class="line">  <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point)</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">    jacobian_matrix = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                         evaluation_point_gradients);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">              1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                    evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                    (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                         coeff                       <span class="comment">//   * a_n</span></div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)) <span class="comment">//   * \nabla \phi_j)</span></div><div class="line">                      -                              <span class="comment">//  -</span></div><div class="line">                      (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                         coeff * coeff * coeff       <span class="comment">//   * a_n^3</span></div><div class="line">                        </div><div class="line">                       (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)       <span class="comment">//   * (\nabla \phi_j</span></div><div class="line">                          evaluation_point_gradients[q]) <span class="comment">//      * \nabla u_n)</span></div><div class="line">                         evaluation_point_gradients[q])) <span class="comment">//   * \nabla u_n)))</span></div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));                <span class="comment">// * dx</span></div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        hanging_node_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                            local_dof_indices,</div><div class="line">                                                            jacobian_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                             boundary_values);</div><div class="line">    Vector&lt;double&gt; dummy_solution(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    Vector&lt;double&gt; dummy_rhs(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                       jacobian_matrix,</div><div class="line">                                       dummy_solution,</div><div class="line">                                       dummy_rhs);</div><div class="line">  }</div></div><!-- fragment --><p>The second half of the function then deals with factorizing the so-computed matrix. To do this, we first create a new <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> object and by assigning it to the member variable <code>jacobian_matrix_factorization</code>, we also destroy whatever object that pointer previously pointed to (if any). Then we tell the object to factorize the Jacobian.</p>
<p>As above, we enclose this block of code into curly braces and use a timer to assess how long this part of the program takes.</p>
<p>(Strictly speaking, we don't actually need the matrix any more after we are done here, and could throw the matrix object away. A code intended to be memory efficient would do this, and only create the matrix object in this function, rather than as a member variable of the surrounding class. We omit this step here because using the same coding style as in previous tutorial programs breeds familiarity with the common style and helps make these tutorial programs easier to read.)</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;factorizing the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Factorizing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    jacobian_matrix_factorization = std::make_unique&lt;SparseDirectUMFPACK&gt;();</div><div class="line">    jacobian_matrix_factorization-&gt;factorize(jacobian_matrix);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingtheresidualvector"></a> </p><h4>Computing the residual vector</h4>
<p>The second part of what <code>assemble_system()</code> used to do in <a class="el" href="step_15.html">step-15</a> is computing the residual vector, i.e., the right hand side vector of the Newton linear systems. We have broken this out of the previous function, but the following function will be easy to understand if you understood what <code>assemble_system()</code> in <a class="el" href="step_15.html">step-15</a> did. Importantly, however, we need to compute the residual not linearized around the current solution vector, but whatever we get from KINSOL. This is necessary for operations such as line search where we want to know what the residual \(F(U^k + \alpha_k \delta U^K)\) is for different values of \(\alpha_k\); KINSOL in those cases simply gives us the argument to the function \(F\) and we then compute the residual \(F(\cdot)\) at this point.</p>
<p>The function prints the norm of the so-computed residual at the end as a way for us to follow along the progress of the program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(</div><div class="line">  <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">  Vector&lt;double&gt; &amp;      residual)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the residual&quot;</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing residual vector...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                       evaluation_point_gradients);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">            1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                  evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) = (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                  coeff                    <span class="comment">// * a_n</span></div><div class="line">                                  evaluation_point_gradients[q] <span class="comment">// * u_n</span></div><div class="line">                                  fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));            <span class="comment">// * dx</span></div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">    }</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(residual);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">       <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">    residual(i) = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">       <a class="code" href="namespaceDoFTools.html#aed6928cb7bdb5a85e8670d6bd5c90e24">DoFTools::extract_hanging_node_dofs</a>(dof_handler))</div><div class="line">    residual(i) = 0;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; norm=&quot;</span> &lt;&lt; residual.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="SolvinglinearsystemswiththeJacobianmatrix"></a> </p><h4>Solving linear systems with the Jacobian matrix</h4>
<p>Next up is the function that implements the solution of a linear system with the Jacobian matrix. Since we have already factored the matrix when we built the matrix, solving a linear system comes down to applying the inverse matrix to the given right hand side vector: This is what the <a class="el" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">SparseDirectUMFPACK::vmult()</a> function does that we use here. Following this, we have to make sure that we also address the values of hanging nodes in the solution vector, and this is done using <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a>.</p>
<p>The function takes an additional, but unused, argument <code>tolerance</code> that indicates how accurately we have to solve the linear system. The meaning of this argument is discussed in the introduction in the context of the "Eisenstat Walker trick", but since we are using a direct rather than an iterative solver, we are not using this opportunity to solve linear systems only inexactly.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                       Vector&lt;double&gt; &amp;      solution,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> <span class="comment">/*tolerance*/</span>)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;linear system solve&quot;</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Solving linear system&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  jacobian_matrix_factorization-&gt;vmult(solution, rhs);</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Refiningthemeshsettingboundaryvaluesandgeneratinggraphicaloutput"></a> </p><h4>Refining the mesh, setting boundary values, and generating graphical output</h4>
<p>The following three functions are again simply copies of the ones in <a class="el" href="step_15.html">step-15</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">    current_solution,</div><div class="line">    estimated_error_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.03);</div><div class="line"></div><div class="line">  triangulation.prepare_coarsening_and_refinement();</div><div class="line"></div><div class="line">  <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">  solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line"></div><div class="line">  triangulation.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  solution_transfer.interpolate(current_solution, tmp);</div><div class="line">  current_solution = std::move(tmp);</div><div class="line"></div><div class="line">  hanging_node_constraints.clear();</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                          hanging_node_constraints);</div><div class="line">  hanging_node_constraints.close();</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(current_solution);</div><div class="line"></div><div class="line">  set_boundary_values();</div><div class="line"></div><div class="line">  setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">{</div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           boundary_values);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">    current_solution(boundary_value.first) = boundary_value.second;</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(current_solution);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;graphical output&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Therunfunctionandtheoveralllogicoftheprogram"></a> </p><h4>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function and the overall logic of the program</h4>
<p>The only function that <em>really</em> is interesting in this program is the one that drives the overall algorithm of starting on a coarse mesh, doing some mesh refinement cycles, and on each mesh using KINSOL to find the solution of the nonlinear algebraic equation we obtain from discretization on this mesh. The <code>refine_mesh()</code> function above makes sure that the solution on one mesh is used as the starting guess on the next mesh. We also use a <a class="el" href="classTimerOutput.html">TimerOutput</a> object to measure how much time every operation on each mesh costs, and reset the timer at the beginning of each cycle.</p>
<p>As discussed in the introduction, it is not necessary to solve problems on coarse meshes particularly accurately since these will only solve as starting guesses for the next mesh. As a consequence, we will use a target tolerance of \(\tau=10^{-3} \frac{1}{10^k}\) for the \(k\)th mesh refinement cycle.</p>
<p>All of this is encoded in the first part of this function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">  triangulation.refine_global(2);</div><div class="line"></div><div class="line">  setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">true</span>);</div><div class="line">  set_boundary_values();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">       ++refinement_cycle)</div><div class="line">    {</div><div class="line">      computing_timer.<a class="code" href="classTimerOutput.html#a017cdef3c18d6050d401dab4f2f64d2e">reset</a>();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">        refine_mesh();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> target_tolerance = 1e-3 * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.1, refinement_cycle);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Target_tolerance: &quot;</span> &lt;&lt; target_tolerance &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl;</div></div><!-- fragment --><p>This is where the fun starts. At the top we create the KINSOL solver object and feed it with an object that encodes a number of additional specifics (of which we only change the nonlinear tolerance we want to reach; but you might want to look into what other members the <a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">SUNDIALS::KINSOL::AdditionalData</a> class has and play with them).</p>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt;::AdditionalData</div><div class="line">    additional_data;</div><div class="line">  additional_data.function_tolerance = target_tolerance;</div><div class="line"></div><div class="line">  <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt; nonlinear_solver(additional_data);</div></div><!-- fragment --><p>Then we have to describe the operations that were already mentioned in the introduction. In essence, we have to teach KINSOL how to (i) resize a vector to the correct size, (ii) compute the residual vector, (iii) compute the Jacobian matrix (during which we also compute its factorization), and (iv) solve a linear system with the Jacobian.</p>
<p>All four of these operations are represented by member variables of the <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a> class that are of type <code>std::function</code>, i.e., they are objects to which we can assign a pointer to a function or, as we do here, a "lambda function" that takes the appropriate arguments and returns the appropriate information. By convention, KINSOL wants that functions doing something nontrivial return an integer where zero indicates success. It turns out that we can do all of this in just 25 lines of code.</p>
<p>(If you're not familiar what "lambda functions" are, take a look at <a class="el" href="step_12.html">step-12</a> or at the <a href="https://en.wikipedia.org/wiki/Anonymous_function">wikipedia page</a> on the subject. The idea of lambda functions is that one wants to define a function with a certain set of arguments, but (i) not make it a named functions because, typically, the function is used in only one place and it seems unnecessary to give it a global name; and (ii) that the function has access to some of the variables that exist at the place where it is defined, including member variables. The syntax of lambda functions is awkward, but ultimately quite useful.)</p>
<p>At the very end of the code block we then tell KINSOL to go to work and solve our problem. The member functions called from the 'residual', 'setup_jacobian', and 'solve_jacobian_system' functions will then print output to screen that allows us to follow along with the progress of the program.</p>
<div class="fragment"><div class="line">  nonlinear_solver.reinit_vector = [&amp;](Vector&lt;double&gt; &amp;x) {</div><div class="line">    x.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  };</div><div class="line"></div><div class="line">  nonlinear_solver.residual =</div><div class="line">    [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">        Vector&lt;double&gt; &amp;      residual) {</div><div class="line">      compute_residual(evaluation_point, residual);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    };</div><div class="line"></div><div class="line">  nonlinear_solver.setup_jacobian =</div><div class="line">    [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;current_u,</div><div class="line">        <span class="keyword">const</span> Vector&lt;double&gt; &amp; <span class="comment">/*current_f*/</span>) {</div><div class="line">      compute_and_factorize_jacobian(current_u);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    };</div><div class="line"></div><div class="line">  nonlinear_solver.solve_with_jacobian = [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                             Vector&lt;double&gt; &amp;      dst,</div><div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance) {</div><div class="line">    this-&gt;solve(rhs, dst, tolerance);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  };</div><div class="line"></div><div class="line">  nonlinear_solver.solve(current_solution);</div><div class="line">}</div></div><!-- fragment --><p>The rest is then just house-keeping: Writing data to a file for visualizing, and showing a summary of the timing collected so that we can interpret how long each operation has taken, how often it was executed, etc:</p>
<div class="fragment"><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step77</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step77;</div><div class="line"></div><div class="line">      MinimalSurfaceProblem&lt;2&gt; laplace_problem_2d;</div><div class="line">      laplace_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>When running the program, you get output that looks like this: </p><div class="fragment"><div class="line">Mesh refinement step 0</div><div class="line">  Target_tolerance: 0.001</div><div class="line"></div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Computing residual vector... norm=0.127245</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Computing residual vector... norm=0.0625301</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0625301</div><div class="line">  Computing residual vector... norm=0.0498864</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0498864</div><div class="line">  Computing residual vector... norm=0.0407765</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0407765</div><div class="line">  Computing residual vector... norm=0.0341589</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0341589</div><div class="line">  Computing residual vector... norm=0.0292867</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0292867</div><div class="line">  Computing residual vector... norm=0.0256309</div><div class="line">  Computing residual vector... norm=0.0223448</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0223448</div><div class="line">  Computing residual vector... norm=0.0202797</div><div class="line">  Computing residual vector... norm=0.0183817</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0183817</div><div class="line">  Computing residual vector... norm=0.0170464</div><div class="line">  Computing residual vector... norm=0.0157967</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0157967</div><div class="line">  Computing residual vector... norm=0.0141572</div><div class="line">  Computing residual vector... norm=0.012657</div><div class="line"> Solving linear system</div><div class="line">  Computing residual vector... norm=0.012657</div><div class="line">  Computing residual vector... norm=0.0116863</div><div class="line">  Computing residual vector... norm=0.0107696</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0107696</div><div class="line">  Computing residual vector... norm=0.0100986</div><div class="line">  Computing residual vector... norm=0.00944829</div><div class="line">  Computing residual vector... norm=0.00822576</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00822576</div><div class="line">  Computing residual vector... norm=0.00781983</div><div class="line">  Computing residual vector... norm=0.00741619</div><div class="line">  Computing residual vector... norm=0.00661792</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00661792</div><div class="line">  Computing residual vector... norm=0.00630571</div><div class="line">  Computing residual vector... norm=0.00599457</div><div class="line">  Computing residual vector... norm=0.00537663</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00537663</div><div class="line">  Computing residual vector... norm=0.00512813</div><div class="line">  Computing residual vector... norm=0.00488033</div><div class="line">  Computing residual vector... norm=0.00438751</div><div class="line">  Computing residual vector... norm=0.00342052</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00342052</div><div class="line">  Computing residual vector... norm=0.00326581</div><div class="line">  Computing residual vector... norm=0.00311176</div><div class="line">  Computing residual vector... norm=0.00280617</div><div class="line">  Computing residual vector... norm=0.00220992</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00220992</div><div class="line">  Computing residual vector... norm=0.00209976</div><div class="line">  Computing residual vector... norm=0.00199943</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00199942</div><div class="line">  Computing residual vector... norm=0.00190953</div><div class="line">  Computing residual vector... norm=0.00182005</div><div class="line">  Computing residual vector... norm=0.00164259</div><div class="line">  Computing residual vector... norm=0.00129652</div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |     0.192s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| assembling the Jacobian         |         2 |    0.0141s |       7.4% |</div><div class="line">| assembling the residual         |        61 |     0.168s |        88% |</div><div class="line">| factorizing the Jacobian        |         2 |    0.0016s |      0.83% |</div><div class="line">| graphical output                |         1 |   0.00385s |         2% |</div><div class="line">| linear system solve             |        19 |    0.0013s |      0.68% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line"></div><div class="line">Mesh refinement step 1</div><div class="line">  Target_tolerance: 0.0001</div><div class="line"></div><div class="line">  Computing residual vector... norm=0.0883422</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0883422</div><div class="line">  Computing residual vector... norm=0.0607066</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0607066</div><div class="line">  Computing residual vector... norm=0.0437266</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0437266</div><div class="line">  Computing residual vector... norm=0.0327999</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0327999</div><div class="line">  Computing residual vector... norm=0.0255418</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0255417</div><div class="line">  Computing residual vector... norm=0.0206042</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0206042</div><div class="line">  Computing residual vector... norm=0.0171602</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0171602</div><div class="line">  Computing residual vector... norm=0.014689</div><div class="line">  Solving linear system</div><div class="line"></div><div class="line">[...]</div></div><!-- fragment --><p>The way this should be interpreted is most easily explained by looking at the first few lines of the output on the first mesh: </p><div class="fragment"><div class="line">Mesh refinement step 0</div><div class="line">Mesh refinement step 0</div><div class="line">  Target_tolerance: 0.001</div><div class="line"></div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Computing residual vector... norm=0.127245</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  ...</div></div><!-- fragment --><p> What is happening is this:</p><ul>
<li>In the first residual computation, KINSOL computes the residual to see whether the desired tolerance has been reached. The answer is no, so it requests the user program to compute the Jacobian matrix (and the function then also factorizes the matrix via <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>).</li>
<li>KINSOL then instructs us to solve a linear system of the form \(J_k \, \delta U_k = -F_k\) with this matrix and the previously computed residual vector.</li>
<li>It is then time to determine how far we want to go in this direction, i.e., do line search. To this end, KINSOL requires us to compute the residual vector \(F(U_k + \alpha_k \delta U_k)\) for different step lengths \(\alpha_k\). For the first step above, it finds an acceptable \(\alpha_k\) after two tries, the second time around it takes three tries.</li>
<li>Having found a suitable updated solution \(U_{k+1}\), the process is repeated except now KINSOL is happy with the current Jacobian matrix and does not instruct us to re-build the matrix and its factorization, and instead asks us to solve a linear system with that same matrix.</li>
</ul>
<p>The program also writes the solution to a VTU file at the end of each mesh refinement cycle, and it looks as follows: </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-77.solution.png"/>
</div>
   </td></tr>
</table>
<p>The key takeaway messages of this program are the following:</p>
<ul>
<li>The solution is the same as the one we computed in <a class="el" href="step_15.html">step-15</a>, i.e., the interfaces to SUNDIALS' KINSOL package really did what they were supposed to do. This should not come as a surprise, but the important point is that we don't have to spend the time implementing the complex algorithms that underlie advanced nonlinear solvers ourselves.</li>
<li>KINSOL is able to avoid all sorts of operations such as rebuilding the Jacobian matrix when that is not actually necessary. Comparing the number of linear solves in the output above with the number of times we rebuild the Jacobian and compute its factorization should make it clear that this leads to very substantial savings in terms of compute times, without us having to implement the intricacies of algorithms that determine when we need to rebuild this information.</li>
</ul>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>For all but the small problems we consider here, a sparse direct solver requires too much time and memory &ndash; we need an iterative solver like we use in many other programs. The trade-off between constructing an expensive preconditioner (say, a geometric or algebraic multigrid method) is different in the current case, however: Since we can re-use the same matrix for numerous linear solves, we can do the same for the preconditioner and putting more work into building a good preconditioner can more easily be justified than if we used it only for a single linear solve as one does for many other situations.</p>
<p>But iterative solvers also afford other opportunities. For example (and as discussed briefly in the introduction), we may not need to solve to very high accuracy (small tolerances) in early nonlinear iterations as long as we are still far away from the actual solution. This was the basis of the Eisenstat-Walker trick mentioned there.</p>
<p>KINSOL provides the function that does the linear solution with a target tolerance that needs to be reached. We ignore it in the program above because the direct solver we use does not need a tolerance and instead solves the linear system exactly (up to round-off, of course), but iterative solvers could make use of this kind of information &ndash; and, in fact, should.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Colorado State University, 2021.</span></div><div class="line"><span class="comment"> * Based on @ref step_15 &quot;step-15&quot; by Sven Wetterauer, University of Heidelberg, 2012.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinsol_8h.html">deal.II/sundials/kinsol.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step77</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    MinimalSurfaceProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">    <span class="keywordtype">void</span> solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">               Vector&lt;double&gt; &amp;      solution,</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">double</span>          tolerance);</div><div class="line">    <span class="keywordtype">void</span> refine_mesh();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line">    <span class="keywordtype">void</span> set_boundary_values();</div><div class="line">    <span class="keywordtype">void</span> compute_and_factorize_jacobian(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point);</div><div class="line">    <span class="keywordtype">void</span> compute_residual(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                          Vector&lt;double&gt; &amp;      residual);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                      sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt;                 jacobian_matrix;</div><div class="line">    std::unique_ptr&lt;SparseDirectUMFPACK&gt; jacobian_matrix_factorization;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; current_solution;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 * numbers::PI * (p[0] + p[1]));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">    : dof_handler(triangulation)</div><div class="line">    , fe(1)</div><div class="line">    , computing_timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;set up&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (initial_step)</div><div class="line">      {</div><div class="line">        dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">        current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">        hanging_node_constraints.clear();</div><div class="line">        <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                                hanging_node_constraints);</div><div class="line">        hanging_node_constraints.close();</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    jacobian_matrix.reinit(sparsity_pattern);</div><div class="line">    jacobian_matrix_factorization.reset();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_and_factorize_jacobian(</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point)</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">      jacobian_matrix = 0;</div><div class="line"></div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                              quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          cell_matrix = 0;</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                           evaluation_point_gradients);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">                1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                      evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                         * coeff                       <span class="comment">//   * a_n</span></div><div class="line">                         * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)) <span class="comment">//   * \nabla \phi_j)</span></div><div class="line">                        -                              <span class="comment">//  -</span></div><div class="line">                        (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                         * coeff * coeff * coeff       <span class="comment">//   * a_n^3</span></div><div class="line">                         *</div><div class="line">                         (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)       <span class="comment">//   * (\nabla \phi_j</span></div><div class="line">                          * evaluation_point_gradients[q]) <span class="comment">//      * \nabla u_n)</span></div><div class="line">                         * evaluation_point_gradients[q])) <span class="comment">//   * \nabla u_n)))</span></div><div class="line">                       * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));                <span class="comment">// * dx</span></div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          hanging_node_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                              local_dof_indices,</div><div class="line">                                                              jacobian_matrix);</div><div class="line">        }</div><div class="line"></div><div class="line">      std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               0,</div><div class="line">                                               <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                               boundary_values);</div><div class="line">      Vector&lt;double&gt; dummy_solution(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      Vector&lt;double&gt; dummy_rhs(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                         jacobian_matrix,</div><div class="line">                                         dummy_solution,</div><div class="line">                                         dummy_rhs);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;factorizing the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Factorizing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      jacobian_matrix_factorization = std::make_unique&lt;SparseDirectUMFPACK&gt;();</div><div class="line">      jacobian_matrix_factorization-&gt;factorize(jacobian_matrix);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">    Vector&lt;double&gt; &amp;      residual)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the residual&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing residual vector...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                         evaluation_point_gradients);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">              1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                    evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) = (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                  * coeff                    <span class="comment">// * a_n</span></div><div class="line">                                  * evaluation_point_gradients[q] <span class="comment">// * u_n</span></div><div class="line">                                  * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));            <span class="comment">// * dx</span></div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">      }</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(residual);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">         <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">      residual(i) = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">         <a class="code" href="namespaceDoFTools.html#aed6928cb7bdb5a85e8670d6bd5c90e24">DoFTools::extract_hanging_node_dofs</a>(dof_handler))</div><div class="line">      residual(i) = 0;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; norm=&quot;</span> &lt;&lt; residual.l2_norm() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                         Vector&lt;double&gt; &amp;      solution,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">double</span> <span class="comment">/*tolerance*/</span>)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;linear system solve&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Solving linear system&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    jacobian_matrix_factorization-&gt;vmult(solution, rhs);</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      current_solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line"></div><div class="line">    triangulation.prepare_coarsening_and_refinement();</div><div class="line"></div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">    solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line"></div><div class="line">    triangulation.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution_transfer.interpolate(current_solution, tmp);</div><div class="line">    current_solution = std::move(tmp);</div><div class="line"></div><div class="line">    hanging_node_constraints.clear();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                            hanging_node_constraints);</div><div class="line">    hanging_node_constraints.close();</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(current_solution);</div><div class="line"></div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">false</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">  {</div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             boundary_values);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">      current_solution(boundary_value.first) = boundary_value.second;</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(current_solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;graphical output&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">    triangulation.refine_global(2);</div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">true</span>);</div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a017cdef3c18d6050d401dab4f2f64d2e">reset</a>();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> target_tolerance = 1e-3 * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.1, refinement_cycle);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Target_tolerance: &quot;</span> &lt;&lt; target_tolerance &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        {</div><div class="line">          <span class="keyword">typename</span> <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt;::AdditionalData</div><div class="line">            additional_data;</div><div class="line">          additional_data.function_tolerance = target_tolerance;</div><div class="line"></div><div class="line">          <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt; nonlinear_solver(additional_data);</div><div class="line"></div><div class="line">          nonlinear_solver.reinit_vector = [&amp;](Vector&lt;double&gt; &amp;x) {</div><div class="line">            x.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">          };</div><div class="line"></div><div class="line">          nonlinear_solver.residual =</div><div class="line">            [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                Vector&lt;double&gt; &amp;      residual) {</div><div class="line">              compute_residual(evaluation_point, residual);</div><div class="line"></div><div class="line">              <span class="keywordflow">return</span> 0;</div><div class="line">            };</div><div class="line"></div><div class="line">          nonlinear_solver.setup_jacobian =</div><div class="line">            [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;current_u,</div><div class="line">                <span class="keyword">const</span> Vector&lt;double&gt; &amp; <span class="comment">/*current_f*/</span>) {</div><div class="line">              compute_and_factorize_jacobian(current_u);</div><div class="line"></div><div class="line">              <span class="keywordflow">return</span> 0;</div><div class="line">            };</div><div class="line"></div><div class="line">          nonlinear_solver.solve_with_jacobian = [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                                     Vector&lt;double&gt; &amp;      dst,</div><div class="line">                                                     <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance) {</div><div class="line">            this-&gt;solve(rhs, dst, tolerance);</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span> 0;</div><div class="line">          };</div><div class="line"></div><div class="line">          nonlinear_solver.solve(current_solution);</div><div class="line">        }</div><div class="line"></div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step77</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step77;</div><div class="line"></div><div class="line">      MinimalSurfaceProblem&lt;2&gt; laplace_problem_2d;</div><div class="line">      laplace_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_15.html">step-15</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#HowdealIIinterfaceswithKINSOL"> How deal.II interfaces with KINSOL </a><a href="#HowdealIIinterfaceswithKINSOL"> How deal.II interfaces with KINSOL </a>
        <li><a href="#Detailsoftheimplementation"> Details of the implementation </a><a href="#Detailsoftheimplementation"> Details of the implementation </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclasstemplate">The <code>MinimalSurfaceProblem</code> class template</a><a href="#ThecodeMinimalSurfaceProblemcodeclasstemplate">The <code>MinimalSurfaceProblem</code> class template</a>
        <li><a href="#Boundarycondition">Boundary condition</a><a href="#Boundarycondition">Boundary condition</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclassimplementation">The <code>MinimalSurfaceProblem</code> class implementation</a><a href="#ThecodeMinimalSurfaceProblemcodeclassimplementation">The <code>MinimalSurfaceProblem</code> class implementation</a>
      <ul>
        <li><a href="#Constructorandsetupfunctions">Constructor and set up functions</a><a href="#Constructorandsetupfunctions">Constructor and set up functions</a>
        <li><a href="#AssemblingandfactorizingtheJacobianmatrix">Assembling and factorizing the Jacobian matrix</a><a href="#AssemblingandfactorizingtheJacobianmatrix">Assembling and factorizing the Jacobian matrix</a>
        <li><a href="#Computingtheresidualvector">Computing the residual vector</a><a href="#Computingtheresidualvector">Computing the residual vector</a>
        <li><a href="#SolvinglinearsystemswiththeJacobianmatrix">Solving linear systems with the Jacobian matrix</a><a href="#SolvinglinearsystemswiththeJacobianmatrix">Solving linear systems with the Jacobian matrix</a>
        <li><a href="#Refiningthemeshsettingboundaryvaluesandgeneratinggraphicaloutput">Refining the mesh, setting boundary values, and generating graphical output</a><a href="#Refiningthemeshsettingboundaryvaluesandgeneratinggraphicaloutput">Refining the mesh, setting boundary values, and generating graphical output</a>
        <li><a href="#Therunfunctionandtheoveralllogicoftheprogram">The run() function and the overall logic of the program</a><a href="#Therunfunctionandtheoveralllogicoftheprogram">The run() function and the overall logic of the program</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
 <em> This program was contributed by Wolfgang Bangerth, Colorado State University.</em></p>
<p><em>This material is based upon work partially supported by National Science Foundation grants OAC-1835673, DMS-1821210, and EAR-1925595; and by the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-1550901 and The University of California-Davis. </em> <br />
 <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The <a class="el" href="step_15.html">step-15</a> program solved the following, nonlinear equationdescribing the minimal surface problem: </p><p class="formulaDsp">
\begin{align*} -\nabla \cdot \left( \frac{1}{\sqrt{1+|\nabla u|^{2}}}\nabla u \right) &amp;= 0 \qquad \qquad &amp;&amp;\textrm{in} ~ \Omega \\ u&amp;=g \qquad\qquad &amp;&amp;\textrm{on} ~ \partial \Omega. \end{align*}
</p>
<p> <a class="el" href="step_15.html">step-15</a> uses a Newton method, andNewton's method works by repeatedly solving alinearized* problem foran update \(\delta u_k\)</p>
<ul>
<li>called the "search direction"</li>
<li>, computing a"step length" \(\alpha_k\) , and then combining them to compute the newguess for the solution via <p class="formulaDsp">
\begin{align*} u_{k+1} = u_k + \alpha_k \, \delta u_k. \end{align*}
</p>
</li>
</ul>
<p>In the course of the discussions in <a class="el" href="step_15.html">step-15</a> , we found that it isawkward to compute the step length, and so just settled for simplechoice: Always choose \(\alpha_k=0.1\) . This is of course not efficient:We know that we can only realize Newton's quadratic convergence rateif we eventually are able to choose \(\alpha_k=1\) , though we may haveto choose it smaller for the first few iterations where we are stilltoo far away to use this long a step length. Among the goals of this program is therefore to address thisshortcoming. Since line search algorithms are not entirely trivial toimplement, one does as one should do anyway: Import complicatedfunctionality from an external library. To this end, we will make useof the interfaces deal.II has to one of the big nonlinear solverpackages, namely the<a href="https://computing.llnl.gov/projects/sundials/kinsol">KINSOL</a>sub-package of the<a href="https://computing.llnl.gov/projects/sundials">SUNDIALS</a>suite. SUNDIALS is, at its heart, a package meant to solve complexordinary differential equations (ODEs) and differential-algebraicequations (DAEs), and the deal.II interfaces allow for this via theclasses in the <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> namespace: Notably the <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a> and <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a> classes. But, because that is an important step in thesolution of ODEs and DAEs with implicit methods, SUNDIALS also has asolver for nonlinear problems called KINSOL, and deal.II has aninterface to it in the form of the <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a> class. This iswhat we will use for the solution of our problem. But SUNDIALS isn't just a convenient way for us to avoid writing aline search algorithm. In general, the solution of nonlinear problemsis quite expensive, and one typically wants to save as much computetime as possible. One way one can achieve this is as follows: Thealgorithm in <a class="el" href="step_15.html">step-15</a> discretizes the problem and then in everyiteration solves a linear system of the form </p><p class="formulaDsp">
\begin{align*} J_k \, \delta U_k = -F_k \end{align*}
</p>
<p> where \(F_k\) is the residual vector computed using the current vectorof nodal values \(U_k\) , \(J_k\) is its derivative (called the"Jacobian"), and \(\delta U_k\) is the update vector that corresponds tothe function \(\delta u_k\) mentioned above. The construction of \(J_k,F_k\) has been thoroughly discussed in <a class="el" href="step_15.html">step-15</a> , as has the way tosolve the linear system in each Newton iteration. So let us focus onanother aspect of the nonlinear solution procedure: Computing \(F_k\) isexpensive, and assembling the matrix \(J_k\) even more so. Do weactually need to do that in every iteration? It turns out that in manyapplications, this is not actually necessary: These methods often convergeeven if we replace \(J_k\) by an approximation \(\tilde J_k\) and solve </p><p class="formulaDsp">
\begin{align*} \tilde J_k \, \widetilde{\delta U}_k = -F_k \end{align*}
</p>
<p> instead, then update </p><p class="formulaDsp">
\begin{align*} U_{k+1} = U_k + \alpha_k \, \widetilde{\delta U}_k. \end{align*}
</p>
<p> This may require an iteration or two more because our update \(\widetilde{\delta U}_k\) is not quite as good as \(\delta U_k\) , but itmay still be a win because we don't have to assemble \(J_k\) quite asoften. What kind of approximation \(\tilde J_k\) would we like for \(J_k\) ? Theorysays that as \(U_k\) converges to the exact solution \(U^\ast\) , we need toensure that \(\tilde J_k\) needs to converge to \(J^\ast = \nabla F(U^\ast)\) .In particular, since \(J_k\rightarrow J^\ast\) , a valid choice is \(\tilde J_k = J_k\) . But so is choosing \(\tilde J_k = J_k\) every, say,fifth iteration \(k=0,5,10,\ldots\) and for the other iterations, we choose \(\tilde J_k\) equal to the last computed \(J_{k&#39;}\) . This is what we will dohere: we will just re-use \(\tilde J_{k-1}\) from theprevious iteration, which may again be what we had used in theiteration before that, \(\tilde J_{k-2}\) . This scheme becomes even more interesting if, for the solution of thelinear system with \(J_k\) , we don't just have to assemble a matrix, butalso compute a good preconditioner. For example, if we were to use asparse LU decomposition via the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class, or used ageometric or algebraic multigrid. In those cases, we would also nothave to update the preconditioner, whose computation may have takenabout as long or longer than the assembly of the matrix in the firstplace. Indeed, with this mindset, we should probably think about usingthebest* preconditioner we can think of, even though theirconstruction is typically quite expensive: We will hope to amortizethe cost of computing this preconditioner by applying it to more thanone just one linear solve. The big question is, of course: By what criterion do we decide whetherwe can get away with the approximation \(\tilde J_k\) based on apreviously computed Jacobian matrix \(J_{k-s}\) that goes back \(s\) steps, or whether we need to</p>
<ul>
<li>at least in this iteration</li>
<li>actuallyre-compute the Jacobian \(J_k\) and the corresponding preconditioner?This is, like the issue with line search, one that requires anon-trivial amount of code that monitors the convergence of theoverall algorithm. Wecould* implement these sorts of thingsourselves, but we probablyshouldn't*: KINSOL already does that forus. It will tell our code when to "update" the Jacobian matrix. One last consideration if we were to use an iterative solver instead ofthe sparse direct one mentioned above: Not only is it possible to getaway with replacing \(J_k\) by some approximation \(\tilde J_k\) whensolving for the update \(\delta U_k\) , but one can also ask whether itis necessary to solve the linear system <p class="formulaDsp">
\begin{align*} \tilde J_k \widetilde{\delta U}_k = -F_k \end{align*}
</p>
 to high accuracy. The thinking goes like this: While our current solution \(U_k\) is still far away from \(U^\ast\) , why would we solve this linearsystem particularly accurately? The update \(U_{k+1}=U_k + \widetilde{\delta U}_k\) is likely still going to be far awayfrom the exact solution, so why spend much time on solving the linear systemto great accuracy? This is the kind of thinking that underlies algorithmssuch as the "Eisenstat-Walker trick" <b>[eiwa96]</b> in which one is givena tolerance to which the linear system above in iteration \(k\) has to besolved, with this tolerance dependent on the progress in the overallnonlinear solver. As before, one could try to implement this oneself,but KINSOL already provides this kind of information for us</li>
<li>though wewill not use it in this program since we use a direct solver that requiresno solver tolerance and just solves the linear system exactly up toround-off. As a summary of all of these considerations, we could say thefollowing: There is no need to reinvent the wheel. Just like deal.IIprovides a vast amount of finite-element functionality, SUNDIALS'KINSOL package provides a vast amount of nonlinear solverfunctionality, and we better use it.</li>
</ul>
<p><a class="anchor" id="HowdealIIinterfaceswithKINSOL"></a></p><h3>How deal.II interfaces with KINSOL </h3>
<p>KINSOL, like many similar packages, works in a pretty abstract way. Atits core, it sees a nonlinear problem of the form </p><p class="formulaDsp">
\begin{align*} F(U) = 0 \end{align*}
</p>
<p> and constructs a sequence of iterates \(U_k\) which, in general, arevectors of the same length as the vector returned by the function \(F\) . To do this, there are a few things it needs from the user:</p>
<ul>
<li>A way to resize a given vector to the correct size.</li>
<li>A way to evaluate, for a given vector \(U\) , the function \(F(U)\) . This function is generally called the "residual" operation because the goal is of course to find a point \(U^\ast\) for which \(F(U^\ast)=0\) ; if \(F(U)\) returns a nonzero vector, then this is the <a href="https://en.wikipedia.org/wiki/Residual_(numerical_analysis)">"residual"</a> (i.e., the "rest", or whatever is "left over"). The function that will do this is in essence the same as the computation of the right hand side vector in <a class="el" href="step_15.html">step-15</a> , but with an important difference: There, the right hand side denoted thenegative* of the residual, so we have to switch a sign.</li>
<li>A way to compute the matrix \(J_k\) if that is necessary in the current iteration, along with possibly a preconditioner or other data structures (e.g., a sparse decomposition via <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> if that's what we choose to use to solve a linear system). This operation will generally be called the "setup" operation.</li>
<li>A way to solve a linear system \(\tilde J_k x = b\) with whatever matrix \(\tilde J_k\) was last computed. This operation will generally be called the "solve" operation. All of these operations need to be provided to KINSOL by <a href="https://en.cppreference.com/w/cpp/utility/functional/function">std::function</a> objects that take the appropriate set of arguments and that generallyreturn an integer that indicates success (a zero return value) orfailure (a nonzero return value). Specifically, the objects we willaccess are the <a class="el" href="classSUNDIALS_1_1KINSOL.html#abdccb7a76e27cd9948048fdd03949380">SUNDIALS::KINSOL::reinit_vector</a>, <a class="el" href="classSUNDIALS_1_1KINSOL.html#aa791c6b63d41c8e7b12ec227e224c72a">SUNDIALS::KINSOL::residual</a>, <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">SUNDIALS::KINSOL::setup_jacobian</a>, and <a class="el" href="classSUNDIALS_1_1KINSOL.html#a388cbc77068ac53927b0b8b3e055a423">SUNDIALS::KINSOL::solve_jacobian_system</a> member variables. (See the documentation of these variables for theirdetails.) In our implementation, we will use<a href="https://en.cppreference.com/w/cpp/language/lambda">lambda functions</a>to implement these "callbacks" that in turn can call member functions;KINSOL will then call these callbacks whenever its internal algorithmsthink it is useful.</li>
</ul>
<p><a class="anchor" id="Detailsoftheimplementation"></a></p><h3>Details of the implementation </h3>
<p>The majority of the code of this tutorial program is as in <a class="el" href="step_15.html">step-15</a> ,and we will not comment on it in much detail. There is really just oneaspect one has to pay some attention to, namely how to compute \(F(U)\) given a vector \(U\) on the one hand, and \(J(U)\) given a vector \(U\) separately. At first, this seems trivial: We just take the<code>assemble_system()</code> function and in the one case throw out all codethat deals with the matrix and in the other case with the right handside vector. There: Problem solved. But it isn't quite as simple. That's because the two are notindependent if we have nonzero Dirichlet boundary values, as we dohere. The linear system we want to solve contains both interior andboundary degrees of freedom, and when eliminating those degrees offreedom from those that are truly "free", using for example <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a>, we need to know thematrix when assembling the right hand side vector. Of course, this completely contravenes the original intent: Tonot* assemble the matrix if we can get away without it. We solve thisproblem as follows:</p>
<ul>
<li>We set the starting guess for the solution vector, \(U_0\) , to one where boundary degrees of freedom already have their correct values.</li>
<li>This implies that all updates can have zero updates for these degrees of freedom, and we can build both residual vectors \(F(U_k)\) and Jacobian matrices \(J_k\) that corresponds to linear systems whose solutions are zero in these vector components. For this special case, the assembly of matrix and right hand side vectors is independent, and can be broken into separate functions. There is an assumption here that whenever KINSOL asks for a linearsolver with the (approximation of the) Jacobian, that this will be forfor an update \(\delta U\) (which has zero boundary values), a multipleof which will be added to the solution (which already has the rightboundary values). This may not be true and if so, we might have torethink our approach. That said, it turns out that in practice this isexactly what KINSOL does when using a Newton method, and so ourapproach is successful.</li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>This program starts out like most others with well known include files. Compared to the <a class="el" href="step_15.html">step-15</a> program from which most of what we do here is copied, the only difference is the include of the header files from which we import the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class and the actual interface to KINSOL:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinsol_8h.html">deal.II/sundials/kinsol.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"> </div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step77</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclasstemplate"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class template</h3>
<p>Similarly, the main class of this program is essentially a copy of the one in <a class="el" href="step_15.html">step-15</a> . The class does, however, split the computation of the Jacobian (system) matrix (and its factorization using a direct solver) and residual into separate functions for the reasons outlined in the introduction. For the same reason, the class also has a pointer to a factorization of the Jacobian matrix that is reset every time we update the Jacobian matrix. (If you are wondering why the program uses a direct object for the Jacobian matrix but a pointer for the factorization: Every time KINSOL requests that the Jacobian be updated, we can simply write <code>jacobian_matrix=0;</code> to reset it to an empty matrix that we can then fill again. On the other hand, the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class does not have any way to throw away its content or to replace it with a new factorization, and so we use a pointer: We just throw away the whole object and create a new one whenever we have a new Jacobian matrix to factor.) Finally, the class has a timer variable that we will use to assess how long the different parts of the program take so that we can assess whether KINSOL's tendency to not rebuild the matrix and its factorization makes sense. We will discuss this in the "Results" section below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MinimalSurfaceProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">  <span class="keywordtype">void</span> solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">             Vector&lt;double&gt; &amp;      solution,</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">double</span>          tolerance);</div><div class="line">  <span class="keywordtype">void</span> refine_mesh();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line">  <span class="keywordtype">void</span> set_boundary_values();</div><div class="line">  <span class="keywordtype">void</span> compute_and_factorize_jacobian(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point);</div><div class="line">  <span class="keywordtype">void</span> compute_residual(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                        Vector&lt;double&gt; &amp;      residual);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                      sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt;                 jacobian_matrix;</div><div class="line">  std::unique_ptr&lt;SparseDirectUMFPACK&gt; jacobian_matrix_factorization;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; current_solution;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Boundarycondition"></a> </p><h3>Boundary condition</h3>
<p>The classes implementing boundary values are a copy from <a class="el" href="step_15.html">step-15</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span> )<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 numbers::PI (p[0] + p[1]));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclassimplementation"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class implementation</h3>
<pre class="fragment">&lt;a name="Constructorandsetupfunctions"&gt;&lt;/a&gt;  &lt;h4&gt;Constructor and set up functions&lt;/h4&gt;
</pre><p>The following few functions are also essentially copies of what <a class="el" href="step_15.html">step-15</a> already does, and so there is little to discuss.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">  : dof_handler(triangulation)</div><div class="line">  , fe(1)</div><div class="line">  , computing_timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;set up&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (initial_step)</div><div class="line">    {</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">      current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">      hanging_node_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                              hanging_node_constraints);</div><div class="line">      hanging_node_constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  jacobian_matrix.reinit(sparsity_pattern);</div><div class="line">  jacobian_matrix_factorization.reset();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="AssemblingandfactorizingtheJacobianmatrix"></a> </p><h4>Assembling and factorizing the Jacobian matrix</h4>
<p>The following function is then responsible for assembling and factorizing the Jacobian matrix. The first half of the function is in essence the <code>assemble_system()</code> function of <a class="el" href="step_15.html">step-15</a> , except that it does not deal with also forming a right hand side vector (i.e., the residual) since we do not always have to do these operations at the same time. We put the whole assembly functionality into a code block enclosed by curly braces so that we can use a <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> variable to measure how much time is spent in this code block, excluding everything that happens in this function after the matching closing brace <code>}</code>.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_and_factorize_jacobian(</div><div class="line">     <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point)</div><div class="line">   {</div><div class="line">     {</div><div class="line">       <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the Jacobian&quot;</span>);</div><div class="line">  </div><div class="line">       std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">       <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">  </div><div class="line">       jacobian_matrix = 0;</div><div class="line">  </div><div class="line">       <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                               quadrature_formula,</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  </div><div class="line">       <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  </div><div class="line">       std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line">  </div><div class="line">       std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  </div><div class="line">       <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">         {</div><div class="line">           cell_matrix = 0;</div><div class="line">  </div><div class="line">           fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">  </div><div class="line">           fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                            evaluation_point_gradients);</div><div class="line">  </div><div class="line">           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">             {</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">                 1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q]</div><div class="line">                                       evaluation_point_gradients[q]);</div><div class="line">  </div><div class="line">               <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                 {</div><div class="line">                   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                     <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                       (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                          coeff                       <span class="comment">//   a_n</span></div><div class="line">                          fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)) <span class="comment">//   \nabla \phi_j)</span></div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-                              <span class="comment">//</span></div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-</div><div class="line">                         (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                          coeff coeff coeff       <span class="comment">//   a_n^3</span></div><div class="line">                         </div><div class="line">                          (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)       <span class="comment">//   (\nabla \phi_j</span></div><div class="line">                           evaluation_point_gradients[q]) <span class="comment">//      \nabla u_n)</span></div><div class="line">                          evaluation_point_gradients[q])) <span class="comment">//   \nabla u_n)))</span></div><div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));                <span class="comment">// dx</span></div><div class="line">                 }</div><div class="line">             }</div><div class="line">  </div><div class="line">           cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">           hanging_node_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                               local_dof_indices,</div><div class="line">                                                               jacobian_matrix);</div><div class="line">         }</div><div class="line">  </div><div class="line">       std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">       <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                                0,</div><div class="line">                                                <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                                boundary_values);</div><div class="line">       Vector&lt;double&gt; dummy_solution(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">       Vector&lt;double&gt; dummy_rhs(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">       <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                          jacobian_matrix,</div><div class="line">                                          dummy_solution,</div><div class="line">                                          dummy_rhs);</div><div class="line">     }</div></div><!-- fragment --><p>The second half of the function then deals with factorizing the so-computed matrix. To do this, we first create a new <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> object and by assigning it to the member variable <code>jacobian_matrix_factorization</code>, we also destroy whatever object that pointer previously pointed to (if any). Then we tell the object to factorize the Jacobian. As above, we enclose this block of code into curly braces and use a timer to assess how long this part of the program takes. (Strictly speaking, we don't actually need the matrix any more after we are done here, and could throw the matrix object away. A code intended to be memory efficient would do this, and only create the matrix object in this function, rather than as a member variable of the surrounding class. We omit this step here because using the same coding style as in previous tutorial programs breeds familiarity with the common style and helps make these tutorial programs easier to read.)</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;factorizing the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Factorizing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    jacobian_matrix_factorization = std::make_unique&lt;SparseDirectUMFPACK&gt;();</div><div class="line">    jacobian_matrix_factorization-&gt;factorize(jacobian_matrix);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingtheresidualvector"></a> </p><h4>Computing the residual vector</h4>
<p>The second part of what <code>assemble_system()</code> used to do in <a class="el" href="step_15.html">step-15</a> is computing the residual vector, i.e., the right hand side vector of the Newton linear systems. We have broken this out of the previous function, but the following function will be easy to understand if you understood what <code>assemble_system()</code> in <a class="el" href="step_15.html">step-15</a> did. Importantly, however, we need to compute the residual not linearized around the current solution vector, but whatever we get from KINSOL. This is necessary for operations such as line search where we want to know what the residual \(F(U^k + \alpha_k \delta U^K)\) is for different values of \(\alpha_k\) ; KINSOL in those cases simply gives us the argument to the function \(F\) and we then compute the residual \(F(\cdot)\) at this point. The function prints the norm of the so-computed residual at the end as a way for us to follow along the progress of the program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(</div><div class="line">  <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">  Vector&lt;double&gt; &amp;      residual)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the residual&quot;</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing residual vector...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                       evaluation_point_gradients);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">            1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q]</div><div class="line">                                  evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) = (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                coeff                    <span class="comment">// a_n</span></div><div class="line">                                evaluation_point_gradients[q] <span class="comment">// u_n</span></div><div class="line">                                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));            <span class="comment">// dx</span></div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">    }</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(residual);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">       <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">    residual(i) = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">       <a class="code" href="namespaceDoFTools.html#aed6928cb7bdb5a85e8670d6bd5c90e24">DoFTools::extract_hanging_node_dofs</a>(dof_handler))</div><div class="line">    residual(i) = 0;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; norm=&quot;</span> &lt;&lt; residual.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="SolvinglinearsystemswiththeJacobianmatrix"></a> </p><h4>Solving linear systems with the Jacobian matrix</h4>
<p>Next up is the function that implements the solution of a linear system with the Jacobian matrix. Since we have already factored the matrix when we built the matrix, solving a linear system comes down to applying the inverse matrix to the given right hand side vector: This is what the <a class="el" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">SparseDirectUMFPACK::vmult()</a> function does that we use here. Following this, we have to make sure that we also address the values of hanging nodes in the solution vector, and this is done using <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a>. The function takes an additional, but unused, argument <code>tolerance</code> that indicates how accurately we have to solve the linear system. The meaning of this argument is discussed in the introduction in the context of the "Eisenstat Walker trick", but since we are using a direct rather than an iterative solver, we are not using this opportunity to solve linear systems only inexactly.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                       Vector&lt;double&gt; &amp;      solution,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span>  <span class="comment">/*tolerance*/</span> )</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;linear system solve&quot;</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Solving linear system&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  jacobian_matrix_factorization-&gt;vmult(solution, rhs);</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Refiningthemeshsettingboundaryvaluesandgeneratinggraphicaloutput"></a> </p><h4>Refining the mesh, setting boundary values, and generating graphical output</h4>
<p>The following three functions are again simply copies of the ones in <a class="el" href="step_15.html">step-15</a> :</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">   {</div><div class="line">     <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line">  </div><div class="line">     <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">       dof_handler,</div><div class="line">       <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt;(fe.degree + 1),</div><div class="line">       std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>&gt;(),</div><div class="line">       current_solution,</div><div class="line">       estimated_error_per_cell);</div><div class="line">  </div><div class="line">     <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                     estimated_error_per_cell,</div><div class="line">                                                     0.3,</div><div class="line">                                                     0.03);</div><div class="line">  </div><div class="line">     triangulation.prepare_coarsening_and_refinement();</div><div class="line">  </div><div class="line">     <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">     solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line">  </div><div class="line">     triangulation.execute_coarsening_and_refinement();</div><div class="line">  </div><div class="line">     dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  </div><div class="line">     Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">     solution_transfer.interpolate(current_solution, tmp);</div><div class="line">     current_solution = std::move(tmp);</div><div class="line">  </div><div class="line">     hanging_node_constraints.clear();</div><div class="line">  </div><div class="line">     <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                             hanging_node_constraints);</div><div class="line">     hanging_node_constraints.close();</div><div class="line">  </div><div class="line">     hanging_node_constraints.distribute(current_solution);</div><div class="line">  </div><div class="line">     set_boundary_values();</div><div class="line">  </div><div class="line">     setup_system( <span class="comment">/*initial_step=*/</span> <span class="keyword">false</span>);</div><div class="line">   }</div><div class="line">  </div><div class="line"> </div><div class="line">  </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">   {</div><div class="line">     std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">     <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                              0,</div><div class="line">                                              BoundaryValues&lt;dim&gt;(),</div><div class="line">                                              boundary_values);</div><div class="line">     <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">       current_solution(boundary_value.first) = boundary_value.second;</div><div class="line">  </div><div class="line">     hanging_node_constraints.distribute(current_solution);</div><div class="line">   }</div><div class="line">  </div><div class="line"> </div><div class="line">  </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)</div><div class="line">   {</div><div class="line">     <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;graphical output&quot;</span>);</div><div class="line">  </div><div class="line">     <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  </div><div class="line">     data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">     data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">     data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> std::string filename =</div><div class="line">       <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">     std::ofstream output(filename);</div><div class="line">     data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="Therunfunctionandtheoveralllogicoftheprogram"></a> </p><h4>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function and the overall logic of the program</h4>
<p>The only function thatreally* is interesting in this program is the one that drives the overall algorithm of starting on a coarse mesh, doing some mesh refinement cycles, and on each mesh using KINSOL to find the solution of the nonlinear algebraic equation we obtain from discretization on this mesh. The <code>refine_mesh()</code> function above makes sure that the solution on one mesh is used as the starting guess on the next mesh. We also use a <a class="el" href="classTimerOutput.html">TimerOutput</a> object to measure how much time every operation on each mesh costs, and reset the timer at the beginning of each cycle. As discussed in the introduction, it is not necessary to solve problems on coarse meshes particularly accurately since these will only solve as starting guesses for the next mesh. As a consequence, we will use a target tolerance of \(\tau=10^{-3} \frac{1}{10^k}\) for the \(k\) th mesh refinement cycle. All of this is encoded in the first part of this function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">  triangulation.refine_global(2);</div><div class="line"></div><div class="line">  setup_system( <span class="comment">/*initial_step=*/</span> <span class="keyword">true</span>);</div><div class="line">  set_boundary_values();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">       ++refinement_cycle)</div><div class="line">    {</div><div class="line">      computing_timer.<a class="code" href="classTimerOutput.html#a017cdef3c18d6050d401dab4f2f64d2e">reset</a>();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">        refine_mesh();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> target_tolerance = 1e-3 <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.1, refinement_cycle);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Target_tolerance: &quot;</span> &lt;&lt; target_tolerance &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl;</div></div><!-- fragment --><p>This is where the fun starts. At the top we create the KINSOL solver object and feed it with an object that encodes a number of additional specifics (of which we only change the nonlinear tolerance we want to reach; but you might want to look into what other members the <a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">SUNDIALS::KINSOL::AdditionalData</a> class has and play with them).</p>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt;::AdditionalData</div><div class="line">    additional_data;</div><div class="line">  additional_data.function_tolerance = target_tolerance;</div><div class="line"></div><div class="line">  <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt; nonlinear_solver(additional_data);</div></div><!-- fragment --><p>Then we have to describe the operations that were already mentioned in the introduction. In essence, we have to teach KINSOL how to (i) resize a vector to the correct size, (ii) compute the residual vector, (iii) compute the Jacobian matrix (during which we also compute its factorization), and (iv) solve a linear system with the Jacobian. All four of these operations are represented by member variables of the <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a> class that are of type <code>std::function</code>, i.e., they are objects to which we can assign a pointer to a function or, as we do here, a "lambda function" that takes the appropriate arguments and returns the appropriate information. By convention, KINSOL wants that functions doing something nontrivial return an integer where zero indicates success. It turns out that we can do all of this in just 25 lines of code. (If you're not familiar what "lambda functions" are, take a look at <a class="el" href="step_12.html">step-12</a> or at the <a href="https://en.wikipedia.org/wiki/Anonymous_function">wikipedia page</a> on the subject. The idea of lambda functions is that one wants to define a function with a certain set of arguments, but (i) not make it a named functions because, typically, the function is used in only one place and it seems unnecessary to give it a global name; and (ii) that the function has access to some of the variables that exist at the place where it is defined, including member variables. The syntax of lambda functions is awkward, but ultimately quite useful.) At the very end of the code block we then tell KINSOL to go to work and solve our problem. The member functions called from the 'residual', 'setup_jacobian', and 'solve_jacobian_system' functions will then print output to screen that allows us to follow along with the progress of the program.</p>
<div class="fragment"><div class="line">  nonlinear_solver.reinit_vector = [&amp;](Vector&lt;double&gt; &amp;x) {</div><div class="line">    x.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  };</div><div class="line"></div><div class="line">  nonlinear_solver.residual =</div><div class="line">    [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">        Vector&lt;double&gt; &amp;      residual) {</div><div class="line">      compute_residual(evaluation_point, residual);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    };</div><div class="line"></div><div class="line">  nonlinear_solver.setup_jacobian =</div><div class="line">    [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;current_u,</div><div class="line">        <span class="keyword">const</span> Vector&lt;double&gt; &amp;  <span class="comment">/*current_f*/</span> ) {</div><div class="line">      compute_and_factorize_jacobian(current_u);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    };</div><div class="line"></div><div class="line">  nonlinear_solver.solve_with_jacobian = [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                             Vector&lt;double&gt; &amp;      dst,</div><div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance) {</div><div class="line">    this-&gt;solve(rhs, dst, tolerance);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  };</div><div class="line"></div><div class="line">  nonlinear_solver.solve(current_solution);</div><div class="line">}</div></div><!-- fragment --><p>The rest is then just house-keeping: Writing data to a file for visualizing, and showing a summary of the timing collected so that we can interpret how long each operation has taken, how often it was executed, etc:</p>
<div class="fragment"><div class="line">        output_results(refinement_cycle);</div><div class="line"> </div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line"> </div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step77</span></div><div class="line"> </div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step77;</div><div class="line"> </div><div class="line">      MinimalSurfaceProblem&lt;2&gt; laplace_problem_2d;</div><div class="line">      laplace_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>When running the program, you get output that looks like this: </p><div class="fragment"><div class="line">Mesh refinement step 0</div><div class="line">  Target_tolerance: 0.001</div><div class="line">  </div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Computing residual vector... norm=0.127245</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Computing residual vector... norm=0.0625301</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0625301</div><div class="line">  Computing residual vector... norm=0.0498864</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0498864</div><div class="line">  Computing residual vector... norm=0.0407765</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0407765</div><div class="line">  Computing residual vector... norm=0.0341589</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0341589</div><div class="line">  Computing residual vector... norm=0.0292867</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0292867</div><div class="line">  Computing residual vector... norm=0.0256309</div><div class="line">  Computing residual vector... norm=0.0223448</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0223448</div><div class="line">  Computing residual vector... norm=0.0202797</div><div class="line">  Computing residual vector... norm=0.0183817</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0183817</div><div class="line">  Computing residual vector... norm=0.0170464</div><div class="line">  Computing residual vector... norm=0.0157967</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0157967</div><div class="line">  Computing residual vector... norm=0.0141572</div><div class="line">  Computing residual vector... norm=0.012657</div><div class="line"> Solving linear system</div><div class="line">  Computing residual vector... norm=0.012657</div><div class="line">  Computing residual vector... norm=0.0116863</div><div class="line">  Computing residual vector... norm=0.0107696</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0107696</div><div class="line">  Computing residual vector... norm=0.0100986</div><div class="line">  Computing residual vector... norm=0.00944829</div><div class="line">  Computing residual vector... norm=0.00822576</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00822576</div><div class="line">  Computing residual vector... norm=0.00781983</div><div class="line">  Computing residual vector... norm=0.00741619</div><div class="line">  Computing residual vector... norm=0.00661792</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00661792</div><div class="line">  Computing residual vector... norm=0.00630571</div><div class="line">  Computing residual vector... norm=0.00599457</div><div class="line">  Computing residual vector... norm=0.00537663</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00537663</div><div class="line">  Computing residual vector... norm=0.00512813</div><div class="line">  Computing residual vector... norm=0.00488033</div><div class="line">  Computing residual vector... norm=0.00438751</div><div class="line">  Computing residual vector... norm=0.00342052</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00342052</div><div class="line">  Computing residual vector... norm=0.00326581</div><div class="line">  Computing residual vector... norm=0.00311176</div><div class="line">  Computing residual vector... norm=0.00280617</div><div class="line">  Computing residual vector... norm=0.00220992</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00220992</div><div class="line">  Computing residual vector... norm=0.00209976</div><div class="line">  Computing residual vector... norm=0.00199943</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00199942</div><div class="line">  Computing residual vector... norm=0.00190953</div><div class="line">  Computing residual vector... norm=0.00182005</div><div class="line">  Computing residual vector... norm=0.00164259</div><div class="line">  Computing residual vector... norm=0.00129652</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |     0.192s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| assembling the Jacobian         |         2 |    0.0141s |       7.4% |</div><div class="line">| assembling the residual         |        61 |     0.168s |        88% |</div><div class="line">| factorizing the Jacobian        |         2 |    0.0016s |      0.83% |</div><div class="line">| graphical output                |         1 |   0.00385s |         2% |</div><div class="line">| linear system solve             |        19 |    0.0013s |      0.68% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">Mesh refinement step 1</div><div class="line">  Target_tolerance: 0.0001</div><div class="line">  </div><div class="line">  Computing residual vector... norm=0.0883422</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0883422</div><div class="line">  Computing residual vector... norm=0.0607066</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0607066</div><div class="line">  Computing residual vector... norm=0.0437266</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0437266</div><div class="line">  Computing residual vector... norm=0.0327999</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0327999</div><div class="line">  Computing residual vector... norm=0.0255418</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0255417</div><div class="line">  Computing residual vector... norm=0.0206042</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0206042</div><div class="line">  Computing residual vector... norm=0.0171602</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0171602</div><div class="line">  Computing residual vector... norm=0.014689</div><div class="line">  Solving linear system</div><div class="line">  </div><div class="line">[...]</div></div><!-- fragment --><p>The way this should be interpreted is most easily explained by looking atthe first few lines of the output on the first mesh: </p><div class="fragment"><div class="line">Mesh refinement step 0</div><div class="line">Mesh refinement step 0</div><div class="line">  Target_tolerance: 0.001</div><div class="line">  </div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Computing residual vector... norm=0.127245</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  ...</div></div><!-- fragment --><p> What is happening is this:</p>
<ul>
<li>In the first residual computation, KINSOL computes the residual to see whether the desired tolerance has been reached. The answer is no, so it requests the user program to compute the Jacobian matrix (and the function then also factorizes the matrix via <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>).</li>
<li>KINSOL then instructs us to solve a linear system of the form \(J_k \, \delta U_k = -F_k\) with this matrix and the previously computed residual vector.</li>
<li>It is then time to determine how far we want to go in this direction, i.e., do line search. To this end, KINSOL requires us to compute the residual vector \(F(U_k + \alpha_k \delta U_k)\) for different step lengths \(\alpha_k\) . For the first step above, it finds an acceptable \(\alpha_k\) after two tries, the second time around it takes three tries.</li>
<li>Having found a suitable updated solution \(U_{k+1}\) , the process is repeated except now KINSOL is happy with the current Jacobian matrix and does not instruct us to re-build the matrix and its factorization, and instead asks us to solve a linear system with that same matrix. The program also writes the solution to a VTU file at the endof each mesh refinement cycle, and it looks as follows: <table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-77.solution.png"/>
</div>
   </td></tr>
</table>
</li>
</ul>
<p>The key takeaway messages of this program are the following:</p>
<ul>
<li>The solution is the same as the one we computed in <a class="el" href="step_15.html">step-15</a> , i.e., the interfaces to SUNDIALS' KINSOL package really did what they were supposed to do. This should not come as a surprise, but the important point is that we don't have to spend the time implementing the complex algorithms that underlie advanced nonlinear solvers ourselves.</li>
<li>KINSOL is able to avoid all sorts of operations such as rebuilding the Jacobian matrix when that is not actually necessary. Comparing the number of linear solves in the output above with the number of times we rebuild the Jacobian and compute its factorization should make it clear that this leads to very substantial savings in terms of compute times, without us having to implement the intricacies of algorithms that determine when we need to rebuild this information. <a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a><h3>Possibilities for extensions </h3>
</li>
</ul>
<p>For all but the small problems we consider here, a sparse direct solverrequires too much time and memory</p>
<ul>
<li>we need an iterative solver likewe use in many other programs. The trade-off between constructing anexpensive preconditioner (say, a geometric or algebraic multigrid method)is different in the current case, however: Since we can re-use the samematrix for numerous linear solves, we can do the same for the preconditionerand putting more work into building a good preconditioner can more easilybe justified than if we used it only for a single linear solve as onedoes for many other situations. But iterative solvers also afford other opportunities. For example (and asdiscussed briefly in the introduction), we may not need to solve tovery high accuracy (small tolerances) in early nonlinear iterations as longas we are still far away from the actual solution. This was the basis of theEisenstat-Walker trick mentioned there. KINSOL provides the function that does the linear solution with a targettolerance that needs to be reached. We ignore it in the program abovebecause the direct solver we use does not need a tolerance and insteadsolves the linear system exactly (up to round-off, of course), but iterativesolvers could make use of this kind of information</li>
<li>and, in fact, should.</li>
</ul>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Colorado State University, 2021.</span></div><div class="line"><span class="comment"> * Based on @ref step_15 &quot;step-15&quot; by Sven Wetterauer, University of Heidelberg, 2012.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinsol_8h.html">deal.II/sundials/kinsol.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step77</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    MinimalSurfaceProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">    <span class="keywordtype">void</span> solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">               Vector&lt;double&gt; &amp;      solution,</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">double</span>          tolerance);</div><div class="line">    <span class="keywordtype">void</span> refine_mesh();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line">    <span class="keywordtype">void</span> set_boundary_values();</div><div class="line">    <span class="keywordtype">void</span> compute_and_factorize_jacobian(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point);</div><div class="line">    <span class="keywordtype">void</span> compute_residual(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                          Vector&lt;double&gt; &amp;      residual);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                      sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt;                 jacobian_matrix;</div><div class="line">    std::unique_ptr&lt;SparseDirectUMFPACK&gt; jacobian_matrix_factorization;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; current_solution;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 * numbers::PI * (p[0] + p[1]));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">    : dof_handler(triangulation)</div><div class="line">    , fe(1)</div><div class="line">    , computing_timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;set up&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (initial_step)</div><div class="line">      {</div><div class="line">        dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">        current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">        hanging_node_constraints.clear();</div><div class="line">        <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                                hanging_node_constraints);</div><div class="line">        hanging_node_constraints.close();</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    jacobian_matrix.reinit(sparsity_pattern);</div><div class="line">    jacobian_matrix_factorization.reset();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_and_factorize_jacobian(</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point)</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">      jacobian_matrix = 0;</div><div class="line"></div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                              quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          cell_matrix = 0;</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                           evaluation_point_gradients);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">                1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                      evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                         * coeff                       <span class="comment">//   * a_n</span></div><div class="line">                         * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)) <span class="comment">//   * \nabla \phi_j)</span></div><div class="line">                        -                              <span class="comment">//  -</span></div><div class="line">                        (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                         * coeff * coeff * coeff       <span class="comment">//   * a_n^3</span></div><div class="line">                         *</div><div class="line">                         (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)       <span class="comment">//   * (\nabla \phi_j</span></div><div class="line">                          * evaluation_point_gradients[q]) <span class="comment">//      * \nabla u_n)</span></div><div class="line">                         * evaluation_point_gradients[q])) <span class="comment">//   * \nabla u_n)))</span></div><div class="line">                       * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));                <span class="comment">// * dx</span></div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          hanging_node_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                              local_dof_indices,</div><div class="line">                                                              jacobian_matrix);</div><div class="line">        }</div><div class="line"></div><div class="line">      std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               0,</div><div class="line">                                               <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                               boundary_values);</div><div class="line">      Vector&lt;double&gt; dummy_solution(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      Vector&lt;double&gt; dummy_rhs(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                         jacobian_matrix,</div><div class="line">                                         dummy_solution,</div><div class="line">                                         dummy_rhs);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;factorizing the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Factorizing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      jacobian_matrix_factorization = std::make_unique&lt;SparseDirectUMFPACK&gt;();</div><div class="line">      jacobian_matrix_factorization-&gt;factorize(jacobian_matrix);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">    Vector&lt;double&gt; &amp;      residual)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the residual&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing residual vector...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                         evaluation_point_gradients);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">              1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                    evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) = (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                  * coeff                    <span class="comment">// * a_n</span></div><div class="line">                                  * evaluation_point_gradients[q] <span class="comment">// * u_n</span></div><div class="line">                                  * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));            <span class="comment">// * dx</span></div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">      }</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(residual);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">         <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">      residual(i) = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">         <a class="code" href="namespaceDoFTools.html#aed6928cb7bdb5a85e8670d6bd5c90e24">DoFTools::extract_hanging_node_dofs</a>(dof_handler))</div><div class="line">      residual(i) = 0;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; norm=&quot;</span> &lt;&lt; residual.l2_norm() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                         Vector&lt;double&gt; &amp;      solution,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">double</span> <span class="comment">/*tolerance*/</span>)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;linear system solve&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Solving linear system&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    jacobian_matrix_factorization-&gt;vmult(solution, rhs);</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      current_solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line"></div><div class="line">    triangulation.prepare_coarsening_and_refinement();</div><div class="line"></div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">    solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line"></div><div class="line">    triangulation.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution_transfer.interpolate(current_solution, tmp);</div><div class="line">    current_solution = std::move(tmp);</div><div class="line"></div><div class="line">    hanging_node_constraints.clear();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                            hanging_node_constraints);</div><div class="line">    hanging_node_constraints.close();</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(current_solution);</div><div class="line"></div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">false</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">  {</div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             boundary_values);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">      current_solution(boundary_value.first) = boundary_value.second;</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(current_solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;graphical output&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">    triangulation.refine_global(2);</div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">true</span>);</div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a017cdef3c18d6050d401dab4f2f64d2e">reset</a>();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> target_tolerance = 1e-3 * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.1, refinement_cycle);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Target_tolerance: &quot;</span> &lt;&lt; target_tolerance &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        {</div><div class="line">          <span class="keyword">typename</span> <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt;::AdditionalData</div><div class="line">            additional_data;</div><div class="line">          additional_data.function_tolerance = target_tolerance;</div><div class="line"></div><div class="line">          <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt; nonlinear_solver(additional_data);</div><div class="line"></div><div class="line">          nonlinear_solver.reinit_vector = [&amp;](Vector&lt;double&gt; &amp;x) {</div><div class="line">            x.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">          };</div><div class="line"></div><div class="line">          nonlinear_solver.residual =</div><div class="line">            [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                Vector&lt;double&gt; &amp;      residual) {</div><div class="line">              compute_residual(evaluation_point, residual);</div><div class="line"></div><div class="line">              <span class="keywordflow">return</span> 0;</div><div class="line">            };</div><div class="line"></div><div class="line">          nonlinear_solver.setup_jacobian =</div><div class="line">            [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;current_u,</div><div class="line">                <span class="keyword">const</span> Vector&lt;double&gt; &amp; <span class="comment">/*current_f*/</span>) {</div><div class="line">              compute_and_factorize_jacobian(current_u);</div><div class="line"></div><div class="line">              <span class="keywordflow">return</span> 0;</div><div class="line">            };</div><div class="line"></div><div class="line">          nonlinear_solver.solve_with_jacobian = [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                                     Vector&lt;double&gt; &amp;      dst,</div><div class="line">                                                     <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance) {</div><div class="line">            this-&gt;solve(rhs, dst, tolerance);</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span> 0;</div><div class="line">          };</div><div class="line"></div><div class="line">          nonlinear_solver.solve(current_solution);</div><div class="line">        }</div><div class="line"></div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step77</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step77;</div><div class="line"></div><div class="line">      MinimalSurfaceProblem&lt;2&gt; laplace_problem_2d;</div><div class="line">      laplace_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_15.html">step-15</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#HowdealIIinterfaceswithKINSOL"> How deal.II interfaces with KINSOL </a>
        <li><a href="#Detailsoftheimplementation"> Details of the implementation </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclasstemplate">The <code>MinimalSurfaceProblem</code> class template</a>
        <li><a href="#Boundarycondition">Boundary condition</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclassimplementation">The <code>MinimalSurfaceProblem</code> class implementation</a>
      <ul>
        <li><a href="#Constructorandsetupfunctions">Constructor and set up functions</a>
        <li><a href="#AssemblingandfactorizingtheJacobianmatrix">Assembling and factorizing the Jacobian matrix</a>
        <li><a href="#Computingtheresidualvector">Computing the residual vector</a>
        <li><a href="#SolvinglinearsystemswiththeJacobianmatrix">Solving linear systems with the Jacobian matrix</a>
        <li><a href="#Refiningthemeshsettingboundaryvaluesandgeneratinggraphicaloutput">Refining the mesh, setting boundary values, and generating graphical output</a>
        <li><a href="#Therunfunctionandtheoveralllogicoftheprogram">The run() function and the overall logic of the program</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-77/doc/intro.dox</p>
<p><br />
</p>
<p><em> This program was contributed by Wolfgang Bangerth, Colorado State University.</em></p>
<p><em>This material is based upon work partially supported by National Science Foundation grants OAC-1835673, DMS-1821210, and EAR-1925595; and by the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-1550901 and The University of California-Davis. </em> <br />
 </p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>15</p>
<p class="formulaDsp">
\begin{align*} -\nabla \cdot \left( \frac{1}{\sqrt{1+|\nabla u|^{2}}}\nabla u \right) &amp;= 0 \qquad \qquad &amp;&amp;\textrm{in} ~ \Omega \\ u&amp;=g \qquad\qquad &amp;&amp;\textrm{on} ~ \partial \Omega. \end{align*}
</p>
<p><a class="el" href="step_15.html">step-15</a> \(\delta u_k\) **&ndash; ""&ndash; "" \(\alpha_k\) </p>
<p class="formulaDsp">
\begin{align*} u_{k+1} = u_k + \alpha_k \, \delta u_k. \end{align*}
</p>
<p>15 \(\alpha_k=0.1\)  \(\alpha_k=1\) </p>
<p>deal.II<a href="https://computing.llnl.gov/projects/sundials">SUNDIALS</a><a href="https://computing.llnl.gov/projects/sundials/kinsol">KINSOL</a>SUNDIALSODEDAEdeal.IISUNDIALS <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a>  <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a> ODEDAESUNDIALSKINSOLdeal.II <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a> </p>
<p>SUNDIALS15</p>
<p class="formulaDsp">
\begin{align*} J_k \, \delta U_k = -F_k \end{align*}
</p>
<p> \(F_k\)  \(U_k\)  \(J_k\)  "" \(\delta U_k\)  \(\delta u_k\) 15 \(J_k,F_k\)  \(F_k\)  \(J_k\)  \(\tilde J_k\)  \(J_k\) </p>
<p class="formulaDsp">
\begin{align*} \tilde J_k \, \widetilde{\delta U}_k = -F_k \end{align*}
</p>
<p></p>
<p class="formulaDsp">
\begin{align*} U_{k+1} = U_k + \alpha_k \, \widetilde{\delta U}_k. \end{align*}
</p>
<p> \(\widetilde{\delta U}_k\)  \(\delta U_k\)  \(J_k\) </p>
<p> \(J_k\)  \(\tilde J_k\)  \(U_k\)  \(U^\ast\)  \(\tilde J_k\)  \(J^\ast = \nabla F(U^\ast)\)  \(J_k\rightarrow J^\ast\)  \(\tilde J_k = J_k\)  \(\tilde J_k = J_k\)  \(\tilde J_k\)  \(J_{k&#39;}\)  \(\tilde J_{k-1}\)  \(\tilde J_{k-2}\) </p>
<p> \(J_k\) SparseDirectUMFPACKLU*</p>
<p> \(J_{k-s}\)  \(s\) &ndash;&ndash; \(J_k\) ****KINSOL " "</p>
<p> \(\delta U_k\)  \(J_k\)  \(\tilde J_k\) </p>
<p class="formulaDsp">
\begin{align*} \tilde J_k \widetilde{\delta U}_k = -F_k \end{align*}
</p>
<p> \(U_k\)  \(U^\ast\)  \(U_{k+1}=U_k + \widetilde{\delta U}_k\)  "Eisenstat-Walker" <b>[eiwa96]</b>  \(k\) KINSOL&ndash;</p>
<p>deal.IISUNDIALSKINSOL</p>
<p><a class="anchor" id="HowdealIIinterfaceswithKINSOL"></a></p><h3>How deal.II interfaces with KINSOL </h3>
<p>KINSOL</p>
<p class="formulaDsp">
\begin{align*} F(U) = 0 \end{align*}
</p>
<p> \(U_k\)  \(F\) </p>
<ul>
<li></li>
<li> \(U\)  \(F(U)\)  " " \(U^\ast\)  \(F(U^\ast)=0\)  \(F(U)\) <a href="https://en.wikipedia.org/wiki/Residual_(numerical_analysis)">"residual"</a> "" ""15 *</li>
<li> \(J_k\) SparseDirectUMFPACK " "</li>
<li> \(\tilde J_k\)  \(\tilde J_k x = b\)  " "</li>
</ul>
<p> <a href="https://en.cppreference.com/w/cpp/utility/functional/function">std::function</a> KINSOL <a class="el" href="classSUNDIALS_1_1KINSOL.html#abdccb7a76e27cd9948048fdd03949380">SUNDIALS::KINSOL::reinit_vector</a>, <a class="el" href="classSUNDIALS_1_1KINSOL.html#aa791c6b63d41c8e7b12ec227e224c72a">SUNDIALS::KINSOL::residual</a>, <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">SUNDIALS::KINSOL::setup_jacobian</a>,  <a class="el" href="classSUNDIALS_1_1KINSOL.html#a388cbc77068ac53927b0b8b3e055a423">SUNDIALS::KINSOL::solve_jacobian_system</a> ()<a href="https://en.cppreference.com/w/cpp/language/lambda">lambda functions</a> ""KINSOL</p>
<p><a class="anchor" id="Detailsoftheimplementation"></a></p><h3>Details of the implementation </h3>
<p>15 \(U\)  \(J(U)\)  \(U\) <code>assemble_system()</code></p>
<p>Dirichlet " " <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a>, </p>
<p>*</p>
<ul>
<li> \(U_0\) </li>
<li> \(F(U_k)\)  \(J_k\) </li>
</ul>
<p>KINSOL \(\delta U\)  KINSOL</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>This program starts out like most others with well known include files. Compared to the <a class="el" href="step_15.html">step-15</a> program from which most of what we do here is copied, the only difference is the include of the header files from which we import the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class and the actual interface to KINSOL:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinsol_8h.html">deal.II/sundials/kinsol.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step77</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclasstemplate"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class template</h3>
<p>Similarly, the main class of this program is essentially a copy of the one in <a class="el" href="step_15.html">step-15</a>. The class does, however, split the computation of the Jacobian (system) matrix (and its factorization using a direct solver) and residual into separate functions for the reasons outlined in the introduction. For the same reason, the class also has a pointer to a factorization of the Jacobian matrix that is reset every time we update the Jacobian matrix.</p>
<p>(If you are wondering why the program uses a direct object for the Jacobian matrix but a pointer for the factorization: Every time KINSOL requests that the Jacobian be updated, we can simply write <code>jacobian_matrix=0;</code> to reset it to an empty matrix that we can then fill again. On the other hand, the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class does not have any way to throw away its content or to replace it with a new factorization, and so we use a pointer: We just throw away the whole object and create a new one whenever we have a new Jacobian matrix to factor.)</p>
<p>Finally, the class has a timer variable that we will use to assess how long the different parts of the program take so that we can assess whether KINSOL's tendency to not rebuild the matrix and its factorization makes sense. We will discuss this in the "Results" section below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MinimalSurfaceProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">  <span class="keywordtype">void</span> solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">             Vector&lt;double&gt; &amp;      solution,</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">double</span>          tolerance);</div><div class="line">  <span class="keywordtype">void</span> refine_mesh();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line">  <span class="keywordtype">void</span> set_boundary_values();</div><div class="line">  <span class="keywordtype">void</span> compute_and_factorize_jacobian(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point);</div><div class="line">  <span class="keywordtype">void</span> compute_residual(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                        Vector&lt;double&gt; &amp;      residual);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                      sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt;                 jacobian_matrix;</div><div class="line">  std::unique_ptr&lt;SparseDirectUMFPACK&gt; jacobian_matrix_factorization;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; current_solution;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Boundarycondition"></a> </p><h3>Boundary condition</h3>
<p>The classes implementing boundary values are a copy from <a class="el" href="step_15.html">step-15</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 * numbers::PI * (p[0] + p[1]));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclassimplementation"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class implementation</h3>
<p><a class="anchor" id="Constructorandsetupfunctions"></a> </p><h4>Constructor and set up functions</h4>
<p>The following few functions are also essentially copies of what <a class="el" href="step_15.html">step-15</a> already does, and so there is little to discuss.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">  : dof_handler(triangulation)</div><div class="line">  , fe(1)</div><div class="line">  , computing_timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;set up&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (initial_step)</div><div class="line">    {</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">      current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">      hanging_node_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                              hanging_node_constraints);</div><div class="line">      hanging_node_constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  jacobian_matrix.reinit(sparsity_pattern);</div><div class="line">  jacobian_matrix_factorization.reset();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="AssemblingandfactorizingtheJacobianmatrix"></a> </p><h4>Assembling and factorizing the Jacobian matrix</h4>
<p>The following function is then responsible for assembling and factorizing the Jacobian matrix. The first half of the function is in essence the <code>assemble_system()</code> function of <a class="el" href="step_15.html">step-15</a>, except that it does not deal with also forming a right hand side vector (i.e., the residual) since we do not always have to do these operations at the same time.</p>
<p>We put the whole assembly functionality into a code block enclosed by curly braces so that we can use a <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> variable to measure how much time is spent in this code block, excluding everything that happens in this function after the matching closing brace <code>}</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_and_factorize_jacobian(</div><div class="line">  <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point)</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">    jacobian_matrix = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                         evaluation_point_gradients);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">              1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                    evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                    (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                       * coeff                       <span class="comment">//   * a_n</span></div><div class="line">                       * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)) <span class="comment">//   * \nabla \phi_j)</span></div><div class="line">                      -                              <span class="comment">//  -</span></div><div class="line">                      (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                       * coeff * coeff * coeff       <span class="comment">//   * a_n^3</span></div><div class="line">                       *</div><div class="line">                       (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)       <span class="comment">//   * (\nabla \phi_j</span></div><div class="line">                        * evaluation_point_gradients[q]) <span class="comment">//      * \nabla u_n)</span></div><div class="line">                       * evaluation_point_gradients[q])) <span class="comment">//   * \nabla u_n)))</span></div><div class="line">                     * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));                <span class="comment">// * dx</span></div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        hanging_node_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                            local_dof_indices,</div><div class="line">                                                            jacobian_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                             boundary_values);</div><div class="line">    Vector&lt;double&gt; dummy_solution(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    Vector&lt;double&gt; dummy_rhs(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                       jacobian_matrix,</div><div class="line">                                       dummy_solution,</div><div class="line">                                       dummy_rhs);</div><div class="line">  }</div></div><!-- fragment --><p>The second half of the function then deals with factorizing the so-computed matrix. To do this, we first create a new <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> object and by assigning it to the member variable <code>jacobian_matrix_factorization</code>, we also destroy whatever object that pointer previously pointed to (if any). Then we tell the object to factorize the Jacobian.</p>
<p>As above, we enclose this block of code into curly braces and use a timer to assess how long this part of the program takes.</p>
<p>(Strictly speaking, we don't actually need the matrix any more after we are done here, and could throw the matrix object away. A code intended to be memory efficient would do this, and only create the matrix object in this function, rather than as a member variable of the surrounding class. We omit this step here because using the same coding style as in previous tutorial programs breeds familiarity with the common style and helps make these tutorial programs easier to read.)</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;factorizing the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Factorizing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    jacobian_matrix_factorization = std::make_unique&lt;SparseDirectUMFPACK&gt;();</div><div class="line">    jacobian_matrix_factorization-&gt;factorize(jacobian_matrix);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingtheresidualvector"></a> </p><h4>Computing the residual vector</h4>
<p>The second part of what <code>assemble_system()</code> used to do in <a class="el" href="step_15.html">step-15</a> is computing the residual vector, i.e., the right hand side vector of the Newton linear systems. We have broken this out of the previous function, but the following function will be easy to understand if you understood what <code>assemble_system()</code> in <a class="el" href="step_15.html">step-15</a> did. Importantly, however, we need to compute the residual not linearized around the current solution vector, but whatever we get from KINSOL. This is necessary for operations such as line search where we want to know what the residual \(F(U^k + \alpha_k \delta U^K)\) is for different values of \(\alpha_k\); KINSOL in those cases simply gives us the argument to the function \(F\) and we then compute the residual \(F(\cdot)\) at this point.</p>
<p>The function prints the norm of the so-computed residual at the end as a way for us to follow along the progress of the program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(</div><div class="line">  <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">  Vector&lt;double&gt; &amp;      residual)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the residual&quot;</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing residual vector...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                       evaluation_point_gradients);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">            1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                  evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) = (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                * coeff                    <span class="comment">// * a_n</span></div><div class="line">                                * evaluation_point_gradients[q] <span class="comment">// * u_n</span></div><div class="line">                                * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));            <span class="comment">// * dx</span></div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">    }</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(residual);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">       <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">    residual(i) = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">       <a class="code" href="namespaceDoFTools.html#aed6928cb7bdb5a85e8670d6bd5c90e24">DoFTools::extract_hanging_node_dofs</a>(dof_handler))</div><div class="line">    residual(i) = 0;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; norm=&quot;</span> &lt;&lt; residual.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="SolvinglinearsystemswiththeJacobianmatrix"></a> </p><h4>Solving linear systems with the Jacobian matrix</h4>
<p>Next up is the function that implements the solution of a linear system with the Jacobian matrix. Since we have already factored the matrix when we built the matrix, solving a linear system comes down to applying the inverse matrix to the given right hand side vector: This is what the <a class="el" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">SparseDirectUMFPACK::vmult()</a> function does that we use here. Following this, we have to make sure that we also address the values of hanging nodes in the solution vector, and this is done using <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a>.</p>
<p>The function takes an additional, but unused, argument <code>tolerance</code> that indicates how accurately we have to solve the linear system. The meaning of this argument is discussed in the introduction in the context of the "Eisenstat Walker trick", but since we are using a direct rather than an iterative solver, we are not using this opportunity to solve linear systems only inexactly.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                       Vector&lt;double&gt; &amp;      solution,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> <span class="comment">/*tolerance*/</span>)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;linear system solve&quot;</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Solving linear system&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  jacobian_matrix_factorization-&gt;vmult(solution, rhs);</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Refiningthemeshsettingboundaryvaluesandgeneratinggraphicaloutput"></a> </p><h4>Refining the mesh, setting boundary values, and generating graphical output</h4>
<p>The following three functions are again simply copies of the ones in <a class="el" href="step_15.html">step-15</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">    current_solution,</div><div class="line">    estimated_error_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.03);</div><div class="line"></div><div class="line">  triangulation.prepare_coarsening_and_refinement();</div><div class="line"></div><div class="line">  <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">  solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line"></div><div class="line">  triangulation.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  solution_transfer.interpolate(current_solution, tmp);</div><div class="line">  current_solution = std::move(tmp);</div><div class="line"></div><div class="line">  hanging_node_constraints.clear();</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                          hanging_node_constraints);</div><div class="line">  hanging_node_constraints.close();</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(current_solution);</div><div class="line"></div><div class="line">  set_boundary_values();</div><div class="line"></div><div class="line">  setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">{</div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           boundary_values);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">    current_solution(boundary_value.first) = boundary_value.second;</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(current_solution);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;graphical output&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Therunfunctionandtheoveralllogicoftheprogram"></a> </p><h4>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function and the overall logic of the program</h4>
<p>The only function that <em>really</em> is interesting in this program is the one that drives the overall algorithm of starting on a coarse mesh, doing some mesh refinement cycles, and on each mesh using KINSOL to find the solution of the nonlinear algebraic equation we obtain from discretization on this mesh. The <code>refine_mesh()</code> function above makes sure that the solution on one mesh is used as the starting guess on the next mesh. We also use a <a class="el" href="classTimerOutput.html">TimerOutput</a> object to measure how much time every operation on each mesh costs, and reset the timer at the beginning of each cycle.</p>
<p>As discussed in the introduction, it is not necessary to solve problems on coarse meshes particularly accurately since these will only solve as starting guesses for the next mesh. As a consequence, we will use a target tolerance of \(\tau=10^{-3} \frac{1}{10^k}\) for the \(k\)th mesh refinement cycle.</p>
<p>All of this is encoded in the first part of this function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">  triangulation.refine_global(2);</div><div class="line"></div><div class="line">  setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">true</span>);</div><div class="line">  set_boundary_values();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">       ++refinement_cycle)</div><div class="line">    {</div><div class="line">      computing_timer.<a class="code" href="classTimerOutput.html#a017cdef3c18d6050d401dab4f2f64d2e">reset</a>();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">        refine_mesh();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> target_tolerance = 1e-3 * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.1, refinement_cycle);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Target_tolerance: &quot;</span> &lt;&lt; target_tolerance &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl;</div></div><!-- fragment --><p>This is where the fun starts. At the top we create the KINSOL solver object and feed it with an object that encodes a number of additional specifics (of which we only change the nonlinear tolerance we want to reach; but you might want to look into what other members the <a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">SUNDIALS::KINSOL::AdditionalData</a> class has and play with them).</p>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt;::AdditionalData</div><div class="line">    additional_data;</div><div class="line">  additional_data.function_tolerance = target_tolerance;</div><div class="line"></div><div class="line">  <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt; nonlinear_solver(additional_data);</div></div><!-- fragment --><p>Then we have to describe the operations that were already mentioned in the introduction. In essence, we have to teach KINSOL how to (i) resize a vector to the correct size, (ii) compute the residual vector, (iii) compute the Jacobian matrix (during which we also compute its factorization), and (iv) solve a linear system with the Jacobian.</p>
<p>All four of these operations are represented by member variables of the <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a> class that are of type <code>std::function</code>, i.e., they are objects to which we can assign a pointer to a function or, as we do here, a "lambda function" that takes the appropriate arguments and returns the appropriate information. By convention, KINSOL wants that functions doing something nontrivial return an integer where zero indicates success. It turns out that we can do all of this in just 25 lines of code.</p>
<p>(If you're not familiar what "lambda functions" are, take a look at <a class="el" href="step_12.html">step-12</a> or at the <a href="https://en.wikipedia.org/wiki/Anonymous_function">wikipedia page</a> on the subject. The idea of lambda functions is that one wants to define a function with a certain set of arguments, but (i) not make it a named functions because, typically, the function is used in only one place and it seems unnecessary to give it a global name; and (ii) that the function has access to some of the variables that exist at the place where it is defined, including member variables. The syntax of lambda functions is awkward, but ultimately quite useful.)</p>
<p>At the very end of the code block we then tell KINSOL to go to work and solve our problem. The member functions called from the 'residual', 'setup_jacobian', and 'solve_jacobian_system' functions will then print output to screen that allows us to follow along with the progress of the program.</p>
<div class="fragment"><div class="line">  nonlinear_solver.reinit_vector = [&amp;](Vector&lt;double&gt; &amp;x) {</div><div class="line">    x.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  };</div><div class="line"></div><div class="line">  nonlinear_solver.residual =</div><div class="line">    [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">        Vector&lt;double&gt; &amp;      residual) {</div><div class="line">      compute_residual(evaluation_point, residual);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    };</div><div class="line"></div><div class="line">  nonlinear_solver.setup_jacobian =</div><div class="line">    [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;current_u,</div><div class="line">        <span class="keyword">const</span> Vector&lt;double&gt; &amp; <span class="comment">/*current_f*/</span>) {</div><div class="line">      compute_and_factorize_jacobian(current_u);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    };</div><div class="line"></div><div class="line">  nonlinear_solver.solve_with_jacobian = [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                             Vector&lt;double&gt; &amp;      dst,</div><div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance) {</div><div class="line">    this-&gt;solve(rhs, dst, tolerance);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  };</div><div class="line"></div><div class="line">  nonlinear_solver.solve(current_solution);</div><div class="line">}</div></div><!-- fragment --><p>The rest is then just house-keeping: Writing data to a file for visualizing, and showing a summary of the timing collected so that we can interpret how long each operation has taken, how often it was executed, etc:</p>
<div class="fragment"><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step77</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step77;</div><div class="line"></div><div class="line">      MinimalSurfaceProblem&lt;2&gt; laplace_problem_2d;</div><div class="line">      laplace_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-77/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p></p>
<div class="fragment"><div class="line">Mesh refinement step 0</div><div class="line">  Target_tolerance: 0.001</div><div class="line"></div><div class="line"></div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Computing residual vector... norm=0.127245</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Computing residual vector... norm=0.0625301</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0625301</div><div class="line">  Computing residual vector... norm=0.0498864</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0498864</div><div class="line">  Computing residual vector... norm=0.0407765</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0407765</div><div class="line">  Computing residual vector... norm=0.0341589</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0341589</div><div class="line">  Computing residual vector... norm=0.0292867</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0292867</div><div class="line">  Computing residual vector... norm=0.0256309</div><div class="line">  Computing residual vector... norm=0.0223448</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0223448</div><div class="line">  Computing residual vector... norm=0.0202797</div><div class="line">  Computing residual vector... norm=0.0183817</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0183817</div><div class="line">  Computing residual vector... norm=0.0170464</div><div class="line">  Computing residual vector... norm=0.0157967</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0157967</div><div class="line">  Computing residual vector... norm=0.0141572</div><div class="line">  Computing residual vector... norm=0.012657</div><div class="line"> Solving linear system</div><div class="line">  Computing residual vector... norm=0.012657</div><div class="line">  Computing residual vector... norm=0.0116863</div><div class="line">  Computing residual vector... norm=0.0107696</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0107696</div><div class="line">  Computing residual vector... norm=0.0100986</div><div class="line">  Computing residual vector... norm=0.00944829</div><div class="line">  Computing residual vector... norm=0.00822576</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00822576</div><div class="line">  Computing residual vector... norm=0.00781983</div><div class="line">  Computing residual vector... norm=0.00741619</div><div class="line">  Computing residual vector... norm=0.00661792</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00661792</div><div class="line">  Computing residual vector... norm=0.00630571</div><div class="line">  Computing residual vector... norm=0.00599457</div><div class="line">  Computing residual vector... norm=0.00537663</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00537663</div><div class="line">  Computing residual vector... norm=0.00512813</div><div class="line">  Computing residual vector... norm=0.00488033</div><div class="line">  Computing residual vector... norm=0.00438751</div><div class="line">  Computing residual vector... norm=0.00342052</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00342052</div><div class="line">  Computing residual vector... norm=0.00326581</div><div class="line">  Computing residual vector... norm=0.00311176</div><div class="line">  Computing residual vector... norm=0.00280617</div><div class="line">  Computing residual vector... norm=0.00220992</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00220992</div><div class="line">  Computing residual vector... norm=0.00209976</div><div class="line">  Computing residual vector... norm=0.00199943</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00199942</div><div class="line">  Computing residual vector... norm=0.00190953</div><div class="line">  Computing residual vector... norm=0.00182005</div><div class="line">  Computing residual vector... norm=0.00164259</div><div class="line">  Computing residual vector... norm=0.00129652</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |     0.192s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| assembling the Jacobian         |         2 |    0.0141s |       7.4% |</div><div class="line">| assembling the residual         |        61 |     0.168s |        88% |</div><div class="line">| factorizing the Jacobian        |         2 |    0.0016s |      0.83% |</div><div class="line">| graphical output                |         1 |   0.00385s |         2% |</div><div class="line">| linear system solve             |        19 |    0.0013s |      0.68% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">Mesh refinement step 1</div><div class="line">  Target_tolerance: 0.0001</div><div class="line"></div><div class="line"></div><div class="line">  Computing residual vector... norm=0.0883422</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0883422</div><div class="line">  Computing residual vector... norm=0.0607066</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0607066</div><div class="line">  Computing residual vector... norm=0.0437266</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0437266</div><div class="line">  Computing residual vector... norm=0.0327999</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0327999</div><div class="line">  Computing residual vector... norm=0.0255418</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0255417</div><div class="line">  Computing residual vector... norm=0.0206042</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0206042</div><div class="line">  Computing residual vector... norm=0.0171602</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0171602</div><div class="line">  Computing residual vector... norm=0.014689</div><div class="line">  Solving linear system</div><div class="line"></div><div class="line"></div><div class="line">[...]</div></div><!-- fragment --><p></p>
<div class="fragment"><div class="line">Mesh refinement step 0</div><div class="line">Mesh refinement step 0</div><div class="line">  Target_tolerance: 0.001</div><div class="line"></div><div class="line"></div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Computing residual vector... norm=0.127245</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  ...</div></div><!-- fragment --><p></p>
<ul>
<li>KINSOLSparseDirectUMFPACK</li>
<li>KINSOL \(J_k \, \delta U_k = -F_k\) </li>
<li>KINSOL \(\alpha_k\)  \(F(U_k + \alpha_k \delta U_k)\)  \(\alpha_k\) </li>
<li> \(U_{k+1}\) KINSOL</li>
</ul>
<p>VTU </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-77.solution.png"/>
</div>
   </td></tr>
</table>
<p></p>
<ul>
<li>15SUNDIALSKINSOL</li>
<li>KINSOL</li>
</ul>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>&ndash;</p>
<p>Eisenstat-Walker</p>
<p>KINSOL&ndash;</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Colorado State University, 2021.</span></div><div class="line"><span class="comment"> * Based on @ref step_15 &quot;step-15&quot; by Sven Wetterauer, University of Heidelberg, 2012.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinsol_8h.html">deal.II/sundials/kinsol.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step77</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    MinimalSurfaceProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">    <span class="keywordtype">void</span> solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">               Vector&lt;double&gt; &amp;      solution,</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">double</span>          tolerance);</div><div class="line">    <span class="keywordtype">void</span> refine_mesh();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line">    <span class="keywordtype">void</span> set_boundary_values();</div><div class="line">    <span class="keywordtype">void</span> compute_and_factorize_jacobian(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point);</div><div class="line">    <span class="keywordtype">void</span> compute_residual(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                          Vector&lt;double&gt; &amp;      residual);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                      sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt;                 jacobian_matrix;</div><div class="line">    std::unique_ptr&lt;SparseDirectUMFPACK&gt; jacobian_matrix_factorization;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; current_solution;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 * numbers::PI * (p[0] + p[1]));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">    : dof_handler(triangulation)</div><div class="line">    , fe(1)</div><div class="line">    , computing_timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;set up&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (initial_step)</div><div class="line">      {</div><div class="line">        dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">        current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">        hanging_node_constraints.clear();</div><div class="line">        <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                                hanging_node_constraints);</div><div class="line">        hanging_node_constraints.close();</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    jacobian_matrix.reinit(sparsity_pattern);</div><div class="line">    jacobian_matrix_factorization.reset();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_and_factorize_jacobian(</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point)</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">      jacobian_matrix = 0;</div><div class="line"></div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                              quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          cell_matrix = 0;</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                           evaluation_point_gradients);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">                1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                      evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                         * coeff                       <span class="comment">//   * a_n</span></div><div class="line">                         * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)) <span class="comment">//   * \nabla \phi_j)</span></div><div class="line">                        -                              <span class="comment">//  -</span></div><div class="line">                        (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                         * coeff * coeff * coeff       <span class="comment">//   * a_n^3</span></div><div class="line">                         *</div><div class="line">                         (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)       <span class="comment">//   * (\nabla \phi_j</span></div><div class="line">                          * evaluation_point_gradients[q]) <span class="comment">//      * \nabla u_n)</span></div><div class="line">                         * evaluation_point_gradients[q])) <span class="comment">//   * \nabla u_n)))</span></div><div class="line">                       * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));                <span class="comment">// * dx</span></div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          hanging_node_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                              local_dof_indices,</div><div class="line">                                                              jacobian_matrix);</div><div class="line">        }</div><div class="line"></div><div class="line">      std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               0,</div><div class="line">                                               <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                               boundary_values);</div><div class="line">      Vector&lt;double&gt; dummy_solution(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      Vector&lt;double&gt; dummy_rhs(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                         jacobian_matrix,</div><div class="line">                                         dummy_solution,</div><div class="line">                                         dummy_rhs);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;factorizing the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Factorizing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      jacobian_matrix_factorization = std::make_unique&lt;SparseDirectUMFPACK&gt;();</div><div class="line">      jacobian_matrix_factorization-&gt;factorize(jacobian_matrix);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">    Vector&lt;double&gt; &amp;      residual)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the residual&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing residual vector...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                         evaluation_point_gradients);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">              1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                    evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) = (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                  * coeff                    <span class="comment">// * a_n</span></div><div class="line">                                  * evaluation_point_gradients[q] <span class="comment">// * u_n</span></div><div class="line">                                  * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));            <span class="comment">// * dx</span></div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">      }</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(residual);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">         <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">      residual(i) = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">         <a class="code" href="namespaceDoFTools.html#aed6928cb7bdb5a85e8670d6bd5c90e24">DoFTools::extract_hanging_node_dofs</a>(dof_handler))</div><div class="line">      residual(i) = 0;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; norm=&quot;</span> &lt;&lt; residual.l2_norm() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                         Vector&lt;double&gt; &amp;      solution,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">double</span> <span class="comment">/*tolerance*/</span>)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;linear system solve&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Solving linear system&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    jacobian_matrix_factorization-&gt;vmult(solution, rhs);</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      current_solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line"></div><div class="line">    triangulation.prepare_coarsening_and_refinement();</div><div class="line"></div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">    solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line"></div><div class="line">    triangulation.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution_transfer.interpolate(current_solution, tmp);</div><div class="line">    current_solution = std::move(tmp);</div><div class="line"></div><div class="line">    hanging_node_constraints.clear();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                            hanging_node_constraints);</div><div class="line">    hanging_node_constraints.close();</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(current_solution);</div><div class="line"></div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">false</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">  {</div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             boundary_values);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">      current_solution(boundary_value.first) = boundary_value.second;</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(current_solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;graphical output&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">    triangulation.refine_global(2);</div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">true</span>);</div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a017cdef3c18d6050d401dab4f2f64d2e">reset</a>();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> target_tolerance = 1e-3 * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.1, refinement_cycle);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Target_tolerance: &quot;</span> &lt;&lt; target_tolerance &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        {</div><div class="line">          <span class="keyword">typename</span> <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt;::AdditionalData</div><div class="line">            additional_data;</div><div class="line">          additional_data.function_tolerance = target_tolerance;</div><div class="line"></div><div class="line">          <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt; nonlinear_solver(additional_data);</div><div class="line"></div><div class="line">          nonlinear_solver.reinit_vector = [&amp;](Vector&lt;double&gt; &amp;x) {</div><div class="line">            x.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">          };</div><div class="line"></div><div class="line">          nonlinear_solver.residual =</div><div class="line">            [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                Vector&lt;double&gt; &amp;      residual) {</div><div class="line">              compute_residual(evaluation_point, residual);</div><div class="line"></div><div class="line">              <span class="keywordflow">return</span> 0;</div><div class="line">            };</div><div class="line"></div><div class="line">          nonlinear_solver.setup_jacobian =</div><div class="line">            [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;current_u,</div><div class="line">                <span class="keyword">const</span> Vector&lt;double&gt; &amp; <span class="comment">/*current_f*/</span>) {</div><div class="line">              compute_and_factorize_jacobian(current_u);</div><div class="line"></div><div class="line">              <span class="keywordflow">return</span> 0;</div><div class="line">            };</div><div class="line"></div><div class="line">          nonlinear_solver.solve_with_jacobian = [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                                     Vector&lt;double&gt; &amp;      dst,</div><div class="line">                                                     <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance) {</div><div class="line">            this-&gt;solve(rhs, dst, tolerance);</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span> 0;</div><div class="line">          };</div><div class="line"></div><div class="line">          nonlinear_solver.solve(current_solution);</div><div class="line">        }</div><div class="line"></div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step77</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step77;</div><div class="line"></div><div class="line">      MinimalSurfaceProblem&lt;2&gt; laplace_problem_2d;</div><div class="line">      laplace_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
