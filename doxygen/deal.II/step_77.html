<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_77.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-77 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-77 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_15.html">step-15</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#HowdealIIinterfaceswithKINSOL"> How deal.II interfaces with KINSOL </a>
        <li><a href="#Detailsoftheimplementation"> Details of the implementation </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclasstemplate">The <code>MinimalSurfaceProblem</code> class template</a>
        <li><a href="#Boundarycondition">Boundary condition</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclassimplementation">The <code>MinimalSurfaceProblem</code> class implementation</a>
      <ul>
        <li><a href="#Constructorandsetupfunctions">Constructor and set up functions</a>
        <li><a href="#AssemblingandfactorizingtheJacobianmatrix">Assembling and factorizing the Jacobian matrix</a>
        <li><a href="#Computingtheresidualvector">Computing the residual vector</a>
        <li><a href="#SolvinglinearsystemswiththeJacobianmatrix">Solving linear systems with the Jacobian matrix</a>
        <li><a href="#Refiningthemeshsettingboundaryvaluesandgeneratinggraphicaloutput">Refining the mesh, setting boundary values, and generating graphical output</a>
        <li><a href="#Therunfunctionandtheoveralllogicoftheprogram">The run() function and the overall logic of the program</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em> This program was contributed by Wolfgang Bangerth, Colorado State University.</em></p>
<p><em>This material is based upon work partially supported by National Science Foundation grants OAC-1835673, DMS-1821210, and EAR-1925595; and by the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-1550901 and The University of California-Davis. </em> <br />
</p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The <a class="el" href="step_15.html">step-15</a> program solved the following, nonlinear equation describing the minimal surface problem: </p><p class="formulaDsp">
\begin{align*} -\nabla \cdot \left( \frac{1}{\sqrt{1+|\nabla u|^{2}}}\nabla u \right) &amp;= 0 \qquad \qquad &amp;&amp;\textrm{in} ~ \Omega \\ u&amp;=g \qquad\qquad &amp;&amp;\textrm{on} ~ \partial \Omega. \end{align*}
</p>
<p> <a class="el" href="step_15.html">step-15</a> uses a Newton method, and Newton's method works by repeatedly solving a <em>linearized</em> problem for an update \(\delta u_k\) &ndash; called the "search direction" &ndash;, computing a "step length" \(\alpha_k\), and then combining them to compute the new guess for the solution via </p><p class="formulaDsp">
\begin{align*} u_{k+1} = u_k + \alpha_k \, \delta u_k. \end{align*}
</p>
<p>In the course of the discussions in <a class="el" href="step_15.html">step-15</a>, we found that it is awkward to compute the step length, and so just settled for simple choice: Always choose \(\alpha_k=0.1\). This is of course not efficient: We know that we can only realize Newton's quadratic convergence rate if we eventually are able to choose \(\alpha_k=1\), though we may have to choose it smaller for the first few iterations where we are still too far away to use this long a step length.</p>
<p>Among the goals of this program is therefore to address this shortcoming. Since line search algorithms are not entirely trivial to implement, one does as one should do anyway: Import complicated functionality from an external library. To this end, we will make use of the interfaces deal.II has to one of the big nonlinear solver packages, namely the <a href="https://computing.llnl.gov/projects/sundials/kinsol">KINSOL</a> sub-package of the <a href="https://computing.llnl.gov/projects/sundials">SUNDIALS</a> suite. SUNDIALS is, at its heart, a package meant to solve complex ordinary differential equations (ODEs) and differential-algebraic equations (DAEs), and the deal.II interfaces allow for this via the classes in the <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> namespace: Notably the <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a> and <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a> classes. But, because that is an important step in the solution of ODEs and DAEs with implicit methods, SUNDIALS also has a solver for nonlinear problems called KINSOL, and deal.II has an interface to it in the form of the <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a> class. This is what we will use for the solution of our problem.</p>
<p>But SUNDIALS isn't just a convenient way for us to avoid writing a line search algorithm. In general, the solution of nonlinear problems is quite expensive, and one typically wants to save as much compute time as possible. One way one can achieve this is as follows: The algorithm in <a class="el" href="step_15.html">step-15</a> discretizes the problem and then in every iteration solves a linear system of the form </p><p class="formulaDsp">
\begin{align*} J_k \, \delta U_k = -F_k \end{align*}
</p>
<p> where \(F_k\) is the residual vector computed using the current vector of nodal values \(U_k\), \(J_k\) is its derivative (called the "Jacobian"), and \(\delta U_k\) is the update vector that corresponds to the function \(\delta u_k\) mentioned above. The construction of \(J_k,F_k\) has been thoroughly discussed in <a class="el" href="step_15.html">step-15</a>, as has the way to solve the linear system in each Newton iteration. So let us focus on another aspect of the nonlinear solution procedure: Computing \(F_k\) is expensive, and assembling the matrix \(J_k\) even more so. Do we actually need to do that in every iteration? It turns out that in many applications, this is not actually necessary: These methods often converge even if we replace \(J_k\) by an approximation \(\tilde J_k\) and solve </p><p class="formulaDsp">
\begin{align*} \tilde J_k \, \widetilde{\delta U}_k = -F_k \end{align*}
</p>
<p> instead, then update </p><p class="formulaDsp">
\begin{align*} U_{k+1} = U_k + \alpha_k \, \widetilde{\delta U}_k. \end{align*}
</p>
<p> This may require an iteration or two more because our update \(\widetilde{\delta U}_k\) is not quite as good as \(\delta U_k\), but it may still be a win because we don't have to assemble \(J_k\) quite as often.</p>
<p>What kind of approximation \(\tilde J_k\) would we like for \(J_k\)? Theory says that as \(U_k\) converges to the exact solution \(U^\ast\), we need to ensure that \(\tilde J_k\) needs to converge to \(J^\ast = \nabla F(U^\ast)\). In particular, since \(J_k\rightarrow J^\ast\), a valid choice is \(\tilde J_k = J_k\). But so is choosing \(\tilde J_k = J_k\) every, say, fifth iteration \(k=0,5,10,\ldots\) and for the other iterations, we choose \(\tilde J_k\) equal to the last computed \(J_{k&#39;}\). This is what we will do here: we will just re-use \(\tilde J_{k-1}\) from the previous iteration, which may again be what we had used in the iteration before that, \(\tilde J_{k-2}\).</p>
<p>This scheme becomes even more interesting if, for the solution of the linear system with \(J_k\), we don't just have to assemble a matrix, but also compute a good preconditioner. For example, if we were to use a sparse LU decomposition via the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class, or used a geometric or algebraic multigrid. In those cases, we would also not have to update the preconditioner, whose computation may have taken about as long or longer than the assembly of the matrix in the first place. Indeed, with this mindset, we should probably think about using the <em>best</em> preconditioner we can think of, even though their construction is typically quite expensive: We will hope to amortize the cost of computing this preconditioner by applying it to more than one just one linear solve.</p>
<p>The big question is, of course: By what criterion do we decide whether we can get away with the approximation \(\tilde J_k\) based on a previously computed Jacobian matrix \(J_{k-s}\) that goes back \(s\) steps, or whether we need to &ndash; at least in this iteration &ndash; actually re-compute the Jacobian \(J_k\) and the corresponding preconditioner? This is, like the issue with line search, one that requires a non-trivial amount of code that monitors the convergence of the overall algorithm. We <em>could</em> implement these sorts of things ourselves, but we probably <em>shouldn't</em>: KINSOL already does that for us. It will tell our code when to "update" the Jacobian matrix.</p>
<p>One last consideration if we were to use an iterative solver instead of the sparse direct one mentioned above: Not only is it possible to get away with replacing \(J_k\) by some approximation \(\tilde J_k\) when solving for the update \(\delta U_k\), but one can also ask whether it is necessary to solve the linear system </p><p class="formulaDsp">
\begin{align*} \tilde J_k \widetilde{\delta U}_k = -F_k \end{align*}
</p>
<p> to high accuracy. The thinking goes like this: While our current solution \(U_k\) is still far away from \(U^\ast\), why would we solve this linear system particularly accurately? The update \(U_{k+1}=U_k + \widetilde{\delta U}_k\) is likely still going to be far away from the exact solution, so why spend much time on solving the linear system to great accuracy? This is the kind of thinking that underlies algorithms such as the "Eisenstat-Walker trick" <b>[eiwa96]</b> in which one is given a tolerance to which the linear system above in iteration \(k\) has to be solved, with this tolerance dependent on the progress in the overall nonlinear solver. As before, one could try to implement this oneself, but KINSOL already provides this kind of information for us &ndash; though we will not use it in this program since we use a direct solver that requires no solver tolerance and just solves the linear system exactly up to round-off.</p>
<p>As a summary of all of these considerations, we could say the following: There is no need to reinvent the wheel. Just like deal.II provides a vast amount of finite-element functionality, SUNDIALS' KINSOL package provides a vast amount of nonlinear solver functionality, and we better use it.</p>
<p><a class="anchor" id="HowdealIIinterfaceswithKINSOL"></a></p><h3>How deal.II interfaces with KINSOL </h3>
<p>KINSOL, like many similar packages, works in a pretty abstract way. At its core, it sees a nonlinear problem of the form </p><p class="formulaDsp">
\begin{align*} F(U) = 0 \end{align*}
</p>
<p> and constructs a sequence of iterates \(U_k\) which, in general, are vectors of the same length as the vector returned by the function \(F\). To do this, there are a few things it needs from the user:</p><ul>
<li>A way to resize a given vector to the correct size.</li>
<li>A way to evaluate, for a given vector \(U\), the function \(F(U)\). This function is generally called the "residual" operation because the goal is of course to find a point \(U^\ast\) for which \(F(U^\ast)=0\); if \(F(U)\) returns a nonzero vector, then this is the <a href="https://en.wikipedia.org/wiki/Residual_(numerical_analysis)">"residual"</a> (i.e., the "rest", or whatever is "left over"). The function that will do this is in essence the same as the computation of the right hand side vector in <a class="el" href="step_15.html">step-15</a>, but with an important difference: There, the right hand side denoted the <em>negative</em> of the residual, so we have to switch a sign.</li>
<li>A way to compute the matrix \(J_k\) if that is necessary in the current iteration, along with possibly a preconditioner or other data structures (e.g., a sparse decomposition via <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> if that's what we choose to use to solve a linear system). This operation will generally be called the "setup" operation.</li>
<li>A way to solve a linear system \(\tilde J_k x = b\) with whatever matrix \(\tilde J_k\) was last computed. This operation will generally be called the "solve" operation.</li>
</ul>
<p>All of these operations need to be provided to KINSOL by <a href="https://en.cppreference.com/w/cpp/utility/functional/function">std::function</a> objects that take the appropriate set of arguments and that generally return an integer that indicates success (a zero return value) or failure (a nonzero return value). Specifically, the objects we will access are the <a class="el" href="classSUNDIALS_1_1KINSOL.html#abdccb7a76e27cd9948048fdd03949380">SUNDIALS::KINSOL::reinit_vector</a>, <a class="el" href="classSUNDIALS_1_1KINSOL.html#aa791c6b63d41c8e7b12ec227e224c72a">SUNDIALS::KINSOL::residual</a>, <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">SUNDIALS::KINSOL::setup_jacobian</a>, and <a class="el" href="classSUNDIALS_1_1KINSOL.html#a388cbc77068ac53927b0b8b3e055a423">SUNDIALS::KINSOL::solve_jacobian_system</a> member variables. (See the documentation of these variables for their details.) In our implementation, we will use <a href="https://en.cppreference.com/w/cpp/language/lambda">lambda functions</a> to implement these "callbacks" that in turn can call member functions; KINSOL will then call these callbacks whenever its internal algorithms think it is useful.</p>
<p><a class="anchor" id="Detailsoftheimplementation"></a></p><h3>Details of the implementation </h3>
<p>The majority of the code of this tutorial program is as in <a class="el" href="step_15.html">step-15</a>, and we will not comment on it in much detail. There is really just one aspect one has to pay some attention to, namely how to compute \(F(U)\) given a vector \(U\) on the one hand, and \(J(U)\) given a vector \(U\) separately. At first, this seems trivial: We just take the <code>assemble_system()</code> function and in the one case throw out all code that deals with the matrix and in the other case with the right hand side vector. There: Problem solved.</p>
<p>But it isn't quite as simple. That's because the two are not independent if we have nonzero Dirichlet boundary values, as we do here. The linear system we want to solve contains both interior and boundary degrees of freedom, and when eliminating those degrees of freedom from those that are truly "free", using for example <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a>, we need to know the matrix when assembling the right hand side vector.</p>
<p>Of course, this completely contravenes the original intent: To <em>not</em> assemble the matrix if we can get away without it. We solve this problem as follows:</p><ul>
<li>We set the starting guess for the solution vector, \(U_0\), to one where boundary degrees of freedom already have their correct values.</li>
<li>This implies that all updates can have zero updates for these degrees of freedom, and we can build both residual vectors \(F(U_k)\) and Jacobian matrices \(J_k\) that corresponds to linear systems whose solutions are zero in these vector components. For this special case, the assembly of matrix and right hand side vectors is independent, and can be broken into separate functions.</li>
</ul>
<p>There is an assumption here that whenever KINSOL asks for a linear solver with the (approximation of the) Jacobian, that this will be for for an update \(\delta U\) (which has zero boundary values), a multiple of which will be added to the solution (which already has the right boundary values). This may not be true and if so, we might have to rethink our approach. That said, it turns out that in practice this is exactly what KINSOL does when using a Newton method, and so our approach is successful.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>This program starts out like most others with well known include files. Compared to the <a class="el" href="step_15.html">step-15</a> program from which most of what we do here is copied, the only difference is the include of the header files from which we import the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class and the actual interface to KINSOL:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinsol_8h.html">deal.II/sundials/kinsol.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step77</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclasstemplate"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class template</h3>
<p>Similarly, the main class of this program is essentially a copy of the one in <a class="el" href="step_15.html">step-15</a>. The class does, however, split the computation of the Jacobian (system) matrix (and its factorization using a direct solver) and residual into separate functions for the reasons outlined in the introduction. For the same reason, the class also has a pointer to a factorization of the Jacobian matrix that is reset every time we update the Jacobian matrix.</p>
<p>(If you are wondering why the program uses a direct object for the Jacobian matrix but a pointer for the factorization: Every time KINSOL requests that the Jacobian be updated, we can simply write <code>jacobian_matrix=0;</code> to reset it to an empty matrix that we can then fill again. On the other hand, the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class does not have any way to throw away its content or to replace it with a new factorization, and so we use a pointer: We just throw away the whole object and create a new one whenever we have a new Jacobian matrix to factor.)</p>
<p>Finally, the class has a timer variable that we will use to assess how long the different parts of the program take so that we can assess whether KINSOL's tendency to not rebuild the matrix and its factorization makes sense. We will discuss this in the "Results" section below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MinimalSurfaceProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">  <span class="keywordtype">void</span> solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">             Vector&lt;double&gt; &amp;      solution,</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">double</span>          tolerance);</div><div class="line">  <span class="keywordtype">void</span> refine_mesh();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line">  <span class="keywordtype">void</span> set_boundary_values();</div><div class="line">  <span class="keywordtype">void</span> compute_and_factorize_jacobian(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point);</div><div class="line">  <span class="keywordtype">void</span> compute_residual(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                        Vector&lt;double&gt; &amp;      residual);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                      sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt;                 jacobian_matrix;</div><div class="line">  std::unique_ptr&lt;SparseDirectUMFPACK&gt; jacobian_matrix_factorization;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; current_solution;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Boundarycondition"></a> </p><h3>Boundary condition</h3>
<p>The classes implementing boundary values are a copy from <a class="el" href="step_15.html">step-15</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 * numbers::PI * (p[0] + p[1]));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclassimplementation"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class implementation</h3>
<p><a class="anchor" id="Constructorandsetupfunctions"></a> </p><h4>Constructor and set up functions</h4>
<p>The following few functions are also essentially copies of what <a class="el" href="step_15.html">step-15</a> already does, and so there is little to discuss.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">  : dof_handler(triangulation)</div><div class="line">  , fe(1)</div><div class="line">  , computing_timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;set up&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (initial_step)</div><div class="line">    {</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">      current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">      hanging_node_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                              hanging_node_constraints);</div><div class="line">      hanging_node_constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  jacobian_matrix.reinit(sparsity_pattern);</div><div class="line">  jacobian_matrix_factorization.reset();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="AssemblingandfactorizingtheJacobianmatrix"></a> </p><h4>Assembling and factorizing the Jacobian matrix</h4>
<p>The following function is then responsible for assembling and factorizing the Jacobian matrix. The first half of the function is in essence the <code>assemble_system()</code> function of <a class="el" href="step_15.html">step-15</a>, except that it does not deal with also forming a right hand side vector (i.e., the residual) since we do not always have to do these operations at the same time.</p>
<p>We put the whole assembly functionality into a code block enclosed by curly braces so that we can use a <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> variable to measure how much time is spent in this code block, excluding everything that happens in this function after the matching closing brace <code>}</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_and_factorize_jacobian(</div><div class="line">  <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point)</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">    jacobian_matrix = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                         evaluation_point_gradients);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">              1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                    evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                    (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                         coeff                       <span class="comment">//   * a_n</span></div><div class="line">                         fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)) <span class="comment">//   * \nabla \phi_j)</span></div><div class="line">                      -                              <span class="comment">//  -</span></div><div class="line">                      (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                         coeff * coeff * coeff       <span class="comment">//   * a_n^3</span></div><div class="line">                        </div><div class="line">                       (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)       <span class="comment">//   * (\nabla \phi_j</span></div><div class="line">                          evaluation_point_gradients[q]) <span class="comment">//      * \nabla u_n)</span></div><div class="line">                         evaluation_point_gradients[q])) <span class="comment">//   * \nabla u_n)))</span></div><div class="line">                       fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));                <span class="comment">// * dx</span></div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        hanging_node_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                            local_dof_indices,</div><div class="line">                                                            jacobian_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                             boundary_values);</div><div class="line">    Vector&lt;double&gt; dummy_solution(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    Vector&lt;double&gt; dummy_rhs(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                       jacobian_matrix,</div><div class="line">                                       dummy_solution,</div><div class="line">                                       dummy_rhs);</div><div class="line">  }</div></div><!-- fragment --><p>The second half of the function then deals with factorizing the so-computed matrix. To do this, we first create a new <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> object and by assigning it to the member variable <code>jacobian_matrix_factorization</code>, we also destroy whatever object that pointer previously pointed to (if any). Then we tell the object to factorize the Jacobian.</p>
<p>As above, we enclose this block of code into curly braces and use a timer to assess how long this part of the program takes.</p>
<p>(Strictly speaking, we don't actually need the matrix any more after we are done here, and could throw the matrix object away. A code intended to be memory efficient would do this, and only create the matrix object in this function, rather than as a member variable of the surrounding class. We omit this step here because using the same coding style as in previous tutorial programs breeds familiarity with the common style and helps make these tutorial programs easier to read.)</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;factorizing the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Factorizing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    jacobian_matrix_factorization = std::make_unique&lt;SparseDirectUMFPACK&gt;();</div><div class="line">    jacobian_matrix_factorization-&gt;factorize(jacobian_matrix);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingtheresidualvector"></a> </p><h4>Computing the residual vector</h4>
<p>The second part of what <code>assemble_system()</code> used to do in <a class="el" href="step_15.html">step-15</a> is computing the residual vector, i.e., the right hand side vector of the Newton linear systems. We have broken this out of the previous function, but the following function will be easy to understand if you understood what <code>assemble_system()</code> in <a class="el" href="step_15.html">step-15</a> did. Importantly, however, we need to compute the residual not linearized around the current solution vector, but whatever we get from KINSOL. This is necessary for operations such as line search where we want to know what the residual \(F(U^k + \alpha_k \delta U^K)\) is for different values of \(\alpha_k\); KINSOL in those cases simply gives us the argument to the function \(F\) and we then compute the residual \(F(\cdot)\) at this point.</p>
<p>The function prints the norm of the so-computed residual at the end as a way for us to follow along the progress of the program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(</div><div class="line">  <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">  Vector&lt;double&gt; &amp;      residual)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the residual&quot;</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing residual vector...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                       evaluation_point_gradients);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">            1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                  evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) = (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                  coeff                    <span class="comment">// * a_n</span></div><div class="line">                                  evaluation_point_gradients[q] <span class="comment">// * u_n</span></div><div class="line">                                  fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));            <span class="comment">// * dx</span></div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">    }</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(residual);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">       <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">    residual(i) = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">       <a class="code" href="namespaceDoFTools.html#aed6928cb7bdb5a85e8670d6bd5c90e24">DoFTools::extract_hanging_node_dofs</a>(dof_handler))</div><div class="line">    residual(i) = 0;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; norm=&quot;</span> &lt;&lt; residual.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="SolvinglinearsystemswiththeJacobianmatrix"></a> </p><h4>Solving linear systems with the Jacobian matrix</h4>
<p>Next up is the function that implements the solution of a linear system with the Jacobian matrix. Since we have already factored the matrix when we built the matrix, solving a linear system comes down to applying the inverse matrix to the given right hand side vector: This is what the <a class="el" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">SparseDirectUMFPACK::vmult()</a> function does that we use here. Following this, we have to make sure that we also address the values of hanging nodes in the solution vector, and this is done using <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a>.</p>
<p>The function takes an additional, but unused, argument <code>tolerance</code> that indicates how accurately we have to solve the linear system. The meaning of this argument is discussed in the introduction in the context of the "Eisenstat Walker trick", but since we are using a direct rather than an iterative solver, we are not using this opportunity to solve linear systems only inexactly.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                       Vector&lt;double&gt; &amp;      solution,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> <span class="comment">/*tolerance*/</span>)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;linear system solve&quot;</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Solving linear system&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  jacobian_matrix_factorization-&gt;vmult(solution, rhs);</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Refiningthemeshsettingboundaryvaluesandgeneratinggraphicaloutput"></a> </p><h4>Refining the mesh, setting boundary values, and generating graphical output</h4>
<p>The following three functions are again simply copies of the ones in <a class="el" href="step_15.html">step-15</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">    current_solution,</div><div class="line">    estimated_error_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.03);</div><div class="line"></div><div class="line">  triangulation.prepare_coarsening_and_refinement();</div><div class="line"></div><div class="line">  <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">  solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line"></div><div class="line">  triangulation.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  solution_transfer.interpolate(current_solution, tmp);</div><div class="line">  current_solution = std::move(tmp);</div><div class="line"></div><div class="line">  hanging_node_constraints.clear();</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                          hanging_node_constraints);</div><div class="line">  hanging_node_constraints.close();</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(current_solution);</div><div class="line"></div><div class="line">  set_boundary_values();</div><div class="line"></div><div class="line">  setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">{</div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           boundary_values);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">    current_solution(boundary_value.first) = boundary_value.second;</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(current_solution);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;graphical output&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Therunfunctionandtheoveralllogicoftheprogram"></a> </p><h4>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function and the overall logic of the program</h4>
<p>The only function that <em>really</em> is interesting in this program is the one that drives the overall algorithm of starting on a coarse mesh, doing some mesh refinement cycles, and on each mesh using KINSOL to find the solution of the nonlinear algebraic equation we obtain from discretization on this mesh. The <code>refine_mesh()</code> function above makes sure that the solution on one mesh is used as the starting guess on the next mesh. We also use a <a class="el" href="classTimerOutput.html">TimerOutput</a> object to measure how much time every operation on each mesh costs, and reset the timer at the beginning of each cycle.</p>
<p>As discussed in the introduction, it is not necessary to solve problems on coarse meshes particularly accurately since these will only solve as starting guesses for the next mesh. As a consequence, we will use a target tolerance of \(\tau=10^{-3} \frac{1}{10^k}\) for the \(k\)th mesh refinement cycle.</p>
<p>All of this is encoded in the first part of this function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">  triangulation.refine_global(2);</div><div class="line"></div><div class="line">  setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">true</span>);</div><div class="line">  set_boundary_values();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">       ++refinement_cycle)</div><div class="line">    {</div><div class="line">      computing_timer.<a class="code" href="classTimerOutput.html#a017cdef3c18d6050d401dab4f2f64d2e">reset</a>();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">        refine_mesh();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> target_tolerance = 1e-3 * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.1, refinement_cycle);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Target_tolerance: &quot;</span> &lt;&lt; target_tolerance &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl;</div></div><!-- fragment --><p>This is where the fun starts. At the top we create the KINSOL solver object and feed it with an object that encodes a number of additional specifics (of which we only change the nonlinear tolerance we want to reach; but you might want to look into what other members the <a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">SUNDIALS::KINSOL::AdditionalData</a> class has and play with them).</p>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt;::AdditionalData</div><div class="line">    additional_data;</div><div class="line">  additional_data.function_tolerance = target_tolerance;</div><div class="line"></div><div class="line">  <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt; nonlinear_solver(additional_data);</div></div><!-- fragment --><p>Then we have to describe the operations that were already mentioned in the introduction. In essence, we have to teach KINSOL how to (i) resize a vector to the correct size, (ii) compute the residual vector, (iii) compute the Jacobian matrix (during which we also compute its factorization), and (iv) solve a linear system with the Jacobian.</p>
<p>All four of these operations are represented by member variables of the <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a> class that are of type <code>std::function</code>, i.e., they are objects to which we can assign a pointer to a function or, as we do here, a "lambda function" that takes the appropriate arguments and returns the appropriate information. By convention, KINSOL wants that functions doing something nontrivial return an integer where zero indicates success. It turns out that we can do all of this in just 25 lines of code.</p>
<p>(If you're not familiar what "lambda functions" are, take a look at <a class="el" href="step_12.html">step-12</a> or at the <a href="https://en.wikipedia.org/wiki/Anonymous_function">wikipedia page</a> on the subject. The idea of lambda functions is that one wants to define a function with a certain set of arguments, but (i) not make it a named functions because, typically, the function is used in only one place and it seems unnecessary to give it a global name; and (ii) that the function has access to some of the variables that exist at the place where it is defined, including member variables. The syntax of lambda functions is awkward, but ultimately quite useful.)</p>
<p>At the very end of the code block we then tell KINSOL to go to work and solve our problem. The member functions called from the 'residual', 'setup_jacobian', and 'solve_jacobian_system' functions will then print output to screen that allows us to follow along with the progress of the program.</p>
<div class="fragment"><div class="line">  nonlinear_solver.reinit_vector = [&amp;](Vector&lt;double&gt; &amp;x) {</div><div class="line">    x.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  };</div><div class="line"></div><div class="line">  nonlinear_solver.residual =</div><div class="line">    [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">        Vector&lt;double&gt; &amp;      residual) {</div><div class="line">      compute_residual(evaluation_point, residual);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    };</div><div class="line"></div><div class="line">  nonlinear_solver.setup_jacobian =</div><div class="line">    [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;current_u,</div><div class="line">        <span class="keyword">const</span> Vector&lt;double&gt; &amp; <span class="comment">/*current_f*/</span>) {</div><div class="line">      compute_and_factorize_jacobian(current_u);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    };</div><div class="line"></div><div class="line">  nonlinear_solver.solve_with_jacobian = [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                             Vector&lt;double&gt; &amp;      dst,</div><div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance) {</div><div class="line">    this-&gt;solve(rhs, dst, tolerance);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  };</div><div class="line"></div><div class="line">  nonlinear_solver.solve(current_solution);</div><div class="line">}</div></div><!-- fragment --><p>The rest is then just house-keeping: Writing data to a file for visualizing, and showing a summary of the timing collected so that we can interpret how long each operation has taken, how often it was executed, etc:</p>
<div class="fragment"><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step77</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step77;</div><div class="line"></div><div class="line">      MinimalSurfaceProblem&lt;2&gt; laplace_problem_2d;</div><div class="line">      laplace_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>When running the program, you get output that looks like this: </p><div class="fragment"><div class="line">Mesh refinement step 0</div><div class="line">  Target_tolerance: 0.001</div><div class="line"></div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Computing residual vector... norm=0.127245</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Computing residual vector... norm=0.0625301</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0625301</div><div class="line">  Computing residual vector... norm=0.0498864</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0498864</div><div class="line">  Computing residual vector... norm=0.0407765</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0407765</div><div class="line">  Computing residual vector... norm=0.0341589</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0341589</div><div class="line">  Computing residual vector... norm=0.0292867</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0292867</div><div class="line">  Computing residual vector... norm=0.0256309</div><div class="line">  Computing residual vector... norm=0.0223448</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0223448</div><div class="line">  Computing residual vector... norm=0.0202797</div><div class="line">  Computing residual vector... norm=0.0183817</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0183817</div><div class="line">  Computing residual vector... norm=0.0170464</div><div class="line">  Computing residual vector... norm=0.0157967</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0157967</div><div class="line">  Computing residual vector... norm=0.0141572</div><div class="line">  Computing residual vector... norm=0.012657</div><div class="line"> Solving linear system</div><div class="line">  Computing residual vector... norm=0.012657</div><div class="line">  Computing residual vector... norm=0.0116863</div><div class="line">  Computing residual vector... norm=0.0107696</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0107696</div><div class="line">  Computing residual vector... norm=0.0100986</div><div class="line">  Computing residual vector... norm=0.00944829</div><div class="line">  Computing residual vector... norm=0.00822576</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00822576</div><div class="line">  Computing residual vector... norm=0.00781983</div><div class="line">  Computing residual vector... norm=0.00741619</div><div class="line">  Computing residual vector... norm=0.00661792</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00661792</div><div class="line">  Computing residual vector... norm=0.00630571</div><div class="line">  Computing residual vector... norm=0.00599457</div><div class="line">  Computing residual vector... norm=0.00537663</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00537663</div><div class="line">  Computing residual vector... norm=0.00512813</div><div class="line">  Computing residual vector... norm=0.00488033</div><div class="line">  Computing residual vector... norm=0.00438751</div><div class="line">  Computing residual vector... norm=0.00342052</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00342052</div><div class="line">  Computing residual vector... norm=0.00326581</div><div class="line">  Computing residual vector... norm=0.00311176</div><div class="line">  Computing residual vector... norm=0.00280617</div><div class="line">  Computing residual vector... norm=0.00220992</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00220992</div><div class="line">  Computing residual vector... norm=0.00209976</div><div class="line">  Computing residual vector... norm=0.00199943</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00199942</div><div class="line">  Computing residual vector... norm=0.00190953</div><div class="line">  Computing residual vector... norm=0.00182005</div><div class="line">  Computing residual vector... norm=0.00164259</div><div class="line">  Computing residual vector... norm=0.00129652</div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |     0.192s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| assembling the Jacobian         |         2 |    0.0141s |       7.4% |</div><div class="line">| assembling the residual         |        61 |     0.168s |        88% |</div><div class="line">| factorizing the Jacobian        |         2 |    0.0016s |      0.83% |</div><div class="line">| graphical output                |         1 |   0.00385s |         2% |</div><div class="line">| linear system solve             |        19 |    0.0013s |      0.68% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line"></div><div class="line">Mesh refinement step 1</div><div class="line">  Target_tolerance: 0.0001</div><div class="line"></div><div class="line">  Computing residual vector... norm=0.0883422</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0883422</div><div class="line">  Computing residual vector... norm=0.0607066</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0607066</div><div class="line">  Computing residual vector... norm=0.0437266</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0437266</div><div class="line">  Computing residual vector... norm=0.0327999</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0327999</div><div class="line">  Computing residual vector... norm=0.0255418</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0255417</div><div class="line">  Computing residual vector... norm=0.0206042</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0206042</div><div class="line">  Computing residual vector... norm=0.0171602</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0171602</div><div class="line">  Computing residual vector... norm=0.014689</div><div class="line">  Solving linear system</div><div class="line"></div><div class="line">[...]</div></div><!-- fragment --><p>The way this should be interpreted is most easily explained by looking at the first few lines of the output on the first mesh: </p><div class="fragment"><div class="line">Mesh refinement step 0</div><div class="line">Mesh refinement step 0</div><div class="line">  Target_tolerance: 0.001</div><div class="line"></div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Computing residual vector... norm=0.127245</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  ...</div></div><!-- fragment --><p> What is happening is this:</p><ul>
<li>In the first residual computation, KINSOL computes the residual to see whether the desired tolerance has been reached. The answer is no, so it requests the user program to compute the Jacobian matrix (and the function then also factorizes the matrix via <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>).</li>
<li>KINSOL then instructs us to solve a linear system of the form \(J_k \, \delta U_k = -F_k\) with this matrix and the previously computed residual vector.</li>
<li>It is then time to determine how far we want to go in this direction, i.e., do line search. To this end, KINSOL requires us to compute the residual vector \(F(U_k + \alpha_k \delta U_k)\) for different step lengths \(\alpha_k\). For the first step above, it finds an acceptable \(\alpha_k\) after two tries, the second time around it takes three tries.</li>
<li>Having found a suitable updated solution \(U_{k+1}\), the process is repeated except now KINSOL is happy with the current Jacobian matrix and does not instruct us to re-build the matrix and its factorization, and instead asks us to solve a linear system with that same matrix.</li>
</ul>
<p>The program also writes the solution to a VTU file at the end of each mesh refinement cycle, and it looks as follows: </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-77.solution.png"/>
</div>
   </td></tr>
</table>
<p>The key takeaway messages of this program are the following:</p>
<ul>
<li>The solution is the same as the one we computed in <a class="el" href="step_15.html">step-15</a>, i.e., the interfaces to SUNDIALS' KINSOL package really did what they were supposed to do. This should not come as a surprise, but the important point is that we don't have to spend the time implementing the complex algorithms that underlie advanced nonlinear solvers ourselves.</li>
<li>KINSOL is able to avoid all sorts of operations such as rebuilding the Jacobian matrix when that is not actually necessary. Comparing the number of linear solves in the output above with the number of times we rebuild the Jacobian and compute its factorization should make it clear that this leads to very substantial savings in terms of compute times, without us having to implement the intricacies of algorithms that determine when we need to rebuild this information.</li>
</ul>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>For all but the small problems we consider here, a sparse direct solver requires too much time and memory &ndash; we need an iterative solver like we use in many other programs. The trade-off between constructing an expensive preconditioner (say, a geometric or algebraic multigrid method) is different in the current case, however: Since we can re-use the same matrix for numerous linear solves, we can do the same for the preconditioner and putting more work into building a good preconditioner can more easily be justified than if we used it only for a single linear solve as one does for many other situations.</p>
<p>But iterative solvers also afford other opportunities. For example (and as discussed briefly in the introduction), we may not need to solve to very high accuracy (small tolerances) in early nonlinear iterations as long as we are still far away from the actual solution. This was the basis of the Eisenstat-Walker trick mentioned there.</p>
<p>KINSOL provides the function that does the linear solution with a target tolerance that needs to be reached. We ignore it in the program above because the direct solver we use does not need a tolerance and instead solves the linear system exactly (up to round-off, of course), but iterative solvers could make use of this kind of information &ndash; and, in fact, should.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Colorado State University, 2021.</span></div><div class="line"><span class="comment"> * Based on @ref step_15 &quot;step-15&quot; by Sven Wetterauer, University of Heidelberg, 2012.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinsol_8h.html">deal.II/sundials/kinsol.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step77</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    MinimalSurfaceProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">    <span class="keywordtype">void</span> solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">               Vector&lt;double&gt; &amp;      solution,</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">double</span>          tolerance);</div><div class="line">    <span class="keywordtype">void</span> refine_mesh();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line">    <span class="keywordtype">void</span> set_boundary_values();</div><div class="line">    <span class="keywordtype">void</span> compute_and_factorize_jacobian(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point);</div><div class="line">    <span class="keywordtype">void</span> compute_residual(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                          Vector&lt;double&gt; &amp;      residual);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                      sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt;                 jacobian_matrix;</div><div class="line">    std::unique_ptr&lt;SparseDirectUMFPACK&gt; jacobian_matrix_factorization;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; current_solution;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 * numbers::PI * (p[0] + p[1]));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">    : dof_handler(triangulation)</div><div class="line">    , fe(1)</div><div class="line">    , computing_timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;set up&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (initial_step)</div><div class="line">      {</div><div class="line">        dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">        current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">        hanging_node_constraints.clear();</div><div class="line">        <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                                hanging_node_constraints);</div><div class="line">        hanging_node_constraints.close();</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    jacobian_matrix.reinit(sparsity_pattern);</div><div class="line">    jacobian_matrix_factorization.reset();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_and_factorize_jacobian(</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point)</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">      jacobian_matrix = 0;</div><div class="line"></div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                              quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          cell_matrix = 0;</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                           evaluation_point_gradients);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">                1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                      evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                         * coeff                       <span class="comment">//   * a_n</span></div><div class="line">                         * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)) <span class="comment">//   * \nabla \phi_j)</span></div><div class="line">                        -                              <span class="comment">//  -</span></div><div class="line">                        (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                         * coeff * coeff * coeff       <span class="comment">//   * a_n^3</span></div><div class="line">                         *</div><div class="line">                         (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)       <span class="comment">//   * (\nabla \phi_j</span></div><div class="line">                          * evaluation_point_gradients[q]) <span class="comment">//      * \nabla u_n)</span></div><div class="line">                         * evaluation_point_gradients[q])) <span class="comment">//   * \nabla u_n)))</span></div><div class="line">                       * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));                <span class="comment">// * dx</span></div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          hanging_node_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                              local_dof_indices,</div><div class="line">                                                              jacobian_matrix);</div><div class="line">        }</div><div class="line"></div><div class="line">      std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               0,</div><div class="line">                                               <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                               boundary_values);</div><div class="line">      Vector&lt;double&gt; dummy_solution(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      Vector&lt;double&gt; dummy_rhs(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                         jacobian_matrix,</div><div class="line">                                         dummy_solution,</div><div class="line">                                         dummy_rhs);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;factorizing the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Factorizing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      jacobian_matrix_factorization = std::make_unique&lt;SparseDirectUMFPACK&gt;();</div><div class="line">      jacobian_matrix_factorization-&gt;factorize(jacobian_matrix);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">    Vector&lt;double&gt; &amp;      residual)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the residual&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing residual vector...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                         evaluation_point_gradients);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">              1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                    evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) = (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                  * coeff                    <span class="comment">// * a_n</span></div><div class="line">                                  * evaluation_point_gradients[q] <span class="comment">// * u_n</span></div><div class="line">                                  * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));            <span class="comment">// * dx</span></div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">      }</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(residual);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">         <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">      residual(i) = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">         <a class="code" href="namespaceDoFTools.html#aed6928cb7bdb5a85e8670d6bd5c90e24">DoFTools::extract_hanging_node_dofs</a>(dof_handler))</div><div class="line">      residual(i) = 0;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; norm=&quot;</span> &lt;&lt; residual.l2_norm() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                         Vector&lt;double&gt; &amp;      solution,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">double</span> <span class="comment">/*tolerance*/</span>)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;linear system solve&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Solving linear system&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    jacobian_matrix_factorization-&gt;vmult(solution, rhs);</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      current_solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line"></div><div class="line">    triangulation.prepare_coarsening_and_refinement();</div><div class="line"></div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">    solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line"></div><div class="line">    triangulation.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution_transfer.interpolate(current_solution, tmp);</div><div class="line">    current_solution = std::move(tmp);</div><div class="line"></div><div class="line">    hanging_node_constraints.clear();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                            hanging_node_constraints);</div><div class="line">    hanging_node_constraints.close();</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(current_solution);</div><div class="line"></div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">false</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">  {</div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             boundary_values);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">      current_solution(boundary_value.first) = boundary_value.second;</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(current_solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;graphical output&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">    triangulation.refine_global(2);</div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">true</span>);</div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a017cdef3c18d6050d401dab4f2f64d2e">reset</a>();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> target_tolerance = 1e-3 * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.1, refinement_cycle);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Target_tolerance: &quot;</span> &lt;&lt; target_tolerance &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        {</div><div class="line">          <span class="keyword">typename</span> <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt;::AdditionalData</div><div class="line">            additional_data;</div><div class="line">          additional_data.function_tolerance = target_tolerance;</div><div class="line"></div><div class="line">          <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt; nonlinear_solver(additional_data);</div><div class="line"></div><div class="line">          nonlinear_solver.reinit_vector = [&amp;](Vector&lt;double&gt; &amp;x) {</div><div class="line">            x.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">          };</div><div class="line"></div><div class="line">          nonlinear_solver.residual =</div><div class="line">            [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                Vector&lt;double&gt; &amp;      residual) {</div><div class="line">              compute_residual(evaluation_point, residual);</div><div class="line"></div><div class="line">              <span class="keywordflow">return</span> 0;</div><div class="line">            };</div><div class="line"></div><div class="line">          nonlinear_solver.setup_jacobian =</div><div class="line">            [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;current_u,</div><div class="line">                <span class="keyword">const</span> Vector&lt;double&gt; &amp; <span class="comment">/*current_f*/</span>) {</div><div class="line">              compute_and_factorize_jacobian(current_u);</div><div class="line"></div><div class="line">              <span class="keywordflow">return</span> 0;</div><div class="line">            };</div><div class="line"></div><div class="line">          nonlinear_solver.solve_with_jacobian = [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                                     Vector&lt;double&gt; &amp;      dst,</div><div class="line">                                                     <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance) {</div><div class="line">            this-&gt;solve(rhs, dst, tolerance);</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span> 0;</div><div class="line">          };</div><div class="line"></div><div class="line">          nonlinear_solver.solve(current_solution);</div><div class="line">        }</div><div class="line"></div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step77</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step77;</div><div class="line"></div><div class="line">      MinimalSurfaceProblem&lt;2&gt; laplace_problem_2d;</div><div class="line">      laplace_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_15.html">step-15</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#HowdealIIinterfaceswithKINSOL"> How deal.II interfaces with KINSOL </a><a href="#HowdealIIinterfaceswithKINSOL"> How deal.II interfaces with KINSOL </a>
        <li><a href="#Detailsoftheimplementation"> Details of the implementation </a><a href="#Detailsoftheimplementation"> Details of the implementation </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclasstemplate">The <code>MinimalSurfaceProblem</code> class template</a><a href="#ThecodeMinimalSurfaceProblemcodeclasstemplate">The <code>MinimalSurfaceProblem</code> class template</a>
        <li><a href="#Boundarycondition">Boundary condition</a><a href="#Boundarycondition">Boundary condition</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclassimplementation">The <code>MinimalSurfaceProblem</code> class implementation</a><a href="#ThecodeMinimalSurfaceProblemcodeclassimplementation">The <code>MinimalSurfaceProblem</code> class implementation</a>
      <ul>
        <li><a href="#Constructorandsetupfunctions">Constructor and set up functions</a><a href="#Constructorandsetupfunctions">Constructor and set up functions</a>
        <li><a href="#AssemblingandfactorizingtheJacobianmatrix">Assembling and factorizing the Jacobian matrix</a><a href="#AssemblingandfactorizingtheJacobianmatrix">Assembling and factorizing the Jacobian matrix</a>
        <li><a href="#Computingtheresidualvector">Computing the residual vector</a><a href="#Computingtheresidualvector">Computing the residual vector</a>
        <li><a href="#SolvinglinearsystemswiththeJacobianmatrix">Solving linear systems with the Jacobian matrix</a><a href="#SolvinglinearsystemswiththeJacobianmatrix">Solving linear systems with the Jacobian matrix</a>
        <li><a href="#Refiningthemeshsettingboundaryvaluesandgeneratinggraphicaloutput">Refining the mesh, setting boundary values, and generating graphical output</a><a href="#Refiningthemeshsettingboundaryvaluesandgeneratinggraphicaloutput">Refining the mesh, setting boundary values, and generating graphical output</a>
        <li><a href="#Therunfunctionandtheoveralllogicoftheprogram">The run() function and the overall logic of the program</a><a href="#Therunfunctionandtheoveralllogicoftheprogram">The run() function and the overall logic of the program</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
 <em> This program was contributed by Wolfgang Bangerth, Colorado State University.</em></p>
<p><em>This material is based upon work partially supported by National Science Foundation grants OAC-1835673, DMS-1821210, and EAR-1925595; and by the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-1550901 and The University of California-Davis. </em> <br />
 <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The <a class="el" href="step_15.html">step-15</a> program solved the following, nonlinear equationdescribing the minimal surface problem: </p><p class="formulaDsp">
\begin{align*} -\nabla \cdot \left( \frac{1}{\sqrt{1+|\nabla u|^{2}}}\nabla u \right) &amp;= 0 \qquad \qquad &amp;&amp;\textrm{in} ~ \Omega \\ u&amp;=g \qquad\qquad &amp;&amp;\textrm{on} ~ \partial \Omega. \end{align*}
</p>
<p> <a class="el" href="step_15.html">step-15</a> uses a Newton method, andNewton's method works by repeatedly solving alinearized* problem foran update \(\delta u_k\)</p>
<ul>
<li>called the "search direction"</li>
<li>, computing a"step length" \(\alpha_k\) , and then combining them to compute the newguess for the solution via <p class="formulaDsp">
\begin{align*} u_{k+1} = u_k + \alpha_k \, \delta u_k. \end{align*}
</p>
</li>
</ul>
<p>In the course of the discussions in <a class="el" href="step_15.html">step-15</a> , we found that it isawkward to compute the step length, and so just settled for simplechoice: Always choose \(\alpha_k=0.1\) . This is of course not efficient:We know that we can only realize Newton's quadratic convergence rateif we eventually are able to choose \(\alpha_k=1\) , though we may haveto choose it smaller for the first few iterations where we are stilltoo far away to use this long a step length. Among the goals of this program is therefore to address thisshortcoming. Since line search algorithms are not entirely trivial toimplement, one does as one should do anyway: Import complicatedfunctionality from an external library. To this end, we will make useof the interfaces deal.II has to one of the big nonlinear solverpackages, namely the<a href="https://computing.llnl.gov/projects/sundials/kinsol">KINSOL</a>sub-package of the<a href="https://computing.llnl.gov/projects/sundials">SUNDIALS</a>suite. SUNDIALS is, at its heart, a package meant to solve complexordinary differential equations (ODEs) and differential-algebraicequations (DAEs), and the deal.II interfaces allow for this via theclasses in the <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> namespace: Notably the <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a> and <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a> classes. But, because that is an important step in thesolution of ODEs and DAEs with implicit methods, SUNDIALS also has asolver for nonlinear problems called KINSOL, and deal.II has aninterface to it in the form of the <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a> class. This iswhat we will use for the solution of our problem. But SUNDIALS isn't just a convenient way for us to avoid writing aline search algorithm. In general, the solution of nonlinear problemsis quite expensive, and one typically wants to save as much computetime as possible. One way one can achieve this is as follows: Thealgorithm in <a class="el" href="step_15.html">step-15</a> discretizes the problem and then in everyiteration solves a linear system of the form </p><p class="formulaDsp">
\begin{align*} J_k \, \delta U_k = -F_k \end{align*}
</p>
<p> where \(F_k\) is the residual vector computed using the current vectorof nodal values \(U_k\) , \(J_k\) is its derivative (called the"Jacobian"), and \(\delta U_k\) is the update vector that corresponds tothe function \(\delta u_k\) mentioned above. The construction of \(J_k,F_k\) has been thoroughly discussed in <a class="el" href="step_15.html">step-15</a> , as has the way tosolve the linear system in each Newton iteration. So let us focus onanother aspect of the nonlinear solution procedure: Computing \(F_k\) isexpensive, and assembling the matrix \(J_k\) even more so. Do weactually need to do that in every iteration? It turns out that in manyapplications, this is not actually necessary: These methods often convergeeven if we replace \(J_k\) by an approximation \(\tilde J_k\) and solve </p><p class="formulaDsp">
\begin{align*} \tilde J_k \, \widetilde{\delta U}_k = -F_k \end{align*}
</p>
<p> instead, then update </p><p class="formulaDsp">
\begin{align*} U_{k+1} = U_k + \alpha_k \, \widetilde{\delta U}_k. \end{align*}
</p>
<p> This may require an iteration or two more because our update \(\widetilde{\delta U}_k\) is not quite as good as \(\delta U_k\) , but itmay still be a win because we don't have to assemble \(J_k\) quite asoften. What kind of approximation \(\tilde J_k\) would we like for \(J_k\) ? Theorysays that as \(U_k\) converges to the exact solution \(U^\ast\) , we need toensure that \(\tilde J_k\) needs to converge to \(J^\ast = \nabla F(U^\ast)\) .In particular, since \(J_k\rightarrow J^\ast\) , a valid choice is \(\tilde J_k = J_k\) . But so is choosing \(\tilde J_k = J_k\) every, say,fifth iteration \(k=0,5,10,\ldots\) and for the other iterations, we choose \(\tilde J_k\) equal to the last computed \(J_{k&#39;}\) . This is what we will dohere: we will just re-use \(\tilde J_{k-1}\) from theprevious iteration, which may again be what we had used in theiteration before that, \(\tilde J_{k-2}\) . This scheme becomes even more interesting if, for the solution of thelinear system with \(J_k\) , we don't just have to assemble a matrix, butalso compute a good preconditioner. For example, if we were to use asparse LU decomposition via the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class, or used ageometric or algebraic multigrid. In those cases, we would also nothave to update the preconditioner, whose computation may have takenabout as long or longer than the assembly of the matrix in the firstplace. Indeed, with this mindset, we should probably think about usingthebest* preconditioner we can think of, even though theirconstruction is typically quite expensive: We will hope to amortizethe cost of computing this preconditioner by applying it to more thanone just one linear solve. The big question is, of course: By what criterion do we decide whetherwe can get away with the approximation \(\tilde J_k\) based on apreviously computed Jacobian matrix \(J_{k-s}\) that goes back \(s\) steps, or whether we need to</p>
<ul>
<li>at least in this iteration</li>
<li>actuallyre-compute the Jacobian \(J_k\) and the corresponding preconditioner?This is, like the issue with line search, one that requires anon-trivial amount of code that monitors the convergence of theoverall algorithm. Wecould* implement these sorts of thingsourselves, but we probablyshouldn't*: KINSOL already does that forus. It will tell our code when to "update" the Jacobian matrix. One last consideration if we were to use an iterative solver instead ofthe sparse direct one mentioned above: Not only is it possible to getaway with replacing \(J_k\) by some approximation \(\tilde J_k\) whensolving for the update \(\delta U_k\) , but one can also ask whether itis necessary to solve the linear system <p class="formulaDsp">
\begin{align*} \tilde J_k \widetilde{\delta U}_k = -F_k \end{align*}
</p>
 to high accuracy. The thinking goes like this: While our current solution \(U_k\) is still far away from \(U^\ast\) , why would we solve this linearsystem particularly accurately? The update \(U_{k+1}=U_k + \widetilde{\delta U}_k\) is likely still going to be far awayfrom the exact solution, so why spend much time on solving the linear systemto great accuracy? This is the kind of thinking that underlies algorithmssuch as the "Eisenstat-Walker trick" <b>[eiwa96]</b> in which one is givena tolerance to which the linear system above in iteration \(k\) has to besolved, with this tolerance dependent on the progress in the overallnonlinear solver. As before, one could try to implement this oneself,but KINSOL already provides this kind of information for us</li>
<li>though wewill not use it in this program since we use a direct solver that requiresno solver tolerance and just solves the linear system exactly up toround-off. As a summary of all of these considerations, we could say thefollowing: There is no need to reinvent the wheel. Just like deal.IIprovides a vast amount of finite-element functionality, SUNDIALS'KINSOL package provides a vast amount of nonlinear solverfunctionality, and we better use it.</li>
</ul>
<p><a class="anchor" id="HowdealIIinterfaceswithKINSOL"></a></p><h3>How deal.II interfaces with KINSOL </h3>
<p>KINSOL, like many similar packages, works in a pretty abstract way. Atits core, it sees a nonlinear problem of the form </p><p class="formulaDsp">
\begin{align*} F(U) = 0 \end{align*}
</p>
<p> and constructs a sequence of iterates \(U_k\) which, in general, arevectors of the same length as the vector returned by the function \(F\) . To do this, there are a few things it needs from the user:</p>
<ul>
<li>A way to resize a given vector to the correct size.</li>
<li>A way to evaluate, for a given vector \(U\) , the function \(F(U)\) . This function is generally called the "residual" operation because the goal is of course to find a point \(U^\ast\) for which \(F(U^\ast)=0\) ; if \(F(U)\) returns a nonzero vector, then this is the <a href="https://en.wikipedia.org/wiki/Residual_(numerical_analysis)">"residual"</a> (i.e., the "rest", or whatever is "left over"). The function that will do this is in essence the same as the computation of the right hand side vector in <a class="el" href="step_15.html">step-15</a> , but with an important difference: There, the right hand side denoted thenegative* of the residual, so we have to switch a sign.</li>
<li>A way to compute the matrix \(J_k\) if that is necessary in the current iteration, along with possibly a preconditioner or other data structures (e.g., a sparse decomposition via <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> if that's what we choose to use to solve a linear system). This operation will generally be called the "setup" operation.</li>
<li>A way to solve a linear system \(\tilde J_k x = b\) with whatever matrix \(\tilde J_k\) was last computed. This operation will generally be called the "solve" operation. All of these operations need to be provided to KINSOL by <a href="https://en.cppreference.com/w/cpp/utility/functional/function">std::function</a> objects that take the appropriate set of arguments and that generallyreturn an integer that indicates success (a zero return value) orfailure (a nonzero return value). Specifically, the objects we willaccess are the <a class="el" href="classSUNDIALS_1_1KINSOL.html#abdccb7a76e27cd9948048fdd03949380">SUNDIALS::KINSOL::reinit_vector</a>, <a class="el" href="classSUNDIALS_1_1KINSOL.html#aa791c6b63d41c8e7b12ec227e224c72a">SUNDIALS::KINSOL::residual</a>, <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">SUNDIALS::KINSOL::setup_jacobian</a>, and <a class="el" href="classSUNDIALS_1_1KINSOL.html#a388cbc77068ac53927b0b8b3e055a423">SUNDIALS::KINSOL::solve_jacobian_system</a> member variables. (See the documentation of these variables for theirdetails.) In our implementation, we will use<a href="https://en.cppreference.com/w/cpp/language/lambda">lambda functions</a>to implement these "callbacks" that in turn can call member functions;KINSOL will then call these callbacks whenever its internal algorithmsthink it is useful.</li>
</ul>
<p><a class="anchor" id="Detailsoftheimplementation"></a></p><h3>Details of the implementation </h3>
<p>The majority of the code of this tutorial program is as in <a class="el" href="step_15.html">step-15</a> ,and we will not comment on it in much detail. There is really just oneaspect one has to pay some attention to, namely how to compute \(F(U)\) given a vector \(U\) on the one hand, and \(J(U)\) given a vector \(U\) separately. At first, this seems trivial: We just take the<code>assemble_system()</code> function and in the one case throw out all codethat deals with the matrix and in the other case with the right handside vector. There: Problem solved. But it isn't quite as simple. That's because the two are notindependent if we have nonzero Dirichlet boundary values, as we dohere. The linear system we want to solve contains both interior andboundary degrees of freedom, and when eliminating those degrees offreedom from those that are truly "free", using for example <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a>, we need to know thematrix when assembling the right hand side vector. Of course, this completely contravenes the original intent: Tonot* assemble the matrix if we can get away without it. We solve thisproblem as follows:</p>
<ul>
<li>We set the starting guess for the solution vector, \(U_0\) , to one where boundary degrees of freedom already have their correct values.</li>
<li>This implies that all updates can have zero updates for these degrees of freedom, and we can build both residual vectors \(F(U_k)\) and Jacobian matrices \(J_k\) that corresponds to linear systems whose solutions are zero in these vector components. For this special case, the assembly of matrix and right hand side vectors is independent, and can be broken into separate functions. There is an assumption here that whenever KINSOL asks for a linearsolver with the (approximation of the) Jacobian, that this will be forfor an update \(\delta U\) (which has zero boundary values), a multipleof which will be added to the solution (which already has the rightboundary values). This may not be true and if so, we might have torethink our approach. That said, it turns out that in practice this isexactly what KINSOL does when using a Newton method, and so ourapproach is successful.</li>
</ul>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>This program starts out like most others with well known include files. Compared to the <a class="el" href="step_15.html">step-15</a> program from which most of what we do here is copied, the only difference is the include of the header files from which we import the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class and the actual interface to KINSOL:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinsol_8h.html">deal.II/sundials/kinsol.h</a>&gt;</span></div><div class="line"> </div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"> </div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step77</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclasstemplate"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class template</h3>
<p>Similarly, the main class of this program is essentially a copy of the one in <a class="el" href="step_15.html">step-15</a> . The class does, however, split the computation of the Jacobian (system) matrix (and its factorization using a direct solver) and residual into separate functions for the reasons outlined in the introduction. For the same reason, the class also has a pointer to a factorization of the Jacobian matrix that is reset every time we update the Jacobian matrix. (If you are wondering why the program uses a direct object for the Jacobian matrix but a pointer for the factorization: Every time KINSOL requests that the Jacobian be updated, we can simply write <code>jacobian_matrix=0;</code> to reset it to an empty matrix that we can then fill again. On the other hand, the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class does not have any way to throw away its content or to replace it with a new factorization, and so we use a pointer: We just throw away the whole object and create a new one whenever we have a new Jacobian matrix to factor.) Finally, the class has a timer variable that we will use to assess how long the different parts of the program take so that we can assess whether KINSOL's tendency to not rebuild the matrix and its factorization makes sense. We will discuss this in the "Results" section below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MinimalSurfaceProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">  <span class="keywordtype">void</span> solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">             Vector&lt;double&gt; &amp;      solution,</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">double</span>          tolerance);</div><div class="line">  <span class="keywordtype">void</span> refine_mesh();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line">  <span class="keywordtype">void</span> set_boundary_values();</div><div class="line">  <span class="keywordtype">void</span> compute_and_factorize_jacobian(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point);</div><div class="line">  <span class="keywordtype">void</span> compute_residual(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                        Vector&lt;double&gt; &amp;      residual);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                      sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt;                 jacobian_matrix;</div><div class="line">  std::unique_ptr&lt;SparseDirectUMFPACK&gt; jacobian_matrix_factorization;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; current_solution;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Boundarycondition"></a> </p><h3>Boundary condition</h3>
<p>The classes implementing boundary values are a copy from <a class="el" href="step_15.html">step-15</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  <span class="comment">/*component*/</span> )<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 numbers::PI (p[0] + p[1]));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclassimplementation"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class implementation</h3>
<pre class="fragment">&lt;a name="Constructorandsetupfunctions"&gt;&lt;/a&gt;  &lt;h4&gt;Constructor and set up functions&lt;/h4&gt;
</pre><p>The following few functions are also essentially copies of what <a class="el" href="step_15.html">step-15</a> already does, and so there is little to discuss.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">  : dof_handler(triangulation)</div><div class="line">  , fe(1)</div><div class="line">  , computing_timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;set up&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (initial_step)</div><div class="line">    {</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">      current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">      hanging_node_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                              hanging_node_constraints);</div><div class="line">      hanging_node_constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  jacobian_matrix.reinit(sparsity_pattern);</div><div class="line">  jacobian_matrix_factorization.reset();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="AssemblingandfactorizingtheJacobianmatrix"></a> </p><h4>Assembling and factorizing the Jacobian matrix</h4>
<p>The following function is then responsible for assembling and factorizing the Jacobian matrix. The first half of the function is in essence the <code>assemble_system()</code> function of <a class="el" href="step_15.html">step-15</a> , except that it does not deal with also forming a right hand side vector (i.e., the residual) since we do not always have to do these operations at the same time. We put the whole assembly functionality into a code block enclosed by curly braces so that we can use a <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> variable to measure how much time is spent in this code block, excluding everything that happens in this function after the matching closing brace <code>}</code>.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_and_factorize_jacobian(</div><div class="line">     <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point)</div><div class="line">   {</div><div class="line">     {</div><div class="line">       <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the Jacobian&quot;</span>);</div><div class="line">  </div><div class="line">       std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">       <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">  </div><div class="line">       jacobian_matrix = 0;</div><div class="line">  </div><div class="line">       <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                               quadrature_formula,</div><div class="line">                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line">  </div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line">  </div><div class="line">       <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line">  </div><div class="line">       std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line">  </div><div class="line">       std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line">  </div><div class="line">       <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">         {</div><div class="line">           cell_matrix = 0;</div><div class="line">  </div><div class="line">           fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line">  </div><div class="line">           fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                            evaluation_point_gradients);</div><div class="line">  </div><div class="line">           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">             {</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">                 1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q]</div><div class="line">                                       evaluation_point_gradients[q]);</div><div class="line">  </div><div class="line">               <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                 {</div><div class="line">                   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                     <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                       (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                          coeff                       <span class="comment">//   a_n</span></div><div class="line">                          fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)) <span class="comment">//   \nabla \phi_j)</span></div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-                              <span class="comment">//</span></div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">  </div><div class="line">-</div><div class="line">                         (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                          coeff coeff coeff       <span class="comment">//   a_n^3</span></div><div class="line">                         </div><div class="line">                          (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)       <span class="comment">//   (\nabla \phi_j</span></div><div class="line">                           evaluation_point_gradients[q]) <span class="comment">//      \nabla u_n)</span></div><div class="line">                          evaluation_point_gradients[q])) <span class="comment">//   \nabla u_n)))</span></div><div class="line">                        fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));                <span class="comment">// dx</span></div><div class="line">                 }</div><div class="line">             }</div><div class="line">  </div><div class="line">           cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">           hanging_node_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                               local_dof_indices,</div><div class="line">                                                               jacobian_matrix);</div><div class="line">         }</div><div class="line">  </div><div class="line">       std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">       <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                                0,</div><div class="line">                                                <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                                boundary_values);</div><div class="line">       Vector&lt;double&gt; dummy_solution(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">       Vector&lt;double&gt; dummy_rhs(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">       <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                          jacobian_matrix,</div><div class="line">                                          dummy_solution,</div><div class="line">                                          dummy_rhs);</div><div class="line">     }</div></div><!-- fragment --><p>The second half of the function then deals with factorizing the so-computed matrix. To do this, we first create a new <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> object and by assigning it to the member variable <code>jacobian_matrix_factorization</code>, we also destroy whatever object that pointer previously pointed to (if any). Then we tell the object to factorize the Jacobian. As above, we enclose this block of code into curly braces and use a timer to assess how long this part of the program takes. (Strictly speaking, we don't actually need the matrix any more after we are done here, and could throw the matrix object away. A code intended to be memory efficient would do this, and only create the matrix object in this function, rather than as a member variable of the surrounding class. We omit this step here because using the same coding style as in previous tutorial programs breeds familiarity with the common style and helps make these tutorial programs easier to read.)</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;factorizing the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Factorizing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    jacobian_matrix_factorization = std::make_unique&lt;SparseDirectUMFPACK&gt;();</div><div class="line">    jacobian_matrix_factorization-&gt;factorize(jacobian_matrix);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingtheresidualvector"></a> </p><h4>Computing the residual vector</h4>
<p>The second part of what <code>assemble_system()</code> used to do in <a class="el" href="step_15.html">step-15</a> is computing the residual vector, i.e., the right hand side vector of the Newton linear systems. We have broken this out of the previous function, but the following function will be easy to understand if you understood what <code>assemble_system()</code> in <a class="el" href="step_15.html">step-15</a> did. Importantly, however, we need to compute the residual not linearized around the current solution vector, but whatever we get from KINSOL. This is necessary for operations such as line search where we want to know what the residual \(F(U^k + \alpha_k \delta U^K)\) is for different values of \(\alpha_k\) ; KINSOL in those cases simply gives us the argument to the function \(F\) and we then compute the residual \(F(\cdot)\) at this point. The function prints the norm of the so-computed residual at the end as a way for us to follow along the progress of the program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(</div><div class="line">  <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">  Vector&lt;double&gt; &amp;      residual)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the residual&quot;</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing residual vector...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                       evaluation_point_gradients);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">            1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q]</div><div class="line">                                  evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) = (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                coeff                    <span class="comment">// a_n</span></div><div class="line">                                evaluation_point_gradients[q] <span class="comment">// u_n</span></div><div class="line">                                fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));            <span class="comment">// dx</span></div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">    }</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(residual);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">       <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">    residual(i) = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">       <a class="code" href="namespaceDoFTools.html#aed6928cb7bdb5a85e8670d6bd5c90e24">DoFTools::extract_hanging_node_dofs</a>(dof_handler))</div><div class="line">    residual(i) = 0;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; norm=&quot;</span> &lt;&lt; residual.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="SolvinglinearsystemswiththeJacobianmatrix"></a> </p><h4>Solving linear systems with the Jacobian matrix</h4>
<p>Next up is the function that implements the solution of a linear system with the Jacobian matrix. Since we have already factored the matrix when we built the matrix, solving a linear system comes down to applying the inverse matrix to the given right hand side vector: This is what the <a class="el" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">SparseDirectUMFPACK::vmult()</a> function does that we use here. Following this, we have to make sure that we also address the values of hanging nodes in the solution vector, and this is done using <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a>. The function takes an additional, but unused, argument <code>tolerance</code> that indicates how accurately we have to solve the linear system. The meaning of this argument is discussed in the introduction in the context of the "Eisenstat Walker trick", but since we are using a direct rather than an iterative solver, we are not using this opportunity to solve linear systems only inexactly.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                       Vector&lt;double&gt; &amp;      solution,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span>  <span class="comment">/*tolerance*/</span> )</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;linear system solve&quot;</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Solving linear system&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  jacobian_matrix_factorization-&gt;vmult(solution, rhs);</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Refiningthemeshsettingboundaryvaluesandgeneratinggraphicaloutput"></a> </p><h4>Refining the mesh, setting boundary values, and generating graphical output</h4>
<p>The following three functions are again simply copies of the ones in <a class="el" href="step_15.html">step-15</a> :</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">   {</div><div class="line">     <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line">  </div><div class="line">     <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">       dof_handler,</div><div class="line">       <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line">  </div><div class="line">- 1&gt;(fe.degree + 1),</div><div class="line">       std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a>&gt;(),</div><div class="line">       current_solution,</div><div class="line">       estimated_error_per_cell);</div><div class="line">  </div><div class="line">     <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                     estimated_error_per_cell,</div><div class="line">                                                     0.3,</div><div class="line">                                                     0.03);</div><div class="line">  </div><div class="line">     triangulation.prepare_coarsening_and_refinement();</div><div class="line">  </div><div class="line">     <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">     solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line">  </div><div class="line">     triangulation.execute_coarsening_and_refinement();</div><div class="line">  </div><div class="line">     dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">  </div><div class="line">     Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">     solution_transfer.interpolate(current_solution, tmp);</div><div class="line">     current_solution = std::move(tmp);</div><div class="line">  </div><div class="line">     hanging_node_constraints.clear();</div><div class="line">  </div><div class="line">     <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                             hanging_node_constraints);</div><div class="line">     hanging_node_constraints.close();</div><div class="line">  </div><div class="line">     hanging_node_constraints.distribute(current_solution);</div><div class="line">  </div><div class="line">     set_boundary_values();</div><div class="line">  </div><div class="line">     setup_system( <span class="comment">/*initial_step=*/</span> <span class="keyword">false</span>);</div><div class="line">   }</div><div class="line">  </div><div class="line"> </div><div class="line">  </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">   {</div><div class="line">     std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">     <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                              0,</div><div class="line">                                              BoundaryValues&lt;dim&gt;(),</div><div class="line">                                              boundary_values);</div><div class="line">     <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">       current_solution(boundary_value.first) = boundary_value.second;</div><div class="line">  </div><div class="line">     hanging_node_constraints.distribute(current_solution);</div><div class="line">   }</div><div class="line">  </div><div class="line"> </div><div class="line">  </div><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">   <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)</div><div class="line">   {</div><div class="line">     <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;graphical output&quot;</span>);</div><div class="line">  </div><div class="line">     <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  </div><div class="line">     data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">     data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">     data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line">  </div><div class="line">     <span class="keyword">const</span> std::string filename =</div><div class="line">       <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">     std::ofstream output(filename);</div><div class="line">     data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">   }</div></div><!-- fragment --><p><a class="anchor" id="Therunfunctionandtheoveralllogicoftheprogram"></a> </p><h4>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function and the overall logic of the program</h4>
<p>The only function thatreally* is interesting in this program is the one that drives the overall algorithm of starting on a coarse mesh, doing some mesh refinement cycles, and on each mesh using KINSOL to find the solution of the nonlinear algebraic equation we obtain from discretization on this mesh. The <code>refine_mesh()</code> function above makes sure that the solution on one mesh is used as the starting guess on the next mesh. We also use a <a class="el" href="classTimerOutput.html">TimerOutput</a> object to measure how much time every operation on each mesh costs, and reset the timer at the beginning of each cycle. As discussed in the introduction, it is not necessary to solve problems on coarse meshes particularly accurately since these will only solve as starting guesses for the next mesh. As a consequence, we will use a target tolerance of \(\tau=10^{-3} \frac{1}{10^k}\) for the \(k\) th mesh refinement cycle. All of this is encoded in the first part of this function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">  triangulation.refine_global(2);</div><div class="line"></div><div class="line">  setup_system( <span class="comment">/*initial_step=*/</span> <span class="keyword">true</span>);</div><div class="line">  set_boundary_values();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">       ++refinement_cycle)</div><div class="line">    {</div><div class="line">      computing_timer.<a class="code" href="classTimerOutput.html#a017cdef3c18d6050d401dab4f2f64d2e">reset</a>();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">        refine_mesh();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> target_tolerance = 1e-3 <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.1, refinement_cycle);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Target_tolerance: &quot;</span> &lt;&lt; target_tolerance &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl;</div></div><!-- fragment --><p>This is where the fun starts. At the top we create the KINSOL solver object and feed it with an object that encodes a number of additional specifics (of which we only change the nonlinear tolerance we want to reach; but you might want to look into what other members the <a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">SUNDIALS::KINSOL::AdditionalData</a> class has and play with them).</p>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt;::AdditionalData</div><div class="line">    additional_data;</div><div class="line">  additional_data.function_tolerance = target_tolerance;</div><div class="line"></div><div class="line">  <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt; nonlinear_solver(additional_data);</div></div><!-- fragment --><p>Then we have to describe the operations that were already mentioned in the introduction. In essence, we have to teach KINSOL how to (i) resize a vector to the correct size, (ii) compute the residual vector, (iii) compute the Jacobian matrix (during which we also compute its factorization), and (iv) solve a linear system with the Jacobian. All four of these operations are represented by member variables of the <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a> class that are of type <code>std::function</code>, i.e., they are objects to which we can assign a pointer to a function or, as we do here, a "lambda function" that takes the appropriate arguments and returns the appropriate information. By convention, KINSOL wants that functions doing something nontrivial return an integer where zero indicates success. It turns out that we can do all of this in just 25 lines of code. (If you're not familiar what "lambda functions" are, take a look at <a class="el" href="step_12.html">step-12</a> or at the <a href="https://en.wikipedia.org/wiki/Anonymous_function">wikipedia page</a> on the subject. The idea of lambda functions is that one wants to define a function with a certain set of arguments, but (i) not make it a named functions because, typically, the function is used in only one place and it seems unnecessary to give it a global name; and (ii) that the function has access to some of the variables that exist at the place where it is defined, including member variables. The syntax of lambda functions is awkward, but ultimately quite useful.) At the very end of the code block we then tell KINSOL to go to work and solve our problem. The member functions called from the 'residual', 'setup_jacobian', and 'solve_jacobian_system' functions will then print output to screen that allows us to follow along with the progress of the program.</p>
<div class="fragment"><div class="line">  nonlinear_solver.reinit_vector = [&amp;](Vector&lt;double&gt; &amp;x) {</div><div class="line">    x.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  };</div><div class="line"></div><div class="line">  nonlinear_solver.residual =</div><div class="line">    [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">        Vector&lt;double&gt; &amp;      residual) {</div><div class="line">      compute_residual(evaluation_point, residual);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    };</div><div class="line"></div><div class="line">  nonlinear_solver.setup_jacobian =</div><div class="line">    [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;current_u,</div><div class="line">        <span class="keyword">const</span> Vector&lt;double&gt; &amp;  <span class="comment">/*current_f*/</span> ) {</div><div class="line">      compute_and_factorize_jacobian(current_u);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    };</div><div class="line"></div><div class="line">  nonlinear_solver.solve_with_jacobian = [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                             Vector&lt;double&gt; &amp;      dst,</div><div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance) {</div><div class="line">    this-&gt;solve(rhs, dst, tolerance);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  };</div><div class="line"></div><div class="line">  nonlinear_solver.solve(current_solution);</div><div class="line">}</div></div><!-- fragment --><p>The rest is then just house-keeping: Writing data to a file for visualizing, and showing a summary of the timing collected so that we can interpret how long each operation has taken, how often it was executed, etc:</p>
<div class="fragment"><div class="line">        output_results(refinement_cycle);</div><div class="line"> </div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line"> </div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step77</span></div><div class="line"> </div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step77;</div><div class="line"> </div><div class="line">      MinimalSurfaceProblem&lt;2&gt; laplace_problem_2d;</div><div class="line">      laplace_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"> </div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>When running the program, you get output that looks like this: </p><div class="fragment"><div class="line">Mesh refinement step 0</div><div class="line">  Target_tolerance: 0.001</div><div class="line">  </div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Computing residual vector... norm=0.127245</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Computing residual vector... norm=0.0625301</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0625301</div><div class="line">  Computing residual vector... norm=0.0498864</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0498864</div><div class="line">  Computing residual vector... norm=0.0407765</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0407765</div><div class="line">  Computing residual vector... norm=0.0341589</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0341589</div><div class="line">  Computing residual vector... norm=0.0292867</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0292867</div><div class="line">  Computing residual vector... norm=0.0256309</div><div class="line">  Computing residual vector... norm=0.0223448</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0223448</div><div class="line">  Computing residual vector... norm=0.0202797</div><div class="line">  Computing residual vector... norm=0.0183817</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0183817</div><div class="line">  Computing residual vector... norm=0.0170464</div><div class="line">  Computing residual vector... norm=0.0157967</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0157967</div><div class="line">  Computing residual vector... norm=0.0141572</div><div class="line">  Computing residual vector... norm=0.012657</div><div class="line"> Solving linear system</div><div class="line">  Computing residual vector... norm=0.012657</div><div class="line">  Computing residual vector... norm=0.0116863</div><div class="line">  Computing residual vector... norm=0.0107696</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0107696</div><div class="line">  Computing residual vector... norm=0.0100986</div><div class="line">  Computing residual vector... norm=0.00944829</div><div class="line">  Computing residual vector... norm=0.00822576</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00822576</div><div class="line">  Computing residual vector... norm=0.00781983</div><div class="line">  Computing residual vector... norm=0.00741619</div><div class="line">  Computing residual vector... norm=0.00661792</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00661792</div><div class="line">  Computing residual vector... norm=0.00630571</div><div class="line">  Computing residual vector... norm=0.00599457</div><div class="line">  Computing residual vector... norm=0.00537663</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00537663</div><div class="line">  Computing residual vector... norm=0.00512813</div><div class="line">  Computing residual vector... norm=0.00488033</div><div class="line">  Computing residual vector... norm=0.00438751</div><div class="line">  Computing residual vector... norm=0.00342052</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00342052</div><div class="line">  Computing residual vector... norm=0.00326581</div><div class="line">  Computing residual vector... norm=0.00311176</div><div class="line">  Computing residual vector... norm=0.00280617</div><div class="line">  Computing residual vector... norm=0.00220992</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00220992</div><div class="line">  Computing residual vector... norm=0.00209976</div><div class="line">  Computing residual vector... norm=0.00199943</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00199942</div><div class="line">  Computing residual vector... norm=0.00190953</div><div class="line">  Computing residual vector... norm=0.00182005</div><div class="line">  Computing residual vector... norm=0.00164259</div><div class="line">  Computing residual vector... norm=0.00129652</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |     0.192s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| assembling the Jacobian         |         2 |    0.0141s |       7.4% |</div><div class="line">| assembling the residual         |        61 |     0.168s |        88% |</div><div class="line">| factorizing the Jacobian        |         2 |    0.0016s |      0.83% |</div><div class="line">| graphical output                |         1 |   0.00385s |         2% |</div><div class="line">| linear system solve             |        19 |    0.0013s |      0.68% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">  </div><div class="line"></div><div class="line"></div><div class="line">  </div><div class="line">Mesh refinement step 1</div><div class="line">  Target_tolerance: 0.0001</div><div class="line">  </div><div class="line">  Computing residual vector... norm=0.0883422</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0883422</div><div class="line">  Computing residual vector... norm=0.0607066</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0607066</div><div class="line">  Computing residual vector... norm=0.0437266</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0437266</div><div class="line">  Computing residual vector... norm=0.0327999</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0327999</div><div class="line">  Computing residual vector... norm=0.0255418</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0255417</div><div class="line">  Computing residual vector... norm=0.0206042</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0206042</div><div class="line">  Computing residual vector... norm=0.0171602</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0171602</div><div class="line">  Computing residual vector... norm=0.014689</div><div class="line">  Solving linear system</div><div class="line">  </div><div class="line">[...]</div></div><!-- fragment --><p>The way this should be interpreted is most easily explained by looking atthe first few lines of the output on the first mesh: </p><div class="fragment"><div class="line">Mesh refinement step 0</div><div class="line">Mesh refinement step 0</div><div class="line">  Target_tolerance: 0.001</div><div class="line">  </div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Computing residual vector... norm=0.127245</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  ...</div></div><!-- fragment --><p> What is happening is this:</p>
<ul>
<li>In the first residual computation, KINSOL computes the residual to see whether the desired tolerance has been reached. The answer is no, so it requests the user program to compute the Jacobian matrix (and the function then also factorizes the matrix via <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>).</li>
<li>KINSOL then instructs us to solve a linear system of the form \(J_k \, \delta U_k = -F_k\) with this matrix and the previously computed residual vector.</li>
<li>It is then time to determine how far we want to go in this direction, i.e., do line search. To this end, KINSOL requires us to compute the residual vector \(F(U_k + \alpha_k \delta U_k)\) for different step lengths \(\alpha_k\) . For the first step above, it finds an acceptable \(\alpha_k\) after two tries, the second time around it takes three tries.</li>
<li>Having found a suitable updated solution \(U_{k+1}\) , the process is repeated except now KINSOL is happy with the current Jacobian matrix and does not instruct us to re-build the matrix and its factorization, and instead asks us to solve a linear system with that same matrix. The program also writes the solution to a VTU file at the endof each mesh refinement cycle, and it looks as follows: <table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-77.solution.png"/>
</div>
   </td></tr>
</table>
</li>
</ul>
<p>The key takeaway messages of this program are the following:</p>
<ul>
<li>The solution is the same as the one we computed in <a class="el" href="step_15.html">step-15</a> , i.e., the interfaces to SUNDIALS' KINSOL package really did what they were supposed to do. This should not come as a surprise, but the important point is that we don't have to spend the time implementing the complex algorithms that underlie advanced nonlinear solvers ourselves.</li>
<li>KINSOL is able to avoid all sorts of operations such as rebuilding the Jacobian matrix when that is not actually necessary. Comparing the number of linear solves in the output above with the number of times we rebuild the Jacobian and compute its factorization should make it clear that this leads to very substantial savings in terms of compute times, without us having to implement the intricacies of algorithms that determine when we need to rebuild this information. <a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a><h3>Possibilities for extensions </h3>
</li>
</ul>
<p>For all but the small problems we consider here, a sparse direct solverrequires too much time and memory</p>
<ul>
<li>we need an iterative solver likewe use in many other programs. The trade-off between constructing anexpensive preconditioner (say, a geometric or algebraic multigrid method)is different in the current case, however: Since we can re-use the samematrix for numerous linear solves, we can do the same for the preconditionerand putting more work into building a good preconditioner can more easilybe justified than if we used it only for a single linear solve as onedoes for many other situations. But iterative solvers also afford other opportunities. For example (and asdiscussed briefly in the introduction), we may not need to solve tovery high accuracy (small tolerances) in early nonlinear iterations as longas we are still far away from the actual solution. This was the basis of theEisenstat-Walker trick mentioned there. KINSOL provides the function that does the linear solution with a targettolerance that needs to be reached. We ignore it in the program abovebecause the direct solver we use does not need a tolerance and insteadsolves the linear system exactly (up to round-off, of course), but iterativesolvers could make use of this kind of information</li>
<li>and, in fact, should.</li>
</ul>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Colorado State University, 2021.</span></div><div class="line"><span class="comment"> * Based on @ref step_15 &quot;step-15&quot; by Sven Wetterauer, University of Heidelberg, 2012.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinsol_8h.html">deal.II/sundials/kinsol.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step77</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    MinimalSurfaceProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">    <span class="keywordtype">void</span> solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">               Vector&lt;double&gt; &amp;      solution,</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">double</span>          tolerance);</div><div class="line">    <span class="keywordtype">void</span> refine_mesh();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line">    <span class="keywordtype">void</span> set_boundary_values();</div><div class="line">    <span class="keywordtype">void</span> compute_and_factorize_jacobian(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point);</div><div class="line">    <span class="keywordtype">void</span> compute_residual(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                          Vector&lt;double&gt; &amp;      residual);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                      sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt;                 jacobian_matrix;</div><div class="line">    std::unique_ptr&lt;SparseDirectUMFPACK&gt; jacobian_matrix_factorization;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; current_solution;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 * numbers::PI * (p[0] + p[1]));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">    : dof_handler(triangulation)</div><div class="line">    , fe(1)</div><div class="line">    , computing_timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;set up&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (initial_step)</div><div class="line">      {</div><div class="line">        dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">        current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">        hanging_node_constraints.clear();</div><div class="line">        <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                                hanging_node_constraints);</div><div class="line">        hanging_node_constraints.close();</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    jacobian_matrix.reinit(sparsity_pattern);</div><div class="line">    jacobian_matrix_factorization.reset();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_and_factorize_jacobian(</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point)</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">      jacobian_matrix = 0;</div><div class="line"></div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                              quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          cell_matrix = 0;</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                           evaluation_point_gradients);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">                1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                      evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                         * coeff                       <span class="comment">//   * a_n</span></div><div class="line">                         * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)) <span class="comment">//   * \nabla \phi_j)</span></div><div class="line">                        -                              <span class="comment">//  -</span></div><div class="line">                        (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                         * coeff * coeff * coeff       <span class="comment">//   * a_n^3</span></div><div class="line">                         *</div><div class="line">                         (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)       <span class="comment">//   * (\nabla \phi_j</span></div><div class="line">                          * evaluation_point_gradients[q]) <span class="comment">//      * \nabla u_n)</span></div><div class="line">                         * evaluation_point_gradients[q])) <span class="comment">//   * \nabla u_n)))</span></div><div class="line">                       * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));                <span class="comment">// * dx</span></div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          hanging_node_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                              local_dof_indices,</div><div class="line">                                                              jacobian_matrix);</div><div class="line">        }</div><div class="line"></div><div class="line">      std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               0,</div><div class="line">                                               <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                               boundary_values);</div><div class="line">      Vector&lt;double&gt; dummy_solution(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      Vector&lt;double&gt; dummy_rhs(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                         jacobian_matrix,</div><div class="line">                                         dummy_solution,</div><div class="line">                                         dummy_rhs);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;factorizing the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Factorizing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      jacobian_matrix_factorization = std::make_unique&lt;SparseDirectUMFPACK&gt;();</div><div class="line">      jacobian_matrix_factorization-&gt;factorize(jacobian_matrix);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">    Vector&lt;double&gt; &amp;      residual)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the residual&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing residual vector...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                         evaluation_point_gradients);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">              1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                    evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) = (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                  * coeff                    <span class="comment">// * a_n</span></div><div class="line">                                  * evaluation_point_gradients[q] <span class="comment">// * u_n</span></div><div class="line">                                  * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));            <span class="comment">// * dx</span></div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">      }</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(residual);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">         <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">      residual(i) = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">         <a class="code" href="namespaceDoFTools.html#aed6928cb7bdb5a85e8670d6bd5c90e24">DoFTools::extract_hanging_node_dofs</a>(dof_handler))</div><div class="line">      residual(i) = 0;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; norm=&quot;</span> &lt;&lt; residual.l2_norm() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                         Vector&lt;double&gt; &amp;      solution,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">double</span> <span class="comment">/*tolerance*/</span>)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;linear system solve&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Solving linear system&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    jacobian_matrix_factorization-&gt;vmult(solution, rhs);</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      current_solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line"></div><div class="line">    triangulation.prepare_coarsening_and_refinement();</div><div class="line"></div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">    solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line"></div><div class="line">    triangulation.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution_transfer.interpolate(current_solution, tmp);</div><div class="line">    current_solution = std::move(tmp);</div><div class="line"></div><div class="line">    hanging_node_constraints.clear();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                            hanging_node_constraints);</div><div class="line">    hanging_node_constraints.close();</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(current_solution);</div><div class="line"></div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">false</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">  {</div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             boundary_values);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">      current_solution(boundary_value.first) = boundary_value.second;</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(current_solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;graphical output&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">    triangulation.refine_global(2);</div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">true</span>);</div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a017cdef3c18d6050d401dab4f2f64d2e">reset</a>();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> target_tolerance = 1e-3 * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.1, refinement_cycle);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Target_tolerance: &quot;</span> &lt;&lt; target_tolerance &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        {</div><div class="line">          <span class="keyword">typename</span> <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt;::AdditionalData</div><div class="line">            additional_data;</div><div class="line">          additional_data.function_tolerance = target_tolerance;</div><div class="line"></div><div class="line">          <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt; nonlinear_solver(additional_data);</div><div class="line"></div><div class="line">          nonlinear_solver.reinit_vector = [&amp;](Vector&lt;double&gt; &amp;x) {</div><div class="line">            x.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">          };</div><div class="line"></div><div class="line">          nonlinear_solver.residual =</div><div class="line">            [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                Vector&lt;double&gt; &amp;      residual) {</div><div class="line">              compute_residual(evaluation_point, residual);</div><div class="line"></div><div class="line">              <span class="keywordflow">return</span> 0;</div><div class="line">            };</div><div class="line"></div><div class="line">          nonlinear_solver.setup_jacobian =</div><div class="line">            [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;current_u,</div><div class="line">                <span class="keyword">const</span> Vector&lt;double&gt; &amp; <span class="comment">/*current_f*/</span>) {</div><div class="line">              compute_and_factorize_jacobian(current_u);</div><div class="line"></div><div class="line">              <span class="keywordflow">return</span> 0;</div><div class="line">            };</div><div class="line"></div><div class="line">          nonlinear_solver.solve_with_jacobian = [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                                     Vector&lt;double&gt; &amp;      dst,</div><div class="line">                                                     <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance) {</div><div class="line">            this-&gt;solve(rhs, dst, tolerance);</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span> 0;</div><div class="line">          };</div><div class="line"></div><div class="line">          nonlinear_solver.solve(current_solution);</div><div class="line">        }</div><div class="line"></div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step77</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step77;</div><div class="line"></div><div class="line">      MinimalSurfaceProblem&lt;2&gt; laplace_problem_2d;</div><div class="line">      laplace_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_15.html">step-15</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#HowdealIIinterfaceswithKINSOL"> How deal.II interfaces with KINSOL </a>
        <li><a href="#Detailsoftheimplementation"> Details of the implementation </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclasstemplate">The <code>MinimalSurfaceProblem</code> class template</a>
        <li><a href="#Boundarycondition">Boundary condition</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclassimplementation">The <code>MinimalSurfaceProblem</code> class implementation</a>
      <ul>
        <li><a href="#Constructorandsetupfunctions">Constructor and set up functions</a>
        <li><a href="#AssemblingandfactorizingtheJacobianmatrix">Assembling and factorizing the Jacobian matrix</a>
        <li><a href="#Computingtheresidualvector">Computing the residual vector</a>
        <li><a href="#SolvinglinearsystemswiththeJacobianmatrix">Solving linear systems with the Jacobian matrix</a>
        <li><a href="#Refiningthemeshsettingboundaryvaluesandgeneratinggraphicaloutput">Refining the mesh, setting boundary values, and generating graphical output</a>
        <li><a href="#Therunfunctionandtheoveralllogicoftheprogram">The run() function and the overall logic of the program</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-77/doc/intro.dox</p>
<p><br />
</p>
<p><em> This program was contributed by Wolfgang Bangerth, Colorado State University.</em></p>
<p><em>This material is based upon work partially supported by National Science Foundation grants OAC-1835673, DMS-1821210, and EAR-1925595; and by the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-1550901 and The University of California-Davis. </em> <br />
 。</p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>第15步程序解决了以下描述最小表面问题的非线性方程。</p>
<p class="formulaDsp">
\begin{align*} -\nabla \cdot \left( \frac{1}{\sqrt{1+|\nabla u|^{2}}}\nabla u \right) &amp;= 0 \qquad \qquad &amp;&amp;\textrm{in} ~ \Omega \\ u&amp;=g \qquad\qquad &amp;&amp;\textrm{on} ~ \partial \Omega. \end{align*}
</p>
<p><a class="el" href="step_15.html">step-15</a>使用的是牛顿方法，牛顿方法的工作原理是反复求解一个更新 \(\delta u_k\) 的*线性化*问题&ndash;称为 "搜索方向"&ndash;计算 "步长" \(\alpha_k\) ，然后将它们结合起来，通过以下方式计算出新的猜测解。</p>
<p class="formulaDsp">
\begin{align*} u_{k+1} = u_k + \alpha_k \, \delta u_k. \end{align*}
</p>
<p>在步骤15的讨论过程中，我们发现计算步长是很尴尬的，所以只是解决了简单的选择。总是选择 \(\alpha_k=0.1\) 。这当然是没有效率的。我们知道，只有当我们最终能够选择 \(\alpha_k=1\) 时，我们才能实现牛顿的二次收敛率，尽管在最初的几次迭代中，我们可能不得不选择较小的步长，因为我们离使用这么长的步长还很遥远。</p>
<p>因此，本方案的目标之一是解决这一缺陷。由于行搜索算法的实现并不完全是微不足道的，因此人们无论如何都要做自己应该做的事。从外部库中导入复杂的功能。为此，我们将利用deal.II与大型非线性求解器包之一的接口，即<a href="https://computing.llnl.gov/projects/sundials">SUNDIALS</a>套件的<a href="https://computing.llnl.gov/projects/sundials/kinsol">KINSOL</a>子包。SUNDIALS的核心是一个用于解决复杂的常微分方程（ODE）和微分代数方程（DAE）的软件包，deal.II接口允许通过SUNDIALS命名空间的类来实现。特别是 <a class="el" href="classSUNDIALS_1_1ARKode.html">SUNDIALS::ARKode</a> 和 <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a> 类。但是，由于这是用隐式方法解决ODE和DAE的一个重要步骤，SUNDIALS也有一个非线性问题的求解器，叫做KINSOL，deal.II有一个接口，以 <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a> 类的形式与之连接。这就是我们将用于解决我们的问题的方法。</p>
<p>但是SUNDIALS不仅仅是一个方便我们避免编写线搜索算法的方法。一般来说，非线性问题的解决是相当昂贵的，人们通常希望尽可能地节省计算时间。一个可以实现这个目标的方法是如下的。第15步中的算法将问题离散化，然后在每次迭代中求解形式为的线性系统</p>
<p class="formulaDsp">
\begin{align*} J_k \, \delta U_k = -F_k \end{align*}
</p>
<p>其中 \(F_k\) 是使用当前节点值矢量 \(U_k\) 计算的残差矢量， \(J_k\) 是其导数（称为 "雅各布"），而 \(\delta U_k\) 是对应于上述函数 \(\delta u_k\) 的更新矢量。步骤15中已经彻底讨论了 \(J_k,F_k\) 的构造，以及在每个牛顿迭代中解决线性系统的方法。因此，让我们关注一下非线性求解过程的另一个方面。计算 \(F_k\) 是昂贵的，而组装矩阵 \(J_k\) 更是如此。我们真的需要在每次迭代中都这样做吗？事实证明，在许多应用中，这实际上是没有必要的。即使我们用近似值 \(\tilde J_k\) 代替 \(J_k\) ，这些方法通常也能收敛，并解决了</p>
<p class="formulaDsp">
\begin{align*} \tilde J_k \, \widetilde{\delta U}_k = -F_k \end{align*}
</p>
<p>代替，然后更新</p>
<p class="formulaDsp">
\begin{align*} U_{k+1} = U_k + \alpha_k \, \widetilde{\delta U}_k. \end{align*}
</p>
<p>这可能需要多一两个迭代，因为我们的更新 \(\widetilde{\delta U}_k\) 并不像 \(\delta U_k\) 那样好，但它可能仍然是一个胜利，因为我们不必经常组装 \(J_k\) 。</p>
<p>对于 \(J_k\) ，我们希望得到什么样的近似值 \(\tilde J_k\) ？理论上说，由于 \(U_k\) 收敛于精确解 \(U^\ast\) ，我们需要确保 \(\tilde J_k\) 需要收敛于 \(J^\ast = \nabla F(U^\ast)\) 。特别是，由于 \(J_k\rightarrow J^\ast\) ，有效的选择是 \(\tilde J_k = J_k\) 。但是每一次，比如说，第五次迭代选择 \(\tilde J_k = J_k\) 也是如此，对于其他的迭代，我们选择 \(\tilde J_k\) 等于最后计算的 \(J_{k&#39;}\) 。这就是我们在这里要做的：我们将只是重新使用前一次迭代中的 \(\tilde J_{k-1}\) ，这可能又是我们在之前的迭代中使用的， \(\tilde J_{k-2}\) 。</p>
<p>如果对于带有 \(J_k\) 的线性系统的求解，我们不只是要组装一个矩阵，还要计算一个好的预处理程序，那么这个方案就变得更加有趣。例如，如果我们要通过SparseDirectUMFPACK类使用稀疏LU分解，或者使用几何或代数多重网格。在这些情况下，我们也不必更新预处理程序，因为预处理程序的计算时间可能和当初组装矩阵的时间一样长，甚至更长。事实上，在这种心态下，我们也许应该考虑使用我们能想到的*好的前置条件器，尽管它们的构造通常相当昂贵。我们希望通过将其应用于不止一个线性求解，来摊销计算这个预处理程序的成本。</p>
<p>当然，最大的问题是。我们根据什么标准来决定我们是否可以摆脱基于先前计算的雅各布矩阵 \(J_{k-s}\) 的近似 \(s\) 步，或者我们是否需要&ndash;至少在这个迭代中&ndash;实际重新计算雅各布 \(J_k\) 和相应的前置条件器？这就像行搜索的问题一样，需要大量的代码来监控整个算法的收敛性。我们*可以*自己实现这些东西，但我们可能*不应该*。KINSOL已经为我们做了这些。它将告诉我们的代码何时要 "更新 "雅各布矩阵。</p>
<p>如果我们要使用迭代求解器而不是上面提到的稀疏直接求解器，还有最后一个考虑。在求解更新 \(\delta U_k\) 时，不仅有可能用一些近似值 \(J_k\) 代替 \(\tilde J_k\) ，而且还可以问是否有必要求解线性系统</p>
<p class="formulaDsp">
\begin{align*} \tilde J_k \widetilde{\delta U}_k = -F_k \end{align*}
</p>
<p>准确度高。其思路是这样的。虽然我们目前的解决方案 \(U_k\) 离 \(U^\ast\) 还很远，但我们为什么要特别精确地解决这个线性系统？更新后的 \(U_{k+1}=U_k + \widetilde{\delta U}_k\) 很可能仍然离精确的解决方案很远，那么为什么要花很多时间来解决这个线性系统的精确性？这就是 "Eisenstat-Walker技巧" <b>[eiwa96]</b> 等算法的基础思维，在该算法中，人们被赋予一个公差，在迭代 \(k\) 中必须解决上述线性系统，该公差取决于整个非线性求解器的进展。像以前一样，我们可以尝试自己实现，但是KINSOL已经为我们提供了这种信息&ndash;尽管我们不会在这个程序中使用它，因为我们使用的是直接求解器，不需要求解器的容忍度，只是精确求解线性系统到舍入。</p>
<p>作为对所有这些考虑的总结，我们可以说以下几点。没有必要重新发明轮子。就像deal.II提供了大量的有限元功能一样，SUNDIALS的KINSOL软件包提供了大量的非线性求解器功能，我们最好使用它。</p>
<p><a class="anchor" id="HowdealIIinterfaceswithKINSOL"></a></p><h3>How deal.II interfaces with KINSOL </h3>
<p>KINSOL，像许多类似的软件包一样，以一种相当抽象的方式工作。在其核心部分，它看到了一个非线性问题，其形式为</p>
<p class="formulaDsp">
\begin{align*} F(U) = 0 \end{align*}
</p>
<p>并构建一个迭代序列 \(U_k\) ，一般来说，迭代序列是与函数返回的向量相同长度的向量 \(F\) 。要做到这一点，它需要从用户那里得到一些东西。</p>
<ul>
<li>将一个给定的向量调整到正确大小的方法。</li>
<li>对于一个给定的向量 \(U\) ，评估函数 \(F(U)\) 的一种方法。这个函数通常被称为 "剩余 "操作，因为目标当然是找到一个点 \(U^\ast\) ，对于这个点 \(F(U^\ast)=0\) ；如果 \(F(U)\) 返回一个非零向量，那么这就是<a href="https://en.wikipedia.org/wiki/Residual_(numerical_analysis)">"residual"</a>（即 "剩余"，或任何 "剩余"）。做到这一点的函数在本质上与步骤15中的右手边向量的计算相同，但有一个重要区别。 在那里，右手边表示的是残差的*负数，所以我们必须换一个符号。</li>
<li>计算矩阵 \(J_k\) 的方法，如果这在当前迭代中是必要的，同时可能还有一个预处理程序或其他数据结构（例如，通过SparseDirectUMFPACK进行稀疏分解，如果我们选择用它来解决一个线性系统）。这个操作通常被称为 "设置 "操作。</li>
<li>用最后计算的任何矩阵 \(\tilde J_k\) 来解决一个线性系统 \(\tilde J_k x = b\) 的方法。这个操作一般被称为 "求解 "操作。</li>
</ul>
<p>所有这些操作都需要由 <a href="https://en.cppreference.com/w/cpp/utility/functional/function">std::function</a> 对象提供给KINSOL，这些对象接受适当的参数集，通常返回一个表示成功（返回值为零）或失败（返回值为非零）的整数。具体来说，我们要访问的对象是 <a class="el" href="classSUNDIALS_1_1KINSOL.html#abdccb7a76e27cd9948048fdd03949380">SUNDIALS::KINSOL::reinit_vector</a>, <a class="el" href="classSUNDIALS_1_1KINSOL.html#aa791c6b63d41c8e7b12ec227e224c72a">SUNDIALS::KINSOL::residual</a>, <a class="el" href="classSUNDIALS_1_1KINSOL.html#a199363bcae2f185e8b6c120fa9152aad">SUNDIALS::KINSOL::setup_jacobian</a>, 和 <a class="el" href="classSUNDIALS_1_1KINSOL.html#a388cbc77068ac53927b0b8b3e055a423">SUNDIALS::KINSOL::solve_jacobian_system</a> 成员变量。(详见这些变量的文档。)在我们的实现中，我们将使用<a href="https://en.cppreference.com/w/cpp/language/lambda">lambda functions</a>来实现这些 "回调"，反过来可以调用成员函数；然后KINSOL将在其内部算法认为有用时调用这些回调。</p>
<p><a class="anchor" id="Detailsoftheimplementation"></a></p><h3>Details of the implementation </h3>
<p>本教程程序的大部分代码与步骤15一样，我们将不作过多评论。实际上只有一个方面需要注意，即一方面给定一个向量 \(U\) ，另一方面给定一个向量 \(J(U)\) ，如何计算 \(U\) 。起初，这似乎很简单：我们只需使用<code>assemble_system()</code>函数，在一种情况下抛出所有处理矩阵的代码，在另一种情况下抛出右手边的向量。就这样。问题解决了。</p>
<p>但它并不那么简单。这是因为如果我们有非零的Dirichlet边界值，这两者并不独立，就像我们在这里做的那样。我们要解决的线性系统包含内部和边界自由度，当从那些真正 "自由 "的自由度中消除这些自由度时，使用例如 <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a>, ，我们在组装右手边的向量时需要知道矩阵。</p>
<p>当然，这完全违背了原意。如果我们可以不组装矩阵，就不要*组装。我们解决这个问题的方法如下。</p>
<ul>
<li>我们将解向量的起始猜测， \(U_0\) ，设定为边界自由度已经有了正确的值。</li>
<li>这意味着所有的更新都可以有这些自由度的零更新，我们可以建立残差向量 \(F(U_k)\) 和雅各布矩阵 \(J_k\) ，对应于线性系统的解在这些向量分量中为零。对于这种特殊情况，矩阵和右手边向量的组装是独立的，可以分解成不同的函数。</li>
</ul>
<p>这里有一个假设，即每当KINSOL要求用雅各布的（近似值）进行线性求解时，这将是为了更新 \(\delta U\) （其边界值为零），其倍数将被添加到解决方案（其已经有正确的边界值）。 这可能不是真的，如果是的话，我们可能要重新考虑我们的方法。也就是说，事实证明，在实践中，这正是KINSOL在使用牛顿方法时的表现，因此我们的方法是成功的。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>This program starts out like most others with well known include files. Compared to the <a class="el" href="step_15.html">step-15</a> program from which most of what we do here is copied, the only difference is the include of the header files from which we import the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class and the actual interface to KINSOL:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinsol_8h.html">deal.II/sundials/kinsol.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step77</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclasstemplate"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class template</h3>
<p>Similarly, the main class of this program is essentially a copy of the one in <a class="el" href="step_15.html">step-15</a>. The class does, however, split the computation of the Jacobian (system) matrix (and its factorization using a direct solver) and residual into separate functions for the reasons outlined in the introduction. For the same reason, the class also has a pointer to a factorization of the Jacobian matrix that is reset every time we update the Jacobian matrix.</p>
<p>(If you are wondering why the program uses a direct object for the Jacobian matrix but a pointer for the factorization: Every time KINSOL requests that the Jacobian be updated, we can simply write <code>jacobian_matrix=0;</code> to reset it to an empty matrix that we can then fill again. On the other hand, the <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> class does not have any way to throw away its content or to replace it with a new factorization, and so we use a pointer: We just throw away the whole object and create a new one whenever we have a new Jacobian matrix to factor.)</p>
<p>Finally, the class has a timer variable that we will use to assess how long the different parts of the program take so that we can assess whether KINSOL's tendency to not rebuild the matrix and its factorization makes sense. We will discuss this in the "Results" section below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  MinimalSurfaceProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">  <span class="keywordtype">void</span> solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">             Vector&lt;double&gt; &amp;      solution,</div><div class="line">             <span class="keyword">const</span> <span class="keywordtype">double</span>          tolerance);</div><div class="line">  <span class="keywordtype">void</span> refine_mesh();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line">  <span class="keywordtype">void</span> set_boundary_values();</div><div class="line">  <span class="keywordtype">void</span> compute_and_factorize_jacobian(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point);</div><div class="line">  <span class="keywordtype">void</span> compute_residual(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                        Vector&lt;double&gt; &amp;      residual);</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                      sparsity_pattern;</div><div class="line">  SparseMatrix&lt;double&gt;                 jacobian_matrix;</div><div class="line">  std::unique_ptr&lt;SparseDirectUMFPACK&gt; jacobian_matrix_factorization;</div><div class="line"></div><div class="line">  Vector&lt;double&gt; current_solution;</div><div class="line"></div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="Boundarycondition"></a> </p><h3>Boundary condition</h3>
<p>The classes implementing boundary values are a copy from <a class="el" href="step_15.html">step-15</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 * numbers::PI * (p[0] + p[1]));</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclassimplementation"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class implementation</h3>
<p><a class="anchor" id="Constructorandsetupfunctions"></a> </p><h4>Constructor and set up functions</h4>
<p>The following few functions are also essentially copies of what <a class="el" href="step_15.html">step-15</a> already does, and so there is little to discuss.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">  : dof_handler(triangulation)</div><div class="line">  , fe(1)</div><div class="line">  , computing_timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;set up&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (initial_step)</div><div class="line">    {</div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">      current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">      hanging_node_constraints.clear();</div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                              hanging_node_constraints);</div><div class="line">      hanging_node_constraints.close();</div><div class="line">    }</div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">  jacobian_matrix.reinit(sparsity_pattern);</div><div class="line">  jacobian_matrix_factorization.reset();</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="AssemblingandfactorizingtheJacobianmatrix"></a> </p><h4>Assembling and factorizing the Jacobian matrix</h4>
<p>The following function is then responsible for assembling and factorizing the Jacobian matrix. The first half of the function is in essence the <code>assemble_system()</code> function of <a class="el" href="step_15.html">step-15</a>, except that it does not deal with also forming a right hand side vector (i.e., the residual) since we do not always have to do these operations at the same time.</p>
<p>We put the whole assembly functionality into a code block enclosed by curly braces so that we can use a <a class="el" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> variable to measure how much time is spent in this code block, excluding everything that happens in this function after the matching closing brace <code>}</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_and_factorize_jacobian(</div><div class="line">  <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point)</div><div class="line">{</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">    jacobian_matrix = 0;</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        cell_matrix = 0;</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                         evaluation_point_gradients);</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">              1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                    evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              {</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                    (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                       * coeff                       <span class="comment">//   * a_n</span></div><div class="line">                       * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)) <span class="comment">//   * \nabla \phi_j)</span></div><div class="line">                      -                              <span class="comment">//  -</span></div><div class="line">                      (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                       * coeff * coeff * coeff       <span class="comment">//   * a_n^3</span></div><div class="line">                       *</div><div class="line">                       (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)       <span class="comment">//   * (\nabla \phi_j</span></div><div class="line">                        * evaluation_point_gradients[q]) <span class="comment">//      * \nabla u_n)</span></div><div class="line">                       * evaluation_point_gradients[q])) <span class="comment">//   * \nabla u_n)))</span></div><div class="line">                     * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));                <span class="comment">// * dx</span></div><div class="line">              }</div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        hanging_node_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                            local_dof_indices,</div><div class="line">                                                            jacobian_matrix);</div><div class="line">      }</div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                             boundary_values);</div><div class="line">    Vector&lt;double&gt; dummy_solution(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    Vector&lt;double&gt; dummy_rhs(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                       jacobian_matrix,</div><div class="line">                                       dummy_solution,</div><div class="line">                                       dummy_rhs);</div><div class="line">  }</div></div><!-- fragment --><p>The second half of the function then deals with factorizing the so-computed matrix. To do this, we first create a new <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> object and by assigning it to the member variable <code>jacobian_matrix_factorization</code>, we also destroy whatever object that pointer previously pointed to (if any). Then we tell the object to factorize the Jacobian.</p>
<p>As above, we enclose this block of code into curly braces and use a timer to assess how long this part of the program takes.</p>
<p>(Strictly speaking, we don't actually need the matrix any more after we are done here, and could throw the matrix object away. A code intended to be memory efficient would do this, and only create the matrix object in this function, rather than as a member variable of the surrounding class. We omit this step here because using the same coding style as in previous tutorial programs breeds familiarity with the common style and helps make these tutorial programs easier to read.)</p>
<div class="fragment"><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;factorizing the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Factorizing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    jacobian_matrix_factorization = std::make_unique&lt;SparseDirectUMFPACK&gt;();</div><div class="line">    jacobian_matrix_factorization-&gt;factorize(jacobian_matrix);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Computingtheresidualvector"></a> </p><h4>Computing the residual vector</h4>
<p>The second part of what <code>assemble_system()</code> used to do in <a class="el" href="step_15.html">step-15</a> is computing the residual vector, i.e., the right hand side vector of the Newton linear systems. We have broken this out of the previous function, but the following function will be easy to understand if you understood what <code>assemble_system()</code> in <a class="el" href="step_15.html">step-15</a> did. Importantly, however, we need to compute the residual not linearized around the current solution vector, but whatever we get from KINSOL. This is necessary for operations such as line search where we want to know what the residual \(F(U^k + \alpha_k \delta U^K)\) is for different values of \(\alpha_k\); KINSOL in those cases simply gives us the argument to the function \(F\) and we then compute the residual \(F(\cdot)\) at this point.</p>
<p>The function prints the norm of the so-computed residual at the end as a way for us to follow along the progress of the program.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(</div><div class="line">  <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">  Vector&lt;double&gt; &amp;      residual)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the residual&quot;</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing residual vector...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                          quadrature_formula,</div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">  Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">    {</div><div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                       evaluation_point_gradients);</div><div class="line"></div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">            1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                  evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) = (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                * coeff                    <span class="comment">// * a_n</span></div><div class="line">                                * evaluation_point_gradients[q] <span class="comment">// * u_n</span></div><div class="line">                                * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));            <span class="comment">// * dx</span></div><div class="line">        }</div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">        residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">    }</div><div class="line"></div><div class="line">  hanging_node_constraints.condense(residual);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">       <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">    residual(i) = 0;</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">       <a class="code" href="namespaceDoFTools.html#aed6928cb7bdb5a85e8670d6bd5c90e24">DoFTools::extract_hanging_node_dofs</a>(dof_handler))</div><div class="line">    residual(i) = 0;</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot; norm=&quot;</span> &lt;&lt; residual.<a class="code" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">l2_norm</a>() &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="SolvinglinearsystemswiththeJacobianmatrix"></a> </p><h4>Solving linear systems with the Jacobian matrix</h4>
<p>Next up is the function that implements the solution of a linear system with the Jacobian matrix. Since we have already factored the matrix when we built the matrix, solving a linear system comes down to applying the inverse matrix to the given right hand side vector: This is what the <a class="el" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">SparseDirectUMFPACK::vmult()</a> function does that we use here. Following this, we have to make sure that we also address the values of hanging nodes in the solution vector, and this is done using <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a>.</p>
<p>The function takes an additional, but unused, argument <code>tolerance</code> that indicates how accurately we have to solve the linear system. The meaning of this argument is discussed in the introduction in the context of the "Eisenstat Walker trick", but since we are using a direct rather than an iterative solver, we are not using this opportunity to solve linear systems only inexactly.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                       Vector&lt;double&gt; &amp;      solution,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> <span class="comment">/*tolerance*/</span>)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;linear system solve&quot;</span>);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Solving linear system&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  jacobian_matrix_factorization-&gt;vmult(solution, rhs);</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(solution);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Refiningthemeshsettingboundaryvaluesandgeneratinggraphicaloutput"></a> </p><h4>Refining the mesh, setting boundary values, and generating graphical output</h4>
<p>The following three functions are again simply copies of the ones in <a class="el" href="step_15.html">step-15</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">{</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    dof_handler,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">    current_solution,</div><div class="line">    estimated_error_per_cell);</div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.03);</div><div class="line"></div><div class="line">  triangulation.prepare_coarsening_and_refinement();</div><div class="line"></div><div class="line">  <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">  solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line"></div><div class="line">  triangulation.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">  Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  solution_transfer.interpolate(current_solution, tmp);</div><div class="line">  current_solution = std::move(tmp);</div><div class="line"></div><div class="line">  hanging_node_constraints.clear();</div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                          hanging_node_constraints);</div><div class="line">  hanging_node_constraints.close();</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(current_solution);</div><div class="line"></div><div class="line">  set_boundary_values();</div><div class="line"></div><div class="line">  setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">false</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">{</div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                           0,</div><div class="line">                                           BoundaryValues&lt;dim&gt;(),</div><div class="line">                                           boundary_values);</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">    current_solution(boundary_value.first) = boundary_value.second;</div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(current_solution);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;graphical output&quot;</span>);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename =</div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">  std::ofstream output(filename);</div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Therunfunctionandtheoveralllogicoftheprogram"></a> </p><h4>The <a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a> function and the overall logic of the program</h4>
<p>The only function that <em>really</em> is interesting in this program is the one that drives the overall algorithm of starting on a coarse mesh, doing some mesh refinement cycles, and on each mesh using KINSOL to find the solution of the nonlinear algebraic equation we obtain from discretization on this mesh. The <code>refine_mesh()</code> function above makes sure that the solution on one mesh is used as the starting guess on the next mesh. We also use a <a class="el" href="classTimerOutput.html">TimerOutput</a> object to measure how much time every operation on each mesh costs, and reset the timer at the beginning of each cycle.</p>
<p>As discussed in the introduction, it is not necessary to solve problems on coarse meshes particularly accurately since these will only solve as starting guesses for the next mesh. As a consequence, we will use a target tolerance of \(\tau=10^{-3} \frac{1}{10^k}\) for the \(k\)th mesh refinement cycle.</p>
<p>All of this is encoded in the first part of this function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">  triangulation.refine_global(2);</div><div class="line"></div><div class="line">  setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">true</span>);</div><div class="line">  set_boundary_values();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">       ++refinement_cycle)</div><div class="line">    {</div><div class="line">      computing_timer.<a class="code" href="classTimerOutput.html#a017cdef3c18d6050d401dab4f2f64d2e">reset</a>();</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">        refine_mesh();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> target_tolerance = 1e-3 * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.1, refinement_cycle);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Target_tolerance: &quot;</span> &lt;&lt; target_tolerance &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl;</div></div><!-- fragment --><p>This is where the fun starts. At the top we create the KINSOL solver object and feed it with an object that encodes a number of additional specifics (of which we only change the nonlinear tolerance we want to reach; but you might want to look into what other members the <a class="el" href="classSUNDIALS_1_1KINSOL_1_1AdditionalData.html">SUNDIALS::KINSOL::AdditionalData</a> class has and play with them).</p>
<div class="fragment"><div class="line">{</div><div class="line">  <span class="keyword">typename</span> <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt;::AdditionalData</div><div class="line">    additional_data;</div><div class="line">  additional_data.function_tolerance = target_tolerance;</div><div class="line"></div><div class="line">  <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt; nonlinear_solver(additional_data);</div></div><!-- fragment --><p>Then we have to describe the operations that were already mentioned in the introduction. In essence, we have to teach KINSOL how to (i) resize a vector to the correct size, (ii) compute the residual vector, (iii) compute the Jacobian matrix (during which we also compute its factorization), and (iv) solve a linear system with the Jacobian.</p>
<p>All four of these operations are represented by member variables of the <a class="el" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL</a> class that are of type <code>std::function</code>, i.e., they are objects to which we can assign a pointer to a function or, as we do here, a "lambda function" that takes the appropriate arguments and returns the appropriate information. By convention, KINSOL wants that functions doing something nontrivial return an integer where zero indicates success. It turns out that we can do all of this in just 25 lines of code.</p>
<p>(If you're not familiar what "lambda functions" are, take a look at <a class="el" href="step_12.html">step-12</a> or at the <a href="https://en.wikipedia.org/wiki/Anonymous_function">wikipedia page</a> on the subject. The idea of lambda functions is that one wants to define a function with a certain set of arguments, but (i) not make it a named functions because, typically, the function is used in only one place and it seems unnecessary to give it a global name; and (ii) that the function has access to some of the variables that exist at the place where it is defined, including member variables. The syntax of lambda functions is awkward, but ultimately quite useful.)</p>
<p>At the very end of the code block we then tell KINSOL to go to work and solve our problem. The member functions called from the 'residual', 'setup_jacobian', and 'solve_jacobian_system' functions will then print output to screen that allows us to follow along with the progress of the program.</p>
<div class="fragment"><div class="line">  nonlinear_solver.reinit_vector = [&amp;](Vector&lt;double&gt; &amp;x) {</div><div class="line">    x.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">  };</div><div class="line"></div><div class="line">  nonlinear_solver.residual =</div><div class="line">    [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">        Vector&lt;double&gt; &amp;      residual) {</div><div class="line">      compute_residual(evaluation_point, residual);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    };</div><div class="line"></div><div class="line">  nonlinear_solver.setup_jacobian =</div><div class="line">    [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;current_u,</div><div class="line">        <span class="keyword">const</span> Vector&lt;double&gt; &amp; <span class="comment">/*current_f*/</span>) {</div><div class="line">      compute_and_factorize_jacobian(current_u);</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 0;</div><div class="line">    };</div><div class="line"></div><div class="line">  nonlinear_solver.solve_with_jacobian = [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                             Vector&lt;double&gt; &amp;      dst,</div><div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance) {</div><div class="line">    this-&gt;solve(rhs, dst, tolerance);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  };</div><div class="line"></div><div class="line">  nonlinear_solver.solve(current_solution);</div><div class="line">}</div></div><!-- fragment --><p>The rest is then just house-keeping: Writing data to a file for visualizing, and showing a summary of the timing collected so that we can interpret how long each operation has taken, how often it was executed, etc:</p>
<div class="fragment"><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step77</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step77;</div><div class="line"></div><div class="line">      MinimalSurfaceProblem&lt;2&gt; laplace_problem_2d;</div><div class="line">      laplace_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-77/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>当运行该程序时，你得到的输出看起来像这样。</p>
<div class="fragment"><div class="line">Mesh refinement step 0</div><div class="line">  Target_tolerance: 0.001</div><div class="line"></div><div class="line"></div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Computing residual vector... norm=0.127245</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Computing residual vector... norm=0.0625301</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0625301</div><div class="line">  Computing residual vector... norm=0.0498864</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0498864</div><div class="line">  Computing residual vector... norm=0.0407765</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0407765</div><div class="line">  Computing residual vector... norm=0.0341589</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0341589</div><div class="line">  Computing residual vector... norm=0.0292867</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0292867</div><div class="line">  Computing residual vector... norm=0.0256309</div><div class="line">  Computing residual vector... norm=0.0223448</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0223448</div><div class="line">  Computing residual vector... norm=0.0202797</div><div class="line">  Computing residual vector... norm=0.0183817</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0183817</div><div class="line">  Computing residual vector... norm=0.0170464</div><div class="line">  Computing residual vector... norm=0.0157967</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0157967</div><div class="line">  Computing residual vector... norm=0.0141572</div><div class="line">  Computing residual vector... norm=0.012657</div><div class="line"> Solving linear system</div><div class="line">  Computing residual vector... norm=0.012657</div><div class="line">  Computing residual vector... norm=0.0116863</div><div class="line">  Computing residual vector... norm=0.0107696</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0107696</div><div class="line">  Computing residual vector... norm=0.0100986</div><div class="line">  Computing residual vector... norm=0.00944829</div><div class="line">  Computing residual vector... norm=0.00822576</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00822576</div><div class="line">  Computing residual vector... norm=0.00781983</div><div class="line">  Computing residual vector... norm=0.00741619</div><div class="line">  Computing residual vector... norm=0.00661792</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00661792</div><div class="line">  Computing residual vector... norm=0.00630571</div><div class="line">  Computing residual vector... norm=0.00599457</div><div class="line">  Computing residual vector... norm=0.00537663</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00537663</div><div class="line">  Computing residual vector... norm=0.00512813</div><div class="line">  Computing residual vector... norm=0.00488033</div><div class="line">  Computing residual vector... norm=0.00438751</div><div class="line">  Computing residual vector... norm=0.00342052</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00342052</div><div class="line">  Computing residual vector... norm=0.00326581</div><div class="line">  Computing residual vector... norm=0.00311176</div><div class="line">  Computing residual vector... norm=0.00280617</div><div class="line">  Computing residual vector... norm=0.00220992</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00220992</div><div class="line">  Computing residual vector... norm=0.00209976</div><div class="line">  Computing residual vector... norm=0.00199943</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.00199942</div><div class="line">  Computing residual vector... norm=0.00190953</div><div class="line">  Computing residual vector... norm=0.00182005</div><div class="line">  Computing residual vector... norm=0.00164259</div><div class="line">  Computing residual vector... norm=0.00129652</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |     0.192s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| assembling the Jacobian         |         2 |    0.0141s |       7.4% |</div><div class="line">| assembling the residual         |        61 |     0.168s |        88% |</div><div class="line">| factorizing the Jacobian        |         2 |    0.0016s |      0.83% |</div><div class="line">| graphical output                |         1 |   0.00385s |         2% |</div><div class="line">| linear system solve             |        19 |    0.0013s |      0.68% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">Mesh refinement step 1</div><div class="line">  Target_tolerance: 0.0001</div><div class="line"></div><div class="line"></div><div class="line">  Computing residual vector... norm=0.0883422</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0883422</div><div class="line">  Computing residual vector... norm=0.0607066</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0607066</div><div class="line">  Computing residual vector... norm=0.0437266</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0437266</div><div class="line">  Computing residual vector... norm=0.0327999</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0327999</div><div class="line">  Computing residual vector... norm=0.0255418</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0255417</div><div class="line">  Computing residual vector... norm=0.0206042</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0206042</div><div class="line">  Computing residual vector... norm=0.0171602</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0171602</div><div class="line">  Computing residual vector... norm=0.014689</div><div class="line">  Solving linear system</div><div class="line"></div><div class="line"></div><div class="line">[...]</div></div><!-- fragment --><p>通过查看第一个网格上的输出的前几行，应该最容易解释这种方式。</p>
<div class="fragment"><div class="line">Mesh refinement step 0</div><div class="line">Mesh refinement step 0</div><div class="line">  Target_tolerance: 0.001</div><div class="line"></div><div class="line"></div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing Jacobian matrix</div><div class="line">  Factorizing Jacobian matrix</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.231202</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.171585</div><div class="line">  Computing residual vector... norm=0.127245</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  Solving linear system</div><div class="line">  Computing residual vector... norm=0.0796471</div><div class="line">  ...</div></div><!-- fragment --><p>现在的情况是这样的。</p>
<ul>
<li>在第一次残差计算中，KINSOL计算残差以查看是否达到了所需的公差。答案是否定的，所以它要求用户程序计算雅各布矩阵（然后该函数还通过SparseDirectUMFPACK对矩阵进行因子化）。</li>
<li>然后KINSOL指示我们用这个矩阵和之前计算的残差向量来解决一个形式为 \(J_k \, \delta U_k = -F_k\) 的线性系统。</li>
<li>然后就是确定我们要在这个方向上走多远，也就是做线搜索。为此，KINSOL要求我们计算不同步长 \(\alpha_k\) 的残差向量 \(F(U_k + \alpha_k \delta U_k)\) 。对于上面的第一步，它在尝试了两次后找到了一个可接受的 \(\alpha_k\) ，第二次则需要尝试三次。</li>
<li>在找到一个合适的更新解 \(U_{k+1}\) 之后，这个过程被重复，只是现在KINSOL对当前的雅各布矩阵很满意，没有指示我们重新建立矩阵和它的因式分解，而是要求我们用同一个矩阵解决一个线性系统。</li>
</ul>
<p>在每个网格细化周期结束时，程序也会将解决方案写入VTU文件，它看起来如下。 </p><table width="60%" align="center">
<tr>
<td align="center"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-77.solution.png"/>
</div>
   </td></tr>
</table>
<p>该计划的主要收获信息如下。</p>
<ul>
<li>这个解和我们在步骤15中计算的解是一样的，也就是说，SUNDIALS的KINSOL包的接口确实做了它们应该做的事。这不应该是一个惊喜，但重要的一点是，我们不必自己花时间去实现高级非线性求解器所依据的复杂算法。</li>
<li>KINSOL能够避免各种操作，比如在实际上没有必要的时候重建雅各布矩阵。将上述输出中的线性求解次数与我们重建雅各布矩阵和计算其因式分解的次数相比较，应该可以清楚地看到，这在计算时间上带来了非常可观的节省，而我们却不需要实现复杂的算法来确定何时需要重建这些信息。</li>
</ul>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>除了我们在这里考虑的小问题之外，稀疏的直接求解器需要太多的时间和内存&ndash;我们需要一个迭代求解器，就像我们在许多其他程序中使用的那样。然而，在目前的情况下，构建一个昂贵的预处理程序（例如，一个几何或代数多重网格方法）的权衡是不同的。由于我们可以在许多线性求解中重复使用同一个矩阵，我们也可以对预处理程序做同样的处理，与我们只在单一线性求解中使用预处理程序相比，在构建一个好的预处理程序上投入更多的工作更容易被证明，就像在许多其他情况下一样。</p>
<p>但迭代求解器也提供了其他机会。例如（正如在介绍中简要讨论的那样），只要我们离实际的解还很远，我们可能不需要在早期的非线性迭代中解到非常高的精度（小公差）。这就是那里提到的Eisenstat-Walker技巧的基础。</p>
<p>KINSOL提供了做线性解的函数，有一个需要达到的目标公差。我们在上面的程序中忽略了它，因为我们使用的直接求解器不需要公差，而是精确地求解线性系统（当然是四舍五入），但是迭代求解器可以利用这种信息&ndash;事实上也应该如此。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Wolfgang Bangerth, Colorado State University, 2021.</span></div><div class="line"><span class="comment"> * Based on @ref step_15 &quot;step-15&quot; by Sven Wetterauer, University of Heidelberg, 2012.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__accessor_8h.html">deal.II/dofs/dof_accessor.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="kinsol_8h.html">deal.II/sundials/kinsol.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step77</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>MinimalSurfaceProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    MinimalSurfaceProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step);</div><div class="line">    <span class="keywordtype">void</span> solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">               Vector&lt;double&gt; &amp;      solution,</div><div class="line">               <span class="keyword">const</span> <span class="keywordtype">double</span>          tolerance);</div><div class="line">    <span class="keywordtype">void</span> refine_mesh();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle);</div><div class="line">    <span class="keywordtype">void</span> set_boundary_values();</div><div class="line">    <span class="keywordtype">void</span> compute_and_factorize_jacobian(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point);</div><div class="line">    <span class="keywordtype">void</span> compute_residual(<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                          Vector&lt;double&gt; &amp;      residual);</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler;</div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe;</div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>                      sparsity_pattern;</div><div class="line">    SparseMatrix&lt;double&gt;                 jacobian_matrix;</div><div class="line">    std::unique_ptr&lt;SparseDirectUMFPACK&gt; jacobian_matrix_factorization;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; current_solution;</div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> computing_timer;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p,</div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p,</div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 * numbers::PI * (p[0] + p[1]));</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem()</div><div class="line">    : dof_handler(triangulation)</div><div class="line">    , fe(1)</div><div class="line">    , computing_timer(<a class="code" href="namespacestd.html">std</a>::cout, <a class="code" href="classTimerOutput.html">TimerOutput</a>::never, <a class="code" href="classTimerOutput.html">TimerOutput</a>::wall_times)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;set up&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (initial_step)</div><div class="line">      {</div><div class="line">        dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line">        current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line"></div><div class="line">        hanging_node_constraints.clear();</div><div class="line">        <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                                hanging_node_constraints);</div><div class="line">        hanging_node_constraints.close();</div><div class="line">      }</div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(dsp);</div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp);</div><div class="line">    jacobian_matrix.reinit(sparsity_pattern);</div><div class="line">    jacobian_matrix_factorization.reset();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_and_factorize_jacobian(</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point)</div><div class="line">  {</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line"></div><div class="line">      jacobian_matrix = 0;</div><div class="line"></div><div class="line">      <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(fe,</div><div class="line">                              quadrature_formula,</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell);</div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">      std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">        {</div><div class="line">          cell_matrix = 0;</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">          fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                           evaluation_point_gradients);</div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">            {</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">                1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                      evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">                {</div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j)</div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) +=</div><div class="line">                      (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">// ((\nabla \phi_i</span></div><div class="line">                         * coeff                       <span class="comment">//   * a_n</span></div><div class="line">                         * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)) <span class="comment">//   * \nabla \phi_j)</span></div><div class="line">                        -                              <span class="comment">//  -</span></div><div class="line">                        (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)    <span class="comment">//  (\nabla \phi_i</span></div><div class="line">                         * coeff * coeff * coeff       <span class="comment">//   * a_n^3</span></div><div class="line">                         *</div><div class="line">                         (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)       <span class="comment">//   * (\nabla \phi_j</span></div><div class="line">                          * evaluation_point_gradients[q]) <span class="comment">//      * \nabla u_n)</span></div><div class="line">                         * evaluation_point_gradients[q])) <span class="comment">//   * \nabla u_n)))</span></div><div class="line">                       * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));                <span class="comment">// * dx</span></div><div class="line">                }</div><div class="line">            }</div><div class="line"></div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">          hanging_node_constraints.distribute_local_to_global(cell_matrix,</div><div class="line">                                                              local_dof_indices,</div><div class="line">                                                              jacobian_matrix);</div><div class="line">        }</div><div class="line"></div><div class="line">      std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">      <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                               0,</div><div class="line">                                               <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                               boundary_values);</div><div class="line">      Vector&lt;double&gt; dummy_solution(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      Vector&lt;double&gt; dummy_rhs(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">      <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values,</div><div class="line">                                         jacobian_matrix,</div><div class="line">                                         dummy_solution,</div><div class="line">                                         dummy_rhs);</div><div class="line">    }</div><div class="line"></div><div class="line">    {</div><div class="line">      <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;factorizing the Jacobian&quot;</span>);</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Factorizing Jacobian matrix&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      jacobian_matrix_factorization = std::make_unique&lt;SparseDirectUMFPACK&gt;();</div><div class="line">      jacobian_matrix_factorization-&gt;factorize(jacobian_matrix);</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(</div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">    Vector&lt;double&gt; &amp;      residual)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembling the residual&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Computing residual vector...&quot;</span> &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1);</div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe,</div><div class="line">                            quadrature_formula,</div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell();</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div><div class="line"></div><div class="line">    Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell);</div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; evaluation_point_gradients(n_q_points);</div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>())</div><div class="line">      {</div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0;</div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell);</div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point,</div><div class="line">                                         evaluation_point_gradients);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q)</div><div class="line">          {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff =</div><div class="line">              1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1 + evaluation_point_gradients[q] *</div><div class="line">                                    evaluation_point_gradients[q]);</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) = (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i</span></div><div class="line">                                  * coeff                    <span class="comment">// * a_n</span></div><div class="line">                                  * evaluation_point_gradients[q] <span class="comment">// * u_n</span></div><div class="line">                                  * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));            <span class="comment">// * dx</span></div><div class="line">          }</div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i)</div><div class="line">          residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i);</div><div class="line">      }</div><div class="line"></div><div class="line">    hanging_node_constraints.condense(residual);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">         <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler))</div><div class="line">      residual(i) = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i :</div><div class="line">         <a class="code" href="namespaceDoFTools.html#aed6928cb7bdb5a85e8670d6bd5c90e24">DoFTools::extract_hanging_node_dofs</a>(dof_handler))</div><div class="line">      residual(i) = 0;</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; norm=&quot;</span> &lt;&lt; residual.l2_norm() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve(<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                         Vector&lt;double&gt; &amp;      solution,</div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">double</span> <span class="comment">/*tolerance*/</span>)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;linear system solve&quot;</span>);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Solving linear system&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    jacobian_matrix_factorization-&gt;vmult(solution, rhs);</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells());</div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">      dof_handler,</div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1),</div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(),</div><div class="line">      current_solution,</div><div class="line">      estimated_error_per_cell);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    estimated_error_per_cell,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.03);</div><div class="line"></div><div class="line">    triangulation.prepare_coarsening_and_refinement();</div><div class="line"></div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler);</div><div class="line">    solution_transfer.prepare_for_coarsening_and_refinement(current_solution);</div><div class="line"></div><div class="line">    triangulation.execute_coarsening_and_refinement();</div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe);</div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">    solution_transfer.interpolate(current_solution, tmp);</div><div class="line">    current_solution = std::move(tmp);</div><div class="line"></div><div class="line">    hanging_node_constraints.clear();</div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler,</div><div class="line">                                            hanging_node_constraints);</div><div class="line">    hanging_node_constraints.close();</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(current_solution);</div><div class="line"></div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">false</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values()</div><div class="line">  {</div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values;</div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler,</div><div class="line">                                             0,</div><div class="line">                                             BoundaryValues&lt;dim&gt;(),</div><div class="line">                                             boundary_values);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;boundary_value : boundary_values)</div><div class="line">      current_solution(boundary_value.first) = boundary_value.second;</div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(current_solution);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results(</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;graphical output&quot;</span>);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>);</div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename =</div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>;</div><div class="line">    std::ofstream output(filename);</div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output);</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation);</div><div class="line">    triangulation.refine_global(2);</div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*initial_step=*/</span><span class="keyword">true</span>);</div><div class="line">    set_boundary_values();</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle = 0; refinement_cycle &lt; 6;</div><div class="line">         ++refinement_cycle)</div><div class="line">      {</div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a017cdef3c18d6050d401dab4f2f64d2e">reset</a>();</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle != 0)</div><div class="line">          refine_mesh();</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> target_tolerance = 1e-3 * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(0.1, refinement_cycle);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Target_tolerance: &quot;</span> &lt;&lt; target_tolerance &lt;&lt; std::endl</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        {</div><div class="line">          <span class="keyword">typename</span> <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt;::AdditionalData</div><div class="line">            additional_data;</div><div class="line">          additional_data.function_tolerance = target_tolerance;</div><div class="line"></div><div class="line">          <a class="code" href="classSUNDIALS_1_1KINSOL.html">SUNDIALS::KINSOL&lt;Vector&lt;double&gt;</a>&gt; nonlinear_solver(additional_data);</div><div class="line"></div><div class="line">          nonlinear_solver.reinit_vector = [&amp;](Vector&lt;double&gt; &amp;x) {</div><div class="line">            x.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>());</div><div class="line">          };</div><div class="line"></div><div class="line">          nonlinear_solver.residual =</div><div class="line">            [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;evaluation_point,</div><div class="line">                Vector&lt;double&gt; &amp;      residual) {</div><div class="line">              compute_residual(evaluation_point, residual);</div><div class="line"></div><div class="line">              <span class="keywordflow">return</span> 0;</div><div class="line">            };</div><div class="line"></div><div class="line">          nonlinear_solver.setup_jacobian =</div><div class="line">            [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;current_u,</div><div class="line">                <span class="keyword">const</span> Vector&lt;double&gt; &amp; <span class="comment">/*current_f*/</span>) {</div><div class="line">              compute_and_factorize_jacobian(current_u);</div><div class="line"></div><div class="line">              <span class="keywordflow">return</span> 0;</div><div class="line">            };</div><div class="line"></div><div class="line">          nonlinear_solver.solve_with_jacobian = [&amp;](<span class="keyword">const</span> Vector&lt;double&gt; &amp;rhs,</div><div class="line">                                                     Vector&lt;double&gt; &amp;      dst,</div><div class="line">                                                     <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance) {</div><div class="line">            this-&gt;solve(rhs, dst, tolerance);</div><div class="line"></div><div class="line">            <span class="keywordflow">return</span> 0;</div><div class="line">          };</div><div class="line"></div><div class="line">          nonlinear_solver.solve(current_solution);</div><div class="line">        }</div><div class="line"></div><div class="line">        output_results(refinement_cycle);</div><div class="line"></div><div class="line">        computing_timer.<a class="code" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a>();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step77</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      <span class="keyword">using namespace </span>Step77;</div><div class="line"></div><div class="line">      MinimalSurfaceProblem&lt;2&gt; laplace_problem_2d;</div><div class="line">      laplace_problem_2d.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
