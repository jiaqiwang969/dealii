<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_12.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-12 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-12 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_7.html">step-7</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Overview">Overview</a>
        <li><a href="#Theequation">The equation</a>
        <li><a href="#Thetestproblem">The test problem</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#TheScratchDataandCopyDataclasses">The ScratchData and CopyData classes</a>
        <li><a href="#TheAdvectionProblemclass">The AdvectionProblem class</a>
      <ul>
        <li><a href="#Theassemble_systemfunction">The assemble_system function</a>
      </ul>
        <li><a href="#Alltherest">All the rest</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Whyusediscontinuouselements">Why use discontinuous elements</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br />
</p>
<p><em> Note: A variant called <a class="el" href="step_12b.html">step-12b</a> of this tutorial exists, using <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> and <a class="el" href="namespaceLocalIntegrators.html" title="Library of integrals over cells and faces 这个命名空间包含了双线性形式、形式和误差估计的特定应用局部\x{00E7}...">LocalIntegrators</a> instead of assembling matrices using <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a> as is done in this tutorial. </em></p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="AnexampleofanadvectionproblemusingtheDiscountinuousGalerkinmethod"></a></p><h1>An example of an advection problem using the Discountinuous Galerkin method</h1>
<p><a class="anchor" id="Overview"></a></p><h3>Overview</h3>
<p>This example is devoted to the <em>discontinuous Galerkin method</em>, or in short, the DG method. It includes the following topics. </p><ol>
<li>
Discretization of the linear advection equation with the DG method. </li>
<li>
Assembling of jump terms and other expressions on the interface between cells using <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a>. </li>
<li>
Assembling of the system matrix using the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>. </li>
</ol>
<p>The particular concern of this program are the loops of DG methods. These turn out to be especially complex, primarily because for the face terms, we have to distinguish the cases of boundary, regular interior faces and interior faces with hanging nodes, respectively. The <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> handles the complexity on iterating over cells and faces and allows specifying "workers" for the different cell and face terms. The integration of face terms itself, including on adaptively refined faces, is done using the <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a> class.</p>
<p><a class="anchor" id="Theequation"></a></p><h3>The equation</h3>
<p>The model problem solved in this example is the linear advection equation </p><p class="formulaDsp">
\[ \nabla\cdot \left({\mathbf \beta} u\right)=0 \qquad\mbox{in }\Omega, \]
</p>
<p> subject to the boundary conditions </p><p class="formulaDsp">
\[ u=g\quad\mbox{on }\Gamma_-, \]
</p>
<p> on the inflow part \(\Gamma_-\) of the boundary \(\Gamma=\partial\Omega\) of the domain. Here, \({\mathbf \beta}={\mathbf \beta}({\bf x})\) denotes a vector field, \(u\) the (scalar) solution function, \(g\) a boundary value function, </p><p class="formulaDsp">
\[ \Gamma_- \dealcoloneq \{{\bf x}\in\Gamma, {\mathbf \beta}({\bf x})\cdot{\bf n}({\bf x})&lt;0\} \]
</p>
<p> the inflow part of the boundary of the domain and \({\bf n}\) denotes the unit outward normal to the boundary \(\Gamma\). This equation is the conservative version of the advection equation already considered in <a class="el" href="step_9.html">step-9</a> of this tutorial.</p>
<p>On each cell \(T\), we multiply by a test function \(v_h\) from the left and integrate by parts to get: </p><p class="formulaDsp">
\[ \left( v_h, \nabla \cdot (\beta u_h) \right)_T = -(\nabla v_h, \beta u_h) + \int_\Gamma v_h u_h \beta \cdot n \]
</p>
<p> When summing this expression over all cells \(T\), the boundary integral is done over all internal and external faces and as such there are three cases: </p><ol>
<li>
outer boundary on the inflow (we replace \(u_h\) by given \(g\)): \(\int_{\Gamma_-} v_h g \beta \cdot n\) </li>
<li>
outer boundary on the outflow: \(\int_{\Gamma_+} v_h u_h \beta \cdot n\) </li>
<li>
inner faces (integral from two sides turns into jump, we use the upwind velocity): \(\int_F [v_h] u_h^{\text{upwind}} \beta \cdot n\) </li>
</ol>
<p>Here, the jump is defined as \([v] = v^+ - v^-\), where the superscripts refer to the left ('+') and right ('-') values at the face. The upwind value \(u^{\text{upwind}}\) is defined to be \(u^+\) if \(\beta \cdot n&gt;0\) and \(u^-\) otherwise.</p>
<p>As a result, the mesh-dependent weak form reads: </p><p class="formulaDsp">
\[ \sum_{T\in \mathbb T_h} -\bigl(\nabla \phi_i,{\mathbf \beta}\cdot \phi_j \bigr)_T + \sum_{F\in\mathbb F_h^i} \bigl&lt; [\phi_i], \phi_j^{upwind} \beta\cdot \mathbf n\bigr&gt;_{F} + \bigl&lt;\phi_i, \phi_j \beta\cdot \mathbf n\bigr&gt;_{\Gamma_+} = -\bigl&lt;\phi_i, g \beta\cdot\mathbf n\bigr&gt;_{\Gamma_-}. \]
</p>
<p> Here, \(\mathbb T_h\) is the set of all active cells of the triangulation and \(\mathbb F_h^i\) is the set of all active interior faces. This formulation is known as the upwind discontinuous Galerkin method.</p>
<p>In order to implement this bilinear form, we need to compute the cell terms (first sum) using the usual way to achieve integration on a cell, the interface terms (second sum) using <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a>, and the boundary terms (the other two terms). The summation of all those is done by <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>.</p>
<p><a class="anchor" id="Thetestproblem"></a></p><h3>The test problem</h3>
<p>We solve the advection equation on \(\Omega=[0,1]^2\) with \({\mathbf \beta}=\frac{1}{|x|}(-x_2, x_1)\) representing a circular counterclockwise flow field, and \(g=1\) on \({\bf x}\in\Gamma_-^1 := [0,0.5]\times\{0\}\) and \(g=0\) on \({\bf x}\in \Gamma_-\setminus \Gamma_-^1\).</p>
<p>We solve on a sequence of meshes by refining the mesh adaptively by estimating the norm of the gradient on each cell. After solving on each mesh, we output the solution in vtk format and compute the \(L^\infty\) norm of the solution. As the exact solution is either 0 or 1, we can measure the magnitude of the overshoot of the numerical solution with this.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>The first few files have already been covered in previous examples and will thus not be further commented on:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q1_8h.html">deal.II/fe/mapping_q1.h</a>&gt;</span></div></div><!-- fragment --><p>Here the discontinuous finite elements are defined. They are used in the same way as all other finite elements, though &ndash; as you have seen in previous tutorial programs &ndash; there isn't much user interaction with finite element classes at all: they are passed to <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> and <code><a class="el" href="classFEValues.html">FEValues</a></code> objects, and that is about it.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div></div><!-- fragment --><p>This header is needed for <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a> to compute integrals on interfaces:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__interface__values_8h.html">deal.II/fe/fe_interface_values.h</a>&gt;</span></div></div><!-- fragment --><p>We are going to use the simplest possible solver, called Richardson iteration, that represents a simple defect correction. This, in combination with a block SSOR preconditioner (defined in <a class="el" href="precondition__block_8h.html">precondition_block.h</a>), that uses the special block matrix structure of system matrices arising from DG discretizations.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__richardson_8h.html">deal.II/lac/solver_richardson.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition__block_8h.html">deal.II/lac/precondition_block.h</a>&gt;</span></div></div><!-- fragment --><p>We are going to use gradients as refinement indicator.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="derivative__approximation_8h.html">deal.II/numerics/derivative_approximation.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, the new include file for using the mesh_loop from the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div></div><!-- fragment --><p>Like in all programs, we finish this section by including the needed C++ headers and declaring we want to use objects in the dealii namespace without prefix.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step12</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>First, we define a class describing the inhomogeneous boundary data. Since only its values are used, we implement value_list(), but leave all other functions of <a class="el" href="classFunction.html">Function</a> undefined.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoundaryValues() = <span class="keywordflow">default</span>;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                          std::vector&lt;double&gt; &amp;          <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div></div><!-- fragment --><p>Given the flow direction, the inflow boundary of the unit square \([0,1]^2\) are the right and the lower boundaries. We prescribe discontinuous boundary values 1 and 0 on the x-axis and value 0 on the right boundary. The values of this function on the outflow boundaries will not be used within the DG scheme.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                     std::vector&lt;double&gt; &amp;          <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void)component;</div><div class="line">  <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; values.size(); ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (points[i](0) &lt; 0.5)</div><div class="line">        values[i] = 1.;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        values[i] = 0.;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Finally, a function that computes and returns the wind field \(\beta=\beta(\mathbf x)\). As explained in the introduction, we will use a rotational field around the origin in 2d. In 3d, we simply leave the \(z\)-component unset (i.e., at zero), whereas the function can not be used in 1d in its current implementation:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> beta(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt;= 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> wind_field;</div><div class="line">  wind_field[0] = -p[1];</div><div class="line">  wind_field[1] = p[0];</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (wind_field.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() &gt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-10)</div><div class="line">    wind_field /= wind_field.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> wind_field;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheScratchDataandCopyDataclasses"></a> </p><h3>The ScratchData and CopyData classes</h3>
<p>The following objects are the scratch and copy objects we use in the call to <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>. The new object is the <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a> object, that works similar to <a class="el" href="classFEValues.html">FEValues</a> or FEFacesValues, except that it acts on an interface between two cells and allows us to assemble the interface terms in our weak form.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>ScratchData</div><div class="line">{</div><div class="line">  ScratchData(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;       mapping,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; fe,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    quadrature,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;quadrature_face,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>          update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> interface_update_flags =</div><div class="line">                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>)</div><div class="line">    : fe_values(mapping, fe, quadrature, update_flags)</div><div class="line">    , fe_interface_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_face,</div><div class="line">                          interface_update_flags)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">    : fe_values(scratch_data.fe_values.get_mapping(),</div><div class="line">                scratch_data.fe_values.get_fe(),</div><div class="line">                scratch_data.fe_values.get_quadrature(),</div><div class="line">                scratch_data.fe_values.get_update_flags())</div><div class="line">    , fe_interface_values(scratch_data.fe_interface_values.get_mapping(),</div><div class="line">                          scratch_data.fe_interface_values.get_fe(),</div><div class="line">                          scratch_data.fe_interface_values.get_quadrature(),</div><div class="line">                          scratch_data.fe_interface_values.get_update_flags())</div><div class="line">  {}</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>          fe_values;</div><div class="line">  <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> fe_interface_values;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct </span>CopyDataFace</div><div class="line">{</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; joint_dof_indices;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct </span>CopyData</div><div class="line">{</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       cell_rhs;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">  std::vector&lt;CopyDataFace&gt;            face_data;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> Iterator &amp;cell, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">  {</div><div class="line">    cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line">    cell_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dofs_per_cell);</div><div class="line"></div><div class="line">    local_dof_indices.resize(dofs_per_cell);</div><div class="line">    cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TheAdvectionProblemclass"></a> </p><h3>The AdvectionProblem class</h3>
<p>After this preparations, we proceed with the main class of this program, called AdvectionProblem.</p>
<p>This should all be pretty familiar to you. Interesting details will only come up in the implementation of the assemble function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>AdvectionProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  AdvectionProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> refine_grid();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div></div><!-- fragment --><p>Furthermore we want to use DG elements.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a> fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>   dof_handler;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; quadrature_face;</div></div><!-- fragment --><p>The next four members represent the linear system to be solved. <code>system_matrix</code> and <code>right_hand_side</code> are generated by <code>assemble_system()</code>, the <code>solution</code> is computed in <code>solve()</code>. The <code>sparsity_pattern</code> is used to determine the location of nonzero elements in <code>system_matrix</code>.</p>
<div class="fragment"><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> right_hand_side;</div><div class="line">};</div></div><!-- fragment --><p>We start with the constructor. The 1 in the constructor call of <code>fe</code> is the polynomial degree.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">AdvectionProblem&lt;dim&gt;::AdvectionProblem()</div><div class="line">  : mapping()</div><div class="line">  , fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , quadrature(fe.tensor_degree() + 1)</div><div class="line">  , quadrature_face(fe.tensor_degree() + 1)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div></div><!-- fragment --><p>In the function that sets up the usual finite element data structures, we first need to distribute the DoFs.</p>
<div class="fragment"><div class="line">dof_handler.distribute_dofs(fe);</div></div><!-- fragment --><p>We start by generating the sparsity pattern. To this end, we first fill an intermediate object of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> with the couplings appearing in the system. After building the pattern, this object is copied to <code>sparsity_pattern</code> and can be discarded.</p>
<p>To build the sparsity pattern for DG discretizations, we can call the function analogue to <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>, which is called <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line"><a class="code" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">sparsity_pattern.copy_from(dsp);</div></div><!-- fragment --><p>Finally, we set up the structure of all components of the linear system.</p>
<div class="fragment"><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  solution.reinit(dof_handler.n_dofs());</div><div class="line">  right_hand_side.reinit(dof_handler.n_dofs());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Theassemble_systemfunction"></a> </p><h4>The assemble_system function</h4>
<p>Here we see the major difference to assembling by hand. Instead of writing loops over cells and faces, the logic is contained in the call to <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> and we only need to specify what should happen on each cell, each boundary face, and each interior face. These three tasks are handled by the lambda functions inside the function below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> Iterator = <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a>;</div><div class="line">  <span class="keyword">const</span> BoundaryValues&lt;dim&gt; boundary_function;</div></div><!-- fragment --><p>This is the function that will be executed for each cell.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                             ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                             CopyData &amp;        copy_data) {</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs =</div><div class="line">    scratch_data.fe_values.get_fe().n_dofs_per_cell();</div><div class="line">  copy_data.reinit(cell, n_dofs);</div><div class="line">  scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = scratch_data.fe_values.get_quadrature_points();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;      fe_v = scratch_data.fe_values;</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW  = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div></div><!-- fragment --><p>We solve a homogeneous equation, thus no right hand side shows up in the cell term. What's left is integrating the matrix entries.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> = 0; <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> &lt; fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">    {</div><div class="line">      <span class="keyword">auto</span> beta_q = beta(q_points[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs; ++j)</div><div class="line">          {</div><div class="line">            copy_data.cell_matrix(i, j) +=</div><div class="line">              -beta_q                      <span class="comment">// -\beta</span></div><div class="line">                fe_v.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)  <span class="comment">// \nabla \phi_i</span></div><div class="line">                fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_j</span></div><div class="line">                JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                <span class="comment">// dx</span></div><div class="line">          }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>This is the function called for boundary faces and consists of a normal integration using <a class="el" href="classFEFaceValues.html">FEFaceValues</a>. New is the logic to decide if the term goes into the system matrix (outflow) or the right-hand side (inflow).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> boundary_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;    cell,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;face_no,</div><div class="line">                                 ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                                 CopyData &amp;          copy_data) {</div><div class="line">  scratch_data.fe_interface_values.reinit(cell, face_no);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_face =</div><div class="line">    scratch_data.fe_interface_values.get_fe_face_values(0);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = fe_face.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_facet_dofs = fe_face.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_face.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_face.<a class="code" href="classFEValuesBase.html#a80d39b9aea51af573ded84342b8b330d">get_normal_vectors</a>();</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; g(q_points.size());</div><div class="line">  boundary_function.value_list(q_points, g);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> = 0; <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> &lt; q_points.size(); ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta_dot_n = beta(q_points[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]) * normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (beta_dot_n &gt; 0)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_facet_dofs; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_facet_dofs; ++j)</div><div class="line">              copy_data.cell_matrix(i, j) +=</div><div class="line">                fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)   <span class="comment">// \phi_i</span></div><div class="line">                  fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_j</span></div><div class="line">                  beta_dot_n                    <span class="comment">// \beta . n</span></div><div class="line">                  JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                   <span class="comment">// dx</span></div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_facet_dofs; ++i)</div><div class="line">          copy_data.cell_rhs(i) += -fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_i</span></div><div class="line">                                     g[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]                     <span class="comment">// g</span></div><div class="line">                                     beta_dot_n  <span class="comment">// \beta . n</span></div><div class="line">                                     JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]; <span class="comment">// dx</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>This is the function called on interior faces. The arguments specify cells, face and subface indices (for adaptive refinement). We just pass them along to the <a class="el" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit()</a> function of <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> face_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;    cell,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;f,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;sf,</div><div class="line">                             <span class="keyword">const</span> Iterator &amp;    ncell,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nf,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nsf,</div><div class="line">                             ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                             CopyData &amp;          copy_data) {</div><div class="line">  <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv = scratch_data.fe_interface_values;</div><div class="line">  fe_iv.<a class="code" href="classFEInterfaceValues.html#af6aa20b6652c2605d4cee36021f6bcd2">reinit</a>(cell, f, sf, ncell, nf, nsf);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = fe_iv.<a class="code" href="classFEInterfaceValues.html#a77a7eb2a9540fe9583bae505fbbe1e73">get_quadrature_points</a>();</div><div class="line"></div><div class="line">  copy_data.face_data.emplace_back();</div><div class="line">  CopyDataFace &amp;copy_data_face = copy_data.face_data.back();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs        = fe_iv.<a class="code" href="classFEInterfaceValues.html#a5345658da9be54b10a6dbb8ca47c886c">n_current_interface_dofs</a>();</div><div class="line">  copy_data_face.joint_dof_indices = fe_iv.<a class="code" href="classFEInterfaceValues.html#a03cd7e51c953a5d44b993860a8dbfe1c">get_interface_dof_indices</a>();</div><div class="line"></div><div class="line">  copy_data_face.cell_matrix.reinit(n_dofs, n_dofs);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_iv.<a class="code" href="classFEInterfaceValues.html#a94062e68c68a7277aa1541854a5ae62d">get_JxW_values</a>();</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_iv.<a class="code" href="classFEInterfaceValues.html#a012d902cd158f8cd225b07ac741fa493">get_normal_vectors</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qpoint = 0; qpoint &lt; q_points.size(); ++qpoint)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta_dot_n = beta(q_points[qpoint]) * normals[qpoint];</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs; ++j)</div><div class="line">          copy_data_face.cell_matrix(i, j) +=</div><div class="line">            fe_iv.<a class="code" href="classFEInterfaceValues.html#a7827502cb506dbd5d6b2f740184f0a21">jump</a>(i, qpoint) <span class="comment">// [\phi_i]</span></div><div class="line">             </div><div class="line">            fe_iv.<a class="code" href="classFEInterfaceValues.html#a64e0e1fd4a783edeeef812c4416d59eb">shape_value</a>((beta_dot_n &gt; 0), j, qpoint) <span class="comment">// phi_j^{upwind}</span></div><div class="line">              beta_dot_n                                   <span class="comment">// (\beta . n)</span></div><div class="line">              JxW[qpoint];                                 <span class="comment">// dx</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>The following lambda function will handle copying the data from the cell and face assembly into the global matrix and right-hand side.</p>
<p>While we would not need an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object, because there are no hanging node constraints in DG discretizations, we use an empty object here as this allows us to use its <code>copy_local_to_global</code> functionality.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;c) {</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(c.cell_matrix,</div><div class="line">                                         c.cell_rhs,</div><div class="line">                                         c.local_dof_indices,</div><div class="line">                                         system_matrix,</div><div class="line">                                         right_hand_side);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cdf : c.face_data)</div><div class="line">    {</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cdf.cell_matrix,</div><div class="line">                                             cdf.joint_dof_indices,</div><div class="line">                                             system_matrix);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">ScratchData&lt;dim&gt; scratch_data(mapping, fe, quadrature, quadrature_face);</div><div class="line">CopyData         copy_data;</div></div><!-- fragment --><p>Here, we finally handle the assembly. We pass in ScratchData and CopyData objects, the lambda functions from above, an specify that we want to assemble interior faces once.</p>
<div class="fragment"><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.begin_active(),</div><div class="line">                        dof_handler.end(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        scratch_data,</div><div class="line">                        copy_data,</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a> |</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa35f26e2d96f28fb49e5b0865adc3ba9d">MeshWorker::assemble_boundary_faces</a> |</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47c6806a06155c94191629fae2755763">MeshWorker::assemble_own_interior_faces_once</a>,</div><div class="line">                        boundary_worker,</div><div class="line">                        face_worker);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Alltherest"></a> </p><h3>All the rest</h3>
<p>For this simple problem we use the simplest possible solver, called Richardson iteration, that represents a simple defect correction. This, in combination with a block SSOR preconditioner, that uses the special block matrix structure of system matrices arising from DG discretizations. The size of these blocks are the number of DoFs per cell. Here, we use a SSOR preconditioning as we have not renumbered the DoFs according to the flow field. If the DoFs are renumbered in the downstream direction of the flow, then a block Gauss-Seidel preconditioner (see the <a class="el" href="classPreconditionBlockSOR.html">PreconditionBlockSOR</a> class with relaxation=1) does a much better job.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">  <a class="code" href="classSolverRichardson.html">SolverRichardson&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div></div><!-- fragment --><p>Here we create the preconditioner,</p>
<div class="fragment"><div class="line"><a class="code" href="classPreconditionBlockSSOR.html">PreconditionBlockSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div></div><!-- fragment --><p>then assign the matrix to it and set the right block size:</p>
<div class="fragment"><div class="line">preconditioner.<a class="code" href="classPreconditionBlock.html#a6c61513fe17633b8b4e1dd2d83b72e81">initialize</a>(system_matrix, fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div></div><!-- fragment --><p>After these preparations we are ready to start the linear solver.</p>
<div class="fragment"><div class="line">  solver.solve(system_matrix, solution, right_hand_side, preconditioner);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Solver converged in &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>We refine the grid according to a very simple refinement criterion, namely an approximation to the gradient of the solution. As here we consider the DG(1) method (i.e. we use piecewise bilinear shape functions) we could simply compute the gradients on each cell. But we do not want to base our refinement indicator on the gradients on each cell only, but want to base them also on jumps of the discontinuous solution function over faces between neighboring cells. The simplest way of doing that is to compute approximative gradients by difference quotients including the cell under consideration and its neighbors. This is done by the <code><a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a></code> class that computes the approximate gradients in a way similar to the <code>GradientEstimation</code> described in <a class="el" href="step_9.html">step-9</a> of this tutorial. In fact, the <code><a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a></code> class was developed following the <code>GradientEstimation</code> class of <a class="el" href="step_9.html">step-9</a>. Relating to the discussion in <a class="el" href="step_9.html">step-9</a>, here we consider \(h^{1+d/2}|\nabla_h u_h|\). Furthermore we note that we do not consider approximate second derivatives because solutions to the linear advection equation are in general not in \(H^2\) but only in \(H^1\) (or, to be more precise: in \(H^1_\beta\), i.e., the space of functions whose derivatives in direction \(\beta\) are square integrable).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::refine_grid()</div><div class="line">{</div></div><!-- fragment --><p>The <code><a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a></code> class computes the gradients to float precision. This is sufficient as they are approximate and serve as refinement indicators only.</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> gradient_indicator(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div></div><!-- fragment --><p>Now the approximate gradients are computed</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceDerivativeApproximation.html#a98d28e4c1c17164c48719cdfe4a363e6">DerivativeApproximation::approximate_gradient</a>(mapping,</div><div class="line">                                              dof_handler,</div><div class="line">                                              solution,</div><div class="line">                                              gradient_indicator);</div></div><!-- fragment --><p>and they are cell-wise scaled by the factor \(h^{1+d/2}\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">  gradient_indicator(cell_no++) *=</div><div class="line">    <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(cell-&gt;diameter(), 1 + 1.0 * dim / 2);</div></div><!-- fragment --><p>Finally they serve as refinement indicator.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  gradient_indicator,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.1);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">}</div></div><!-- fragment --><p>The output of this program consists of a vtk file of the adaptively refined grids and the numerical solutions. Finally, we also compute the L-infinity norm of the solution using <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Writing solution to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl;</div><div class="line">  std::ofstream output(filename);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;u&quot;</span>, <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                      dof_handler,</div><div class="line">                                      solution,</div><div class="line">                                      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                      values,</div><div class="line">                                      quadrature,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> l_infty =</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                        values,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  L-infinity norm: &quot;</span> &lt;&lt; l_infty &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The following <code>run</code> function is similar to previous examples.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 6; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step12</span></div></div><!-- fragment --><p>The following <code>main</code> function is similar to previous examples as well, and need not be commented on.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step12::AdvectionProblem&lt;2&gt; dgmethod;</div><div class="line">      dgmethod.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The output of this program consist of the console output and solutions in vtk format: </p><div class="fragment"><div class="line">Cycle 0</div><div class="line">  Number of active cells:       64</div><div class="line">  Number of degrees of freedom: 256</div><div class="line">  Solver converged in 4 iterations.</div><div class="line">  Writing solution to &lt;solution-0.vtk&gt;</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.09057</div><div class="line">Cycle 1</div><div class="line">  Number of active cells:       112</div><div class="line">  Number of degrees of freedom: 448</div><div class="line">  Solver converged in 9 iterations.</div><div class="line">  Writing solution to &lt;solution-1.vtk&gt;</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.10402</div><div class="line">Cycle 2</div><div class="line">  Number of active cells:       214</div><div class="line">  Number of degrees of freedom: 856</div><div class="line">  Solver converged in 16 iterations.</div><div class="line">  Writing solution to &lt;solution-2.vtk&gt;</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.09813</div><div class="line">Cycle 3</div><div class="line">  Number of active cells:       415</div><div class="line">  Number of degrees of freedom: 1660</div><div class="line">  Solver converged in 26 iterations.</div><div class="line">  Writing solution to &lt;solution-3.vtk&gt;</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.09579</div><div class="line">Cycle 4</div><div class="line">  Number of active cells:       796</div><div class="line">  Number of degrees of freedom: 3184</div><div class="line">  Solver converged in 44 iterations.</div><div class="line">  Writing solution to &lt;solution-4.vtk&gt;</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.09612</div><div class="line">Cycle 5</div><div class="line">  Number of active cells:       1561</div><div class="line">  Number of degrees of freedom: 6244</div><div class="line">  Solver converged in 81 iterations.</div><div class="line">  Writing solution to &lt;solution-5.vtk&gt;</div></div><!-- fragment --><p>We show the solutions on the initial mesh, the mesh after two and after five adaptive refinement steps.</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-0.png"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-2.png"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-5.png"/>
</div>
<p>And finally we show a plot of a 3d computation.</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-5-3d.png"/>
</div>
<p><a class="anchor" id="dg-vs-cg"></a> <a class="anchor" id="Whyusediscontinuouselements"></a></p><h3>Why use discontinuous elements</h3>
<p>In this program we have used discontinuous elements. It is a legitimate question to ask why not simply use the normal, continuous ones. Of course, to everyone with a background in numerical methods, the answer is obvious: the continuous Galerkin (cG) method is not stable for the transport equation, unless one specifically adds stabilization terms. The DG method, however, <em>is</em> stable. Illustrating this with the current program is not very difficult; in fact, only the following minor modifications are necessary:</p><ul>
<li>Change the element to <a class="el" href="classFE__Q.html">FE_Q</a> instead of <a class="el" href="classFE__DGQ.html">FE_DGQ</a>.</li>
<li>Add handling of hanging node constraints in exactly the same way as <a class="el" href="step_6.html">step-6</a>.</li>
<li>We need a different solver; the direct solver in <a class="el" href="step_29.html">step-29</a> is a convenient choice. An experienced deal.II user will be able to do this in less than 10 minutes.</li>
</ul>
<p>While the 2d solution has been shown above, containing a number of small spikes at the interface that are, however, stable in height under mesh refinement, results look much different when using a continuous element:</p>
<table align="center">
<tr>
<td valign="top">0 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-0.png"/>
</div>
  </td><td valign="top">1 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-1.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">2 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-2.png"/>
</div>
  </td><td valign="top">3 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-3.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">4 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-4.png"/>
</div>
  </td><td valign="top">5 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-5.png"/>
</div>
   </td></tr>
</table>
<p>In refinement iteration 5, the image can't be plotted in a reasonable way any more as a 3d plot. We thus show a color plot with a range of \([-1,2]\) (the solution values of the exact solution lie in \([0,1]\), of course). In any case, it is clear that the continuous Galerkin solution exhibits oscillatory behavior that gets worse and worse as the mesh is refined more and more.</p>
<p>There are a number of strategies to stabilize the cG method, if one wants to use continuous elements for some reason. Discussing these methods is beyond the scope of this tutorial program; an interested reader could, for example, take a look at <a class="el" href="step_31.html">step-31</a>.</p>
<p><a class="anchor" id="extensions"></a> <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>Given that the exact solution is known in this case, one interesting avenue for further extensions would be to confirm the order of convergence for this program. In the current case, the solution is non-smooth, and so we can not expect to get a particularly high order of convergence, even if we used higher order elements. But even if the solution <em>is</em> smooth, the equation is not elliptic and so it is not immediately clear that we should obtain a convergence order that equals that of the optimal interpolation estimates (i.e. for example that we would get \(h^3\) convergence in the \(L^2\) norm by using quadratic elements).</p>
<p>In fact, for hyperbolic equations, theoretical predictions often indicate that the best one can hope for is an order one half below the interpolation estimate. For example, for the streamline diffusion method (an alternative method to the DG method used here to stabilize the solution of the transport equation), one can prove that for elements of degree \(p\), the order of convergence is \(p+\frac 12\) on arbitrary meshes. While the observed order is frequently \(p+1\) on uniformly refined meshes, one can construct so-called Peterson meshes on which the worse theoretical bound is actually attained. This should be relatively simple to verify, for example using the <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a> function.</p>
<p>A different direction is to observe that the solution of transport problems often has discontinuities and that therefore a mesh in which we <em>bisect</em> every cell in every coordinate direction may not be optimal. Rather, a better strategy would be to only cut cells in the direction parallel to the discontinuity. This is called <em>anisotropic mesh refinement</em> and is the subject of <a class="el" href="step_30.html">step-30</a>.</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2009 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Guido Kanschat, Texas A&amp;M University, 2009</span></div><div class="line"><span class="comment"> *         Timo Heister, Clemson University, 2019</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q1_8h.html">deal.II/fe/mapping_q1.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__interface__values_8h.html">deal.II/fe/fe_interface_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__richardson_8h.html">deal.II/lac/solver_richardson.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition__block_8h.html">deal.II/lac/precondition_block.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="derivative__approximation_8h.html">deal.II/numerics/derivative_approximation.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step12</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryValues() = <span class="keywordflow">default</span>;</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                            std::vector&lt;double&gt; &amp;          values,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                       std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; values.size(); ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (points[i](0) &lt; 0.5)</div><div class="line">          values[i] = 1.;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          values[i] = 0.;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> beta(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt;= 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> wind_field;</div><div class="line">    wind_field[0] = -p[1];</div><div class="line">    wind_field[1] = p[0];</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (wind_field.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() &gt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-10)</div><div class="line">      wind_field /= wind_field.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> wind_field;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>ScratchData</div><div class="line">  {</div><div class="line">    ScratchData(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;       mapping,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; fe,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    quadrature,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;quadrature_face,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>          update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> interface_update_flags =</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>)</div><div class="line">      : fe_values(mapping, fe, quadrature, update_flags)</div><div class="line">      , fe_interface_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_face,</div><div class="line">                            interface_update_flags)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">      : fe_values(scratch_data.fe_values.get_mapping(),</div><div class="line">                  scratch_data.fe_values.get_fe(),</div><div class="line">                  scratch_data.fe_values.get_quadrature(),</div><div class="line">                  scratch_data.fe_values.get_update_flags())</div><div class="line">      , fe_interface_values(scratch_data.fe_interface_values.get_mapping(),</div><div class="line">                            scratch_data.fe_interface_values.get_fe(),</div><div class="line">                            scratch_data.fe_interface_values.get_quadrature(),</div><div class="line">                            scratch_data.fe_interface_values.get_update_flags())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>          fe_values;</div><div class="line">    <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> fe_interface_values;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyDataFace</div><div class="line">  {</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; joint_dof_indices;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    Vector&lt;double&gt;                       cell_rhs;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">    std::vector&lt;CopyDataFace&gt;            face_data;</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> Iterator &amp;cell, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">    {</div><div class="line">      cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line">      cell_rhs.reinit(dofs_per_cell);</div><div class="line"></div><div class="line">      local_dof_indices.resize(dofs_per_cell);</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>AdvectionProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    AdvectionProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> refine_grid();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a> fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>   dof_handler;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; quadrature_face;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; right_hand_side;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  AdvectionProblem&lt;dim&gt;::AdvectionProblem()</div><div class="line">    : mapping()</div><div class="line">    , fe(1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , quadrature(fe.tensor_degree() + 1)</div><div class="line">    , quadrature_face(fe.tensor_degree() + 1)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">    <a class="code" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.copy_from(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    solution.reinit(dof_handler.n_dofs());</div><div class="line">    right_hand_side.reinit(dof_handler.n_dofs());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <span class="keyword">using</span> Iterator = <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a>;</div><div class="line">    <span class="keyword">const</span> BoundaryValues&lt;dim&gt; boundary_function;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                                 ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                                 CopyData &amp;        copy_data) {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs =</div><div class="line">        scratch_data.fe_values.get_fe().n_dofs_per_cell();</div><div class="line">      copy_data.reinit(cell, n_dofs);</div><div class="line">      scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = scratch_data.fe_values.get_quadrature_points();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;      fe_v = scratch_data.fe_values;</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW  = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> = 0; <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> &lt; fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">        {</div><div class="line">          <span class="keyword">auto</span> beta_q = beta(q_points[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs; ++j)</div><div class="line">              {</div><div class="line">                copy_data.cell_matrix(i, j) +=</div><div class="line">                  -beta_q                      <span class="comment">// -\beta</span></div><div class="line">                  * fe_v.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)  <span class="comment">// \nabla \phi_i</span></div><div class="line">                  * fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_j</span></div><div class="line">                  * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                <span class="comment">// dx</span></div><div class="line">              }</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> boundary_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;    cell,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;face_no,</div><div class="line">                                     ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                                     CopyData &amp;          copy_data) {</div><div class="line">      scratch_data.fe_interface_values.reinit(cell, face_no);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_face =</div><div class="line">        scratch_data.fe_interface_values.get_fe_face_values(0);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = fe_face.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_facet_dofs = fe_face.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_face.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line">      <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_face.<a class="code" href="classFEValuesBase.html#a80d39b9aea51af573ded84342b8b330d">get_normal_vectors</a>();</div><div class="line"></div><div class="line">      std::vector&lt;double&gt; g(q_points.size());</div><div class="line">      boundary_function.value_list(q_points, g);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> = 0; <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> &lt; q_points.size(); ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> beta_dot_n = beta(q_points[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]) * normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (beta_dot_n &gt; 0)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_facet_dofs; ++i)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_facet_dofs; ++j)</div><div class="line">                  copy_data.cell_matrix(i, j) +=</div><div class="line">                    fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)   <span class="comment">// \phi_i</span></div><div class="line">                    * fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_j</span></div><div class="line">                    * beta_dot_n                    <span class="comment">// \beta . n</span></div><div class="line">                    * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                   <span class="comment">// dx</span></div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_facet_dofs; ++i)</div><div class="line">              copy_data.cell_rhs(i) += -fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_i</span></div><div class="line">                                       * g[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]                     <span class="comment">// g</span></div><div class="line">                                       * beta_dot_n  <span class="comment">// \beta . n</span></div><div class="line">                                       * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]; <span class="comment">// dx</span></div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> face_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;    cell,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;f,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;sf,</div><div class="line">                                 <span class="keyword">const</span> Iterator &amp;    ncell,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nf,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nsf,</div><div class="line">                                 ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                                 CopyData &amp;          copy_data) {</div><div class="line">      <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv = scratch_data.fe_interface_values;</div><div class="line">      fe_iv.<a class="code" href="classFEInterfaceValues.html#af6aa20b6652c2605d4cee36021f6bcd2">reinit</a>(cell, f, sf, ncell, nf, nsf);</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = fe_iv.<a class="code" href="classFEInterfaceValues.html#a77a7eb2a9540fe9583bae505fbbe1e73">get_quadrature_points</a>();</div><div class="line"></div><div class="line">      copy_data.face_data.emplace_back();</div><div class="line">      CopyDataFace &amp;copy_data_face = copy_data.face_data.back();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs        = fe_iv.<a class="code" href="classFEInterfaceValues.html#a5345658da9be54b10a6dbb8ca47c886c">n_current_interface_dofs</a>();</div><div class="line">      copy_data_face.joint_dof_indices = fe_iv.<a class="code" href="classFEInterfaceValues.html#a03cd7e51c953a5d44b993860a8dbfe1c">get_interface_dof_indices</a>();</div><div class="line"></div><div class="line">      copy_data_face.cell_matrix.reinit(n_dofs, n_dofs);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_iv.<a class="code" href="classFEInterfaceValues.html#a94062e68c68a7277aa1541854a5ae62d">get_JxW_values</a>();</div><div class="line">      <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_iv.<a class="code" href="classFEInterfaceValues.html#a012d902cd158f8cd225b07ac741fa493">get_normal_vectors</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qpoint = 0; qpoint &lt; q_points.size(); ++qpoint)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> beta_dot_n = beta(q_points[qpoint]) * normals[qpoint];</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs; ++j)</div><div class="line">              copy_data_face.cell_matrix(i, j) +=</div><div class="line">                fe_iv.<a class="code" href="classFEInterfaceValues.html#a7827502cb506dbd5d6b2f740184f0a21">jump</a>(i, qpoint) <span class="comment">// [\phi_i]</span></div><div class="line">                *</div><div class="line">                fe_iv.<a class="code" href="classFEInterfaceValues.html#a64e0e1fd4a783edeeef812c4416d59eb">shape_value</a>((beta_dot_n &gt; 0), j, qpoint) <span class="comment">// phi_j^{upwind}</span></div><div class="line">                * beta_dot_n                                   <span class="comment">// (\beta . n)</span></div><div class="line">                * JxW[qpoint];                                 <span class="comment">// dx</span></div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;c) {</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(c.cell_matrix,</div><div class="line">                                             c.cell_rhs,</div><div class="line">                                             c.local_dof_indices,</div><div class="line">                                             system_matrix,</div><div class="line">                                             right_hand_side);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cdf : c.face_data)</div><div class="line">        {</div><div class="line">          constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cdf.cell_matrix,</div><div class="line">                                                 cdf.joint_dof_indices,</div><div class="line">                                                 system_matrix);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    ScratchData&lt;dim&gt; scratch_data(mapping, fe, quadrature, quadrature_face);</div><div class="line">    CopyData         copy_data;</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.begin_active(),</div><div class="line">                          dof_handler.end(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          scratch_data,</div><div class="line">                          copy_data,</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a> |</div><div class="line">                            <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa35f26e2d96f28fb49e5b0865adc3ba9d">MeshWorker::assemble_boundary_faces</a> |</div><div class="line">                            <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47c6806a06155c94191629fae2755763">MeshWorker::assemble_own_interior_faces_once</a>,</div><div class="line">                          boundary_worker,</div><div class="line">                          face_worker);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">    <a class="code" href="classSolverRichardson.html">SolverRichardson&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionBlockSSOR.html">PreconditionBlockSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line"></div><div class="line">    preconditioner.<a class="code" href="classPreconditionBlock.html#a6c61513fe17633b8b4e1dd2d83b72e81">initialize</a>(system_matrix, fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, right_hand_side, preconditioner);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Solver converged in &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::refine_grid()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; gradient_indicator(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceDerivativeApproximation.html#a98d28e4c1c17164c48719cdfe4a363e6">DerivativeApproximation::approximate_gradient</a>(mapping,</div><div class="line">                                                  dof_handler,</div><div class="line">                                                  solution,</div><div class="line">                                                  gradient_indicator);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">      gradient_indicator(cell_no++) *=</div><div class="line">        <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(cell-&gt;diameter(), 1 + 1.0 * dim / 2);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    gradient_indicator,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.1);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Writing solution to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl;</div><div class="line">    std::ofstream output(filename);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;u&quot;</span>, <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line"></div><div class="line">    {</div><div class="line">      Vector&lt;float&gt; <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                        dof_handler,</div><div class="line">                                        solution,</div><div class="line">                                        <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                        values,</div><div class="line">                                        quadrature,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> l_infty =</div><div class="line">        <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                          values,</div><div class="line">                                          <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  L-infinity norm: &quot;</span> &lt;&lt; l_infty &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 6; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step12</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step12::AdvectionProblem&lt;2&gt; dgmethod;</div><div class="line">      dgmethod.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_7.html">step-7</a> . <table class="tutorial"
 width="50%"> <tr><th colspan="2"><b><small>Table of
 contents</small></b><b><small>Table of contents</small></b></th></tr>
 <tr><td width="50%" valign="top">
 <ol>
 <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro"
 class=bold>Introduction</a>
 <ul>
 <li><a href="#Overview">Overview</a><a href="#Overview">Overview</a>
 <li><a href="#Theequation">The equation</a><a href="#Theequation">The
 equation</a>
 <li><a href="#Thetestproblem">The test problem</a><a
 href="#Thetestproblem">The test problem</a>
 </ul>
 <li> <a href="#CommProg" class=bold>The commented program</a><a
 href="#CommProg" class=bold>The commented program</a>
 <ul>
 <li><a href="#Equationdata">Equation data</a><a
 href="#Equationdata">Equation data</a>
 <li><a href="#TheScratchDataandCopyDataclasses">The ScratchData and
 CopyData classes</a><a href="#TheScratchDataandCopyDataclasses">The
 ScratchData and CopyData classes</a>
 <li><a href="#TheAdvectionProblemclass">The AdvectionProblem class</a><a
 href="#TheAdvectionProblemclass">The AdvectionProblem class</a>
 <ul>
 <li><a href="#Theassemble_systemfunction">The assemble_system
 function</a><a href="#Theassemble_systemfunction">The assemble_system
 function</a>
 </ul>
 <li><a href="#Alltherest">All the rest</a><a href="#Alltherest">All the
 rest</a>
 </ul>
 </ol></td><td width="50%" valign="top"><ol>
 <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results"
 class=bold>Results</a>
 <ul>
 <li><a href="#Whyusediscontinuouselements">Why use discontinuous
 elements</a><a href="#Whyusediscontinuouselements">Why use discontinuous
 elements</a>
 <li><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a><a href="#Possibilitiesforextensions">Possibilities for
 extensions</a>
 </ul>
 <li> <a href="#PlainProg" class=bold>The plain program</a><a
 href="#PlainProg" class=bold>The plain program</a>
 </ol> </td> </tr> </table>
  <br />
 <em> Note: A variant called <a class="el" href="step_12b.html">step-12b</a> of this tutorial exists, using <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> and <a class="el" href="namespaceLocalIntegrators.html" title="Library of integrals over cells and faces 这个命名空间包含了双线性形式、形式和误差估计的特定应用局部\x{00E7}...">LocalIntegrators</a> instead of assembling matrices using <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a> as is done in this tutorial. </em> <a class="anchor" id="Intro"></a><a class="anchor" id="AnexampleofanadvectionproblemusingtheDiscountinuousGalerkinmethod"></a></p><h1>An example of an advection problem using the Discountinuous Galerkin method</h1>
<p><a class="anchor" id="Overview"></a></p><h3>Overview</h3>
<p>This example is devoted to the <em> discontinuousGalerkin method </em> , or in short, the DG method. It includes the following topics. </p><ol>
<li>
Discretization of the linear advection equation with the DG method. </li>
<li>
Assembling of jump terms and other expressions on the interface between cells using <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a>. </li>
<li>
Assembling of the system matrix using the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>. </li>
</ol>
<p>The particular concern of this program are the loops of DG methods. These turnout to be especially complex, primarily because for the face terms, we have todistinguish the cases of boundary, regular interior faces and interior faceswith hanging nodes, respectively. The <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> handles thecomplexity on iterating over cells and faces and allows specifying "workers"for the different cell and face terms. The integration of face terms itself,including on adaptively refined faces, is done using the FEInterfaceValuesclass. <a class="anchor" id="Theequation"></a></p><h3>The equation</h3>
<p>The model problem solved in this example is the linear advection equation </p><p class="formulaDsp">
\[ \nabla\cdot \left({\mathbf \beta} u\right)=0 \qquad\mbox{in }\Omega, \]
</p>
<p> to the boundary conditions </p><p class="formulaDsp">
\[ u=g\quad\mbox{on }\Gamma_-, \]
</p>
<p> the inflow part \(\Gamma_-\) of the boundary \(\Gamma=\partial\Omega\) of the domain. Here, \({\mathbf \beta}={\mathbf \beta}({\bf x})\) denotes avector field, \(u\) the (scalar) solutionfunction, \(g\) a boundary value function, </p><p class="formulaDsp">
\[ \Gamma_- \dealcoloneq \{{\bf x}\in\Gamma, {\mathbf \beta}({\bf x})\cdot{\bf n}({\bf x})&lt;0\} \]
</p>
<p> inflow part of the boundary of the domain and \({\bf n}\) denotesthe unit outward normal to the boundary \(\Gamma\) . This equation is theconservative version of the advection equation already considered in <a class="el" href="step_9.html">step-9</a> of this tutorial.</p>
<p>On each cell \(T\) , we multiply by a test function \(v_h\) from the left and integrate by partsto get: </p><p class="formulaDsp">
\[ \left( v_h, \nabla \cdot (\beta u_h) \right)_T = -(\nabla v_h, \beta u_h) + \int_\Gamma v_h u_h \beta \cdot n \]
</p>
<p> summing this expression over all cells \(T\) , the boundary integral is done overall internal and external faces and as such there are three cases: </p><ol>
<li>
outer boundary on the inflow (we replace \(u_h\) by given \(g\) ): \(\int_{\Gamma_-} v_h g \beta \cdot n\) </li>
<li>
outer boundary on the outflow: \(\int_{\Gamma_+} v_h u_h \beta \cdot n\) </li>
<li>
inner faces (integral from two sides turns into jump, we use the upwind velocity): \(\int_F [v_h] u_h^{\text{upwind}} \beta \cdot n\) </li>
</ol>
<p>Here, the jump is defined as \([v] = v^+ - v^-\) , where the superscripts referto the left ('+') and right ('-') values at the face. The upwind value \(u^{\text{upwind}}\) is defined to be \(u^+\) if \(\beta \cdot n&gt;0\) and \(u^-\) otherwise. As a result, the mesh-dependent weak form reads: </p><p class="formulaDsp">
\[ \sum_{T\in \mathbb T_h} -\bigl(\nabla \phi_i,{\mathbf \beta}\cdot \phi_j \bigr)_T + \sum_{F\in\mathbb F_h^i} \bigl&lt; [\phi_i], \phi_j^{upwind} \beta\cdot \mathbf n\bigr&gt;_{F} + \bigl&lt;\phi_i, \phi_j \beta\cdot \mathbf n\bigr&gt;_{\Gamma_+} = -\bigl&lt;\phi_i, g \beta\cdot\mathbf n\bigr&gt;_{\Gamma_-}. \]
</p>
<p>, \(\mathbb T_h\) is the set of all active cells of the triangulationand \(\mathbb F_h^i\) is the set of all active interior faces. This formulationis known as the upwind discontinuous Galerkin method. In order to implement this bilinear form, we need to compute the cell terms(first sum) using the usual way to achieve integration on a cell, the interface terms (second sum) usingFEInterfaceValues, and the boundary terms (the other two terms).The summation of all those is done by <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>.</p>
<p><a class="anchor" id="Thetestproblem"></a></p><h3>The test problem</h3>
<p>We solve the advection equation on \(\Omega=[0,1]^2\) with \({\mathbf \beta}=\frac{1}{|x|}(-x_2, x_1)\) representing a circular counterclockwise flow field, and \(g=1\) on \({\bf x}\in\Gamma_-^1 := [0,0.5]\times\{0\}\) and \(g=0\) on \({\bf x}\in \Gamma_-\setminus \Gamma_-^1\) . We solve on a sequence of meshes by refining the mesh adaptively by estimatingthe norm of the gradient on each cell. After solving on each mesh, we outputthe solution in vtk format and compute the \(L^\infty\) norm of the solution. Asthe exact solution is either 0 or 1, we can measure the magnitude of theovershoot of the numerical solution with this.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>The first few files have already been covered in previous examples and will thus not be further commented on:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q1_8h.html">deal.II/fe/mapping_q1.h</a>&gt;</span></div></div><!-- fragment --><p>Here the discontinuous finite elements are defined. They are used in the same way as all other finite elements, though</p>
<ul>
<li>as you have seen in previous tutorial programs</li>
<li>there isn't much user interaction with finite element classes at all: they are passed to <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> and <code><a class="el" href="classFEValues.html">FEValues</a></code> objects, and that is about it.</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div></div><!-- fragment --><p>This header is needed for <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a> to compute integrals on interfaces:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__interface__values_8h.html">deal.II/fe/fe_interface_values.h</a>&gt;</span></div></div><!-- fragment --><p>We are going to use the simplest possible solver, called Richardson iteration, that represents a simple defect correction. This, in combination with a block SSOR preconditioner (defined in <a class="el" href="precondition__block_8h.html">precondition_block.h</a>), that uses the special block matrix structure of system matrices arising from DG discretizations.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__richardson_8h.html">deal.II/lac/solver_richardson.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition__block_8h.html">deal.II/lac/precondition_block.h</a>&gt;</span></div></div><!-- fragment --><p>We are going to use gradients as refinement indicator.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="derivative__approximation_8h.html">deal.II/numerics/derivative_approximation.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, the new include file for using the mesh_loop from the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div></div><!-- fragment --><p>Like in all programs, we finish this section by including the needed C++ headers and declaring we want to use objects in the dealii namespace without prefix.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step12</div><div class="line">{</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>First, we define a class describing the inhomogeneous boundary data. Since only its values are used, we implement value_list(), but leave all other functions of <a class="el" href="classFunction.html">Function</a> undefined.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoundaryValues() = <span class="keywordflow">default</span>;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                          std::vector&lt;double&gt; &amp;          values,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div></div><!-- fragment --><p>Given the flow direction, the inflow boundary of the unit square \([0,1]^2\) are the right and the lower boundaries. We prescribe discontinuous boundary values 1 and 0 on the x-axis and value 0 on the right boundary. The values of this function on the outflow boundaries will not be used within the DG scheme.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                     std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void)component;</div><div class="line">  <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; values.size(); ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (points[i](0) &lt; 0.5)</div><div class="line">        values[i] = 1.;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        values[i] = 0.;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Finally, a function that computes and returns the wind field \(\beta=\beta(\mathbf x)\) . As explained in the introduction, we will use a rotational field around the origin in 2d. In 3d, we simply leave the \(z\) -component unset (i.e., at zero), whereas the function can not be used in 1d in its current implementation:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> beta(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt;= 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> wind_field;</div><div class="line">  wind_field[0] =</div><div class="line"></div><div class="line">-p[1];</div><div class="line">  wind_field[1] = p[0];</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (wind_field.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() &gt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-10)</div><div class="line">    wind_field /= wind_field.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> wind_field;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheScratchDataandCopyDataclasses"></a> </p><h3>The ScratchData and CopyData classes</h3>
<p>The following objects are the scratch and copy objects we use in the call to <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>. The new object is the <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a> object, that works similar to <a class="el" href="classFEValues.html">FEValues</a> or FEFacesValues, except that it acts on an interface between two cells and allows us to assemble the interface terms in our weak form.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>ScratchData</div><div class="line">{</div><div class="line">  ScratchData(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;       mapping,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; fe,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    quadrature,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt; &amp;quadrature_face,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>          update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> interface_update_flags =</div><div class="line">                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>)</div><div class="line">    : fe_values(mapping, fe, quadrature, update_flags)</div><div class="line">    , fe_interface_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_face,</div><div class="line">                          interface_update_flags)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">    : fe_values(scratch_data.fe_values.get_mapping(),</div><div class="line">                scratch_data.fe_values.get_fe(),</div><div class="line">                scratch_data.fe_values.get_quadrature(),</div><div class="line">                scratch_data.fe_values.get_update_flags())</div><div class="line">    , fe_interface_values(scratch_data.fe_interface_values.get_mapping(),</div><div class="line">                          scratch_data.fe_interface_values.get_fe(),</div><div class="line">                          scratch_data.fe_interface_values.get_quadrature(),</div><div class="line">                          scratch_data.fe_interface_values.get_update_flags())</div><div class="line">  {}</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>          fe_values;</div><div class="line">  <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> fe_interface_values;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct </span>CopyDataFace</div><div class="line">{</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; joint_dof_indices;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct </span>CopyData</div><div class="line">{</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       cell_rhs;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">  std::vector&lt;CopyDataFace&gt;            face_data;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> Iterator &amp;cell, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">  {</div><div class="line">    cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line">    cell_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dofs_per_cell);</div><div class="line"></div><div class="line">    local_dof_indices.resize(dofs_per_cell);</div><div class="line">    cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TheAdvectionProblemclass"></a> </p><h3>The AdvectionProblem class</h3>
<p>After this preparations, we proceed with the main class of this program, called AdvectionProblem. This should all be pretty familiar to you. Interesting details will only come up in the implementation of the assemble function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>AdvectionProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  AdvectionProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> refine_grid();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div></div><!-- fragment --><p>Furthermore we want to use DG elements.</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a> fe;</div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>   dof_handler;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim</div><div class="line"></div><div class="line">- 1&gt; quadrature_face;</div></div><!-- fragment --><p>The next four members represent the linear system to be solved. <code>system_matrix</code> and <code>right_hand_side</code> are generated by <code>assemble_system()</code>, the <code>solution</code> is computed in <code>solve()</code>. The <code>sparsity_pattern</code> is used to determine the location of nonzero elements in <code>system_matrix</code> .</p>
<div class="fragment"><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> right_hand_side;</div><div class="line">};</div></div><!-- fragment --><p>We start with the constructor. The 1 in the constructor call of <code>fe</code> is the polynomial degree.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">AdvectionProblem&lt;dim&gt;::AdvectionProblem()</div><div class="line">  : mapping()</div><div class="line">  , fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , quadrature(fe.tensor_degree() + 1)</div><div class="line">  , quadrature_face(fe.tensor_degree() + 1)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div></div><!-- fragment --><p>In the function that sets up the usual finite element data structures, we first need to distribute the DoFs.</p>
<div class="fragment"><div class="line">dof_handler.distribute_dofs(fe);</div></div><!-- fragment --><p>We start by generating the sparsity pattern. To this end, we first fill an intermediate object of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> with the couplings appearing in the system. After building the pattern, this object is copied to <code>sparsity_pattern</code> and can be discarded.</p>
<p>To build the sparsity pattern for DG discretizations, we can call the function analogue to <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>, which is called <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line"><a class="code" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">sparsity_pattern.copy_from(dsp);</div></div><!-- fragment --><p>Finally, we set up the structure of all components of the linear system.</p>
<div class="fragment"><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  solution.reinit(dof_handler.n_dofs());</div><div class="line">  right_hand_side.reinit(dof_handler.n_dofs());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Theassemble_systemfunction"></a> </p><h4>The assemble_system function</h4>
<p>Here we see the major difference to assembling by hand. Instead of writing loops over cells and faces, the logic is contained in the call to <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> and we only need to specify what should happen on each cell, each boundary face, and each interior face. These three tasks are handled by the lambda functions inside the function below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> Iterator = <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a>;</div><div class="line">  <span class="keyword">const</span> BoundaryValues&lt;dim&gt; boundary_function;</div></div><!-- fragment --><p>This is the function that will be executed for each cell.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                             ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                             CopyData &amp;        copy_data) {</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs =</div><div class="line">    scratch_data.fe_values.get_fe().n_dofs_per_cell();</div><div class="line">  copy_data.reinit(cell, n_dofs);</div><div class="line">  scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = scratch_data.fe_values.get_quadrature_points();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;      fe_v = scratch_data.fe_values;</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW  = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div></div><!-- fragment --><p>We solve a homogeneous equation, thus no right hand side shows up in the cell term. What's left is integrating the matrix entries.</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> = 0; <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> &lt; fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">      {</div><div class="line">        <span class="keyword">auto</span> beta_q = beta(q_points[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs; ++i)</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs; ++j)</div><div class="line">            {</div><div class="line">              copy_data.cell_matrix(i, j) +=</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">-beta_q                      <span class="comment">//</span></div><div class="line"></div><div class="line">-\beta</div><div class="line">                fe_v.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)  <span class="comment">// \nabla \phi_i</span></div><div class="line">                fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_j</span></div><div class="line">                JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                <span class="comment">// dx</span></div><div class="line">            }</div><div class="line">      }</div><div class="line">  };</div></div><!-- fragment --><p>This is the function called for boundary faces and consists of a normal integration using <a class="el" href="classFEFaceValues.html">FEFaceValues</a>. New is the logic to decide if the term goes into the system matrix (outflow) or the right-hand side (inflow).</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> boundary_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;    cell,</div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;face_no,</div><div class="line">                                   ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                                   CopyData &amp;          copy_data) {</div><div class="line">    scratch_data.fe_interface_values.reinit(cell, face_no);</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_face =</div><div class="line">      scratch_data.fe_interface_values.get_fe_face_values(0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = fe_face.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_facet_dofs = fe_face.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">    <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_face.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line">    <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_face.<a class="code" href="classFEValuesBase.html#a80d39b9aea51af573ded84342b8b330d">get_normal_vectors</a>();</div><div class="line"></div><div class="line">    std::vector&lt;double&gt; g(q_points.size());</div><div class="line">    boundary_function.value_list(q_points, g);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> = 0; <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> &lt; q_points.size(); ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">      {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> beta_dot_n = beta(q_points[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]) normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (beta_dot_n &gt; 0)</div><div class="line">          {</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_facet_dofs; ++i)</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_facet_dofs; ++j)</div><div class="line">                copy_data.cell_matrix(i, j) +=</div><div class="line">                  fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)   <span class="comment">// \phi_i</span></div><div class="line">                  fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_j</span></div><div class="line">                  beta_dot_n                    <span class="comment">// \beta . n</span></div><div class="line">                  JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                   <span class="comment">// dx</span></div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_facet_dofs; ++i)</div><div class="line">            copy_data.cell_rhs(i) +=</div><div class="line"></div><div class="line">-fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_i</span></div><div class="line">                                     g[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]                     <span class="comment">// g</span></div><div class="line">                                     beta_dot_n  <span class="comment">// \beta . n</span></div><div class="line">                                     JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]; <span class="comment">// dx</span></div><div class="line">      }</div><div class="line">  };</div></div><!-- fragment --><p>This is the function called on interior faces. The arguments specify cells, face and subface indices (for adaptive refinement). We just pass them along to the <a class="el" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit()</a> function of <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> face_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;    cell,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;f,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;sf,</div><div class="line">                             <span class="keyword">const</span> Iterator &amp;    ncell,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nf,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nsf,</div><div class="line">                             ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                             CopyData &amp;          copy_data) {</div><div class="line">  <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv = scratch_data.fe_interface_values;</div><div class="line">  fe_iv.<a class="code" href="classFEInterfaceValues.html#af6aa20b6652c2605d4cee36021f6bcd2">reinit</a>(cell, f, sf, ncell, nf, nsf);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = fe_iv.<a class="code" href="classFEInterfaceValues.html#a77a7eb2a9540fe9583bae505fbbe1e73">get_quadrature_points</a>();</div><div class="line"></div><div class="line">  copy_data.face_data.emplace_back();</div><div class="line">  CopyDataFace &amp;copy_data_face = copy_data.face_data.back();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs        = fe_iv.<a class="code" href="classFEInterfaceValues.html#a5345658da9be54b10a6dbb8ca47c886c">n_current_interface_dofs</a>();</div><div class="line">  copy_data_face.joint_dof_indices = fe_iv.<a class="code" href="classFEInterfaceValues.html#a03cd7e51c953a5d44b993860a8dbfe1c">get_interface_dof_indices</a>();</div><div class="line"></div><div class="line">  copy_data_face.cell_matrix.reinit(n_dofs, n_dofs);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_iv.<a class="code" href="classFEInterfaceValues.html#a94062e68c68a7277aa1541854a5ae62d">get_JxW_values</a>();</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_iv.<a class="code" href="classFEInterfaceValues.html#a012d902cd158f8cd225b07ac741fa493">get_normal_vectors</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qpoint = 0; qpoint &lt; q_points.size(); ++qpoint)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta_dot_n = beta(q_points[qpoint]) normals[qpoint];</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs; ++j)</div><div class="line">          copy_data_face.cell_matrix(i, j) +=</div><div class="line">            fe_iv.<a class="code" href="classFEInterfaceValues.html#a7827502cb506dbd5d6b2f740184f0a21">jump</a>(i, qpoint) <span class="comment">// [\phi_i]</span></div><div class="line"></div><div class="line">            fe_iv.<a class="code" href="classFEInterfaceValues.html#a64e0e1fd4a783edeeef812c4416d59eb">shape_value</a>((beta_dot_n &gt; 0), j, qpoint) <span class="comment">// phi_j^{upwind}</span></div><div class="line">            beta_dot_n                                   <span class="comment">// (\beta . n)</span></div><div class="line">            JxW[qpoint];                                 <span class="comment">// dx</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>The following lambda function will handle copying the data from the cell and face assembly into the global matrix and right-hand side. While we would not need an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object, because there are no hanging node constraints in DG discretizations, we use an empty object here as this allows us to use its <code>copy_local_to_global</code> functionality.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;c) {</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(c.cell_matrix,</div><div class="line">                                         c.cell_rhs,</div><div class="line">                                         c.local_dof_indices,</div><div class="line">                                         system_matrix,</div><div class="line">                                         right_hand_side);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cdf : c.face_data)</div><div class="line">    {</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cdf.cell_matrix,</div><div class="line">                                             cdf.joint_dof_indices,</div><div class="line">                                             system_matrix);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">ScratchData&lt;dim&gt; scratch_data(mapping, fe, quadrature, quadrature_face);</div><div class="line">CopyData         copy_data;</div></div><!-- fragment --><p>Here, we finally handle the assembly. We pass in ScratchData and CopyData objects, the lambda functions from above, an specify that we want to assemble interior faces once.</p>
<div class="fragment"><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.begin_active(),</div><div class="line">                        dof_handler.end(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        scratch_data,</div><div class="line">                        copy_data,</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a> |</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa35f26e2d96f28fb49e5b0865adc3ba9d">MeshWorker::assemble_boundary_faces</a> |</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47c6806a06155c94191629fae2755763">MeshWorker::assemble_own_interior_faces_once</a>,</div><div class="line">                        boundary_worker,</div><div class="line">                        face_worker);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Alltherest"></a> </p><h3>All the rest</h3>
<p>For this simple problem we use the simplest possible solver, called Richardson iteration, that represents a simple defect correction. This, in combination with a block SSOR preconditioner, that uses the special block matrix structure of system matrices arising from DG discretizations. The size of these blocks are the number of DoFs per cell. Here, we use a SSOR preconditioning as we have not renumbered the DoFs according to the flow field. If the DoFs are renumbered in the downstream direction of the flow, then a block Gauss-Seidel preconditioner (see the <a class="el" href="classPreconditionBlockSOR.html">PreconditionBlockSOR</a> class with relaxation=1) does a much better job.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">  <a class="code" href="classSolverRichardson.html">SolverRichardson&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div></div><!-- fragment --><p>Here we create the preconditioner,</p>
<div class="fragment"><div class="line"><a class="code" href="classPreconditionBlockSSOR.html">PreconditionBlockSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div></div><!-- fragment --><p>then assign the matrix to it and set the right block size:</p>
<div class="fragment"><div class="line">preconditioner.<a class="code" href="classPreconditionBlock.html#a6c61513fe17633b8b4e1dd2d83b72e81">initialize</a>(system_matrix, fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div></div><!-- fragment --><p>After these preparations we are ready to start the linear solver.</p>
<div class="fragment"><div class="line">  solver.solve(system_matrix, solution, right_hand_side, preconditioner);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Solver converged in &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>We refine the grid according to a very simple refinement criterion, namely an approximation to the gradient of the solution. As here we consider the DG(1) method (i.e. we use piecewise bilinear shape functions) we could simply compute the gradients on each cell. But we do not want to base our refinement indicator on the gradients on each cell only, but want to base them also on jumps of the discontinuous solution function over faces between neighboring cells. The simplest way of doing that is to compute approximative gradients by difference quotients including the cell under consideration and its neighbors. This is done by the <code><a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a></code> class that computes the approximate gradients in a way similar to the <code>GradientEstimation</code> described in <a class="el" href="step_9.html">step-9</a> of this tutorial. In fact, the <code><a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a></code> class was developed following the <code>GradientEstimation</code> class of <a class="el" href="step_9.html">step-9</a> . Relating to the discussion in <a class="el" href="step_9.html">step-9</a> , here we consider \(h^{1+d/2}|\nabla_h u_h|\) . Furthermore we note that we do not consider approximate second derivatives because solutions to the linear advection equation are in general not in \(H^2\) but only in \(H^1\) (or, to be more precise: in \(H^1_\beta\) , i.e., the space of functions whose derivatives in direction \(\beta\) are square integrable).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::refine_grid()</div><div class="line">{</div></div><!-- fragment --><p>The <code><a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a></code> class computes the gradients to float precision. This is sufficient as they are approximate and serve as refinement indicators only.</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> gradient_indicator(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div></div><!-- fragment --><p>Now the approximate gradients are computed</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceDerivativeApproximation.html#a98d28e4c1c17164c48719cdfe4a363e6">DerivativeApproximation::approximate_gradient</a>(mapping,</div><div class="line">                                              dof_handler,</div><div class="line">                                              solution,</div><div class="line">                                              gradient_indicator);</div></div><!-- fragment --><p>and they are cell-wise scaled by the factor \(h^{1+d/2}\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">  gradient_indicator(cell_no++)=</div><div class="line">    <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(cell-&gt;diameter(), 1 + 1.0 dim / 2);</div></div><!-- fragment --><p>Finally they serve as refinement indicator.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  gradient_indicator,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.1);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">}</div></div><!-- fragment --><p>The output of this program consists of a vtk file of the adaptively refined grids and the numerical solutions. Finally, we also compute the L-infinity norm of the solution using <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Writing solution to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl;</div><div class="line">  std::ofstream output(filename);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;u&quot;</span>, <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                      dof_handler,</div><div class="line">                                      solution,</div><div class="line">                                      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                      values,</div><div class="line">                                      quadrature,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> l_infty =</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                        values,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  L-infinity norm: &quot;</span> &lt;&lt; l_infty &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The following <code>run</code> function is similar to previous examples.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem&lt;dim&gt;::run</a>()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 6; ++cycle)</div><div class="line">    {</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">        {</div><div class="line">          <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">          triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3);</div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        refine_grid();</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:       &quot;</span></div><div class="line">                &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      setup_system();</div><div class="line"></div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">                &lt;&lt; std::endl;</div><div class="line"></div><div class="line">      assemble_system();</div><div class="line">      solve();</div><div class="line"></div><div class="line">      output_results(cycle);</div><div class="line">    }</div><div class="line">}</div><div class="line">} <span class="comment">// namespace Step12</span></div></div><!-- fragment --><p>The following <code>main</code> function is similar to previous examples as well, and need not be commented on.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line"><span class="keywordflow">try</span></div><div class="line">  {</div><div class="line">    Step12::AdvectionProblem&lt;2&gt; dgmethod;</div><div class="line">    dgmethod.run();</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"><span class="keywordflow">catch</span> (...)</div><div class="line">  {</div><div class="line">    std::cerr &lt;&lt; std::endl</div><div class="line">              &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">              &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> 1;</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>The output of this program consist of the console output andsolutions in vtk format: </p><div class="fragment"><div class="line">Cycle 0</div><div class="line">Number of active cells:       64</div><div class="line">Number of degrees of freedom: 256</div><div class="line">Solver converged in 4 iterations.</div><div class="line">Writing solution to &lt;solution-0.vtk&gt;</div><div class="line"><a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.09057</div><div class="line">Cycle 1</div><div class="line">Number of active cells:       112</div><div class="line">Number of degrees of freedom: 448</div><div class="line">Solver converged in 9 iterations.</div><div class="line">Writing solution to &lt;solution-1.vtk&gt;</div><div class="line"><a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.10402</div><div class="line">Cycle 2</div><div class="line">Number of active cells:       214</div><div class="line">Number of degrees of freedom: 856</div><div class="line">Solver converged in 16 iterations.</div><div class="line">Writing solution to &lt;solution-2.vtk&gt;</div><div class="line"><a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.09813</div><div class="line">Cycle 3</div><div class="line">Number of active cells:       415</div><div class="line">Number of degrees of freedom: 1660</div><div class="line">Solver converged in 26 iterations.</div><div class="line">Writing solution to &lt;solution-3.vtk&gt;</div><div class="line"><a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.09579</div><div class="line">Cycle 4</div><div class="line">Number of active cells:       796</div><div class="line">Number of degrees of freedom: 3184</div><div class="line">Solver converged in 44 iterations.</div><div class="line">Writing solution to &lt;solution-4.vtk&gt;</div><div class="line"><a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.09612</div><div class="line">Cycle 5</div><div class="line">Number of active cells:       1561</div><div class="line">Number of degrees of freedom: 6244</div><div class="line">Solver converged in 81 iterations.</div><div class="line">Writing solution to &lt;solution-5.vtk&gt;</div></div><!-- fragment --><p>We show the solutions on the initial mesh, the mesh after twoand after five adaptive refinement steps. </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-0.png"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-2.png"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-5.png"/>
</div>
<p> And finally we show a plot of a 3d computation. </p><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-5-3d.png"/>
</div>
<p><a class="anchor" id="dg-vs-cg"></a><a class="anchor" id="Whyusediscontinuouselements"></a></p><h3>Why use discontinuous elements</h3>
<p>In this program we have used discontinuous elements. It is a legitimatequestion to ask why not simply use the normal, continuous ones. Of course, toeveryone with a background in numerical methods, the answer is obvious: thecontinuous Galerkin (cG) method is not stable for the transport equation,unless one specifically adds stabilization terms. The DG method, however,<em>is</em> stable. Illustrating this with the current program is not verydifficult; in fact, only the following minor modifications are necessary:</p>
<ul>
<li>Change the element to <a class="el" href="classFE__Q.html">FE_Q</a> instead of <a class="el" href="classFE__DGQ.html">FE_DGQ</a>.</li>
<li>Add handling of hanging node constraints in exactly the same way as <a class="el" href="step_6.html">step-6</a> .</li>
<li>We need a different solver; the direct solver in <a class="el" href="step_29.html">step-29</a> is a convenient choice.An experienced deal.II user will be able to do this in less than 10 minutes. While the 2d solution has been shown above, containing a number of smallspikes at the interface that are, however, stable in height under meshrefinement, results look much different when using a continuous element: <table align="center">
<tr>
<td valign="top">0 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-0.png"/>
</div>
  </td><td valign="top">1 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-1.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">2 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-2.png"/>
</div>
  </td><td valign="top">3 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-3.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">4 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-4.png"/>
</div>
  </td><td valign="top">5 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-5.png"/>
</div>
   </td></tr>
</table>
In refinement iteration 5, the image can't be plotted in a reasonable way anymore as a 3d plot. We thus show a color plot with a range of \([-1,2]\) (thesolution values of the exact solution lie in \([0,1]\) , of course). In any case,it is clear that the continuous Galerkin solution exhibits oscillatorybehavior that gets worse and worse as the mesh is refined more and more. There are a number of strategies to stabilize the cG method, if one wants touse continuous elements for some reason. Discussing these methods is beyondthe scope of this tutorial program; an interested reader could, for example,take a look at <a class="el" href="step_31.html">step-31</a></li>
</ul>
<p><a class="anchor" id="extensions"></a><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>Given that the exact solution is known in this case, one interestingavenue for further extensions would be to confirm the order ofconvergence for this program. In the current case, the solution isnon-smooth, and so we can not expect to get a particularly high orderof convergence, even if we used higher order elements. But even if thesolution <em>is</em> smooth, the equation is not elliptic and so it is notimmediately clear that we should obtain a convergence order thatequals that of the optimal interpolation estimates (i.e. for examplethat we would get \(h^3\) convergence in the \(L^2\) norm by usingquadratic elements). In fact, for hyperbolic equations, theoretical predictions oftenindicate that the best one can hope for is an order one half below theinterpolation estimate. For example, for the streamline diffusionmethod (an alternative method to the DG method used here to stabilizethe solution of the transport equation), one can prove that forelements of degree \(p\) , the order of convergence is \(p+\frac 12\) onarbitrary meshes. While the observed order is frequently \(p+1\) onuniformly refined meshes, one can construct so-called Peterson mesheson which the worse theoretical bound is actually attained. This shouldbe relatively simple to verify, for example using the <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a> function. A different direction is to observe that the solution of transport problemsoften has discontinuities and that therefore a mesh in which we <em>bisect</em>every cell in every coordinate direction may not be optimal. Rather, a betterstrategy would be to only cut cells in the direction parallel to thediscontinuity. This is called <em>anisotropic mesh refinement</em> and is thesubject of <a class="el" href="step_30.html">step-30</a> .</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2009 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Guido Kanschat, Texas A&amp;M University, 2009</span></div><div class="line"><span class="comment"> *         Timo Heister, Clemson University, 2019</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q1_8h.html">deal.II/fe/mapping_q1.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__interface__values_8h.html">deal.II/fe/fe_interface_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__richardson_8h.html">deal.II/lac/solver_richardson.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition__block_8h.html">deal.II/lac/precondition_block.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="derivative__approximation_8h.html">deal.II/numerics/derivative_approximation.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step12</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryValues() = <span class="keywordflow">default</span>;</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                            std::vector&lt;double&gt; &amp;          values,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                       std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; values.size(); ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (points[i](0) &lt; 0.5)</div><div class="line">          values[i] = 1.;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          values[i] = 0.;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> beta(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt;= 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> wind_field;</div><div class="line">    wind_field[0] = -p[1];</div><div class="line">    wind_field[1] = p[0];</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (wind_field.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() &gt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-10)</div><div class="line">      wind_field /= wind_field.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> wind_field;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>ScratchData</div><div class="line">  {</div><div class="line">    ScratchData(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;       mapping,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; fe,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    quadrature,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;quadrature_face,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>          update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> interface_update_flags =</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>)</div><div class="line">      : fe_values(mapping, fe, quadrature, update_flags)</div><div class="line">      , fe_interface_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_face,</div><div class="line">                            interface_update_flags)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">      : fe_values(scratch_data.fe_values.get_mapping(),</div><div class="line">                  scratch_data.fe_values.get_fe(),</div><div class="line">                  scratch_data.fe_values.get_quadrature(),</div><div class="line">                  scratch_data.fe_values.get_update_flags())</div><div class="line">      , fe_interface_values(scratch_data.fe_interface_values.get_mapping(),</div><div class="line">                            scratch_data.fe_interface_values.get_fe(),</div><div class="line">                            scratch_data.fe_interface_values.get_quadrature(),</div><div class="line">                            scratch_data.fe_interface_values.get_update_flags())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>          fe_values;</div><div class="line">    <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> fe_interface_values;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyDataFace</div><div class="line">  {</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; joint_dof_indices;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    Vector&lt;double&gt;                       cell_rhs;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">    std::vector&lt;CopyDataFace&gt;            face_data;</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> Iterator &amp;cell, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">    {</div><div class="line">      cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line">      cell_rhs.reinit(dofs_per_cell);</div><div class="line"></div><div class="line">      local_dof_indices.resize(dofs_per_cell);</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>AdvectionProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    AdvectionProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> refine_grid();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a> fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>   dof_handler;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; quadrature_face;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; right_hand_side;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  AdvectionProblem&lt;dim&gt;::AdvectionProblem()</div><div class="line">    : mapping()</div><div class="line">    , fe(1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , quadrature(fe.tensor_degree() + 1)</div><div class="line">    , quadrature_face(fe.tensor_degree() + 1)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">    <a class="code" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.copy_from(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    solution.reinit(dof_handler.n_dofs());</div><div class="line">    right_hand_side.reinit(dof_handler.n_dofs());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <span class="keyword">using</span> Iterator = <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a>;</div><div class="line">    <span class="keyword">const</span> BoundaryValues&lt;dim&gt; boundary_function;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                                 ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                                 CopyData &amp;        copy_data) {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs =</div><div class="line">        scratch_data.fe_values.get_fe().n_dofs_per_cell();</div><div class="line">      copy_data.reinit(cell, n_dofs);</div><div class="line">      scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = scratch_data.fe_values.get_quadrature_points();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;      fe_v = scratch_data.fe_values;</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW  = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> = 0; <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> &lt; fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">        {</div><div class="line">          <span class="keyword">auto</span> beta_q = beta(q_points[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs; ++j)</div><div class="line">              {</div><div class="line">                copy_data.cell_matrix(i, j) +=</div><div class="line">                  -beta_q                      <span class="comment">// -\beta</span></div><div class="line">                  * fe_v.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)  <span class="comment">// \nabla \phi_i</span></div><div class="line">                  * fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_j</span></div><div class="line">                  * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                <span class="comment">// dx</span></div><div class="line">              }</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> boundary_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;    cell,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;face_no,</div><div class="line">                                     ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                                     CopyData &amp;          copy_data) {</div><div class="line">      scratch_data.fe_interface_values.reinit(cell, face_no);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_face =</div><div class="line">        scratch_data.fe_interface_values.get_fe_face_values(0);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = fe_face.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_facet_dofs = fe_face.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_face.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line">      <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_face.<a class="code" href="classFEValuesBase.html#a80d39b9aea51af573ded84342b8b330d">get_normal_vectors</a>();</div><div class="line"></div><div class="line">      std::vector&lt;double&gt; g(q_points.size());</div><div class="line">      boundary_function.value_list(q_points, g);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> = 0; <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> &lt; q_points.size(); ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> beta_dot_n = beta(q_points[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]) * normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (beta_dot_n &gt; 0)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_facet_dofs; ++i)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_facet_dofs; ++j)</div><div class="line">                  copy_data.cell_matrix(i, j) +=</div><div class="line">                    fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)   <span class="comment">// \phi_i</span></div><div class="line">                    * fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_j</span></div><div class="line">                    * beta_dot_n                    <span class="comment">// \beta . n</span></div><div class="line">                    * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                   <span class="comment">// dx</span></div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_facet_dofs; ++i)</div><div class="line">              copy_data.cell_rhs(i) += -fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_i</span></div><div class="line">                                       * g[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]                     <span class="comment">// g</span></div><div class="line">                                       * beta_dot_n  <span class="comment">// \beta . n</span></div><div class="line">                                       * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]; <span class="comment">// dx</span></div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> face_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;    cell,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;f,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;sf,</div><div class="line">                                 <span class="keyword">const</span> Iterator &amp;    ncell,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nf,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nsf,</div><div class="line">                                 ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                                 CopyData &amp;          copy_data) {</div><div class="line">      <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv = scratch_data.fe_interface_values;</div><div class="line">      fe_iv.<a class="code" href="classFEInterfaceValues.html#af6aa20b6652c2605d4cee36021f6bcd2">reinit</a>(cell, f, sf, ncell, nf, nsf);</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = fe_iv.<a class="code" href="classFEInterfaceValues.html#a77a7eb2a9540fe9583bae505fbbe1e73">get_quadrature_points</a>();</div><div class="line"></div><div class="line">      copy_data.face_data.emplace_back();</div><div class="line">      CopyDataFace &amp;copy_data_face = copy_data.face_data.back();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs        = fe_iv.<a class="code" href="classFEInterfaceValues.html#a5345658da9be54b10a6dbb8ca47c886c">n_current_interface_dofs</a>();</div><div class="line">      copy_data_face.joint_dof_indices = fe_iv.<a class="code" href="classFEInterfaceValues.html#a03cd7e51c953a5d44b993860a8dbfe1c">get_interface_dof_indices</a>();</div><div class="line"></div><div class="line">      copy_data_face.cell_matrix.reinit(n_dofs, n_dofs);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_iv.<a class="code" href="classFEInterfaceValues.html#a94062e68c68a7277aa1541854a5ae62d">get_JxW_values</a>();</div><div class="line">      <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_iv.<a class="code" href="classFEInterfaceValues.html#a012d902cd158f8cd225b07ac741fa493">get_normal_vectors</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qpoint = 0; qpoint &lt; q_points.size(); ++qpoint)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> beta_dot_n = beta(q_points[qpoint]) * normals[qpoint];</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs; ++j)</div><div class="line">              copy_data_face.cell_matrix(i, j) +=</div><div class="line">                fe_iv.<a class="code" href="classFEInterfaceValues.html#a7827502cb506dbd5d6b2f740184f0a21">jump</a>(i, qpoint) <span class="comment">// [\phi_i]</span></div><div class="line">                *</div><div class="line">                fe_iv.<a class="code" href="classFEInterfaceValues.html#a64e0e1fd4a783edeeef812c4416d59eb">shape_value</a>((beta_dot_n &gt; 0), j, qpoint) <span class="comment">// phi_j^{upwind}</span></div><div class="line">                * beta_dot_n                                   <span class="comment">// (\beta . n)</span></div><div class="line">                * JxW[qpoint];                                 <span class="comment">// dx</span></div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;c) {</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(c.cell_matrix,</div><div class="line">                                             c.cell_rhs,</div><div class="line">                                             c.local_dof_indices,</div><div class="line">                                             system_matrix,</div><div class="line">                                             right_hand_side);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cdf : c.face_data)</div><div class="line">        {</div><div class="line">          constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cdf.cell_matrix,</div><div class="line">                                                 cdf.joint_dof_indices,</div><div class="line">                                                 system_matrix);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    ScratchData&lt;dim&gt; scratch_data(mapping, fe, quadrature, quadrature_face);</div><div class="line">    CopyData         copy_data;</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.begin_active(),</div><div class="line">                          dof_handler.end(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          scratch_data,</div><div class="line">                          copy_data,</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a> |</div><div class="line">                            <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa35f26e2d96f28fb49e5b0865adc3ba9d">MeshWorker::assemble_boundary_faces</a> |</div><div class="line">                            <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47c6806a06155c94191629fae2755763">MeshWorker::assemble_own_interior_faces_once</a>,</div><div class="line">                          boundary_worker,</div><div class="line">                          face_worker);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">    <a class="code" href="classSolverRichardson.html">SolverRichardson&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionBlockSSOR.html">PreconditionBlockSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line"></div><div class="line">    preconditioner.<a class="code" href="classPreconditionBlock.html#a6c61513fe17633b8b4e1dd2d83b72e81">initialize</a>(system_matrix, fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, right_hand_side, preconditioner);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Solver converged in &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::refine_grid()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; gradient_indicator(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceDerivativeApproximation.html#a98d28e4c1c17164c48719cdfe4a363e6">DerivativeApproximation::approximate_gradient</a>(mapping,</div><div class="line">                                                  dof_handler,</div><div class="line">                                                  solution,</div><div class="line">                                                  gradient_indicator);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">      gradient_indicator(cell_no++) *=</div><div class="line">        <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(cell-&gt;diameter(), 1 + 1.0 * dim / 2);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    gradient_indicator,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.1);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Writing solution to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl;</div><div class="line">    std::ofstream output(filename);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;u&quot;</span>, <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line"></div><div class="line">    {</div><div class="line">      Vector&lt;float&gt; <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                        dof_handler,</div><div class="line">                                        solution,</div><div class="line">                                        <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                        values,</div><div class="line">                                        quadrature,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> l_infty =</div><div class="line">        <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                          values,</div><div class="line">                                          <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  L-infinity norm: &quot;</span> &lt;&lt; l_infty &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 6; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step12</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step12::AdvectionProblem&lt;2&gt; dgmethod;</div><div class="line">      dgmethod.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>This tutorial depends on <a class="el" href="step_7.html">step-7</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Overview">Overview</a>
        <li><a href="#Theequation">The equation</a>
        <li><a href="#Thetestproblem">The test problem</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Equationdata">Equation data</a>
        <li><a href="#TheScratchDataandCopyDataclasses">The ScratchData and CopyData classes</a>
        <li><a href="#TheAdvectionProblemclass">The AdvectionProblem class</a>
      <ul>
        <li><a href="#Theassemble_systemfunction">The assemble_system function</a>
      </ul>
        <li><a href="#Alltherest">All the rest</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Whyusediscontinuouselements">Why use discontinuous elements</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-12/doc/intro.dox</p>
<p><br />
</p>
<p><em> Note: A variant called <a class="el" href="step_12b.html">step-12b</a> of this tutorial exists, using <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> and <a class="el" href="namespaceLocalIntegrators.html" title="Library of integrals over cells and faces 这个命名空间包含了双线性形式、形式和误差估计的特定应用局部\x{00E7}...">LocalIntegrators</a> instead of assembling matrices using <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a> as is done in this tutorial. </em></p>
<p><a class="anchor" id="Intro"></a></p>
<p><a class="anchor" id="AnexampleofanadvectionproblemusingtheDiscountinuousGalerkinmethod"></a></p><h1>An example of an advection problem using the Discountinuous Galerkin method</h1>
<p><a class="anchor" id="Overview"></a></p><h3>Overview</h3>
<p>本例专门介绍了 <em> 非连续Galerkin方法 </em> ，简称为DG方法。它包括以下内容。</p><ol>
<li>
用DG方法对线性平流方程进行离散化。 </li>
<li>
使用FEInterfaceValues组装跳跃项和单元间界面上的其他表达式。 </li>
<li>
使用 <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>. </li>
</ol>
<p>组合系统矩阵。</p>
<p>这个项目特别关注的是DG方法的循环。这些被证明是特别复杂的，主要是因为对于面的条件，我们必须分别区分边界、规则的内部面和有悬挂节点的内部面的情况。 <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> 处理了单元和面迭代的复杂性，并允许为不同的单元和面项指定 "工作者"。面条款本身的整合，包括对自适应细化面的整合，是通过FEInterfaceValues类完成的。</p>
<p><a class="anchor" id="Theequation"></a></p><h3>The equation</h3>
<p>本例中解决的模型问题是线性平流方程</p>
<p class="formulaDsp">
\[ \nabla\cdot \left({\mathbf \beta} u\right)=0 \qquad\mbox{in }\Omega, \]
</p>
<p>受制于边界条件</p>
<p class="formulaDsp">
\[ u=g\quad\mbox{on }\Gamma_-, \]
</p>
<p>在域的边界 \(\Gamma=\partial\Omega\) 的流入部分 \(\Gamma_-\) 。 这里， \({\mathbf \beta}={\mathbf \beta}({\bf x})\) 表示一个矢量场， \(u\) 是（标量）解函数， \(g\) 是边界值函数。</p>
<p class="formulaDsp">
\[ \Gamma_- \dealcoloneq \{{\bf x}\in\Gamma, {\mathbf \beta}({\bf x})\cdot{\bf n}({\bf x})&lt;0\} \]
</p>
<p>表示域边界的流入部分， \({\bf n}\) 表示边界的单位外向法线 \(\Gamma\) 。这个方程是本教程第9步中已经考虑过的平流方程的保守版本。</p>
<p>在每个单元格 \(T\) 上，我们从左边乘以一个测试函数 \(v_h\) ，并通过部分整合得到。</p>
<p class="formulaDsp">
\[ \left( v_h, \nabla \cdot (\beta u_h) \right)_T = -(\nabla v_h, \beta u_h) + \int_\Gamma v_h u_h \beta \cdot n \]
</p>
<p>当对所有单元 \(T\) 求和时，边界积分是在所有内部和外部面进行的，因此，有三种情况。</p><ol>
<li>
流入的外部边界（我们用给定的 \(g\) 代替 \(u_h\) ）。 \(\int_{\Gamma_-} v_h g \beta \cdot n\) </li>
<li>
流出的外部边界。 \(\int_{\Gamma_+} v_h u_h \beta \cdot n\) </li>
<li>
内面（两边的积分变成了跳跃，我们使用上风速度）。 \(\int_F [v_h] u_h^{\text{upwind}} \beta \cdot n\) </li>
</ol>
<p>。</p>
<p>这里，跳跃被定义为 \([v] = v^+ - v^-\) ，其中上标指的是面的左（'+'）和右（'-'）值。如果 \(\beta \cdot n&gt;0\) ，上风值 \(u^{\text{upwind}}\) 被定义为 \(u^+\) ，否则为 \(u^-\) 。</p>
<p>因此，依赖网格的弱形式为：。</p>
<p class="formulaDsp">
\[ \sum_{T\in \mathbb T_h} -\bigl(\nabla \phi_i,{\mathbf \beta}\cdot \phi_j \bigr)_T + \sum_{F\in\mathbb F_h^i} \bigl&lt; [\phi_i], \phi_j^{upwind} \beta\cdot \mathbf n\bigr&gt;_{F} + \bigl&lt;\phi_i, \phi_j \beta\cdot \mathbf n\bigr&gt;_{\Gamma_+} = -\bigl&lt;\phi_i, g \beta\cdot\mathbf n\bigr&gt;_{\Gamma_-}. \]
</p>
<p>这里， \(\mathbb T_h\) 是三角形的所有活动单元的集合， \(\mathbb F_h^i\) 是所有活动内部面的集合。这种公式被称为上风非连续Galerkin方法。</p>
<p>为了实现这种双线性形式，我们需要用通常的方法计算单元项（第一个和）来实现单元上的积分，用FEInterfaceValues计算界面项（第二个和），以及边界项（另外两个项）。所有这些的求和是通过 <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>. 完成的。</p>
<p><a class="anchor" id="Thetestproblem"></a></p><h3>The test problem</h3>
<p>我们在 \(\Omega=[0,1]^2\) 上求解平流方程， \({\mathbf \beta}=\frac{1}{|x|}(-x_2, x_1)\) 代表一个圆形的逆时针流场， \(g=1\) 代表 \({\bf x}\in\Gamma_-^1 := [0,0.5]\times\{0\}\) ， \(g=0\) 代表 \({\bf x}\in \Gamma_-\setminus \Gamma_-^1\) 。</p>
<p>我们通过估计每个单元的梯度规范，自适应地细化网格，在一连串的网格上求解。在每个网格上求解后，我们以vtk格式输出解决方案，并计算解决方案的 \(L^\infty\) 准则。由于精确解是0或1，我们可以用它来衡量数值解的过冲程度。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>The first few files have already been covered in previous examples and will thus not be further commented on:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q1_8h.html">deal.II/fe/mapping_q1.h</a>&gt;</span></div></div><!-- fragment --><p>Here the discontinuous finite elements are defined. They are used in the same way as all other finite elements, though &ndash; as you have seen in previous tutorial programs &ndash; there isn't much user interaction with finite element classes at all: they are passed to <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> and <code><a class="el" href="classFEValues.html">FEValues</a></code> objects, and that is about it.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div></div><!-- fragment --><p>This header is needed for <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a> to compute integrals on interfaces:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__interface__values_8h.html">deal.II/fe/fe_interface_values.h</a>&gt;</span></div></div><!-- fragment --><p>We are going to use the simplest possible solver, called Richardson iteration, that represents a simple defect correction. This, in combination with a block SSOR preconditioner (defined in <a class="el" href="precondition__block_8h.html">precondition_block.h</a>), that uses the special block matrix structure of system matrices arising from DG discretizations.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__richardson_8h.html">deal.II/lac/solver_richardson.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition__block_8h.html">deal.II/lac/precondition_block.h</a>&gt;</span></div></div><!-- fragment --><p>We are going to use gradients as refinement indicator.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="derivative__approximation_8h.html">deal.II/numerics/derivative_approximation.h</a>&gt;</span></div></div><!-- fragment --><p>Finally, the new include file for using the mesh_loop from the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> framework</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div></div><!-- fragment --><p>Like in all programs, we finish this section by including the needed C++ headers and declaring we want to use objects in the dealii namespace without prefix.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step12</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div></div><!-- fragment --><p><a class="anchor" id="Equationdata"></a> </p><h3>Equation data</h3>
<p>First, we define a class describing the inhomogeneous boundary data. Since only its values are used, we implement value_list(), but leave all other functions of <a class="el" href="classFunction.html">Function</a> undefined.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  BoundaryValues() = <span class="keywordflow">default</span>;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                          std::vector&lt;double&gt; &amp;          values,</div><div class="line">                          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">};</div></div><!-- fragment --><p>Given the flow direction, the inflow boundary of the unit square \([0,1]^2\) are the right and the lower boundaries. We prescribe discontinuous boundary values 1 and 0 on the x-axis and value 0 on the right boundary. The values of this function on the outflow boundaries will not be used within the DG scheme.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                     std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  (void)component;</div><div class="line">  <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">         <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; values.size(); ++i)</div><div class="line">    {</div><div class="line">      <span class="keywordflow">if</span> (points[i](0) &lt; 0.5)</div><div class="line">        values[i] = 1.;</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        values[i] = 0.;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Finally, a function that computes and returns the wind field \(\beta=\beta(\mathbf x)\). As explained in the introduction, we will use a rotational field around the origin in 2d. In 3d, we simply leave the \(z\)-component unset (i.e., at zero), whereas the function can not be used in 1d in its current implementation:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> beta(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">{</div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt;= 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> wind_field;</div><div class="line">  wind_field[0] = -p[1];</div><div class="line">  wind_field[1] = p[0];</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (wind_field.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() &gt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-10)</div><div class="line">    wind_field /= wind_field.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> wind_field;</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="TheScratchDataandCopyDataclasses"></a> </p><h3>The ScratchData and CopyData classes</h3>
<p>The following objects are the scratch and copy objects we use in the call to <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>. The new object is the <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a> object, that works similar to <a class="el" href="classFEValues.html">FEValues</a> or FEFacesValues, except that it acts on an interface between two cells and allows us to assemble the interface terms in our weak form.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">struct </span>ScratchData</div><div class="line">{</div><div class="line">  ScratchData(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;       mapping,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; fe,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    quadrature,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;quadrature_face,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>          update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                               <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>,</div><div class="line">              <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> interface_update_flags =</div><div class="line">                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>)</div><div class="line">    : fe_values(mapping, fe, quadrature, update_flags)</div><div class="line">    , fe_interface_values(mapping,</div><div class="line">                          fe,</div><div class="line">                          quadrature_face,</div><div class="line">                          interface_update_flags)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">    : fe_values(scratch_data.fe_values.get_mapping(),</div><div class="line">                scratch_data.fe_values.get_fe(),</div><div class="line">                scratch_data.fe_values.get_quadrature(),</div><div class="line">                scratch_data.fe_values.get_update_flags())</div><div class="line">    , fe_interface_values(scratch_data.fe_interface_values.get_mapping(),</div><div class="line">                          scratch_data.fe_interface_values.get_fe(),</div><div class="line">                          scratch_data.fe_interface_values.get_quadrature(),</div><div class="line">                          scratch_data.fe_interface_values.get_update_flags())</div><div class="line">  {}</div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>          fe_values;</div><div class="line">  <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> fe_interface_values;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct </span>CopyDataFace</div><div class="line">{</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; joint_dof_indices;</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct </span>CopyData</div><div class="line">{</div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a>                       cell_rhs;</div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">  std::vector&lt;CopyDataFace&gt;            face_data;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> Iterator &amp;cell, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">  {</div><div class="line">    cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line">    cell_rhs.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(dofs_per_cell);</div><div class="line"></div><div class="line">    local_dof_indices.resize(dofs_per_cell);</div><div class="line">    cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p><a class="anchor" id="TheAdvectionProblemclass"></a> </p><h3>The AdvectionProblem class</h3>
<p>After this preparations, we proceed with the main class of this program, called AdvectionProblem.</p>
<p>This should all be pretty familiar to you. Interesting details will only come up in the implementation of the assemble function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>AdvectionProblem</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  AdvectionProblem();</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">void</span> setup_system();</div><div class="line">  <span class="keywordtype">void</span> assemble_system();</div><div class="line">  <span class="keywordtype">void</span> solve();</div><div class="line">  <span class="keywordtype">void</span> refine_grid();</div><div class="line">  <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div></div><!-- fragment --><p>Furthermore we want to use DG elements.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a> fe;</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>   dof_handler;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature;</div><div class="line"><span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; quadrature_face;</div></div><!-- fragment --><p>The next four members represent the linear system to be solved. <code>system_matrix</code> and <code>right_hand_side</code> are generated by <code>assemble_system()</code>, the <code>solution</code> is computed in <code>solve()</code>. The <code>sparsity_pattern</code> is used to determine the location of nonzero elements in <code>system_matrix</code>.</p>
<div class="fragment"><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">  <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> solution;</div><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> right_hand_side;</div><div class="line">};</div></div><!-- fragment --><p>We start with the constructor. The 1 in the constructor call of <code>fe</code> is the polynomial degree.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">AdvectionProblem&lt;dim&gt;::AdvectionProblem()</div><div class="line">  : mapping()</div><div class="line">  , fe(1)</div><div class="line">  , dof_handler(triangulation)</div><div class="line">  , quadrature(fe.tensor_degree() + 1)</div><div class="line">  , quadrature_face(fe.tensor_degree() + 1)</div><div class="line">{}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_system()</div><div class="line">{</div></div><!-- fragment --><p>In the function that sets up the usual finite element data structures, we first need to distribute the DoFs.</p>
<div class="fragment"><div class="line">dof_handler.distribute_dofs(fe);</div></div><!-- fragment --><p>We start by generating the sparsity pattern. To this end, we first fill an intermediate object of type <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> with the couplings appearing in the system. After building the pattern, this object is copied to <code>sparsity_pattern</code> and can be discarded.</p>
<p>To build the sparsity pattern for DG discretizations, we can call the function analogue to <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>, which is called <a class="el" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line"><a class="code" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">sparsity_pattern.copy_from(dsp);</div></div><!-- fragment --><p>Finally, we set up the structure of all components of the linear system.</p>
<div class="fragment"><div class="line">  system_matrix.reinit(sparsity_pattern);</div><div class="line">  solution.reinit(dof_handler.n_dofs());</div><div class="line">  right_hand_side.reinit(dof_handler.n_dofs());</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Theassemble_systemfunction"></a> </p><h4>The assemble_system function</h4>
<p>Here we see the major difference to assembling by hand. Instead of writing loops over cells and faces, the logic is contained in the call to <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> and we only need to specify what should happen on each cell, each boundary face, and each interior face. These three tasks are handled by the lambda functions inside the function below.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_system()</div><div class="line">{</div><div class="line">  <span class="keyword">using</span> Iterator = <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a>;</div><div class="line">  <span class="keyword">const</span> BoundaryValues&lt;dim&gt; boundary_function;</div></div><!-- fragment --><p>This is the function that will be executed for each cell.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                             ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                             CopyData &amp;        copy_data) {</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs =</div><div class="line">    scratch_data.fe_values.get_fe().n_dofs_per_cell();</div><div class="line">  copy_data.reinit(cell, n_dofs);</div><div class="line">  scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = scratch_data.fe_values.get_quadrature_points();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;      fe_v = scratch_data.fe_values;</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW  = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div></div><!-- fragment --><p>We solve a homogeneous equation, thus no right hand side shows up in the cell term. What's left is integrating the matrix entries.</p>
<div class="fragment"><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> = 0; <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> &lt; fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">    {</div><div class="line">      <span class="keyword">auto</span> beta_q = beta(q_points[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs; ++j)</div><div class="line">          {</div><div class="line">            copy_data.cell_matrix(i, j) +=</div><div class="line">              -beta_q                      <span class="comment">// -\beta</span></div><div class="line">              * fe_v.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)  <span class="comment">// \nabla \phi_i</span></div><div class="line">              * fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_j</span></div><div class="line">              * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                <span class="comment">// dx</span></div><div class="line">          }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>This is the function called for boundary faces and consists of a normal integration using <a class="el" href="classFEFaceValues.html">FEFaceValues</a>. New is the logic to decide if the term goes into the system matrix (outflow) or the right-hand side (inflow).</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> boundary_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;    cell,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;face_no,</div><div class="line">                                 ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                                 CopyData &amp;          copy_data) {</div><div class="line">  scratch_data.fe_interface_values.reinit(cell, face_no);</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_face =</div><div class="line">    scratch_data.fe_interface_values.get_fe_face_values(0);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = fe_face.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_facet_dofs = fe_face.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_face.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_face.<a class="code" href="classFEValuesBase.html#a80d39b9aea51af573ded84342b8b330d">get_normal_vectors</a>();</div><div class="line"></div><div class="line">  std::vector&lt;double&gt; g(q_points.size());</div><div class="line">  boundary_function.value_list(q_points, g);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> = 0; <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> &lt; q_points.size(); ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta_dot_n = beta(q_points[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]) * normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (beta_dot_n &gt; 0)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_facet_dofs; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_facet_dofs; ++j)</div><div class="line">              copy_data.cell_matrix(i, j) +=</div><div class="line">                fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)   <span class="comment">// \phi_i</span></div><div class="line">                * fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_j</span></div><div class="line">                * beta_dot_n                    <span class="comment">// \beta . n</span></div><div class="line">                * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                   <span class="comment">// dx</span></div><div class="line">        }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_facet_dofs; ++i)</div><div class="line">          copy_data.cell_rhs(i) += -fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_i</span></div><div class="line">                                   * g[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]                     <span class="comment">// g</span></div><div class="line">                                   * beta_dot_n  <span class="comment">// \beta . n</span></div><div class="line">                                   * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]; <span class="comment">// dx</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>This is the function called on interior faces. The arguments specify cells, face and subface indices (for adaptive refinement). We just pass them along to the <a class="el" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit()</a> function of <a class="el" href="classFEInterfaceValues.html">FEInterfaceValues</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> face_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;    cell,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;f,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;sf,</div><div class="line">                             <span class="keyword">const</span> Iterator &amp;    ncell,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nf,</div><div class="line">                             <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nsf,</div><div class="line">                             ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                             CopyData &amp;          copy_data) {</div><div class="line">  <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv = scratch_data.fe_interface_values;</div><div class="line">  fe_iv.<a class="code" href="classFEInterfaceValues.html#af6aa20b6652c2605d4cee36021f6bcd2">reinit</a>(cell, f, sf, ncell, nf, nsf);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = fe_iv.<a class="code" href="classFEInterfaceValues.html#a77a7eb2a9540fe9583bae505fbbe1e73">get_quadrature_points</a>();</div><div class="line"></div><div class="line">  copy_data.face_data.emplace_back();</div><div class="line">  CopyDataFace &amp;copy_data_face = copy_data.face_data.back();</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs        = fe_iv.<a class="code" href="classFEInterfaceValues.html#a5345658da9be54b10a6dbb8ca47c886c">n_current_interface_dofs</a>();</div><div class="line">  copy_data_face.joint_dof_indices = fe_iv.<a class="code" href="classFEInterfaceValues.html#a03cd7e51c953a5d44b993860a8dbfe1c">get_interface_dof_indices</a>();</div><div class="line"></div><div class="line">  copy_data_face.cell_matrix.reinit(n_dofs, n_dofs);</div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_iv.<a class="code" href="classFEInterfaceValues.html#a94062e68c68a7277aa1541854a5ae62d">get_JxW_values</a>();</div><div class="line">  <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_iv.<a class="code" href="classFEInterfaceValues.html#a012d902cd158f8cd225b07ac741fa493">get_normal_vectors</a>();</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qpoint = 0; qpoint &lt; q_points.size(); ++qpoint)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> beta_dot_n = beta(q_points[qpoint]) * normals[qpoint];</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs; ++i)</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs; ++j)</div><div class="line">          copy_data_face.cell_matrix(i, j) +=</div><div class="line">            fe_iv.<a class="code" href="classFEInterfaceValues.html#a7827502cb506dbd5d6b2f740184f0a21">jump</a>(i, qpoint) <span class="comment">// [\phi_i]</span></div><div class="line">            *</div><div class="line">            fe_iv.<a class="code" href="classFEInterfaceValues.html#a64e0e1fd4a783edeeef812c4416d59eb">shape_value</a>((beta_dot_n &gt; 0), j, qpoint) <span class="comment">// phi_j^{upwind}</span></div><div class="line">            * beta_dot_n                                   <span class="comment">// (\beta . n)</span></div><div class="line">            * JxW[qpoint];                                 <span class="comment">// dx</span></div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>The following lambda function will handle copying the data from the cell and face assembly into the global matrix and right-hand side.</p>
<p>While we would not need an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object, because there are no hanging node constraints in DG discretizations, we use an empty object here as this allows us to use its <code>copy_local_to_global</code> functionality.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;c) {</div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(c.cell_matrix,</div><div class="line">                                         c.cell_rhs,</div><div class="line">                                         c.local_dof_indices,</div><div class="line">                                         system_matrix,</div><div class="line">                                         right_hand_side);</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cdf : c.face_data)</div><div class="line">    {</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cdf.cell_matrix,</div><div class="line">                                             cdf.joint_dof_indices,</div><div class="line">                                             system_matrix);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">ScratchData&lt;dim&gt; scratch_data(mapping, fe, quadrature, quadrature_face);</div><div class="line">CopyData         copy_data;</div></div><!-- fragment --><p>Here, we finally handle the assembly. We pass in ScratchData and CopyData objects, the lambda functions from above, an specify that we want to assemble interior faces once.</p>
<div class="fragment"><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.begin_active(),</div><div class="line">                        dof_handler.end(),</div><div class="line">                        cell_worker,</div><div class="line">                        copier,</div><div class="line">                        scratch_data,</div><div class="line">                        copy_data,</div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a> |</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa35f26e2d96f28fb49e5b0865adc3ba9d">MeshWorker::assemble_boundary_faces</a> |</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47c6806a06155c94191629fae2755763">MeshWorker::assemble_own_interior_faces_once</a>,</div><div class="line">                        boundary_worker,</div><div class="line">                        face_worker);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="Alltherest"></a> </p><h3>All the rest</h3>
<p>For this simple problem we use the simplest possible solver, called Richardson iteration, that represents a simple defect correction. This, in combination with a block SSOR preconditioner, that uses the special block matrix structure of system matrices arising from DG discretizations. The size of these blocks are the number of DoFs per cell. Here, we use a SSOR preconditioning as we have not renumbered the DoFs according to the flow field. If the DoFs are renumbered in the downstream direction of the flow, then a block Gauss-Seidel preconditioner (see the <a class="el" href="classPreconditionBlockSOR.html">PreconditionBlockSOR</a> class with relaxation=1) does a much better job.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::solve()</div><div class="line">{</div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">  <a class="code" href="classSolverRichardson.html">SolverRichardson&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div></div><!-- fragment --><p>Here we create the preconditioner,</p>
<div class="fragment"><div class="line"><a class="code" href="classPreconditionBlockSSOR.html">PreconditionBlockSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div></div><!-- fragment --><p>then assign the matrix to it and set the right block size:</p>
<div class="fragment"><div class="line">preconditioner.<a class="code" href="classPreconditionBlock.html#a6c61513fe17633b8b4e1dd2d83b72e81">initialize</a>(system_matrix, fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div></div><!-- fragment --><p>After these preparations we are ready to start the linear solver.</p>
<div class="fragment"><div class="line">  solver.solve(system_matrix, solution, right_hand_side, preconditioner);</div><div class="line"></div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Solver converged in &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">            &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>We refine the grid according to a very simple refinement criterion, namely an approximation to the gradient of the solution. As here we consider the DG(1) method (i.e. we use piecewise bilinear shape functions) we could simply compute the gradients on each cell. But we do not want to base our refinement indicator on the gradients on each cell only, but want to base them also on jumps of the discontinuous solution function over faces between neighboring cells. The simplest way of doing that is to compute approximative gradients by difference quotients including the cell under consideration and its neighbors. This is done by the <code><a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a></code> class that computes the approximate gradients in a way similar to the <code>GradientEstimation</code> described in <a class="el" href="step_9.html">step-9</a> of this tutorial. In fact, the <code><a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a></code> class was developed following the <code>GradientEstimation</code> class of <a class="el" href="step_9.html">step-9</a>. Relating to the discussion in <a class="el" href="step_9.html">step-9</a>, here we consider \(h^{1+d/2}|\nabla_h u_h|\). Furthermore we note that we do not consider approximate second derivatives because solutions to the linear advection equation are in general not in \(H^2\) but only in \(H^1\) (or, to be more precise: in \(H^1_\beta\), i.e., the space of functions whose derivatives in direction \(\beta\) are square integrable).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::refine_grid()</div><div class="line">{</div></div><!-- fragment --><p>The <code><a class="el" href="namespaceDerivativeApproximation.html">DerivativeApproximation</a></code> class computes the gradients to float precision. This is sufficient as they are approximate and serve as refinement indicators only.</p>
<div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> gradient_indicator(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div></div><!-- fragment --><p>Now the approximate gradients are computed</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceDerivativeApproximation.html#a98d28e4c1c17164c48719cdfe4a363e6">DerivativeApproximation::approximate_gradient</a>(mapping,</div><div class="line">                                              dof_handler,</div><div class="line">                                              solution,</div><div class="line">                                              gradient_indicator);</div></div><!-- fragment --><p>and they are cell-wise scaled by the factor \(h^{1+d/2}\)</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">  gradient_indicator(cell_no++) *=</div><div class="line">    <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(cell-&gt;diameter(), 1 + 1.0 * dim / 2);</div></div><!-- fragment --><p>Finally they serve as refinement indicator.</p>
<div class="fragment"><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                  gradient_indicator,</div><div class="line">                                                  0.3,</div><div class="line">                                                  0.1);</div><div class="line"></div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">}</div></div><!-- fragment --><p>The output of this program consists of a vtk file of the adaptively refined grids and the numerical solutions. Finally, we also compute the L-infinity norm of the solution using <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">  <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  Writing solution to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl;</div><div class="line">  std::ofstream output(filename);</div><div class="line"></div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;u&quot;</span>, <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping);</div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line"></div><div class="line">  {</div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">    <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                      dof_handler,</div><div class="line">                                      solution,</div><div class="line">                                      <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                      values,</div><div class="line">                                      quadrature,</div><div class="line">                                      <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> l_infty =</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                        values,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  L-infinity norm: &quot;</span> &lt;&lt; l_infty &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>The following <code>run</code> function is similar to previous examples.</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 6; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step12</span></div></div><!-- fragment --><p>The following <code>main</code> function is similar to previous examples as well, and need not be commented on.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step12::AdvectionProblem&lt;2&gt; dgmethod;</div><div class="line">      dgmethod.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> examples/step-12/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>这个程序的输出包括控制台输出和vtk格式的解决方案。</p>
<div class="fragment"><div class="line">Cycle 0</div><div class="line">  Number of active cells:       64</div><div class="line">  Number of degrees of freedom: 256</div><div class="line">  Solver converged in 4 iterations.</div><div class="line">  Writing solution to &lt;solution-0.vtk&gt;</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.09057</div><div class="line">Cycle 1</div><div class="line">  Number of active cells:       112</div><div class="line">  Number of degrees of freedom: 448</div><div class="line">  Solver converged in 9 iterations.</div><div class="line">  Writing solution to &lt;solution-1.vtk&gt;</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.10402</div><div class="line">Cycle 2</div><div class="line">  Number of active cells:       214</div><div class="line">  Number of degrees of freedom: 856</div><div class="line">  Solver converged in 16 iterations.</div><div class="line">  Writing solution to &lt;solution-2.vtk&gt;</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.09813</div><div class="line">Cycle 3</div><div class="line">  Number of active cells:       415</div><div class="line">  Number of degrees of freedom: 1660</div><div class="line">  Solver converged in 26 iterations.</div><div class="line">  Writing solution to &lt;solution-3.vtk&gt;</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.09579</div><div class="line">Cycle 4</div><div class="line">  Number of active cells:       796</div><div class="line">  Number of degrees of freedom: 3184</div><div class="line">  Solver converged in 44 iterations.</div><div class="line">  Writing solution to &lt;solution-4.vtk&gt;</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a0a1f0b9f7bb0b746b8f27d7f297ed7fe">L</a>-infinity <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a>: 1.09612</div><div class="line">Cycle 5</div><div class="line">  Number of active cells:       1561</div><div class="line">  Number of degrees of freedom: 6244</div><div class="line">  Solver converged in 81 iterations.</div><div class="line">  Writing solution to &lt;solution-5.vtk&gt;</div></div><!-- fragment --><p>我们展示了初始网格的解决方案，以及经过两个和五个自适应细化步骤后的网格。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-0.png"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-2.png"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-5.png"/>
</div>
<p> 。</p>
<p>最后我们展示一个3D计算的图。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.sol-5-3d.png"/>
</div>
<p><a class="anchor" id="dg-vs-cg"></a></p>
<p><a class="anchor" id="Whyusediscontinuouselements"></a></p><h3>Why use discontinuous elements</h3>
<p>在这个程序中，我们使用了不连续的元素。这是一个合理的问题，为什么不简单地使用正常的、连续的元素呢？当然，对于每个有数值方法背景的人来说，答案是显而易见的：连续Galerkin（cG）方法对于输运方程是不稳定的，除非特别添加稳定项。然而，DG方法<em>is</em>则是稳定的。用目前的程序来说明这一点并不十分困难；事实上，只需要做以下的小修改就可以了。</p>
<ul>
<li>将该元素改为FE_Q，而不是FE_DGQ。</li>
<li>以与步骤6完全相同的方式增加对悬挂节点约束的处理。</li>
<li>我们需要一个不同的求解器；步骤29中的直接求解器是一个方便的选择。一个有经验的deal.II用户将能够在10分钟内完成这一工作。</li>
</ul>
<p>虽然上面显示了二维解决方案，在界面上含有一些小的尖峰，但是在网格细化的情况下，这些尖峰的高度是稳定的，当使用连续元素时，结果看起来有很大不同。</p>
<table align="center">
<tr>
<td valign="top">0 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-0.png"/>
</div>
  </td><td valign="top">1 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-1.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">2 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-2.png"/>
</div>
  </td><td valign="top">3 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-3.png"/>
</div>
   </td></tr>
<tr>
<td valign="top">4 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-4.png"/>
</div>
  </td><td valign="top">5 &#160;  </td><td valign="top"><div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-12.cg.sol-5.png"/>
</div>
   </td></tr>
</table>
<p>在细化迭代5中，图像不能再以合理的方式绘制成三维图。因此我们展示了一个范围为 \([-1,2]\) 的彩色图（当然，精确解的解值位于 \([0,1]\) ）。在任何情况下，很明显，连续Galerkin解表现出振荡行为，随着网格的细化越来越差。</p>
<p>如果出于某种原因想使用连续元素，有很多策略可以稳定cG方法。讨论这些方法超出了本教程程序的范围；例如，感兴趣的读者可以看看步骤31。</p>
<p><a class="anchor" id="extensions"></a></p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>鉴于在这种情况下确切的解是已知的，进一步扩展的一个有趣的途径是确认这个程序的收敛顺序。在目前的情况下，解是非光滑的，因此我们不能期望得到特别高的收敛阶，即使我们使用高阶元素。但是，即使解<em>is</em>光滑，方程也不是椭圆的，因此，我们应该得到等于最优插值估计的收敛阶，这一点并不明显（例如，我们通过使用二次元会得到 \(h^3\) 在 \(L^2\) 准则下的收敛）。</p>
<p>事实上，对于双曲方程来说，理论预测常常表明，我们所能希望的最好结果是比插值估计值低二分之一的阶。例如，对于流线扩散法（此处用于稳定传输方程解的DG法的替代方法），可以证明对于度数为 \(p\) 的元素，在任意网格上的收敛阶为 \(p+\frac 12\) 。虽然在均匀细化的网格上观察到的顺序经常是 \(p+1\) ，但人们可以构建所谓的彼得森网格，在这些网格上实际上达到了更差的理论约束。这应该是比较容易验证的，例如使用 <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a> 函数。</p>
<p>一个不同的方向是观察运输问题的解决经常有不连续性，因此，我们<em>bisect</em>在每个坐标方向上的每个单元的网格可能不是最佳的。相反，一个更好的策略是只在平行于不连续的方向上切割单元。这被称为<em>anisotropic mesh refinement</em>，是步骤30的主题。</p>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Copyright (C) 2009 - 2021 by the deal.II authors</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div><div class="line"><span class="comment"> * the top level directory of deal.II.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Author: Guido Kanschat, Texas A&amp;M University, 2009</span></div><div class="line"><span class="comment"> *         Timo Heister, Clemson University, 2019</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__out_8h.html">deal.II/grid/grid_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mapping__q1_8h.html">deal.II/fe/mapping_q1.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__dgq_8h.html">deal.II/fe/fe_dgq.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__interface__values_8h.html">deal.II/fe/fe_interface_values.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__richardson_8h.html">deal.II/lac/solver_richardson.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition__block_8h.html">deal.II/lac/precondition_block.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="derivative__approximation_8h.html">deal.II/numerics/derivative_approximation.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step12</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    BoundaryValues() = <span class="keywordflow">default</span>;</div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                            std::vector&lt;double&gt; &amp;          values,</div><div class="line">                            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>;</div><div class="line">  };</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> BoundaryValues&lt;dim&gt;::value_list(<span class="keyword">const</span> std::vector&lt;<a class="code" href="classPoint.html">Point&lt;dim&gt;</a>&gt; &amp;points,</div><div class="line">                                       std::vector&lt;double&gt; &amp;          values,</div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    (void)component;</div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(component, 1);</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(values.size() == points.size(),</div><div class="line">           <a class="code" href="group__Exceptions.html#ga6060b2304b8600f5efa0d31eeda0207d">ExcDimensionMismatch</a>(values.size(), points.size()));</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; values.size(); ++i)</div><div class="line">      {</div><div class="line">        <span class="keywordflow">if</span> (points[i](0) &lt; 0.5)</div><div class="line">          values[i] = 1.;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          values[i] = 0.;</div><div class="line">      }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> beta(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(dim &gt;= 2, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>());</div><div class="line"></div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> wind_field;</div><div class="line">    wind_field[0] = -p[1];</div><div class="line">    wind_field[1] = p[0];</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (wind_field.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>() &gt; 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-10)</div><div class="line">      wind_field /= wind_field.<a class="code" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a>();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> wind_field;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">struct </span>ScratchData</div><div class="line">  {</div><div class="line">    ScratchData(<span class="keyword">const</span> <a class="code" href="classMapping.html">Mapping&lt;dim&gt;</a> &amp;       mapping,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classFiniteElement.html">FiniteElement&lt;dim&gt;</a> &amp; fe,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim&gt;</a> &amp;    quadrature,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="classQuadrature.html">Quadrature&lt;dim - 1&gt;</a> &amp;quadrature_face,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>          update_flags = <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> |</div><div class="line">                                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div><div class="line">                                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                                                 <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>,</div><div class="line">                <span class="keyword">const</span> <a class="code" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> interface_update_flags =</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> |</div><div class="line">                  <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa5e7366a91c84a50ca4e7dbd43ca6369f">update_normal_vectors</a>)</div><div class="line">      : fe_values(mapping, fe, quadrature, update_flags)</div><div class="line">      , fe_interface_values(mapping,</div><div class="line">                            fe,</div><div class="line">                            quadrature_face,</div><div class="line">                            interface_update_flags)</div><div class="line">    {}</div><div class="line"></div><div class="line"></div><div class="line">    ScratchData(<span class="keyword">const</span> ScratchData&lt;dim&gt; &amp;scratch_data)</div><div class="line">      : fe_values(scratch_data.fe_values.get_mapping(),</div><div class="line">                  scratch_data.fe_values.get_fe(),</div><div class="line">                  scratch_data.fe_values.get_quadrature(),</div><div class="line">                  scratch_data.fe_values.get_update_flags())</div><div class="line">      , fe_interface_values(scratch_data.fe_interface_values.get_mapping(),</div><div class="line">                            scratch_data.fe_interface_values.get_fe(),</div><div class="line">                            scratch_data.fe_interface_values.get_quadrature(),</div><div class="line">                            scratch_data.fe_interface_values.get_update_flags())</div><div class="line">    {}</div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>          fe_values;</div><div class="line">    <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> fe_interface_values;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyDataFace</div><div class="line">  {</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; joint_dof_indices;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">struct </span>CopyData</div><div class="line">  {</div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a>                   <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>;</div><div class="line">    Vector&lt;double&gt;                       cell_rhs;</div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices;</div><div class="line">    std::vector&lt;CopyDataFace&gt;            face_data;</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Iterator&gt;</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(<span class="keyword">const</span> Iterator &amp;cell, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell)</div><div class="line">    {</div><div class="line">      cell_matrix.reinit(dofs_per_cell, dofs_per_cell);</div><div class="line">      cell_rhs.reinit(dofs_per_cell);</div><div class="line"></div><div class="line">      local_dof_indices.resize(dofs_per_cell);</div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices);</div><div class="line">    }</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keyword">class </span>AdvectionProblem</div><div class="line">  {</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    AdvectionProblem();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>();</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> setup_system();</div><div class="line">    <span class="keywordtype">void</span> assemble_system();</div><div class="line">    <span class="keywordtype">void</span> solve();</div><div class="line">    <span class="keywordtype">void</span> refine_grid();</div><div class="line">    <span class="keywordtype">void</span> output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a>   <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classMappingQ1.html">MappingQ1&lt;dim&gt;</a> mapping;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a> fe;</div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>   dof_handler;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature;</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss</a>&lt;dim - 1&gt; quadrature_face;</div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern;</div><div class="line">    <a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a> system_matrix;</div><div class="line"></div><div class="line">    Vector&lt;double&gt; solution;</div><div class="line">    Vector&lt;double&gt; right_hand_side;</div><div class="line">  };</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  AdvectionProblem&lt;dim&gt;::AdvectionProblem()</div><div class="line">    : mapping()</div><div class="line">    , fe(1)</div><div class="line">    , dof_handler(triangulation)</div><div class="line">    , quadrature(fe.tensor_degree() + 1)</div><div class="line">    , quadrature_face(fe.tensor_degree() + 1)</div><div class="line">  {}</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::setup_system()</div><div class="line">  {</div><div class="line">    dof_handler.distribute_dofs(fe);</div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.n_dofs());</div><div class="line">    <a class="code" href="group__constraints.html#ga7b2627e9bde96b98d4fcf95b629e4fd4">DoFTools::make_flux_sparsity_pattern</a>(dof_handler, dsp);</div><div class="line">    sparsity_pattern.copy_from(dsp);</div><div class="line"></div><div class="line">    system_matrix.reinit(sparsity_pattern);</div><div class="line">    solution.reinit(dof_handler.n_dofs());</div><div class="line">    right_hand_side.reinit(dof_handler.n_dofs());</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::assemble_system()</div><div class="line">  {</div><div class="line">    <span class="keyword">using</span> Iterator = <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a>;</div><div class="line">    <span class="keyword">const</span> BoundaryValues&lt;dim&gt; boundary_function;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;  cell,</div><div class="line">                                 ScratchData&lt;dim&gt; &amp;scratch_data,</div><div class="line">                                 CopyData &amp;        copy_data) {</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs =</div><div class="line">        scratch_data.fe_values.get_fe().n_dofs_per_cell();</div><div class="line">      copy_data.reinit(cell, n_dofs);</div><div class="line">      scratch_data.fe_values.reinit(cell);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = scratch_data.fe_values.get_quadrature_points();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> &amp;      fe_v = scratch_data.fe_values;</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;JxW  = fe_v.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> = 0; <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> &lt; fe_v.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>; ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">        {</div><div class="line">          <span class="keyword">auto</span> beta_q = beta(q_points[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]);</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs; ++j)</div><div class="line">              {</div><div class="line">                copy_data.cell_matrix(i, j) +=</div><div class="line">                  -beta_q                      <span class="comment">// -\beta</span></div><div class="line">                  * fe_v.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)  <span class="comment">// \nabla \phi_i</span></div><div class="line">                  * fe_v.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_j</span></div><div class="line">                  * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                <span class="comment">// dx</span></div><div class="line">              }</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> boundary_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;    cell,</div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;face_no,</div><div class="line">                                     ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                                     CopyData &amp;          copy_data) {</div><div class="line">      scratch_data.fe_interface_values.reinit(cell, face_no);</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFEFaceValuesBase.html">FEFaceValuesBase&lt;dim&gt;</a> &amp;fe_face =</div><div class="line">        scratch_data.fe_interface_values.get_fe_face_values(0);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = fe_face.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_facet_dofs = fe_face.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_face.<a class="code" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a>();</div><div class="line">      <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_face.<a class="code" href="classFEValuesBase.html#a80d39b9aea51af573ded84342b8b330d">get_normal_vectors</a>();</div><div class="line"></div><div class="line">      std::vector&lt;double&gt; g(q_points.size());</div><div class="line">      boundary_function.value_list(q_points, g);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> = 0; <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> &lt; q_points.size(); ++<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> beta_dot_n = beta(q_points[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]) * normals[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];</div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (beta_dot_n &gt; 0)</div><div class="line">            {</div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_facet_dofs; ++i)</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_facet_dofs; ++j)</div><div class="line">                  copy_data.cell_matrix(i, j) +=</div><div class="line">                    fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>)   <span class="comment">// \phi_i</span></div><div class="line">                    * fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(j, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_j</span></div><div class="line">                    * beta_dot_n                    <span class="comment">// \beta . n</span></div><div class="line">                    * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>];                   <span class="comment">// dx</span></div><div class="line">            }</div><div class="line">          <span class="keywordflow">else</span></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_facet_dofs; ++i)</div><div class="line">              copy_data.cell_rhs(i) += -fe_face.<a class="code" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a>(i, <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>) <span class="comment">// \phi_i</span></div><div class="line">                                       * g[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]                     <span class="comment">// g</span></div><div class="line">                                       * beta_dot_n  <span class="comment">// \beta . n</span></div><div class="line">                                       * JxW[<a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>]; <span class="comment">// dx</span></div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> face_worker = [&amp;](<span class="keyword">const</span> Iterator &amp;    cell,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;f,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;sf,</div><div class="line">                                 <span class="keyword">const</span> Iterator &amp;    ncell,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nf,</div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp;nsf,</div><div class="line">                                 ScratchData&lt;dim&gt; &amp;  scratch_data,</div><div class="line">                                 CopyData &amp;          copy_data) {</div><div class="line">      <a class="code" href="classFEInterfaceValues.html">FEInterfaceValues&lt;dim&gt;</a> &amp;fe_iv = scratch_data.fe_interface_values;</div><div class="line">      fe_iv.<a class="code" href="classFEInterfaceValues.html#af6aa20b6652c2605d4cee36021f6bcd2">reinit</a>(cell, f, sf, ncell, nf, nsf);</div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;q_points = fe_iv.<a class="code" href="classFEInterfaceValues.html#a77a7eb2a9540fe9583bae505fbbe1e73">get_quadrature_points</a>();</div><div class="line"></div><div class="line">      copy_data.face_data.emplace_back();</div><div class="line">      CopyDataFace &amp;copy_data_face = copy_data.face_data.back();</div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dofs        = fe_iv.<a class="code" href="classFEInterfaceValues.html#a5345658da9be54b10a6dbb8ca47c886c">n_current_interface_dofs</a>();</div><div class="line">      copy_data_face.joint_dof_indices = fe_iv.<a class="code" href="classFEInterfaceValues.html#a03cd7e51c953a5d44b993860a8dbfe1c">get_interface_dof_indices</a>();</div><div class="line"></div><div class="line">      copy_data_face.cell_matrix.reinit(n_dofs, n_dofs);</div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;double&gt; &amp;        JxW     = fe_iv.<a class="code" href="classFEInterfaceValues.html#a94062e68c68a7277aa1541854a5ae62d">get_JxW_values</a>();</div><div class="line">      <span class="keyword">const</span> std::vector&lt;Tensor&lt;1, dim&gt;&gt; &amp;normals = fe_iv.<a class="code" href="classFEInterfaceValues.html#a012d902cd158f8cd225b07ac741fa493">get_normal_vectors</a>();</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> qpoint = 0; qpoint &lt; q_points.size(); ++qpoint)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> beta_dot_n = beta(q_points[qpoint]) * normals[qpoint];</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; n_dofs; ++i)</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; n_dofs; ++j)</div><div class="line">              copy_data_face.cell_matrix(i, j) +=</div><div class="line">                fe_iv.<a class="code" href="classFEInterfaceValues.html#a7827502cb506dbd5d6b2f740184f0a21">jump</a>(i, qpoint) <span class="comment">// [\phi_i]</span></div><div class="line">                *</div><div class="line">                fe_iv.<a class="code" href="classFEInterfaceValues.html#a64e0e1fd4a783edeeef812c4416d59eb">shape_value</a>((beta_dot_n &gt; 0), j, qpoint) <span class="comment">// phi_j^{upwind}</span></div><div class="line">                * beta_dot_n                                   <span class="comment">// (\beta . n)</span></div><div class="line">                * JxW[qpoint];                                 <span class="comment">// dx</span></div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> constraints;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [&amp;](<span class="keyword">const</span> CopyData &amp;c) {</div><div class="line">      constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(c.cell_matrix,</div><div class="line">                                             c.cell_rhs,</div><div class="line">                                             c.local_dof_indices,</div><div class="line">                                             system_matrix,</div><div class="line">                                             right_hand_side);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cdf : c.face_data)</div><div class="line">        {</div><div class="line">          constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cdf.cell_matrix,</div><div class="line">                                                 cdf.joint_dof_indices,</div><div class="line">                                                 system_matrix);</div><div class="line">        }</div><div class="line">    };</div><div class="line"></div><div class="line">    ScratchData&lt;dim&gt; scratch_data(mapping, fe, quadrature, quadrature_face);</div><div class="line">    CopyData         copy_data;</div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.begin_active(),</div><div class="line">                          dof_handler.end(),</div><div class="line">                          cell_worker,</div><div class="line">                          copier,</div><div class="line">                          scratch_data,</div><div class="line">                          copy_data,</div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a> |</div><div class="line">                            <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa35f26e2d96f28fb49e5b0865adc3ba9d">MeshWorker::assemble_boundary_faces</a> |</div><div class="line">                            <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa47c6806a06155c94191629fae2755763">MeshWorker::assemble_own_interior_faces_once</a>,</div><div class="line">                          boundary_worker,</div><div class="line">                          face_worker);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::solve()</div><div class="line">  {</div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(1000, 1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-12);</div><div class="line">    <a class="code" href="classSolverRichardson.html">SolverRichardson&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control);</div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionBlockSSOR.html">PreconditionBlockSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner;</div><div class="line"></div><div class="line">    preconditioner.<a class="code" href="classPreconditionBlock.html#a6c61513fe17633b8b4e1dd2d83b72e81">initialize</a>(system_matrix, fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>());</div><div class="line"></div><div class="line">    solver.solve(system_matrix, solution, right_hand_side, preconditioner);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Solver converged in &quot;</span> &lt;&lt; solver_control.last_step()</div><div class="line">              &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::refine_grid()</div><div class="line">  {</div><div class="line">    Vector&lt;float&gt; gradient_indicator(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"></div><div class="line">    <a class="code" href="namespaceDerivativeApproximation.html#a98d28e4c1c17164c48719cdfe4a363e6">DerivativeApproximation::approximate_gradient</a>(mapping,</div><div class="line">                                                  dof_handler,</div><div class="line">                                                  solution,</div><div class="line">                                                  gradient_indicator);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell_no = 0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">      gradient_indicator(cell_no++) *=</div><div class="line">        <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(cell-&gt;diameter(), 1 + 1.0 * dim / 2);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation,</div><div class="line">                                                    gradient_indicator,</div><div class="line">                                                    0.3,</div><div class="line">                                                    0.1);</div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#ac8b4fbb207303ec7f5ef758821ecd8cb">execute_coarsening_and_refinement</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> AdvectionProblem&lt;dim&gt;::output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keyword">const</span> std::string filename = <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(cycle) + <span class="stringliteral">&quot;.vtk&quot;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;  Writing solution to &lt;&quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot;&gt;&quot;</span> &lt;&lt; std::endl;</div><div class="line">    std::ofstream output(filename);</div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(solution, <span class="stringliteral">&quot;u&quot;</span>, <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(mapping);</div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(output);</div><div class="line"></div><div class="line">    {</div><div class="line">      Vector&lt;float&gt; <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">      <a class="code" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference</a>(mapping,</div><div class="line">                                        dof_handler,</div><div class="line">                                        solution,</div><div class="line">                                        <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(),</div><div class="line">                                        values,</div><div class="line">                                        quadrature,</div><div class="line">                                        <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> l_infty =</div><div class="line">        <a class="code" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error</a>(triangulation,</div><div class="line">                                          values,</div><div class="line">                                          <a class="code" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>);</div><div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;  L-infinity norm: &quot;</span> &lt;&lt; l_infty &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">  }</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">AdvectionProblem&lt;dim&gt;::run</a>()</div><div class="line">  {</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cycle = 0; cycle &lt; 6; ++cycle)</div><div class="line">      {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Cycle &quot;</span> &lt;&lt; cycle &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (cycle == 0)</div><div class="line">          {</div><div class="line">            <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(triangulation);</div><div class="line">            triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(3);</div><div class="line">          }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">          refine_grid();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of active cells:       &quot;</span></div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        setup_system();</div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div><div class="line">                  &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        assemble_system();</div><div class="line">        solve();</div><div class="line"></div><div class="line">        output_results(cycle);</div><div class="line">      }</div><div class="line">  }</div><div class="line">} <span class="comment">// namespace Step12</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="keywordflow">try</span></div><div class="line">    {</div><div class="line">      Step12::AdvectionProblem&lt;2&gt; dgmethod;</div><div class="line">      dgmethod.run();</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">  <span class="keywordflow">catch</span> (...)</div><div class="line">    {</div><div class="line">      std::cerr &lt;&lt; std::endl</div><div class="line">                &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div><div class="line">                &lt;&lt; std::endl;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
