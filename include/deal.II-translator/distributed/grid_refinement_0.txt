[0.x.0]*
         Compute the global max and min of the criteria vector. These are         returned only on the processor with rank zero, all others get a pair         of zeros.        
* [0.x.1]*
           Compute a threshold value so that exactly n_target_cells have a           value that is larger.          
* [0.x.2]*
           Compute a threshold value so that the error accumulated over all           criteria[i] so that               criteria[i] > threshold           is larger than target_error.          
* [0.x.3]*
     This namespace provides a collection of functions that aid in refinement     and coarsening of triangulations. Despite the name of the namespace, the     functions do not actually [1.x.0] the triangulation, but only     [1.x.1]. In other words, they     perform the "mark" part of the typical "solve-estimate-mark-refine"     cycle of the adaptive finite element loop.         In contrast to the functions in namespace  [2.x.0]      the functions in the current namespace are intended for distributed     meshes, i.e., objects of type  [2.x.1]         
*  [2.x.2]     
* [0.x.4]*
       Like  [2.x.3]  but for       parallel distributed triangulations.             The vector of criteria needs to be a vector of refinement criteria       for all cells active on the current triangulation, i.e.,       it needs to be of length  [2.x.4]  (and not        [2.x.5] ). In other words,       the vector needs to include entries for ghost and artificial       cells. However, the current       function will only look at the indicators that correspond to those       cells that are actually locally owned, and ignore the indicators for       all other cells. The function will then coordinate among all       processors that store part of the triangulation so that at the end       a fraction  [2.x.6]  of all  [2.x.7]        active cells are refined, rather than a fraction of the        [2.x.8]  on each processor individually.       In other words, it may be that on some processors, no cells are       refined at all.             The same is true for the fraction of cells that is coarsened.              [2.x.9]  tria The triangulation whose cells this function is       supposed to mark for coarsening and refinement.              [2.x.10]  criteria The refinement criterion for each mesh cell active       on the current triangulation. Entries may not be negative.              [2.x.11]  top_fraction_of_cells The fraction of cells to be refined.       If this number is zero, no cells will be refined. If it equals one,       the result will be flagging for global refinement.              [2.x.12]  bottom_fraction_of_cells The fraction of cells to be       coarsened. If this number is zero, no cells will be coarsened.              [2.x.13]  max_n_cells This argument can be used to specify a maximal       number of cells. If this number is going to be exceeded upon       refinement, then refinement and coarsening fractions are going to be       adjusted in an attempt to reach the maximum number of cells. Be aware       though that through proliferation of refinement due to        [2.x.14]  this number is only an indicator. The       default value of this argument is to impose no limit on the number of       cells.      
* [0.x.5]*
       Like  [2.x.15]  but       for parallel distributed triangulations.             The vector of criteria needs to be a vector of refinement criteria       for all cells active on the current triangulation, i.e.,       it needs to be of length  [2.x.16]  (and not        [2.x.17] ). In other words,       the vector needs to include entries for ghost and artificial       cells. However, the current       function will only look at the indicators that correspond to those       cells that are actually locally owned, and ignore the indicators for       all other cells. The function will then coordinate among all       processors that store part of the triangulation so that at the end       the smallest fraction of  [2.x.18]  (not        [2.x.19]  on each processor       individually)       is refined that together make up a total of  [2.x.20]        of the total error. In other words, it may be that on some       processors, no cells are refined at all.             The same is true for the fraction of cells that is coarsened.              [2.x.21]  tria The triangulation whose cells this function is       supposed to mark for coarsening and refinement.              [2.x.22]  criteria The refinement criterion computed on each mesh cell       active on the current triangulation. Entries may not be negative.              [2.x.23]  top_fraction_of_error The fraction of the total estimate       which should be refined. If this number is zero, no cells will be       refined. If it equals one, the result will be flagging for global       refinement.              [2.x.24]  bottom_fraction_of_error The fraction of the estimate       coarsened. If this number is zero, no cells will be coarsened.              [2.x.25]  norm_type To determine thresholds, combined errors on       subsets of cells are calculated as norms of the criteria on these       cells. Different types of norms can be used for this purpose, from       which  [2.x.26]  and        [2.x.27]  are currently supported.      
* [0.x.6]