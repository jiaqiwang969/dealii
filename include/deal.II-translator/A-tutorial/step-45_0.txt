[0.x.0]*
 [2.x.0] 
* This tutorial depends on  [2.x.1] .
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6]
*  [2.x.2] 
* [1.x.7][1.x.8][1.x.9][1.x.10]
* 

* In this example we present how to use periodic boundary conditions indeal.II. Periodic boundary conditions are algebraic constraints thattypically occur in computations on representative regions of a largerdomain that repeat in one or more directions.
* An example is the simulation of the electronic structure of photoniccrystals, because they have a lattice-like structure and, thus, it oftensuffices to do the actual computation on only one box of the lattice. Tobe able to proceed this way one has to assume that the model can beperiodically extended to the other boxes; this requires the solution tohave a periodic structure.
* [1.x.11][1.x.12][1.x.13]
* 

* deal.II provides a number of high level entry points to impose periodicboundary conditions.The general approach to apply periodic boundary conditions consists ofthree steps (see also the [2.x.3]  "Glossary entry on periodic boundary conditions"):
* 
*  - Create a mesh
* 
*  - Identify those pairs of faces on different parts of the boundary across which   the solution should be symmetric, using  [2.x.4] 
* 
*  - Add the periodicity information to the mesh   using  [2.x.5] 
* 
*  - Add periodicity constraints using  [2.x.6] 
* The second and third step are necessary for parallel meshes using the [2.x.7]  classto ensure that cells on opposite sides of the domain but connected by periodicfaces are part of the ghost layer if one of them is stored on the local processor.If the Triangulation is not a  [2.x.8] these steps are not necessary.
* The first step consists of collecting matching periodic faces and storing them ina  [2.x.9]  of  [2.x.10]  This is done with thefunction  [2.x.11]  that can be invoked for examplelike this:
* [1.x.14]
* 
* This call loops over all faces of the container dof_handler on the periodicboundaries with boundary indicator  [2.x.12]  and  [2.x.13] respectively. (You can assign these boundary indicators by hand aftercreating the coarse mesh, see [2.x.14]  "Boundary indicator". Alternatively, youcan also let many of the functions in namespace GridGenerator do thisfor if you specify the "colorize" flag; in that case, these functionswill assign different boundary indicators to different parts of theboundary, with the details typically spelled out in the documentationof these functions.)
* Concretely, if  [2.x.15]  are the vertices of two faces [2.x.16] , then the function call above will match pairs offaces (and dofs) such that the difference between  [2.x.17] and  [2.x.18]  vanishes in everycomponent apart from direction and stores the resulting pairs withassociated data in  [2.x.19]  (See [2.x.20]  for detailed information about thematching process.)
* Consider, for example, the colored unit square  [2.x.21]  with boundaryindicator 0 on the left, 1 on the right, 2 on the bottom and 3 on the topfaces. (See the documentation of  [2.x.22]  for thisconvention on how boundary indicators are assigned.) Then,
* [1.x.15]
* would yield periodicity constraints such that  [2.x.23]  for all [2.x.24] .
* If we instead consider the parallelogram given by the convex hull of [2.x.25] ,  [2.x.26] ,  [2.x.27] ,  [2.x.28]  we can achieve the constraints [2.x.29]  by specifying an  [2.x.30] 
* [1.x.16]
* or
* [1.x.17]
* Here, again, the assignment of boundary indicators 0 and 1 stems fromwhat  [2.x.31]  documents.
* The resulting  [2.x.32]  can be used in [2.x.33]  for populating an AffineConstraintsobject with periodicity constraints:
* [1.x.18]
* 
* Apart from this high level interface there are also variants of [2.x.34]  available that combine those twosteps (see the variants of  [2.x.35] 
* There is also a low level interface to [2.x.36]  if more flexibility is needed. Thelow level variant allows to directly specify two faces that shall beconstrained:
* [1.x.19]
* Here, we need to specify the orientation of the two faces using [2.x.37]   [2.x.38]  and  [2.x.39]  For a closer descriptionhave a look at the documentation of  [2.x.40] The remaining parameters are the same as for the high level interface apartfrom the self-explaining  [2.x.41]  and  [2.x.42] 
* 

* [1.x.20][1.x.21][1.x.22]
* 

* In the following, we show how to use the above functions in a more involvedexample. The task is to enforce rotated periodicity constraints for thevelocity component of a Stokes flow.
* On a quarter-circle defined by  [2.x.43]  we aregoing to solve the Stokes problem[1.x.23]
* where the boundary  [2.x.44]  is defined as  [2.x.45] .For the remaining parts of the boundary we are going to use periodic boundary conditions, i.e.
* [1.x.24]
* 
* The mesh will be generated by  [2.x.46] which also documents how it assigns boundary indicators to its variousboundaries if its `colorize` argument is set to `true`.
* 

*  [1.x.25] [1.x.26]
*  This example program is a slight modification of  [2.x.47]  running in parallel using Trilinos to demonstrate the usage of periodic boundary conditions in deal.II. We thus omit to discuss the majority of the source code and only comment on the parts that deal with periodicity constraints. For the rest have a look at  [2.x.48]  and the full source code at the bottom.
* 

* 
*  In order to implement periodic boundary conditions only two functions have to be modified:
* 

* 
* 
*  -  [2.x.49] : To populate an AffineConstraints object with periodicity constraints
* 

* 
* 
*  -  [2.x.50] : To supply a distributed triangulation with periodicity information.
* 

* 
*  The rest of the program is identical to  [2.x.51] , so let us skip this part and only show these two functions in the following. (The full program can be found in the "Plain program" section below, though.)
* 

* 
*  
*     
*  
*  [1.x.27]  [1.x.28]
* 

* 
* [1.x.29]
* 
*  Before we can prescribe periodicity constraints, we need to ensure that cells on opposite sides of the domain but connected by periodic faces are part of the ghost layer if one of them is stored on the local processor. At this point we need to think about how we want to prescribe periodicity. The vertices  [2.x.52]  of a face on the left boundary should be matched to the vertices  [2.x.53]  of a face on the lower boundary given by  [2.x.54]  where the rotation matrix  [2.x.55]  and the offset  [2.x.56]  are given by

* 
* [1.x.30]
*  The data structure we are saving the resulting information into is here based on the Triangulation.
* 

* 
* [1.x.31]
* 
*  Now telling the triangulation about the desired periodicity is particularly easy by just calling  [2.x.57] 
* 

* 
* [1.x.32]
* 
*  After we provided the mesh with the necessary information for the periodicity constraints, we are now able to actual create them. For describing the matching we are using the same approach as before, i.e., the  [2.x.58]  of a face on the left boundary should be matched to the vertices  [2.x.59]  of a face on the lower boundary given by  [2.x.60]  where the rotation matrix  [2.x.61]  and the offset  [2.x.62]  are given by

* 
* [1.x.33]
*  These two objects not only describe how faces should be matched but also in which sense the solution should be transformed from  [2.x.63]  to  [2.x.64] .
* 

* 
* [1.x.34]
* 
*  For setting up the constraints, we first store the periodicity information in an auxiliary object of type  [2.x.65]   [2.x.66]  </code>. The periodic boundaries have the boundary indicators 2 (x=0) and 3 (y=0). All the other parameters we have set up before. In this case the direction does not matter. Due to  [2.x.67]  this is exactly what we want.
* 

* 
* [1.x.35]
* 
*  Next, we need to provide information on which vector valued components of the solution should be rotated. Since we choose here to just constraint the velocity and this starts at the first component of the solution vector, we simply insert a 0:
* 

* 
* [1.x.36]
* 
*  After setting up all the information in periodicity_vector all we have to do is to tell make_periodicity_constraints to create the desired constraints.
* 

* 
* [1.x.37]
* 
*  The rest of the program is then again identical to  [2.x.68] . We will omit it here now, but as before, you can find these parts in the "Plain program" section below.
* 

* 
* [1.x.38][1.x.39]
* 

* The created output is not very surprising. We simply see that the solution isperiodic with respect to the left and lower boundary:
*  [2.x.69] 
* Without the periodicity constraints we would have ended up with the following solution:
*  [2.x.70] 
* 

* [1.x.40][1.x.41] [2.x.71] 
* [0.x.1]