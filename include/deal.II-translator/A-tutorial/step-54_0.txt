[0.x.0]*
 [2.x.0] 
* This tutorial depends on  [2.x.1] .
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16]
*  [2.x.2] 
* [1.x.17]
*  [2.x.3]  This program elaborates on concepts of industrial geometry, using toolsthat interface with the OpenCASCADE library (http://www.opencascade.org) thatallow the specification of arbitrary IGES files to describe the boundaries foryour geometries.
*  [2.x.4] 
* [1.x.18][1.x.19][1.x.20]
* 

* 
* In some of the previous tutorial programs ( [2.x.5] ,  [2.x.6] ,  [2.x.7] ,  [2.x.8]  and [2.x.9]  among others) we have learned how to use the mesh refinement methodsprovided in deal.II. These tutorials have shown how to employ such tools toproduce a fine grid for a single simulation, as done in  [2.x.10] ; or to start froma coarse grid and carry out a series of simulations on adaptively refined grids,as is the case of  [2.x.11] . Regardless of which approach is taken, the meshrefinement requires a suitable geometrical description of the computationaldomain boundary in order to place, at each refinement, the new mesh nodes ontothe boundary surface. For instance,  [2.x.12]  shows how creating a circular gridautomatically attaches a circular manifold object to the computational domain,so that the faces lying on the boundary are refined onto the circle.  [2.x.13] shows how to do this with a Manifold defined by experimentally obtained data.But, at least as far as elementary boundary shapes are concerned, deal.II reallyonly provides circles, spheres, boxes and other elementary combinations. In thistutorial, we will show how to use a set of classes developed to import arbitraryCAD geometries, assign them to the desired boundary of the computational domain,and refine a computational grid on such complex shapes.
* 

* [1.x.21][1.x.22]
* 

* In the most common industrial practice, the geometrical models of arbitrarilyshaped objects are realized by means of Computer Aided Design (CAD) tools. Theuse of CAD modelers has spread in the last decades, as they allow for thegeneration of a full virtual model of each designed object, which through acomputer can be visualized, inspected, and analyzed in its finest details wellbefore it is physically crafted.  From a mathematical perspective, the enginelying under the hood of CAD modelers is represented by analytical geometry,and in particular by parametric curves and surfaces such as B-splines andNURBS that are rich enough that they can represent most surfaces of practicalinterest.  Once a virtual model is ready, all the geometrical features of thedesired object are stored in files which materially contain the coefficientsof the parametric surfaces and curves composing the object. Depending on thespecific CAD tool used to define the geometrical model, there are of courseseveral different file formats in which the information of a CAD model can beorganized. To provide a common ground to exchange data across CAD tools, theU.S. National Bureau of Standards published in 1980 the Initial GraphicsExchange Representation (IGES) neutral file format, which is used in thisexample.
* [1.x.23][1.x.24]
* 

* To import and interrogate CAD models, the deal.II library implements a series ofwrapper functions for the OpenCASCADE open source library for CAD modeling.These functions allow to import IGES files into OpenCASCADE native objects, andwrap them inside a series of Manifold classes.
* Once imported from an IGES file, the model is stored in a [2.x.14] , which is the generic topological entity defined inthe OpenCASCADE framework. From a  [2.x.15] , it is then possibleto access all the sub-shapes (such as vertices, edges and faces) composing it,along with their geometrical description. In the deal.II framework, thetopological entities composing a shape are used to create a correspondingManifold representation. In  [2.x.16]  we saw how to use  [2.x.17] to create a hyper sphere, which automatically attaches a SphericalManifoldto all boundary faces. This guarantees that boundary faces stay on asphere or circle during mesh refinement. The functions of the CAD modeling interfacehave been designed to retain the same structure, allowing the user to build aprojector object using the imported CAD shapes, maintaining the same procedurewe used in other tutorial programs, i.e., assigning such projector object tocells, faces or edges of a coarse mesh. At each refinement cycle, the new meshnodes will be then automatically generated by projecting a midpoint of anexisting object onto the specified geometry.
* Differently from a spherical or circular boundary, a boundary with a complexgeometry poses problems as to where it is best to place the new nodes createdupon refinement on the prescribed shape. PolarManifold, for example, transformsthe surrounding points to polar coordinates, calculates the average in thatcoordinate system (for each coordinate individually) and finally transformsthe point back to Cartesian coordinates.
* In the case of an arbitrary and complex shape though, an appropriate choice forthe placement of a new node cannot be identified that easily. The OpenCASCADEwrappers in deal.II provide several projector classes that employ differentprojection strategies. A first projector, implemented in the [2.x.18]  class, is to be used only foredge refinement. It is built assigning it a topological shape of dimensionone, either a  [2.x.19]  (which isa compound shape, made of several connected  [2.x.20] s) andrefines a mesh edge finding the new vertex as the point splitting in two evenparts the curvilinear length of the CAD curve portion that lies between thevertices of the original edge.
*  [2.x.21] 
* 

* A different projection strategy has been implemented in the [2.x.22]  class. The  [2.x.23] assigned at construction time can be arbitrary (a collection of shapes, faces,edges or a single face or edge will all work). The new cell nodes are firstcomputed by averaging the surrounding points in the same way as FlatManifolddoes. In a second step, all the new nodes will be projected onto the [2.x.24]  along the direction normal to the shape. If nonormal projection is available, the point which is closest to theshape---typically lying on the shape boundary---is selected.  If the shape iscomposed of several sub-shapes, the projection is carried out onto everysingle sub-shape, and the closest projection point is selected.
*  [2.x.25]  [2.x.26] 
* As we are about to experience, for some shapes, setting the projectiondirection as that normal to the CAD surface will not lead to surface meshelements of suitable quality. This is because the direction normal to the CADsurface has in principle nothing to do with the direction along which the meshneeds the new nodes to be located. The [2.x.27]  class, in this case, can help. Thisclass is constructed assigning a  [2.x.28]  (containing atleast a face) and a direction along which all the projections will be carriedout. New points will be computed by first averaging the surrounding points (asin the FlatManifold case), and then taking the closest intersection betweenthe topological shape and the line passing through the resulting point, alongthe direction used at construction time.  In this way, the user will have ahigher control on the projection direction to be enforced to ensure good meshquality.
*  [2.x.29] 
* 

* Of course the latter approach is effective only when the orientation of thesurface is rather uniform, so that a single projection direction can beidentified. In cases in which the surface direction is approaching theprojection direction, it is even possible that the directional projection isnot found. To overcome these problems, the [2.x.30]  class implements a thirdprojection algorithm. The  [2.x.31]  class isbuilt assigning a  [2.x.32]  (containing at least one face) tothe constructor, and works exactly like a [2.x.33]  But, as the name of the class suggests, [2.x.34]  tries to come up with a suitableestimate of the direction normal to the mesh elements to be refined, and usesit for the projection of the new nodes onto the CAD surface. If we consider amesh edge in a 2D space, the direction of its axis is a direction along whichto split it in order to give rise to two new cells of the same length. We hereextended this concept in 3D, and project all new nodes in a direction thatapproximates the cell normal.
* In the next figure, which is inspired by the geometry considered in thistutorial, we make an attempt to compare the behavior of the three projectorsconsidered. As can be seen on the left, given the original cell (in blue), thenew point found with the normal projection is in a position which does notallow for the generation of evenly spaced new elements (in red). The situationwill get worse in further refinement steps.  Since the geometry we consideredis somehow perpendicular to the horizontal direction, the directionalprojection (central image) defined with horizontal direction as the projectiondirection, does a rather good job in getting the new mesh point. Yet, sincethe surface is almost horizontal at the bottom of the picture, we can expectproblems in those regions when further refinement steps are carriedout. Finally, the picture on the right shows that a node located on the cellaxis will result in two new cells having the same length. Of course thesituation in 3D gets a little more complicated than that described in thissimple 2D case. Nevertheless, the results of this test confirm that the normalto the mesh direction is the best approach among the three tested, whenarbitrarily shaped surfaces are considered, and unless you have a geometry forwhich a more specific approach is known to be appropriate.
* 

*  [2.x.35] 
* 

* [1.x.25][1.x.26]
* 

* In this program, we will consider creating a surface mesh for a real geometrydescribing the bow of a ship (this geometry is frequently used in CAD and meshgeneration comparisons and is freely available). The surface mesh we get fromthis could then be used to solve a boundary element equation to simulate theflow of water around the ship (in a way similar to  [2.x.36] ) but we will nottry to do this here. To already give you an idea of the geometry we consider,here is a picture:
*  [2.x.37] 
* In the program, we read both the geometry and a coarse mesh from files, andthen employ several of the options discussed above to place new vertices for asequence of mesh refinement steps.
* 

*  [1.x.27] [1.x.28]
*   [1.x.29]  [1.x.30]
* 

* 
*  We start with including a bunch of files that we will use in the various parts of the program. Most of them have been discussed in previous tutorials already:
* 

* 
* [1.x.31]
* 
*  These are the headers of the opencascade support classes and functions. Notice that these will contain sensible data only if you compiled your deal.II library with support for OpenCASCADE, i.e., specifying  [2.x.38]  and  [2.x.39]  when calling  [2.x.40]  during deal.II configuration.
* 

* 
* [1.x.32]
* 
*  Finally, a few C++ standard header files
* 

* 
* [1.x.33]
* 
*  We isolate the rest of the program in its own namespace
* 

* 
* [1.x.34]
* 
*   [1.x.35]  [1.x.36]
* 

* 
*  This is the main class. All it really does is store names for input and output files, and a triangulation. It then provides a function that generates such a triangulation from a coarse mesh, using one of the strategies discussed in the introduction and listed in the enumeration type at the top of the class.   
*   The member functions of this class are similar to what you can find in most of the other tutorial programs in the setup stage of the grid for the simulations.
* 

* 
*  

* 
* [1.x.37]
* 
*   [1.x.38]  [1.x.39]
* 

* 
*  The constructor of the TriangulationOnCAD class is very simple. The input arguments are strings for the input and output file names, and the enumeration type that determines which kind of surface projector is used in the mesh refinement cycles (see below for details).
* 

* 
*  

* 
* [1.x.40]
* 
*   [1.x.41]  [1.x.42]
* 

* 
*  
*   The following function represents the core of this program.  In this function we import the CAD shape upon which we want to generate and refine our triangulation. We assume that the CAD surface is contained in the  [2.x.41]  file (we provide an example IGES file in the input directory called "input/DTMB-5415_bulbous_bow.iges" that represents the bulbous bow of a ship). The presence of several convex and concave high curvature regions makes the geometry we provided a particularly meaningful example.   
*   After importing the hull bow surface, we extract some of the curves and surfaces composing it, and use them to generate a set of projectors. Such projectors define the rules the Triangulation has to follow to position each new node during cell refinement.   
*   To initialize the Triangulation, as done in previous tutorial programs, we import a pre-existing grid saved in VTK format. We assume here that the user has generated a coarse mesh externally, which matches the IGES geometry. At the moment of writing this tutorial, the deal.II library does not automatically support generation of such meshes, but there are several tools which can provide you with reasonable initial meshes starting from CAD files. In our example, the imported mesh is composed of a single quadrilateral cell whose vertices have been placed on the CAD shape.   
*   After importing both the IGES geometry and the initial mesh, we assign the projectors previously discussed to each of the edges and cells which will have to be refined on the CAD surface.   
*   In this tutorial, we will test the three different CAD surface projectors described in the introduction, and will analyze the results obtained with each of them.  As mentioned, each of these projection strategies has been implemented in a different class, and objects of these types can be assigned to a triangulation using the  [2.x.42]  method.   
*   The following function then first imports the given CAD file. The function arguments are a string containing the desired file name, and a scale factor. In this example, the scale factor is set to 1e-3, as the original geometry is written in millimeters (which is the typical unit of measure for most IGES files), while we prefer to work in meters.  The output of the function is an object of OpenCASCADE generic topological shape class, namely a  [2.x.43] 
* 

* 
* [1.x.43]
* 
*  Each CAD geometrical object is defined along with a tolerance, which indicates possible inaccuracy of its placement. For instance, the tolerance  [2.x.44]  of a vertex indicates that it can be located in any point contained in a sphere centered in the nominal position and having radius  [2.x.45]  While projecting a point onto a surface (which will in turn have its tolerance) we must keep in mind that the precision of the projection will be limited by the tolerance with which the surface is built.
* 

* 
*  The following method extracts the tolerance of the given shape and makes it a bit bigger to stay our of trouble:
* 

* 
* [1.x.44]
* 
*  We now want to extract a set of composite sub-shapes from the generic shape. In particular, each face of the CAD file is composed of a trimming curve of type  [2.x.46]  which is the collection of  [2.x.47]  that compose the boundary of a surface, and a NURBS description of the surface itself. We will use a line projector to associate the boundary of our Triangulation to the wire delimiting the surface.  To extract all compound sub-shapes, like wires, shells, or solids, we resort to a method of the OpenCASCADE namespace.  The input of  [2.x.48]  is a shape and a set of empty  [2.x.49]  of subshapes, which will be filled with all compound shapes found in the given topological shape:
* 

* 
* [1.x.45]
* 
*  The next few steps are more familiar, and allow us to import an existing mesh from an external VTK file, and convert it to a deal triangulation.
* 

* 
* [1.x.46]
* 
*  We output this initial mesh saving it as the refinement step 0.
* 

* 
* [1.x.47]
* 
*  The mesh imported has a single, two-dimensional cell located in three-dimensional space. We now want to ensure that it is refined according to the CAD geometry imported above. This this end, we get an iterator to that cell and assign to it the manifold_id 1 (see  [2.x.50]  "this glossary entry"). We also get an iterator to its four faces, and assign each of them the manifold_id 2:
* 

* 
* [1.x.48]
* 
*  Once both the CAD geometry and the initial mesh have been imported and digested, we use the CAD surfaces and curves to define the projectors and assign them to the manifold ids just specified.
* 

* 
*  A first projector is defined using the single wire contained in our CAD file.  The ArclengthProjectionLineManifold will make sure that every mesh edge located on the wire is refined with a point that lies on the wire and splits it into two equal arcs lying between the edge vertices. We first check that the wires vector contains at least one element and then create a Manifold object for it.     
*   Once the projector is created, we then assign it to all the parts of the triangulation with manifold_id = 2:
* 

* 
* [1.x.49]
* 
*  The surface projector is created according to what is specified with the  [2.x.51]  option of the constructor. In particular, if the surface_projection_kind value equals  [2.x.52]  we select the  [2.x.53]  The new mesh points will then initially be generated at the barycenter of the cell/edge considered, and then projected on the CAD surface along its normal direction.  The NormalProjectionManifold constructor only needs a shape and a tolerance, and we then assign it to the triangulation for use with all parts that manifold having id 1:
* 

* 
* [1.x.50]
* 
*   [2.x.54]  surface_projection_kind value is  [2.x.55]  we select the  [2.x.56]  class. The new mesh points will then initially be generated at the barycenter of the cell/edge considered, and then projected on the CAD surface along a direction that is specified to the  [2.x.57]  constructor. In this case, the projection is done along the y-axis.
* 

* 
* [1.x.51]
* 
*  As a third option, if  [2.x.58]  value is  [2.x.59]  we select the  [2.x.60]  The new mesh points will again initially be generated at the barycenter of the cell/edge considered, and then projected on the CAD surface along a direction that is an estimate of the mesh normal direction. The  [2.x.61]  constructor only requires a shape (containing at least a face) and a tolerance.
* 

* 
* [1.x.52]
* 
*  Finally, we use good software cleanliness by ensuring that this really covers all possible options of the  [2.x.62]  statement. If we get any other value, we simply abort the program:
* 

* 
* [1.x.53]
* 
*   [1.x.54]  [1.x.55]
* 

* 
*  This function globally refines the mesh. In other tutorials, it would typically also distribute degrees of freedom, and resize matrices and vectors. These tasks are not carried out here, since we are not running any simulation on the Triangulation produced.   
*   While the function looks innocent, this is where most of the work we are interested in for this tutorial program actually happens. In particular, when refining the quads and lines that define the surface of the ship's hull, the Triangulation class will ask the various objects we have assigned to handle individual manifold ids for where the new vertices should lie.
* 

* 
* [1.x.56]
* 
*   [1.x.57]  [1.x.58]
* 

* 
*  Outputting the results of our computations is a rather mechanical task. All the components of this function have been discussed before:
* 

* 
* [1.x.59]
* 
*   [1.x.60]  [1.x.61]
* 

* 
*  This is the main function. It should be self explanatory in its briefness:
* 

* 
* [1.x.62]
* 
*   [1.x.63]  [1.x.64]
* 

* 
*  This is the main function of this program. It is in its basic structure like all previous tutorial programs, but runs the main class through the three possibilities of new vertex placement:
* 

* 
* [1.x.65]
* [1.x.66][1.x.67]
* 

* The program execution produces a series of mesh files  [2.x.63] that we can visualize with any of the usual visualization programs that can read the VTKfile format.
* The following table illustrates the results obtained employing the normal projection strategy. The first tworows of the table show side views of the grids obtained for progressive levelsof refinement, overlain on a very fine rendering of the exact geometry. Thedark and light red areas simply indicate whether the current mesh or the finegeometry is closer to the observer; the distinction does not carry anyparticularly deep meaning. The last rowof pictures depict front views (mirrored to both sides of the geometry) of thesame grids shown in the second row.
* 

*  [2.x.64] 
* As can be seen in the pictures---and as we anticipated---the normal refinement strategy is unable to produce nicely shaped elementswhen applied to surfaces with significant curvature changes. This isparticularly apparent at the bulb of the hull where all new points have beenplaced in the upper part of the bulb and the lower part remains completelyunresolved.
* The following table, which is arranged as the previous one, illustratesthe results obtained adopting the directional projection approach, in which the projection direction selected was the y-axis (whichis indicated with a small yellow arrow at the bottom left of each image).
* 

*  [2.x.65] 
* The images confirm that the quality of the mesh obtained with a directional projection is sensibly higher than that obtained projecting along thesurface normal. Yet, a number of elements elongated in the y-direction are observed around the bottom of the bulb, where the surface is almost parallel to thedirection chosen for the projection.
* The final test shows results using instead the projection normal to the faces:
*  [2.x.66] 
* The pictures confirm that the normal to mesh projection approach leads to grids that remain evenly spacedthroughtout the refinement steps. At the same time, these meshes represent rather well the original geometry even in the bottom regionof the bulb, which is not well recovered employing the directional projector or the normal projector.
* 

* [1.x.68][1.x.69] [2.x.67] 
* [0.x.1]