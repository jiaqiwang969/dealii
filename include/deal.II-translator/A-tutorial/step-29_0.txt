[0.x.0]*
 [2.x.0] 
* This tutorial depends on  [2.x.1] .
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22]
*  [2.x.2] 
* [1.x.23]
* [1.x.24] In order to run this program, deal.II must be configured to usethe UMFPACK sparse direct solver. Refer to the [1.x.25] for instructions how to do this.
* 

* [1.x.26][1.x.27][1.x.28]
* 

* 
* A question that comes up frequently is how to solve problems involving complexvalued functions with deal.II. For many problems, instead of working withcomplex valued finite elements directly, it is often more convenient to split complex valuedfunctions into their real and imaginary parts and use separate scalar finiteelement fields for discretizing each one of them. Basically this amounts toviewing a single complex valued equation as a system of two real valuedequations. This short example demonstrates how this can be implemented indeal.II by using an  [2.x.3]  object to stack two finite elementfields representing real and imaginary parts. (The opposite approach,keeping everything complex-valued, is demonstrated in a differenttutorial program: see  [2.x.4]  for this.)When split into real and imaginary parts, the equations covered herefall into the class of vector-valued problems. A toplevel overview ofthis topic can be found in the  [2.x.5]  module.
* In addition to this discussion, we also discuss the ParameterHandlerclass, which provides a convenient way for reading parameters from aconfiguration file at runtime without the need to recompile theprogram code.
* 

* [1.x.29][1.x.30]
* 

* The original purpose of this program is to simulate the focusing propertiesof an ultrasound wave generated by a transducer lens with variablegeometry. Recent applications in medical imaging use ultrasound waves not onlyfor imaging purposes, but also to excite certain local effects in amaterial, like changes in optical properties, that can then be measured byother imaging techniques. A vital ingredient for these methods is the abilityto focus the intensity of the ultrasound wave in a particular part of thematerial, ideally in a point, to be able to examine the properties of thematerial at that particular location.
* To derive a model for this problem, we think of ultrasound as a pressure wavegoverned by the wave equation:[1.x.31]where  [2.x.6]  is the wave speed (that for simplicity we assume to be constant),  [2.x.7] . The boundary [2.x.8]  is divided into two parts  [2.x.9]  and [2.x.10] , with  [2.x.11]  representing thetransducer lens and  [2.x.12]  an absorbing boundary (that is, we want tochoose boundary conditions on  [2.x.13]  in such a way that they imitate alarger domain). On  [2.x.14] , the transducer generates a wave of constantfrequency  [2.x.15]  and constant amplitude (that we chose to be 1 here):[1.x.32]
* If there are no other (interior or boundary) sources, and since the onlysource has frequency  [2.x.16] , then the solution admits a separation ofvariables of the form  [2.x.17] . The complex-valued function  [2.x.18]  describes the spatialdependency of amplitude and phase (relative to the source) of the waves offrequency  [2.x.19] , with the amplitude being the quantity that we areinterested in. By plugging this form of the solution into the wave equation,we see that for  [2.x.20]  we have[1.x.33]
* 
* For finding suitable conditions on  [2.x.21]  that model an absorbingboundary, consider a wave of the form  [2.x.22]  withfrequency  [2.x.23]  traveling in direction  [2.x.24] . In orderfor  [2.x.25]  to solve the wave equation,  [2.x.26]  musthold. Suppose that this wave hits the boundary in  [2.x.27]  at a rightangle, i.e.  [2.x.28]  with  [2.x.29]  denoting the outer unit normal of [2.x.30]  in  [2.x.31] . Then at  [2.x.32] , this wave satisfies the equation[1.x.34]Hence, by enforcing the boundary condition[1.x.35]waves that hit the boundary  [2.x.33]  at a right angle will be perfectlyabsorbed. On the other hand, those parts of the wave field that do not hit aboundary at a right angle do not satisfy this condition and enforcing it as aboundary condition will yield partial reflections, i.e. only parts of the wavewill pass through the boundary as if it wasn't here whereas the remainingfraction of the wave will be reflected back into the domain.
* If we are willing to accept this as a sufficient approximation to an absorbingboundary we finally arrive at the following problem for  [2.x.34] :[1.x.36]
* This is a Helmholtz equation (similar to the one in  [2.x.35] , but this time with''the bad sign'') with Dirichlet data on  [2.x.36]  and mixed boundaryconditions on  [2.x.37] . Because of the condition on  [2.x.38] , we cannot justtreat the equations for real and imaginary parts of  [2.x.39]  separately. What we cando however is to view the PDE for  [2.x.40]  as a system of two PDEs for the real andimaginary parts of  [2.x.41] , with the boundary condition on  [2.x.42]  representingthe coupling terms between the two components of the system. This works alongthe following lines: Let  [2.x.43] , then in termsof  [2.x.44]  and  [2.x.45]  we have the following system:[1.x.37]
* 
* For test functions  [2.x.46]  with  [2.x.47] , afterthe usual multiplication, integration over  [2.x.48]  and applying integration byparts, we get the weak formulation[1.x.38]
* 
* We choose finite element spaces  [2.x.49]  and  [2.x.50]  with bases  [2.x.51]  and look for approximate solutions[1.x.39]Plugging into the variational form yields the equation system[1.x.40]In matrix notation:[1.x.41](One should not be fooled by the right hand side being zero here, that isbecause we haven't included the Dirichlet boundary data yet.)Because of the alternating sign in the off-diagonal blocks, we can alreadysee that this system is non-symmetric, in fact it is even indefinite.Of course, there is no necessity to choose the spaces  [2.x.52]  and  [2.x.53]  to bethe same. However, we expect real and imaginary part of the solution tohave similar properties and will therefore indeed take  [2.x.54]  in theimplementation, and also use the same basis functions  [2.x.55]  forboth spaces. The reason for the notation using different symbols is just thatit allows us to distinguish between shape functions for  [2.x.56]  and  [2.x.57] , as thisdistinction plays an important role in the implementation.
* 

* [1.x.42][1.x.43]
* 

* For the computations, we will consider wave propagation in the unit square,with ultrasound generated by a transducer lens that is shaped like a segmentof the circle with center at  [2.x.58]  and aradius slightly greater than  [2.x.59] ; this shape should lead to a focusing of the soundwave at the center of the circle. Varying  [2.x.60]  changes the "focus" of the lensand affects the spatial distribution of the intensity of  [2.x.61] , where our mainconcern is how well  [2.x.62]  is focused.
* In the program below, we will implement the complex-valued Helmholtz equationsusing the formulation with split real and imaginary parts. We will alsodiscuss how to generate a domain that looks like a square with a slight bulgesimulating the transducer (in the [2.x.63]  function), and how togenerate graphical output that not only contains the solution components  [2.x.64]  and [2.x.65] , but also the magnitude  [2.x.66]  directly in the output file (in [2.x.67] ). Finally, we use theParameterHandler class to easily read parameters like the focal distance  [2.x.68] ,wave speed  [2.x.69] , frequency  [2.x.70] , and a number of other parameters from aninput file at run-time, rather than fixing those parameters in the source codewhere we would have to re-compile every time we want to change parameters.
* 

*  [1.x.44] [1.x.45]
*   [1.x.46]  [1.x.47]
* 

* 
*  The following header files have all been discussed before:
* 

* 
*  

* 
* [1.x.48]
* 
*  This header file contains the necessary declarations for the ParameterHandler class that we will use to read our parameters from a configuration file:
* 

* 
* [1.x.49]
* 
*  For solving the linear system, we'll use the sparse LU-decomposition provided by UMFPACK (see the SparseDirectUMFPACK class), for which the following header file is needed.  Note that in order to compile this tutorial program, the deal.II-library needs to be built with UMFPACK support, which is enabled by default:
* 

* 
* [1.x.50]
* 
*  The FESystem class allows us to stack several FE-objects to one compound, vector-valued finite element field. The necessary declarations for this class are provided in this header file:
* 

* 
* [1.x.51]
* 
*  Finally, include the header file that declares the Timer class that we will use to determine how much time each of the operations of our program takes:
* 

* 
* [1.x.52]
* 
*  As the last step at the beginning of this program, we put everything that is in this program into its namespace and, within it, make everything that is in the deal.II namespace globally available, without the need to prefix everything with  [2.x.71] :
* 

* 
* [1.x.53]
* 
*   [1.x.54]  [1.x.55]
* 

* 
*  First we define a class for the function representing the Dirichlet boundary values. This has been done many times before and therefore does not need much explanation.   
*   Since there are two values  [2.x.72]  and  [2.x.73]  that need to be prescribed at the boundary, we have to tell the base class that this is a vector-valued function with two components, and the  [2.x.74]  function and its cousin  [2.x.75]  must return vectors with two entries. In our case the function is very simple, it just returns 1 for the real part  [2.x.76]  and 0 for the imaginary part  [2.x.77]  regardless of the point where it is evaluated.
* 

* 
* [1.x.56]
* 
*   [1.x.57]  [1.x.58]
* 

* 
*  The next class is responsible for preparing the ParameterHandler object and reading parameters from an input file.  It includes a function  [2.x.78]  that declares all the necessary parameters and a  [2.x.79]  function that is called from outside to initiate the parameter reading process.
* 

* 
* [1.x.59]
* 
*  The constructor stores a reference to the ParameterHandler object that is passed to it:
* 

* 
* [1.x.60]
* 
*   [1.x.61]  [1.x.62]
* 

* 
*  The  [2.x.80]  function declares all the parameters that our ParameterHandler object will be able to read from input files, along with their types, range conditions and the subsections they appear in. We will wrap all the entries that go into a section in a pair of braces to force the editor to indent them by one level, making it simpler to read which entries together form a section:
* 

* 
* [1.x.63]
* 
*  Parameters for mesh and geometry include the number of global refinement steps that are applied to the initial coarse mesh and the focal distance  [2.x.81]  of the transducer lens. For the number of refinement steps, we allow integer values in the range  [2.x.82] , where the omitted second argument to the  [2.x.83]  object denotes the half-open interval.  For the focal distance any number greater than zero is accepted:
* 

* 
* [1.x.64]
* 
*  The next subsection is devoted to the physical parameters appearing in the equation, which are the frequency  [2.x.84]  and wave speed  [2.x.85] . Again, both need to lie in the half-open interval  [2.x.86]  represented by calling the  [2.x.87]  class with only the left end-point as argument:
* 

* 
* [1.x.65]
* 
*  Last but not least we would like to be able to change some properties of the output, like filename and format, through entries in the configuration file, which is the purpose of the last subsection:
* 

* 
* [1.x.66]
* 
*  Since different output formats may require different parameters for generating output (like for example, postscript output needs viewpoint angles, line widths, colors etc), it would be cumbersome if we had to declare all these parameters by hand for every possible output format supported in the library. Instead, each output format has a  [2.x.88]  function, which declares all the parameters specific to that format in an own subsection. The following call of  [2.x.89]  executes  [2.x.90]  for all available output formats, so that for each format an own subsection will be created with parameters declared for that particular output format. (The actual value of the template parameter in the call,  [2.x.91]  above, does not matter here: the function does the same work independent of the dimension, but happens to be in a template-parameter-dependent class.)  To find out what parameters there are for which output format, you can either consult the documentation of the DataOutBase class, or simply run this program without a parameter file present. It will then create a file with all declared parameters set to their default values, which can conveniently serve as a starting point for setting the parameters to the values you desire.
* 

* 
* [1.x.67]
* 
*   [1.x.68]  [1.x.69]
* 

* 
*  This is the main function in the ParameterReader class.  It gets called from outside, first declares all the parameters, and then reads them from the input file whose filename is provided by the caller. After the call to this function is complete, the  [2.x.92]  object can be used to retrieve the values of the parameters read in from the file:
* 

* 
* [1.x.70]
* 
*   [1.x.71]  [1.x.72]
* 

* 
*  As mentioned in the introduction, the quantity that we are really after is the spatial distribution of the intensity of the ultrasound wave, which corresponds to  [2.x.93] . Now we could just be content with having  [2.x.94]  and  [2.x.95]  in our output, and use a suitable visualization or postprocessing tool to derive  [2.x.96]  from the solution we computed. However, there is also a way to output data derived from the solution in deal.II, and we are going to make use of this mechanism here.
* 

* 
*  So far we have always used the  [2.x.97]  function to add vectors containing output data to a DataOut object.  There is a special version of this function that in addition to the data vector has an additional argument of type DataPostprocessor. What happens when this function is used for output is that at each point where output data is to be generated, the  [2.x.98]  or  [2.x.99]  function of the specified DataPostprocessor object is invoked to compute the output quantities from the values, the gradients and the second derivatives of the finite element function represented by the data vector (in the case of face related data, normal vectors are available as well). Hence, this allows us to output any quantity that can locally be derived from the values of the solution and its derivatives.  Of course, the ultrasound intensity  [2.x.100]  is such a quantity and its computation doesn't even involve any derivatives of  [2.x.101]  or  [2.x.102] .
* 

* 
*  In practice, the DataPostprocessor class only provides an interface to this functionality, and we need to derive our own class from it in order to implement the functions specified by the interface. In the most general case one has to implement several member functions but if the output quantity is a single scalar then some of this boilerplate code can be handled by a more specialized class, DataPostprocessorScalar and we can derive from that one instead. This is what the  [2.x.103]  class does:
* 

* 
* [1.x.73]
* 
*  In the constructor, we need to call the constructor of the base class with two arguments. The first denotes the name by which the single scalar quantity computed by this class should be represented in output files. In our case, the postprocessor has  [2.x.104]  as output, so we use "Intensity".   
*   The second argument is a set of flags that indicate which data is needed by the postprocessor in order to compute the output quantities.  This can be any subset of update_values, update_gradients and update_hessians (and, in the case of face data, also update_normal_vectors), which are documented in UpdateFlags.  Of course, computation of the derivatives requires additional resources, so only the flags for data that are really needed should be given here, just as we do when we use FEValues objects. In our case, only the function values of  [2.x.105]  and  [2.x.106]  are needed to compute  [2.x.107] , so we're good with the update_values flag.
* 

* 
* [1.x.74]
* 
*  The actual postprocessing happens in the following function. Its input is an object that stores values of the function (which is here vector-valued) representing the data vector given to  [2.x.108]  evaluated at all evaluation points where we generate output, and some tensor objects representing derivatives (that we don't use here since  [2.x.109]  is computed from just  [2.x.110]  and  [2.x.111] ). The derived quantities are returned in the  [2.x.112]  vector. Remember that this function may only use data for which the respective update flag is specified by  [2.x.113] . For example, we may not use the derivatives here, since our implementation of  [2.x.114]  requests that only function values are provided.
* 

* 
* [1.x.75]
* 
*  The computation itself is straightforward: We iterate over each entry in the output vector and compute  [2.x.115]  from the corresponding values of  [2.x.116]  and  [2.x.117] . We do this by creating a complex number  [2.x.118]  and then calling  [2.x.119]  on the result. (One may be tempted to call  [2.x.120]  but in a historical quirk, the C++ committee decided that  [2.x.121]  should return the [1.x.76] of the absolute value
* 
*  -  thereby not satisfying the properties mathematicians require of something called a "norm".)
* 

* 
* [1.x.77]
* 
*   [1.x.78]  [1.x.79]
* 

* 
*  Finally here is the main class of this program.  It's member functions are very similar to the previous examples, in particular  [2.x.122] , and the list of member variables does not contain any major surprises either. The ParameterHandler object that is passed to the constructor is stored as a reference to allow easy access to the parameters from all functions of the class.  Since we are working with vector valued finite elements, the FE object we are using is of type FESystem.
* 

* 
* [1.x.80]
* 
*  The constructor takes the ParameterHandler object and stores it in a reference. It also initializes the DoF-Handler and the finite element system, which consists of two copies of the scalar Q1 field, one for  [2.x.123]  and one for  [2.x.124] :
* 

* 
* [1.x.81]
* 
*   [1.x.82]  [1.x.83]
* 

* 
*  Here we setup the grid for our domain.  As mentioned in the exposition, the geometry is just a unit square (in 2d) with the part of the boundary that represents the transducer lens replaced by a sector of a circle.
* 

* 
* [1.x.84]
* 
*  First we generate some logging output and start a timer so we can compute execution time when this function is done:
* 

* 
* [1.x.85]
* 
*  Then we query the values for the focal distance of the transducer lens and the number of mesh refinement steps from our ParameterHandler object:
* 

* 
* [1.x.86]
* 
*  Next, two points are defined for position and focal point of the transducer lens, which is the center of the circle whose segment will form the transducer part of the boundary. Notice that this is the only point in the program where things are slightly different in 2D and 3D. Even though this tutorial only deals with the 2D case, the necessary additions to make this program functional in 3D are so minimal that we opt for including them:
* 

* 
* [1.x.87]
* 
*  As initial coarse grid we take a simple unit square with 5 subdivisions in each direction. The number of subdivisions is chosen so that the line segment  [2.x.125]  that we want to designate as the transducer boundary is spanned by a single face. Then we step through all cells to find the faces where the transducer is to be located, which in fact is just the single edge from 0.4 to 0.6 on the x-axis. This is where we want the refinements to be made according to a circle shaped boundary, so we mark this edge with a different manifold indicator. Since we will Dirichlet boundary conditions on the transducer, we also change its boundary indicator.
* 

* 
* [1.x.88]
* 
*  For the circle part of the transducer lens, a SphericalManifold object is used (which, of course, in 2D just represents a circle), with center computed as above.
* 

* 
* [1.x.89]
* 
*  Now global refinement is executed. Cells near the transducer location will be automatically refined according to the circle shaped boundary of the transducer lens:
* 

* 
* [1.x.90]
* 
*  Lastly, we generate some more logging output. We stop the timer and query the number of CPU seconds elapsed since the beginning of the function:
* 

* 
* [1.x.91]
* 
*   [1.x.92]  [1.x.93]   
*   Initialization of the system matrix, sparsity patterns and vectors are the same as in previous examples and therefore do not need further comment. As in the previous function, we also output the run time of what we do here:
* 

* 
* [1.x.94]
* 
*   [1.x.95]  [1.x.96]
* 

* 
*  As before, this function takes care of assembling the system matrix and right hand side vector:
* 

* 
* [1.x.97]
* 
*  First we query wavespeed and frequency from the ParameterHandler object and store them in local variables, as they will be used frequently throughout this function.
* 

* 
*  

* 
* [1.x.98]
* 
*  As usual, for computing integrals ordinary Gauss quadrature rule is used. Since our bilinear form involves boundary integrals on  [2.x.126] , we also need a quadrature rule for surface integration on the faces, which are  [2.x.127]  dimensional:
* 

* 
* [1.x.99]
* 
*  The FEValues objects will evaluate the shape functions for us.  For the part of the bilinear form that involves integration on  [2.x.128] , we'll need the values and gradients of the shape functions, and of course the quadrature weights.  For the terms involving the boundary integrals, only shape function values and the quadrature weights are necessary.
* 

* 
* [1.x.100]
* 
*  As usual, the system matrix is assembled cell by cell, and we need a matrix for storing the local cell contributions as well as an index vector to transfer the cell contributions to the appropriate location in the global system matrix after.
* 

* 
* [1.x.101]
* 
*  On each cell, we first need to reset the local contribution matrix and request the FEValues object to compute the shape functions for the current cell:
* 

* 
* [1.x.102]
* 
*  At this point, it is important to keep in mind that we are dealing with a finite element system with two components. Due to the way we constructed this FESystem, namely as the Cartesian product of two scalar finite element fields, each shape function has only a single nonzero component (they are, in deal.II lingo,  [2.x.129]  GlossPrimitive "primitive").  Hence, each shape function can be viewed as one of the  [2.x.130] 's or  [2.x.131] 's from the introduction, and similarly the corresponding degrees of freedom can be attributed to either  [2.x.132]  or  [2.x.133] . As we iterate through all the degrees of freedom on the current cell however, they do not come in any particular order, and so we cannot decide right away whether the DoFs with index  [2.x.134]  and  [2.x.135]  belong to the real or imaginary part of our solution.  On the other hand, if you look at the form of the system matrix in the introduction, this distinction is crucial since it will determine to which block in the system matrix the contribution of the current pair of DoFs will go and hence which quantity we need to compute from the given two shape functions.  Fortunately, the FESystem object can provide us with this information, namely it has a function  [2.x.136]  that for each local DoF index returns a pair of integers of which the first indicates to which component of the system the DoF belongs. The second integer of the pair indicates which index the DoF has in the scalar base finite element field, but this information is not relevant here. If you want to know more about this function and the underlying scheme behind primitive vector valued elements, take a look at  [2.x.137]  or the  [2.x.138]  module, where these topics are explained in depth.
* 

* 
* [1.x.103]
* 
*  If both DoFs  [2.x.139]  and  [2.x.140]  belong to same component, i.e. their shape functions are both  [2.x.141] 's or both  [2.x.142] 's, the contribution will end up in one of the diagonal blocks in our system matrix, and since the corresponding entries are computed by the same formula, we do not bother if they actually are  [2.x.143]  or  [2.x.144]  shape functions. We can simply compute the entry by iterating over all quadrature points and adding up their contributions, where values and gradients of the shape functions are supplied by our FEValues object.
* 

* 
*  

* 
* [1.x.104]
* 
*  You might think that we would have to specify which component of the shape function we'd like to evaluate when requesting shape function values or gradients from the FEValues object. However, as the shape functions are primitive, they have only one nonzero component, and the FEValues class is smart enough to figure out that we are definitely interested in this one nonzero component.
* 

* 
* [1.x.105]
* 
*  We also have to add contributions due to boundary terms. To this end, we loop over all faces of the current cell and see if first it is at the boundary, and second has the correct boundary indicator associated with  [2.x.145] , the part of the boundary where we have absorbing boundary conditions:
* 

* 
* [1.x.106]
* 
*  These faces will certainly contribute to the off-diagonal blocks of the system matrix, so we ask the FEFaceValues object to provide us with the shape function values on this face:
* 

* 
* [1.x.107]
* 
*  Next, we loop through all DoFs of the current cell to find pairs that belong to different components and both have support on the current face_no:
* 

* 
* [1.x.108]
* 
*  The check whether shape functions have support on a face is not strictly necessary: if we don't check for it we would simply add up terms to the local cell matrix that happen to be zero because at least one of the shape functions happens to be zero. However, we can save that work by adding the checks above.
* 

* 
*  In either case, these DoFs will contribute to the boundary integrals in the off-diagonal blocks of the system matrix. To compute the integral, we loop over all the quadrature points on the face and sum up the contribution weighted with the quadrature weights that the face quadrature rule provides.  In contrast to the entries on the diagonal blocks, here it does matter which one of the shape functions is a  [2.x.146]  and which one is a  [2.x.147] , since that will determine the sign of the entry.  We account for this by a simple conditional statement that determines the correct sign. Since we already checked that DoF  [2.x.148]  and  [2.x.149]  belong to different components, it suffices here to test for one of them to which component it belongs.
* 

* 
* [1.x.109]
* 
*  Now we are done with this cell and have to transfer its contributions from the local to the global system matrix. To this end, we first get a list of the global indices of the this cells DoFs...
* 

* 
* [1.x.110]
* 
*  ...and then add the entries to the system matrix one by one:
* 

* 
* [1.x.111]
* 
*  The only thing left are the Dirichlet boundary values on  [2.x.150] , which is characterized by the boundary indicator 1. The Dirichlet values are provided by the  [2.x.151]  class we defined above:
* 

* 
* [1.x.112]
* 
*   [1.x.113]  [1.x.114]
* 

* 
*  As already mentioned in the introduction, the system matrix is neither symmetric nor definite, and so it is not quite obvious how to come up with an iterative solver and a preconditioner that do a good job on this matrix.  We chose instead to go a different way and solve the linear system with the sparse LU decomposition provided by UMFPACK. This is often a good first choice for 2D problems and works reasonably well even for a large number of DoFs.  The deal.II interface to UMFPACK is given by the SparseDirectUMFPACK class, which is very easy to use and allows us to solve our linear system with just 3 lines of code.
* 

* 
*  Note again that for compiling this example program, you need to have the deal.II library built with UMFPACK support.
* 

* 
* [1.x.115]
* 
*  The code to solve the linear system is short: First, we allocate an object of the right type. The following  [2.x.152]  call provides the matrix that we would like to invert to the SparseDirectUMFPACK object, and at the same time kicks off the LU-decomposition. Hence, this is also the point where most of the computational work in this program happens.
* 

* 
* [1.x.116]
* 
*  After the decomposition, we can use  [2.x.153]  like a matrix representing the inverse of our system matrix, so to compute the solution we just have to multiply with the right hand side vector:
* 

* 
* [1.x.117]
* 
*   [1.x.118]  [1.x.119]
* 

* 
*  Here we output our solution  [2.x.154]  and  [2.x.155]  as well as the derived quantity  [2.x.156]  in the format specified in the parameter file. Most of the work for deriving  [2.x.157]  from  [2.x.158]  and  [2.x.159]  was already done in the implementation of the  [2.x.160]  class, so that the output routine is rather straightforward and very similar to what is done in the previous tutorials.
* 

* 
* [1.x.120]
* 
*  Define objects of our  [2.x.161]  class and a DataOut object:
* 

* 
* [1.x.121]
* 
*  Next we query the output-related parameters from the ParameterHandler. The  [2.x.162]  call acts as a counterpart to the  [2.x.163]  call in  [2.x.164] . It collects all the output format related parameters from the ParameterHandler and sets the corresponding properties of the DataOut object accordingly.
* 

* 
* [1.x.122]
* 
*  Now we put together the filename from the base name provided by the ParameterHandler and the suffix which is provided by the DataOut class (the default suffix is set to the right type that matches the one set in the .prm file through parse_parameters()):
* 

* 
* [1.x.123]
* 
*  The solution vectors  [2.x.165]  and  [2.x.166]  are added to the DataOut object in the usual way:
* 

* 
* [1.x.124]
* 
*  For the intensity, we just call  [2.x.167]  again, but this with our  [2.x.168]  object as the second argument, which effectively adds  [2.x.169]  to the output data:
* 

* 
* [1.x.125]
* 
*  The last steps are as before. Note that the actual output format is now determined by what is stated in the input file, i.e. one can change the output format without having to re-compile this program:
* 

* 
* [1.x.126]
* 
*   [1.x.127]  [1.x.128]
* 

* 
*  Here we simply execute our functions one after the other:
* 

* 
* [1.x.129]
* 
*   [1.x.130]  [1.x.131]
* 

* 
*  Finally the  [2.x.170]  function of the program. It has the same structure as in almost all of the other tutorial programs. The only exception is that we define ParameterHandler and  [2.x.171]  objects, and let the latter read in the parameter values from a textfile called  [2.x.172] . The values so read are then handed over to an instance of the UltrasoundProblem class:
* 

* 
* [1.x.132]
* [1.x.133][1.x.134][1.x.135]
* 

* The current program reads its run-time parameters from an input filecalled  [2.x.173]  that looks like this:
* [1.x.136]
* 
* As can be seen, we set [2.x.174] , which amounts to a focus of the transducer lensat  [2.x.175] ,  [2.x.176] . The coarse mesh is refined 5 times,resulting in 160x160 cells, and the output is written in vtuformat. The parameter reader understands many more parameterspertaining in particular to the generation of output, but weneed none of these parameters here and therefore stick withtheir default values.
* Here's the console output of the program in debug mode:
* [1.x.137]
* 
* (Of course, execution times will differ if you run the programlocally.) The fact that most of the time is spent on assemblingthe system matrix and generating output is due to the many assertionsthat need to be checked in debug mode. In release mode these partsof the program run much faster whereas solving the linear system ishardly sped up at all:
* [1.x.138]
* 
* The graphical output of the program looks as follows:
* 

*  [2.x.177] 
* The first two pictures show the real and imaginary parts of [2.x.178] , whereas the last shows the intensity  [2.x.179] . One can clearlysee that the intensity is focused around the focal point of thelens (0.5, 0.3), and that the focusis rather sharp in  [2.x.180] -direction but more blurred in  [2.x.181] -direction, which is aconsequence of the geometry of the focusing lens, its finite aperture,and the wave nature of the problem.
* Because colorful graphics are always fun, and to stress the focusingeffects some more, here is another set of images highlighting how wellthe intensity is actually focused in  [2.x.182] -direction:
*  [2.x.183] 
* 

* As a final note, the structure of the program makes it easy todetermine which parts of the program scale nicely as the mesh isrefined and which parts don't. Here are the run times for 5, 6, and 7global refinements:
* [1.x.139]
* 
* Each time we refine the mesh once, so the number of cells and degreesof freedom roughly quadruples from each step to the next. As can be seen,generating the grid, setting up degrees of freedom, assembling thelinear system, and generating output scale pretty closely to linear,whereas solving the linear system is an operation that requires 8times more time each time the number of degrees of freedom isincreased by a factor of 4, i.e. it is  [2.x.184] . This canbe explained by the fact that (using optimal ordering) thebandwidth of a finite element matrix is  [2.x.185] ,and the effort to solve a banded linear system using LU decompositionis  [2.x.186] . This also explains why the program does run in 3das well (after changing the dimension on the [2.x.187]  object), but scales very badly andtakes extraordinary patience before it finishes solving the linearsystem on a mesh with appreciable resolution, even though all theother parts of the program scale very nicely.
* 

* 
* [1.x.140][1.x.141][1.x.142]
* 

* An obvious possible extension for this program is to run it in 3d&mdash; after all, the world around us is three-dimensional, andultrasound beams propagate in three-dimensional media. You can trythis by simply changing the template parameter of the principal classin  [2.x.188]  and running it. This won't get you very far,though: certainly not if you do 5 global refinement steps as set inthe parameter file. You'll simply run out of memory as both the mesh(with its  [2.x.189]  cells)and in particular the sparse direct solver take too much memory. Youcan solve with 3 global refinement steps, however, if you have a bitof time: in early 2011, the direct solve takes about half anhour. What you'll notice, however, is that the solution is completelywrong: the mesh size is simply not small enough to resolve thesolution's waves accurately, and you can see this in plots of thesolution. Consequently, this is one of the cases where adaptivity isindispensable if you don't just want to throw a bigger (presumably%parallel) machine at the problem.
* 

* [1.x.143][1.x.144] [2.x.190] 
* [0.x.1]