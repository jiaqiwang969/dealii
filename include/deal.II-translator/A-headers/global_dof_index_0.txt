[0.x.0]*
  [2.x.0] 
*  deal.II can be configured to use 64-bit indices for degrees of freedom, rather than the usual unsigned integers that default to 32-bit on most current systems. This is necessary since we want to be able to solve problems with more than 4 billion unknowns (the limit of what can be represented with 32-bit unsigned integers). At the same time, we do not want to indiscriminately replace all integers in deal.II with 64-bit versions, since this would increase memory use in many places where we represent quantities that will most definitely not be larger than 4 billion.
*  The data type we define for these indices to keep the bulk of the code base free of  [2.x.1] s is  [2.x.2]  If deal.II is configured as normal, this type is  [2.x.3] , but can be switched to  [2.x.4]  if the right flag is provided (see the ReadMe file). This page is intended to clarify when  [2.x.5]  must be used and when one can use a regular unsigned integer:
*   [2.x.6] 
*  <dt class="glossary"> [2.x.7]  GlobalDoFIndexBlockIndices [1.x.0]</dt>  [2.x.8]  The number of blocks is an unsigned int because the number is expected to be low, i.e less than four billions. However, the size of the block is a  [2.x.9]  because each block can be arbitrary large.  [2.x.10] 
*  <dt class="glossary"> [2.x.11]  GlobalDoFIndexCell [1.x.1]</dt>  [2.x.12]  The ID of cell is not unique: Cells with different levels of refinement and/or on different processors can have the same ID. Thus, all the data associated to cells can be unsigned int because on a single processor, one one mesh level, there will definitely not be more than 4 billion cells.  [2.x.13] 
*  <dt class="glossary"> [2.x.14]  GlobalDoFIndexDoFHandler [1.x.2]</dt>  [2.x.15]  The ID of each degree of freedom is unique in a parallel computation. Therefore, degrees of freedom are  [2.x.16]   [2.x.17] 
*  <dt class="glossary"> [2.x.18]  GlobalDoFIndexFullMatrix [1.x.3]</dt>  [2.x.19]  The numbers of row and column are  [2.x.20]  even if it is not expected that someone will create a FullMatrix with so many entries. However, some methods of the AffineConstraints class are templated on the matrix type and thus, the size of a FullMatrix has to be of the same type than the size of SparseMatrix.  [2.x.21] 
*  <dt class="glossary"> [2.x.22]  GlobalDoFIndexSparseMatrix [1.x.4]</dt>  [2.x.23]  The size of SparseMatrix can be arbitrary large and it is conceivable that with sufficient memory on a single node, one may generate a matrix with more than 4 billion rows or columns. Therefore,  [2.x.24]  is used. However, even for a large complex problem we can solve now, it is not reasonable to expect the number of non-zero entries in a sparse matrix to go over four billion. Thus, we still use unsigned int for, e.g.,  [2.x.25]  and similar functions.  [2.x.26] 
*   [2.x.27] 

* 
* [0.x.1]