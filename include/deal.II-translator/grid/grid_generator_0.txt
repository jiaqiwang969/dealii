[0.x.0]*
 This namespace provides a collection of functions for generating triangulations for some basic geometries.
*  Some of these functions receive a flag  [2.x.0]  (see  [2.x.1]  "the glossary entry on colorization"). If this is set, parts of the boundary receive different  [2.x.2]  "boundary indicators" allowing them to be distinguished for the purpose of evaluating different boundary conditions.
*  If the domain is curved, each of the domain parts that should be refined by following an appropriate Manifold description will receive a different  [2.x.3]  "manifold indicator", and the correct Manifold descriptor will be attached to the Triangulation. Notice that if you later transform the triangulation, you have to make sure you attach the correct new Manifold to the triangulation.
* 

* 
*  [2.x.4] 

* 
* [0.x.1]*
    [2.x.5]  Creating meshes for basic geometries  
* [0.x.2]*
   Initialize the given triangulation with a hypercube (line in 1D, square   in 2D, etc) consisting of exactly one cell. The hypercube volume is the   tensor product interval  [2.x.6]  in the present number   of dimensions, where the limits are given as arguments. They default to   zero and unity, then producing the unit hypercube.     If the argument  [2.x.7]  is false, then all boundary indicators are   set to zero (the default boundary indicator) for 2d and 3d. If it is   true, the boundary is    [2.x.8]  "colorized"   as in hyper_rectangle(). In 1d the   indicators are always colorized, see hyper_rectangle().      [2.x.9]      If  [2.x.10]  <  [2.x.11]  this will create a  [2.x.12]  dimensional object in   the first  [2.x.13]  coordinate directions embedded into the  [2.x.14]    dimensional space with the remaining entries set to zero. For example, a   <tt>Triangulation [2.x.15]  will be a square in the xy plane with z=0.     See also subdivided_hyper_cube() for a coarse mesh consisting of several   cells. See hyper_rectangle(), if different lengths in different ordinate   directions are required.      [2.x.16]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.3]*
   Create a  [2.x.17] -[1.x.0]   (i.e., a triangle in 2d, or a tetrahedron in 3d) with    [2.x.18]  corners. Since deal.II does not support triangular and   tetrahedral cells, the simplex described by the input arguments   is subdivided into quadrilaterals and hexahedra by adding edge,   face, and simplex midpoints, resulting in a mesh that consists of    [2.x.19]  quadrilateral or hexahedral cells.     The  [2.x.20]  argument contains a vector with all d+1 vertices defining   the corners of the simplex. They must be given in an order such that the   vectors from the first vertex to each of the others form a right-handed   system.     The meshes generated in two and three dimensions are:      [2.x.21]     [2.x.22]       [2.x.23]  tria The triangulation to be created. It needs to be empty upon   calling this function.      [2.x.24]  vertices The dim+1 corners of the simplex.    
*  [2.x.25]  Implemented for <tt>Triangulation [2.x.26]    <tt>Triangulation [2.x.27]   
* [0.x.4]   Create a (coarse) grid with a single cell of the shape of the provided   reference cell. This is a generalization of the hyper_cube() and simplex()   functions above.  
* [0.x.5]*
   Same as hyper_cube(), but with the difference that not only one cell is   created but each coordinate direction is subdivided into  [2.x.28]    cells. Thus, the number of cells filling the given volume is   <tt>repetitions<sup>dim</sup></tt>.     If  [2.x.29]  <  [2.x.30]  this will create a  [2.x.31]  dimensional object in   the first  [2.x.32]  coordinate directions embedded into the  [2.x.33]    dimensional space with the remaining entries set to zero. For example, a   <tt>Triangulation [2.x.34]  will be a square in the xy plane with z=0.      [2.x.35]  The triangulation passed as argument needs to be empty when calling   this function.      [2.x.36]  tria The triangulation to create. It needs to be empty upon   calling this function.      [2.x.37]  repetitions An unsigned integer denoting the number of cells to   generate in each direction.      [2.x.38]  left Lower bound for the interval used to create the hyper cube.      [2.x.39]  right Upper bound for the interval used to create the hyper cube.      [2.x.40]  colorize Assign different boundary ids if set to true.  
* [0.x.6]*
   Create a coordinate-parallel brick from the two diagonally opposite   corner points  [2.x.41]  and  [2.x.42]      If the  [2.x.43]  flag is  [2.x.44] , then the  [2.x.45]  of   the boundary faces are assigned, such that the lower one in  [2.x.46]    x-direction is 0, the upper one is 1. The indicators for the surfaces in    [2.x.47]  are 2 and 3, the ones for  [2.x.48]  are 4 and 5. This   corresponds to the numbers of faces of the unit square of cube as laid   out in the documentation of the GeometryInfo class; see also    [2.x.49]  "the glossary entry on colorization".   Importantly,   however, in 3d    [2.x.50]  "colorization"   does not set  [2.x.51]    boundary_ids of [1.x.1], but only of [1.x.2], because each   boundary edge is shared between two faces and it is not clear how the   boundary id of an edge should be set in that case.     Additionally, if  [2.x.52]  is  [2.x.53]  material ids are assigned to the   cells according to the octant their center is in: being in the right half   space for any coordinate direction [1.x.3] adds   2<sup>i</sup>. For instance, a cell with center point (1,-1,1) yields a   material id 5, assuming that the center of the hyper rectangle lies at   the origin. No manifold id is set for the cells.     If  [2.x.54]  <  [2.x.55]  this will create a  [2.x.56]  dimensional object in   the first  [2.x.57]  coordinate directions embedded into the  [2.x.58]    dimensional space with the remaining entries set to zero. For example, a   <tt>Triangulation [2.x.59]  will be a rectangle in the xy plane with   z=0, defined by the two opposing corners  [2.x.60]  and  [2.x.61]       [2.x.62]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.7]*
   Create a coordinate-parallel brick from the two diagonally opposite   corner points  [2.x.63]  and  [2.x.64]  The number of cells in coordinate   direction  [2.x.65]  is given by the integer <tt>repetitions[i]</tt>.     To get cells with an aspect ratio different from that of the domain, use   different numbers of subdivisions, given by  [2.x.66]  in different   coordinate directions. The minimum number of subdivisions in each   direction is 1.     If the  [2.x.67]  flag is  [2.x.68] , then the  [2.x.69]  of   the surfaces are assigned, such that the lower one in  [2.x.70]  is   0, the upper one is 1 (the left and the right vertical face). The   indicators for the surfaces in  [2.x.71]  are 2 and 3, the ones for    [2.x.72]  are 4 and 5.  Additionally, material ids are assigned to the cells   according to the octant their center is in: being in the right half plane   for any coordinate direction [1.x.4] adds 2<sup>i</sup> (see    [2.x.73]  "the glossary entry on colorization").   For   instance, the center point (1,-1,1) yields a material id 5 (this means   that in 2d only material ids 0,1,2,3 are assigned independent from the   number of repetitions).     Note that the  [2.x.74]  flag is ignored in 1d and is assumed to always   be true. That means the boundary indicator is 0 on the left and 1 on the   right.  See  [2.x.75]  for details.     If  [2.x.76]  <  [2.x.77]  this will create a  [2.x.78]  dimensional object in   the first  [2.x.79]  coordinate directions embedded into the  [2.x.80]    dimensional space with the remaining entries set to zero. For example, a   <tt>Triangulation [2.x.81]  will be a rectangle in the xy plane with   z=0, defined by the two opposing corners  [2.x.82]  and  [2.x.83]     
*  [2.x.84]  For an example of the use of this function see the  [2.x.85]  tutorial   program.      [2.x.86]  tria The triangulation to be created. It needs to be empty upon   calling this function.      [2.x.87]  repetitions A vector of  [2.x.88]  positive values denoting the number   of cells to generate in that direction.      [2.x.89]  p1 First corner point.      [2.x.90]  p2 Second corner opposite to  [2.x.91]       [2.x.92]  colorize Assign different boundary ids if set to true. The same   comments apply as for the hyper_rectangle() function.  
* [0.x.8]*
   Like the previous function. However, here the second argument does not   denote the number of subdivisions in each coordinate direction, but a   sequence of step sizes for each coordinate direction. The domain will   therefore be subdivided into  [2.x.93]  cells in   coordinate direction  [2.x.94] , with width    [2.x.95] th cell.     This function is therefore the right one to generate graded meshes where   cells are concentrated in certain areas, rather than a uniformly   subdivided mesh as the previous function generates.     The step sizes have to add up to the dimensions of the hyper rectangle   specified by the points  [2.x.96]  and  [2.x.97]   
* [0.x.9]*
   Like the previous function, but with the following twist: the  [2.x.98]    material_id argument is a dim-dimensional array that, for each cell,   indicates which material_id should be set. In addition, and this is the   major new functionality, if the material_id of a cell is <tt>(unsigned   char)(-1)</tt>, then that cell is deleted from the triangulation, i.e.   the domain will have a void there.    
*  [2.x.99]  If you need a lot of holes, you may consider cheese().  
* [0.x.10]*
   \brief Rectangular domain with rectangular pattern of holes     The domain itself is rectangular, very much as if it had been generated   by subdivided_hyper_rectangle(). The argument  [2.x.100]    specifies how many square holes the domain should have in each coordinate   direction. The total number of mesh cells in that direction is then twice   this number plus one.     The number of holes in one direction must be at least one.     An example with two by three holes is      [2.x.101]      If  [2.x.102]  <  [2.x.103]  this will create a  [2.x.104]  dimensional object in   the first  [2.x.105]  coordinate directions embedded into the  [2.x.106]    dimensional space with the remaining entries set to zero.      [2.x.107]  tria The triangulation to be created. It needs to be empty upon   calling this function.      [2.x.108]  holes Positive number of holes in each of the dim directions.  
* [0.x.11]*
   \brief Rectangular plate with an (offset) cylindrical hole.     Generate a rectangular plate with an (offset) cylindrical hole. The   geometry consists of 2 regions:   The first is a square region with length  [2.x.109]  and a hole of radius  [2.x.110]  .   Cells in this region will have TransfiniteInterpolationManifold with   manifold id  [2.x.111]  attached to them. Additionally, the boundary   faces of the hole will be associated with a PolarManifold (in 2D) or   CylindricalManifold (in 3D). The center of this   region can be prescribed via  [2.x.112]  , namely the axis of the hole will   be located at  [2.x.113]  .   The second region describes the remainder of the bulk material. It is   specified via padding   parameters  [2.x.114]   [2.x.115]   [2.x.116]  and  [2.x.117]    All cells in this region will have a FlatManifold attached to them.   The final width of the plate will be <code>padding_left + 2*outer_radius +   padding_right</code>, while its length is <code>padding_top +   2*outer_radius + padding_bottom</code>.     Here is the non-symmetric grid (after one global refinement, colored   according to manifold id) in 2D and 3D, respectively:     \htmlonly <style>div.image   img[src="plate_with_a_hole.png"]{width:25%;}</style> \endhtmlonly    [2.x.118]    \htmlonly <style>div.image   img[src="plate_with_a_hole_3D.png"]{width:25%;}</style> \endhtmlonly    [2.x.119]      In 3D, triangulation will be extruded in the z-direction by the total   height of  [2.x.120]  using  [2.x.121]  slices (minimum is 2).
*    If the  [2.x.122]  flag is  [2.x.123] , the boundary_ids of the   boundary faces are assigned such that the lower one in the x-direction is   0, and the upper one is 1 (see    [2.x.124]  "the glossary entry on colorization").   The indicators for the surfaces in the y-direction are 2 and 3, and the   ones for the z-direction are 5 and 6. The hole boundary has indicator 4.      [2.x.125]  is the triangulation to be created. It needs to be empty upon   calling this function.
* [0.x.12]*
   Generate a grid consisting of a channel with a cylinder. This is a common   benchmark for Navier-Stokes solvers. The geometry consists of a channel   of size  [2.x.126]  (where the  [2.x.127]    dimension is omitted in 2D) with a cylinder, parallel to the  [2.x.128]  axis   with diameter  [2.x.129] , centered at  [2.x.130] . The channel has three   distinct regions:    [2.x.131]       [2.x.132] If  [2.x.133]  is greater than zero, then there are that many shells     centered around the cylinder, [2.x.134]       [2.x.135] a blending region between the shells and the rest of the     triangulation, and [2.x.136]       [2.x.137] a bulk region consisting of Cartesian cells. [2.x.138]     [2.x.139]    Since the cylinder is slightly offset from the center of the channel,   this geometry results in vortex shedding at moderate Reynolds   numbers. Here is the grid (without additional global refinement) in 2D:      [2.x.140]      and in 3D:      [2.x.141]      The resulting Triangulation uses three manifolds: a PolarManifold (in 2D)   or CylindricalManifold (in 3D) with manifold id  [2.x.142] , a   TransfiniteInterpolationManifold with manifold id  [2.x.143] , and a FlatManifold   everywhere else. For more information on this topic see    [2.x.144]  "the glossary entry on manifold indicators".   The   cell faces on the cylinder and surrounding shells have manifold ids of    [2.x.145] , while the cell volumes adjacent to the shells (or, if they do not   exist, the cylinder) have a manifold id of  [2.x.146] . Put another way: this   grid uses TransfiniteInterpolationManifold to smoothly transition from   the shells (generated with  [2.x.147]  to the   bulk region. All other cell volumes and faces have manifold id    [2.x.148]  and use FlatManifold. All cells with id    [2.x.149]  are rectangular prisms aligned with the   coordinate axes.     The picture below shows part of the 2D grid (using all default arguments   to this function) after two global refinements. The cells with manifold   id  [2.x.150]  are orange (the polar manifold id), cells with manifold id  [2.x.151]  are   yellow (the transfinite interpolation manifold id), and the ones with   manifold id  [2.x.152]  are cyan:      [2.x.153]       [2.x.154]  tria Triangulation to be created. Must be empty upon calling this   function.      [2.x.155]  shell_region_width Width of the layer of shells around the cylinder.   This value should be between  [2.x.156]  and  [2.x.157] ; the default value is  [2.x.158] .      [2.x.159]  n_shells Number of shells to use in the shell layer.      [2.x.160]  skewness Parameter controlling how close the shells are   to the cylinder: see the mathematical definition given in    [2.x.161]       [2.x.162]  colorize Assign different boundary ids if set to true. For more   information on boundary indicators see    [2.x.163]  "this glossary entry".   The left boundary (at  [2.x.164] ) is assigned an id of  [2.x.165] , the right   boundary (at  [2.x.166] ) is assigned an id of  [2.x.167] , the cylinder boundary   is assigned an id of  [2.x.168] , and the channel walls are assigned an id of    [2.x.169] .     See the original paper for more information:  
* [1.x.5]
*   
* [0.x.13]*
   A general  [2.x.170] 
* 
*  - imensional cell (a segment if dim is 1, a quadrilateral   if  [2.x.171]  is 2, or a hexahedron if  [2.x.172]  is 3) immersed in a    [2.x.173] 
* 
*  - imensional space. It is the responsibility of the user to   provide the vertices in the right order (see the documentation of the   GeometryInfo class) because the vertices are stored in the same order as   they are given. It is also important to make sure that the volume of the   cell is positive.     If the argument  [2.x.174]  is false, then all boundary indicators are   set to zero for 2d and 3d. If it is true, the boundary is colorized as in   hyper_rectangle() (see    [2.x.175]  "the glossary entry on colorization").   In 1d the   indicators are always colorized, see hyper_rectangle().      [2.x.176]  tria The triangulation that will be created    [2.x.177]  vertices The 2^dim vertices of the cell    [2.x.178]  colorize If true, set different boundary ids.  
* [0.x.14]*
   A parallelogram. The first corner point is the origin. The next  [2.x.179]    vertices are the ones given in the second argument and the last vertex   will be the sum of the two vectors connecting the origin to those   points. Colorizing is done in the same way as in hyper_rectangle().    
*  [2.x.180]  This function is implemented in 2d only.      [2.x.181]  tria The triangulation to be created. It needs to be empty upon   calling this function.      [2.x.182]  corners Second and third vertices of the parallelogram.      [2.x.183]  colorize Assign different boundary ids if true. (see    [2.x.184]  "the glossary entry on colorization").  
* [0.x.15]*
   A parallelepiped. The first corner point is the origin. The  [2.x.185]    adjacent points are vectors describing the edges of the parallelepiped   with respect to the origin. Additional points are sums of these dim   vectors. Colorizing is done according to hyper_rectangle().    
*  [2.x.186]  This function silently reorders the vertices on the cells to   lexicographic ordering (see  [2.x.187] ).   In other words, if reordering of the vertices does occur, the ordering of   vertices in the array of  [2.x.188]  will no longer refer to the   same triangulation.      [2.x.189]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.16]*
   A subdivided parallelepiped. The first corner point is the origin. The  [2.x.190]    dim adjacent points are vectors describing the edges of the   parallelepiped with respect to the origin. Additional points are sums of   these dim vectors. The variable  [2.x.191]  designates the number   of subdivisions in each of the  [2.x.192]  directions. Colorizing is done   according to hyper_rectangle().      [2.x.193]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.17]*
   A subdivided parallelepiped, i.e., the same as above, but where the   number of subdivisions in each of the  [2.x.194]  directions may vary.   Colorizing is done according to hyper_rectangle().      [2.x.195]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.18]*
   A subdivided parallelepiped.      [2.x.196]  tria The triangulation to be created. It needs to be empty upon   calling this function.      [2.x.197]  origin First corner of the parallelepiped.      [2.x.198]  edges An array of  [2.x.199]  tensors describing the length and   direction of the edges from  [2.x.200]       [2.x.201]  subdivisions Number of subdivisions in each of the dim directions.   Each entry must be positive. An empty vector is equivalent to one   subdivision in each direction.      [2.x.202]  colorize Assign different boundary ids if set to true (see    [2.x.203]  "the glossary entry on colorization").    
*  [2.x.204]  Implemented for all combinations of  [2.x.205]  and  [2.x.206]     
*  [2.x.207]  You likely need to help the compiler by explicitly specifying the   two template parameters when calling this function.  
* [0.x.19]*
   Hypercube with a layer of hypercubes around it. Parameters  [2.x.208]  and    [2.x.209]  give the lower and upper bound of the inner hypercube in all   coordinate directions.   [2.x.210]  marks the size of the layer cells.     If the flag  [2.x.211]  is set, the outer cells get material ids   according to the following scheme: extending over the inner cube in (+/-)   x-direction 1/2, y-direction 4/8, z-direction 16/32. A bitwise OR operation   is used to get these values at the corners and edges (3d), (see also    [2.x.212]  "the glossary entry on colorization").     Presently only available in 2d and 3d.      [2.x.213]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.20]*
   Initialize the given triangulation with several    [2.x.214]  "coarse mesh cells"   that cover a hyperball, i.e. a circle in 2d or a   ball in 3d, around  [2.x.215]  with given  [2.x.216]  The function is   used in  [2.x.217] .     In order to avoid degenerate cells at the boundaries, the circle is   triangulated by five cells, whereas in 3d the ball is subdivided by   seven cells. Specifically, these   cells are one cell in the center plus one "cap" cell on each of the faces   of this center cell. This ensures that under repeated refinement, none   of the cells at the outer boundary will degenerate to have an interior   angle approaching 180 degrees, as opposed to the case where one might   start with just one square (or cube) to approximate the domain.   The diameter of the   center cell is chosen so that the aspect ratio of the boundary cells   after one refinement is optimized.     This function is declared to exist for triangulations of all space   dimensions, but throws an error if called in 1d.     By default, the manifold_id is set to 0 on the boundary faces, 1 on the   boundary cells, and  [2.x.218]  on the central cell and on   internal faces.     A SphericalManifold is attached by default to the boundary faces for   correct placement of boundary vertices upon refinement and to be able to   use higher order mappings. However, it turns out that this strategy may   not be the optimal one to create a good a mesh for a hyperball. The   "Possibilities for extensions" section of  [2.x.219]  has an extensive   discussion of how one would construct better meshes and what one needs to   do for it. Setting the argument   `attach_spherical_manifold_on_boundary_cells` to true attaches a   SphericalManifold manifold also to the cells adjacent to the boundary, and   not only to the boundary faces.    
*  [2.x.220]  Since this is likely one of the earliest functions users typically     consider to create meshes with curved boundaries, let us also comment     on one aspect that is often confusing: Namely, that what one sees is not     always what is actually happening. Specifically, if you output the coarse     mesh with a function such as  [2.x.221]  using default options,     then one doesn't generally get to see curved faces at the boundary.     That's because most file formats by default only store vertex locations,     with the implicit understanding that cells are composed from these     vertices and bounded by straight edges. At the same time, the fact     that this function attaches a SphericalManifold object to the boundary     faces means that at leastinternally*, edges really are curved. If     you want to see them that way, you need to make sure that the function     you use to output the mesh actually plots boundary faces as curved     lines rather than straight lines characterized by only the locations     of the two end points. For example,  [2.x.222]  can do     that if you set the corresponding flag in the  [2.x.223]      structure. It is, however, an entirely separate consideration whether     you are actuallycomputing* on curved cells. In typical finite     element computations, one has to compute integrals and these are     computed by transforming back actual cells using a mapping to the     reference cell. What mapping is used determines what shape the     cells have for these internal computations: For example, with the     widely used  [2.x.224]  mapping (implicitly used in  [2.x.225] ), integration     always happens on cells that are assumed to have straight boundaries     described by only the vertex locations. In other words, if such a     mapping is used, then the cells of the domain really do have     straight edges, regardless of the manifold description attached     to these edges and regardless of the flags given when generating     output. As a consequence of all of this, it is important to     distinguish three things: (i) the manifold description attached to an     object in the mesh; (ii) the mapping used in integration; and (iii) the     style used in outputting graphical information about the mesh. All of     these can be chosen more or less independently of each other, and     what you see visualized is not necessarily exactly what is     happening.      [2.x.226]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.21]*
   This is an alternative to hyper_ball with 12 cells in 2d and 32 cells in   3d, which provides a better balance between the size of the cells around   the outer curved boundaries and the cell in the interior. The mesh is   based on the cells used by  [2.x.227]  with   appropriate copies and rotations to fill the whole ball.     The following pictures show the resulting mesh in 2D (left) and 3D:    [2.x.228]      By default, the manifold_id is set to 0 on the boundary faces, 1 on the   boundary cells, and  [2.x.229]  on the central cell and on   internal faces.      [2.x.230]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.22]*
   Generate a 2D mesh consisting of the unit square joined with a copy shifted   by  [2.x.231] . Depending on the flags passed either the right or the left   square is rotated by  [2.x.232] . This way one can generate a mesh in which one   square possibly contains an edge that has the opposite tangential (and   hence also opposite normal) orientation of the neighboring edge of the   other square.     This mesh is not overly useful from a practical point of view. For   debugging purposes it can be used to check for orientation issues for   vector- or tensor-valued finite elements.    
*  [2.x.233]  If  [2.x.234]  the mesh is consistently oriented.      [2.x.235]  tria The input triangulation.    [2.x.236]  rotate_left_square  [2.x.237]  if the left square is   rotated by  [2.x.238] .    [2.x.239]  rotate_right_square  [2.x.240]  if the right square is   rotated by  [2.x.241] .  
* [0.x.23]*
   Generate a 3D mesh consisting of the unit cube joined with a copy shifted   by  [2.x.242] . Depending on the flags passed either the right or the   left cube (when looking at the positively oriented (x,z)-plane) contains a   face that is either not in standard orientation and/or is rotated by either    [2.x.243] ,  [2.x.244]  or  [2.x.245] .     This mesh is not overly useful from a practical point of view. For   debugging purposes it can be used to check for orientation issues for   vector- or tensor-valued finite elements.      [2.x.246]  tria The input triangulation.    [2.x.247]  face_orientation  [2.x.248]  if the face is the not in   standard orientation.    [2.x.249]  face_flip  [2.x.250]  if the face is rotated by +180   degrees    [2.x.251]  face_rotation  [2.x.252]  if the face is rotated   (additionally) by +90 degrees    [2.x.253]  manipulate_left_cube  [2.x.254]  if the left cube is   to be re-ordered. If `false`, it is the right cube.  
* [0.x.24]*
   Creates a hyper sphere, i.e., a surface of a ball in  [2.x.255]    dimensions. This function only exists for dim+1=spacedim in 2 and 3 space   dimensions. (To create a mesh of a ball, use  [2.x.256]      By default, all manifold ids of the triangulation are set to zero, and a   SphericalManifold is attached to the grid.     The following pictures are generated with:  
* [1.x.6]
*      See the    [2.x.257]  "documentation module on manifolds"   for more details.      [2.x.258]     [2.x.259]       [2.x.260]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.25]*
   This function produces a hyper-ball intersected with the positive orthant   relative to  [2.x.261]  which contains three elements in 2d and four in   3d. The interior points of the mesh are chosen to balance the minimal   singular value of the Jacobian of the mapping from reference to real   coordinates among the cells around the interior point, which corresponds   to a high mesh quality.     The boundary indicators for the final triangulation are 0 for the curved   boundary and 1 for the cut plane. The manifold id for the curved boundary   is set to zero, and a SphericalManifold is attached to it.     The resulting grid in 2D and 3D looks as follows:    [2.x.262]       [2.x.263]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.26]*
   This function produces a half hyper-ball around  [2.x.264]  which contains   four elements in 2d and 6 in 3d. The cut plane is perpendicular to the   [1.x.7]-axis.     The boundary indicators for the final triangulation are 0 for the curved   boundary and 1 for the cut plane. The manifold id for the curved boundary   is set to zero, and a SphericalManifold is attached to it.      [2.x.265]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.27]*
   Create a  [2.x.266]  dimensional cylinder where the  [2.x.267] -axis serves as   the axis of the cylinder. For the purposes of this function, a   cylinder is defined as a ( [2.x.268] 
* 
*  - 1) dimensional disk of given    [2.x.269]  extruded along the axis of the cylinder (which is the   first coordinate direction). Consequently, in three dimensions,   the cylinder extends from `x=-half_length` to `x=+half_length`   and its projection into the  [2.x.270]  is a circle of radius  [2.x.271]    radius. In two dimensions, the cylinder is a rectangle from   `x=-half_length` to `x=+half_length` and from `y=-radius` to   `y=radius`.     The boundaries are colored according to the following scheme: 0 for the   hull of the cylinder, 1 for the left hand face and 2 for the right hand   face (see    [2.x.272]  "the glossary entry on colorization").     The manifold id for the hull of the cylinder is set to zero, and a   CylindricalManifold is attached to it.      [2.x.273]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.28]*
   Create a  [2.x.274]  dimensional cylinder where the  [2.x.275] -axis serves as   the axis of the cylinder. For the purposes of this function, a   cylinder is defined as a ( [2.x.276] 
* 
*  - 1) dimensional disk of given    [2.x.277]  extruded along the axis of the cylinder (which is the   first coordinate direction). Consequently, in three dimensions,   the cylinder extends from `x=-half_length` to `x=+half_length`   and its projection into the  [2.x.278]  is a circle of radius  [2.x.279]    radius. In two dimensions, the cylinder is a rectangle from   `x=-half_length` to `x=+half_length` and from `y=-radius` to   `y=radius`. This function is only implemented for dim==3.     The boundaries are colored according to the following scheme: 0 for the   hull of the cylinder, 1 for the left hand face and 2 for the right hand   face (see    [2.x.280]  "the glossary entry on colorization").     The manifold id for the hull of the cylinder is set to zero, and a   CylindricalManifold is attached to it.      [2.x.281]       [2.x.282]  tria The triangulation to be created. It needs to be empty upon   calling this function.      [2.x.283]  x_subdivisions A positive integer denoting the number   of cells to generate in the x direction. The default cylinder has   x_repetitions=2.      [2.x.284]  radius The radius of the circle in the yz-plane used to extrude the cylinder.      [2.x.285]  half_length The half-length of the cylinder in the x direction.  
* [0.x.29]*
   Create a cut cone around the x-axis.  The cone extends from   <tt>x=-half_length</tt> to <tt>x=half_length</tt> and its projection into   the  [2.x.286]  is a circle of radius  [2.x.287]  at   <tt>x=-half_length</tt> and a circle of radius  [2.x.288]  at   <tt>x=+half_length</tt>. In between the radius is linearly decreasing.     In two dimensions, the cone is a trapezoid from <tt>x=-half_length</tt>   to <tt>x=+half_length</tt> and from <tt>y=-radius_0</tt> to   <tt>y=radius_0</tt> at <tt>x=-half_length</tt> and from   <tt>y=-radius_1</tt> to <tt>y=radius_1</tt> at <tt>x=+half_length</tt>.   In between the range of <tt>y</tt> is linearly decreasing.     The boundaries are colored according to the following scheme: 0 for the   hull of the cone, 1 for the left hand face, and 2 for the right hand face   (see    [2.x.289]  "the glossary entry on colorization").   Both the boundary indicators and the manifold indicators are set.     In three dimensions, the manifold id of the hull is set to zero, and a   CylindricalManifold is attached to it.     Here are the grids in 2D and 3D after two mesh refinements:      [2.x.290]     [2.x.291]       [2.x.292]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.30]*
   \brief A center cell with stacks of cell protruding from each surface.     Each of the square mesh cells is Cartesian and has size one in each   coordinate direction. The center of cell number zero is the origin.      [2.x.293]  tria A Triangulation object which has to be empty.      [2.x.294]  sizes A vector of integers of dimension    [2.x.295]  with the following meaning: the legs of   the cross are stacked on the faces of the center cell, in the usual order   of deal.II cells, namely first  [2.x.296] , then  [2.x.297] , then  [2.x.298]  and so on. The   corresponding entries in  [2.x.299]  name the number of cells   stacked on this face. All numbers may be zero, thus L- and T-shaped   domains are specializations of this domain.      [2.x.300]  colorize_cells If colorization is enabled, then the material id of   a cells corresponds to the leg it is in. The id of the center cell is   zero, and then the legs are numbered starting at one (see    [2.x.301]  "the glossary entry on colorization").     Examples in two and three dimensions are:      [2.x.302]     [2.x.303]   
* [0.x.31]*
   Initialize the given triangulation with a hyper-L (in 2d or 3d)   consisting of exactly <tt>2^dim-1</tt> cells. It produces the   hypercube with the interval [[1.x.8]] without the   hypercube made out of the interval [[1.x.9]]   for each coordinate. Because the domain is about the simplest one   with a reentrant (i.e., non-convex) corner, solutions of many   partial differential equations have singularities at this   corner. That is, at the corner, the gradient or a higher   derivative (depending on the boundary conditions chosen) does not   remain bounded. As a consequence, this domain is often used to   test convergence of schemes when the solution lacks regularity.     If the  [2.x.304]  flag is  [2.x.305] , the  [2.x.306]  of the   surfaces are assigned such that the left boundary is 0 and the others are   assigned counterclockwise in ascending order (see    [2.x.307]  "the glossary entry on colorization"). The  [2.x.308]    colorize option only works in two dimensions.     This function will create the classical L-shape in 2d   and it will look like the following in 3d:      [2.x.309]     
*  [2.x.310]  The 3d domain is also often referred to as the "Fichera corner",   named after Gaetano Fichera (1922-1996) who first computed an   approximation of the corner singularity exponent of the lowest   eigenfunction of the domain.     This function exists for triangulations of all space   dimensions, but throws an error if called in 1d.      [2.x.311]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.32]*
   Initialize the given triangulation in 2D or 3D with a generalized   subdivided hyper-L.     This function produces a subdivided hyper rectangle with dimensions given   by  [2.x.312]  and  [2.x.313]  with the given number of   subdivisions in each direction given in the vector  [2.x.314]    and with a number of cells removed, given in the vector  [2.x.315]    Note that  [2.x.316]  contains integers, meaning that its entries   can be both positive and negative. A positive number denotes   cutting away cells in the 'positive' orientation, for example   left to right in the x-direction, bottom to top in   the y-direction, and front to back in the z-direction. A negative number   denotes cutting away cells in the reverse direction, so right to left,   top to bottom, and back to front.     A demonstration of this grid can be found in  [2.x.317] .     This function may be used to generate a mesh for a backward   facing step, a useful domain for benchmark problems in fluid dynamics.   The first image is a backward facing step in 3D, generated by   removing all cells in the z-direction, and 2 cells in the   positive x- and y-directions:    [2.x.318]    And in 2D, we can cut away 1 cell in the negative x-direction, and 2 cells   in the negative y-direction:    [2.x.319]     
*  [2.x.320]  This function is declared to exist for triangulations of all space   dimensions, but throws an error if called in 1D.  
* [0.x.33]*
   Initialize the given Triangulation with a hypercube with a slit. In each   coordinate direction, the hypercube extends from  [2.x.321]  to  [2.x.322]      In 2d, the split goes in vertical direction from <tt>x=(left+right)/2,   y=left</tt> to the center of the square at <tt>x=y=(left+right)/2</tt>.     In 3d, the 2d domain is just extended in the [1.x.10]-direction, such   that a plane cuts the lower half of a rectangle in two.  This function is   declared to exist for triangulations of all space dimensions, but throws   an error if called in 1d.     If  [2.x.323]  is set to  [2.x.324]  the faces forming the slit are marked   with boundary id 1 and 2, respectively (see    [2.x.325]  "the glossary entry on colorization").      [2.x.326]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.34]*
   Produce a hyper-shell, the region between two spheres around   <tt>center</tt>, with given <tt>inner_radius</tt> and   <tt>outer_radius</tt>. The number <tt>n_cells</tt> indicates the number   of cells of the resulting triangulation, i.e., how many cells form the   ring (in 2d) or the shell (in 3d).     If the flag  [2.x.327]  is  [2.x.328] , then the outer boundary   will have the indicator 1 while the inner boundary has id zero. In 3d,   this applies to both the faces and the edges of these boundaries. If the   flag is  [2.x.329]  both have indicator zero (see    [2.x.330]  "the glossary entry on colorization").     All manifold ids are set to zero, and a SphericalManifold is attached to   every cell and face of the triangulation.     In 2d, the number <tt>n_cells</tt> of elements for this initial   triangulation can be chosen arbitrarily. If the number of initial cells   is zero (as is the default), then it is computed adaptively such that the   resulting elements have the least aspect ratio.     In 3d, only certain numbers are allowed:    [2.x.331]     [2.x.332]  6 (or the default 0) for a surface based on a hexahedron (i.e. 6        panels on the inner sphere extruded in radial direction to form 6        cells),    [2.x.333]  12 for the rhombic dodecahedron,    [2.x.334]  24 for the hexahedron-based surface refined once in the azimuthal        directions but not in the radial direction,    [2.x.335]  48 for the rhombic dodecahedron refined once in the azimuthal        directions but not in the radial direction,    [2.x.336]  96 for the rhombic dodecahedron refined once. This choice dates from        an older version of deal.II before the Manifold classes were        implemented: today this choce is equivalent to the rhombic        dodecahedron after performing one global refinement.    [2.x.337]  Numbers of the kind  [2.x.338]  with  [2.x.339]  integer. This        choice is similar to the 24 and 48 cell cases, but provides        additional refinements in azimuthal direction combined with a single        layer in radial direction. The base mesh is either the 6 or 12 cell        version, depending on whether  [2.x.340]  in the power is odd or even,        respectively.    [2.x.341]    The versions with 24, 48, and  [2.x.342]  cells are useful if the shell is   thin and the radial lengths should be made more similar to the   circumferential lengths.     The 3d grids with 12 and 96 cells are plotted below:      [2.x.343]     [2.x.344]     
*  [2.x.345]  This function is declared to exist for triangulations of all space   dimensions, but throws an error if called in 1d.      [2.x.346]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.35]*
   Produce an eccentric hyper-shell, the region between two spheres centered   on two distinct center points. One has to specify the <tt>inner_center</tt>   and <tt>outer_center</tt>, with given <tt>inner_radius</tt> and   <tt>outer_radius</tt>. The number <tt>n_cells</tt> indicates the number of   cells of the resulting triangulation, i.e., how many cells form the ring   (in 2d) or the shell (in 3d).     By default, the outer boundary has the indicator 1 while the inner boundary   has id 0. In 3d, this applies to both the faces and the edges of these   boundaries.     A SphericalManifold is attached to the outer boundary with an id of 1 while   another SphericalManifold is attached to the inner boundary with an id of   0. A TransfiniteInterpolationManifold is attached to all other cells and   faces of the triangulation with an id of 2.     Here, the number <tt>n_cells</tt> of elements has the same meaning as in    [2.x.347]      The grids with a 30% offset of the inner shell in the x direction, 12   initial cells and 3 levels of global refinement are plotted below:      [2.x.348]     [2.x.349]     
*  [2.x.350]  Because it uses the definition of the hyper shell, this function is   declared to exist for triangulations of all space dimensions, but throws an   error if called in 1d.      [2.x.351]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.36]*
   Produce a half hyper-shell, i.e. the space between two circles in two   space dimensions and the region between two spheres in 3d, with given   inner and outer radius and a given number of elements for this initial   triangulation.  However, opposed to the previous function, it does not   produce a whole shell, but only one half of it, namely that part for   which the first component is restricted to non-negative values. The   purpose of this function is to enable computations for solutions which have   rotational symmetry, in which case the half shell in 2d represents a   shell in 3d.     If the number of initial cells  [2.x.352]  is zero in 2d (as is the   default), then it is computed adaptively such that the resulting elements   have the least aspect ratio. The argument is ignored in 3d, where the   coarse mesh always has 5 cells.     If colorize is set to  [2.x.353] , the inner, outer, and the part   of the boundary where  [2.x.354] , get indicator 0, 1, and 2,   respectively. Additionally, in 2d, the boundary indicator 3 is given to   the vertical edge below the x-axis. Otherwise, if colorize is set to    [2.x.355]  all indicators are set to 0 (see    [2.x.356]  "the glossary entry on colorization").     All manifold ids are set to zero, and a SphericalManifold is attached   to the triangulation.      [2.x.357]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.37]*
   Produce a domain that is the intersection between a hyper-shell with   given inner and outer radius, i.e. the space between two circles in two   space dimensions and the region between two spheres in 3d, and the   positive quadrant (in 2d) or octant (in 3d). In 2d, this is indeed a   quarter of the full annulus, while the function is a misnomer in 3d   because there the domain is not a quarter but one eighth of the full   shell.     If the number of initial cells is zero (as is the default), then it is   computed adaptively such that the resulting elements have the least   aspect ratio in 2d.     If  [2.x.358]  is set to  [2.x.359] , the inner, outer, left, and   right boundary get indicator 0, 1, 2, and 3 in 2d,   respectively. Otherwise all indicators are set to 0. In 3d indicator 2 is   at the face  [2.x.360] , 3 at  [2.x.361] , 4 at  [2.x.362]  (see    [2.x.363]  "the glossary entry on colorization").     All manifold ids are set to zero, and a SphericalManifold is attached   to the triangulation.      [2.x.364]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.38]*
   Produce a domain that is the space between two cylinders in 3d, with   given length, inner and outer radius and a given number of elements. The   cylinder shell is built around the  [2.x.365] -axis with the two faces located   at  [2.x.366]  and  [2.x.367]   [2.x.368]      If  [2.x.369]  is zero (as is the   default), then it is computed adaptively such that the resulting elements   have the least aspect ratio. The same holds for  [2.x.370]     
*  [2.x.371]  Although this function is declared as a template, it does not make   sense in 1D and 2D. Also keep in mind that this object is rotated   and positioned differently than the one created by cylinder().     All manifold ids are set to zero, and a CylindricalManifold is attached   to the triangulation.      [2.x.372]  The triangulation passed as argument needs to be empty when calling   this function.      [2.x.373]      In this picture, a cylinder shell of length 2, inner radius 0.5, outer   radius 1 is shown. The default argument for n_radial_cells and   n_axial_cells are used and a single global refinement is carried out.  
* [0.x.39]*
   Produce the volume or surface mesh of a torus. The axis of the torus is   the  [2.x.374] -axis while the plane of the torus is the  [2.x.375] - [2.x.376]  plane.     If  [2.x.377]  is 3, the mesh will be the volume of the torus, using a mesh   equivalent to the circle in the poloidal coordinates with 5 cells on the   cross section. This function attaches a TorusManifold to all boundary   faces which are marked with a manifold id of 1, a CylindricalManifold to   the interior cells and all their faces which are marked with a manifold   id of 2 (representing a flat state within the poloidal coordinates), and   a TransfiniteInterpolationManifold to the cells between the TorusManifold   on the surface and the ToroidalManifold in the center, with cells marked   with manifold id 0.     An example for the case if  [2.x.378]  is 3 with a cut through the domain at    [2.x.379] , 6 toroidal cells,  [2.x.380]  and  [2.x.381]  without any global refinement   is given here:      [2.x.382]      In this picture, the light gray shade represents the manifold id 0 of the   transfinite interpolation, which is applied to smoothly add new points   between the toroidal shape on the domain boundary and the inner rim where   a cylindrical description around the y-axis is prescribed. The inner rim   with the manifold id 2 is shown in red shade.     If  [2.x.383]  is 2, the mesh will describe the surface of the torus and this   function attaches a TorusManifold to all cells and faces (which are   marked with a manifold id of 0).      [2.x.384]  tria The triangulation to be filled.      [2.x.385]  R The radius of the circle, which forms the middle line of the   torus containing the loop of cells. Must be greater than  [2.x.386]       [2.x.387]  r The inner radius of the torus.      [2.x.388]  n_cells_toroidal Optional argument to set the number of cell   layers in toroidal direction. The default is 6 cell layers.      [2.x.389]  phi Optional argument to generate an open torus with angle    [2.x.390] . The default value is  [2.x.391] ,   in which case a closed torus is generated. If the torus is open,   the torus is cut at two planes perpendicular to the torus centerline.   The center of these two planes are located at  [2.x.392]    and  [2.x.393] .    
*  [2.x.394]  Implemented for Triangulation<2,3> and Triangulation<3,3>.  
* [0.x.40]*
   This function produces a square in the [1.x.11]-plane with a cylindrical   hole in the middle. The square and the circle are centered at the   origin. In 3d, this geometry is extruded in  [2.x.395]  direction to the interval    [2.x.396] .     The inner boundary has a manifold id of  [2.x.397]  and a boundary id of    [2.x.398] . This function attaches a PolarManifold or CylindricalManifold to the   interior boundary in 2d and 3d respectively. The other faces have   boundary ids of  [2.x.399] , or  [2.x.400]  given in the standard order of   faces in 2d or 3d.      [2.x.401]      It is implemented in 2d and 3d, and takes the following arguments:      [2.x.402]  triangulation The triangulation to be filled.    [2.x.403]  inner_radius  Radius of the internal hole.    [2.x.404]  outer_radius Half of the edge length of the square.    [2.x.405]  L  Extension in  [2.x.406]  (only used in 3d).    [2.x.407]  repetitions Number of subdivisions along the  [2.x.408]     [2.x.409]  colorize Whether to assign different boundary indicators to   different faces (see    [2.x.410]  "the glossary entry on colorization").   The colors are given in lexicographic ordering for the   flat faces (0 to 3 in 2d, 0 to 5 in 3d) plus the curved hole (4 in 2d,   and 6 in 3d). If  [2.x.411]  is set to false, then flat faces get the   number 0 and the hole gets number 1.  
* [0.x.41]*
   Produce a grid consisting of concentric shells. The primary difference   between this function and  [2.x.412]  is that this   function permits unevenly spaced (in the radial direction)    [2.x.413]  "coarse level cells".     The parameters  [2.x.414]   [2.x.415]  and  [2.x.416]  behave in   the same way as the first three arguments to    [2.x.417]   [2.x.418]  gives the total number of shells   to use (i.e., the number of cells in the radial direction). The outer   radius of the  [2.x.419] th shell is given by     [1.x.12]     where  [2.x.420]  is a parameter controlling the shell spacing in the   radial direction: values of  [2.x.421]  close to zero correspond to even   spacing, while larger values of  [2.x.422]  (such as  [2.x.423]  or  [2.x.424] )   correspond to shells biased to the inner radius.      [2.x.425]  is the same as in  [2.x.426]  in 2d   the default choice of zero will result in 8 cells per shell (and 12 in   3d). The only valid values in 3d are 6 (the default), 12, and 96 cells:   see the documentation of  [2.x.427]  for more information.     If  [2.x.428]  is  [2.x.429]  then the outer boundary of the merged   shells has a boundary id of  [2.x.430]  and the inner boundary has a boundary id   of  [2.x.431] .     Example: The following code (see, e.g.,  [2.x.432]  for instructions on how   to visualize GNUPLOT output)    
* [1.x.13]
*      generates the following output:      [2.x.433]   
* [0.x.42]*
   Produce a ring of cells in 3d that is cut open, twisted and glued   together again. This results in a kind of moebius-loop.      [2.x.434]  tria        The triangulation to be worked on.    [2.x.435]  n_cells     The number of cells in the loop. Must be greater than   4.    [2.x.436]  n_rotations The number of rotations ( [2.x.437]  each) to be performed   before gluing the loop together.    [2.x.438]  R           The radius of the circle, which forms the middle line   of the torus containing the loop of cells. Must be greater than  [2.x.439]     [2.x.440]  r           The radius of the cylinder bent together as a loop.  
* [0.x.43]*
   Call one of the other GridGenerator functions, parsing the name of the   function to call from the string  [2.x.441]  and   the arguments to the function from the string    [2.x.442]      The string that supplies the arguments is passed to the function    [2.x.443]  where `TupleType` here is   a tuple containing*all** the arguments of the GridGenerator function,   including all optional arguments.     An example usage of this function is given by:  
* [1.x.14]
*    Here, the colon separates the function arguments, and the comma separates   the coordinates of a Point<2> argument.     According to the arity of the `TupleType`, the arguments of the function   may be separated by different separators (see the documentation of    [2.x.444]  for the details of how the conversion is   performed). If a wrong format is used, an exception is thrown, and the   expected format is output as an error message.     All GridGenerator functions are supported. If you find some that are   missing, please open an issue on GitHub.      [2.x.445]  tria                              The triangulation to be worked on    [2.x.446]  grid_generator_function_name      The name of the function to call    [2.x.447]  grid_generator_function_arguments The arguments of the function, in   the format of a tuple-convertible string  
* [0.x.44]*
    [2.x.448]  Creating meshes from other meshes  
* [0.x.45]*
   Given the two triangulations specified as the first two arguments, create   the triangulation that contains the cells of both triangulation and store   it in the third parameter. Previous content of  [2.x.449]  will be deleted.   One of the two input triangulations can also be the  [2.x.450]  triangulation.     This function is most often used to compose meshes for more complicated   geometries if the geometry can be composed of simpler parts for which   functions exist to generate    [2.x.451]  "coarse meshes". For example, the channel mesh   used in  [2.x.452]  could in principle be created using a mesh created by the    [2.x.453]  function and several   rectangles, and merging them using the current function. The rectangles   will have to be translated to the right for this, a task that can be done   using the  [2.x.454]  function (other tools to transform individual   mesh building blocks are  [2.x.455]   [2.x.456]  and    [2.x.457]      Vertices that are less than  [2.x.458]  apart will be merged   together. It is usually necessary to set this value to something that   depends on the input triangulations in some way. One reasonable choice is   to use the minimum distance between all adjacent vertices of the input   mesh divided by some constant:    
* [1.x.15]
*      This will merge any vertices that are closer than any pair of vertices on   the input meshes.    
*  [2.x.459]  The two input triangulations must be    [2.x.460]  "coarse meshes", i.e., they can not have any   refined cells.    
*  [2.x.461]  The function copies the material ids of the cells of the two input   triangulations into the output triangulation. If  [2.x.462]  is   set to  [2.x.463]  manifold ids will be copied. Boundary indicators are never   copied. In other words, if the two coarse meshes have anything but the   default boundary indicators, then you will have to set boundary indicators   again by hand in the output triangulation.    
*  [2.x.464]  This function does not attach any manifolds to  [2.x.465]  nor does   it set any manifold ids. In particular, manifolds attached to the two   input triangulations will be lost in the  [2.x.466]  triangulation.    
*  [2.x.467]  For a related operation on refined meshes when both meshes are   derived from the same coarse mesh, see    [2.x.468]   
* [0.x.46]*
   Same as above but allows to merge more than two triangulations at once.   The following gives an example of how to use this function:  
* [1.x.16]
*   
* [0.x.47]*
   \brief Replicate a given triangulation in multiple coordinate axes      [2.x.469]  input The triangulation which will be replicated along the   coordinate axes.      [2.x.470]  extents A vector with <tt>dim</tt> entries specifying how many   copies of a triangulation should be present along each coordinate axis.      [2.x.471]  result The triangulation to be created. It needs to be empty upon   calling this function.     This function creates a new Triangulation equal to a   <tt>dim</tt>-dimensional array of copies of  [2.x.472]  Copies of  [2.x.473]    are created by translating  [2.x.474]  along the coordinate axes. Boundary   ids of faces (but not lines in 3D) and all manifold ids are copied but   Manifold objects are not since most Manifold objects do not work   correctly when a Triangulation has been translated.     To see how this works, consider the following code:  
* [1.x.17]
*    results in      [2.x.475]      And, similarly, in 3D:  
* [1.x.18]
*    results in      [2.x.476]     
*  [2.x.477]  This function determines the spacing of the copies of  [2.x.478]    based on the BoundingBox of  [2.x.479]  If the boundary faces of  [2.x.480]    are not aligned with the coordinate axes then the copies might not share   common faces; i.e., this function is intended for simple geometries with   boundary faces aligned along the coordinate axes.  
* [0.x.48]*
   Given the two triangulations specified as the first two arguments, create   the triangulation that contains the finest cells of both triangulation   and store it in the third parameter. Previous content of  [2.x.481]  will   be deleted.    
*  [2.x.482]  This function is intended to create an adaptively refined   triangulation that contains the [1.x.19] from two input   triangulations that were derived from the [1.x.20]    [2.x.483]  "coarse mesh" by   adaptive refinement. This is an operation sometimes needed when one   solves for two variables of a coupled problem on separately refined   meshes on the same domain (for example because these variables have   boundary layers in different places) but then needs to compute something   that involves both variables or wants to output the result into a single   file. In both cases, in order not to lose information, the two solutions   can not be interpolated onto the respectively other mesh because that may   be coarser than the ones on which the variable was computed. Rather, one   needs to have a mesh for the domain that is at least as fine as each of   the two initial meshes. This function computes such a mesh.    
*  [2.x.484]  If you want to create a mesh that is the merger of two other    [2.x.485]  "coarse meshes",   for example in order to compose   a mesh for a complicated geometry   from meshes for simpler geometries, then this is not the function for   you. Instead, consider  [2.x.486]     
*  [2.x.487]  This function assumes that both  [2.x.488]  and  [2.x.489]    triangulation_2 have the same manifold descriptions. The output   Triangulation  [2.x.490]  the same manifold ids as these two triangulations.    
*  [2.x.491]  Both of the source conditions need to be available entirely locally.   In other words, they can not be objects of type    [2.x.492]   
* [0.x.49]*
   This function creates a triangulation that consists of the same cells as   are present in the first argument, except those cells that are listed in   the second argument. The purpose of the function is to generate   geometries [1.x.21] from the geometry described by an   existing triangulation. A prototypical case is a 2d domain with   rectangular holes. This can be achieved by first meshing the entire   domain and then using this function to get rid of the cells that are   located at the holes. A demonstration of this particular use case is part   of  [2.x.493] . Likewise, you could create the mesh that    [2.x.494]  produces by starting with a    [2.x.495]  refining it once, and then calling the   current function with a single cell in the second argument.      [2.x.496]  input_triangulation The original triangulation that serves as   the template from which the new one is to be created.    [2.x.497]  cells_to_remove A list of cells of the triangulation provided   as first argument that should be removed (i.e., that should not show up   in the result.    [2.x.498]  result The resulting triangulation that consists of the same   cells as are in  [2.x.499]  with the exception of the cells   listed in  [2.x.500]     
*  [2.x.501]  Unlike most GridGenerator functions, this function does not attach   any manifolds to  [2.x.502]  nor does it set any manifold ids.      [2.x.503]  Because we cannot create triangulations de novo that contain   adaptively refined cells, the input triangulation needs to have all of   its cells on the same level. Oftentimes, this will in fact be the   coarsest level, but it is allowed to pass in a triangulation that has   been refined [1.x.22] a number of times. The output triangulation   will in that case simply be a mesh with only one level that consists of   the active cells of the input minus the ones listed in the second   argument. However, the input triangulation must not have been   [1.x.23] refined.  
* [0.x.50]*
   Extrude the Triangulation  [2.x.504]  in the  [2.x.505]  direction from  [2.x.506]  to  [2.x.507]  and store it in  [2.x.508]      The number of  [2.x.509] slices [2.x.510] , or layers of cells   perpendicular to the  [2.x.511]  plane, will be  [2.x.512]  slices (minimum is   2). The boundary indicators of the faces of  [2.x.513]  will be assigned to   the corresponding side walls in  [2.x.514]  direction. The bottom and top get the   next two free boundary indicators: i.e., if  [2.x.515]  has boundary ids of    [2.x.516] ,  [2.x.517] , and  [2.x.518] , then the  [2.x.519]  boundary id of  [2.x.520]  will be  [2.x.521]    and the  [2.x.522]  boundary id will be  [2.x.523] .     This function does not, by default, copy manifold ids. The reason for   this is that there is no way to set the manifold ids on the lines of the   resulting Triangulation without more information: for example, if two   faces of  [2.x.524]  with different manifold ids meet at a shared vertex then   there is no  [2.x.525] a priori [2.x.526]  reason to pick one manifold id or another   for the lines created in  [2.x.527]  that are parallel to the  [2.x.528] -axis and   pass through that point. If  [2.x.529]  is  [2.x.530]    then this function sets line manifold ids by picking the one that appears    [2.x.531] first [2.x.532]  in  [2.x.533]  For example: if  [2.x.534]    manifold_priorities is  [2.x.535]    and the line under consideration is adjacent to faces with manifold ids of    [2.x.536] , then that line will have a manifold id   of  [2.x.537] . The correct ordering is almost always    [2.x.538]       [2.x.539] manifold ids set on the boundary, [2.x.540]       [2.x.541] manifold ids that describe most of the cells in the Triangulation     (e.g.,  [2.x.542]  and [2.x.543]       [2.x.544] any manifold ids corresponding to TransfiniteInterpolationManifold     manifolds. [2.x.545]     [2.x.546]      In particular, since TransfiniteInterpolationManifold interpolates   between surrounding manifolds, its manifold id should usually not be set   on lines or faces that are adjacent to cells with different manifold   ids. The default value for  [2.x.547]  follows this ranking   (where each category is sorted in ascending order):    [2.x.548]       [2.x.549] manifold ids associated with manifolds that are not     TransfiniteInterpolationManifold, and [2.x.550]       [2.x.551] manifold ids associated with any TransfiniteInterpolationManifold     objects. [2.x.552]     [2.x.553]    Note that  [2.x.554]  (should it be a manifold id of  [2.x.555]    input) will always be the last entry in the first category.      [2.x.556]  The 2d input triangulation  [2.x.557]  must be a    [2.x.558]  "coarse mesh",   i.e., it cannot have any   refined cells.    
*  [2.x.559]  Since  [2.x.560]  and  [2.x.561]  have different spatial dimensions, no   manifold objects are copied by this function regardless of the value of    [2.x.562]   
* [0.x.51]*
   Overload of extrude_triangulation() to allow dimension independent   code to compile. This function throws an error when called, as   extrude_triangulation() is only implemented to extrude a dim=2 to a dim=3   Triangulation.  
* [0.x.52]*
   Overload of the previous function. Take a 2d Triangulation that is being   extruded. Differing from the previous function taking height and number of   slices for uniform extrusion, this function takes z-axis values    [2.x.563]  where the slicing will happen. The boundary indicators   of the faces of  [2.x.564]  are going to be assigned to the corresponding side   walls in z direction. The bottom and top get the next two free boundary   indicators.      [2.x.565]  The 2d input triangulation  [2.x.566]  must be a    [2.x.567]  "coarse mesh",   i.e., it cannot have any   refined cells.    
*  [2.x.568]  Since  [2.x.569]  and  [2.x.570]  have different spatial dimensions no   manifold objects are copied (nor are any manifold ids set) by this   function.  
* [0.x.53]*
   Overload of extrude_triangulation() to allow dimension independent   code to compile. This function throws an error when called, as   extrude_triangulation() is only implemented to extrude a dim=2 to a dim=3   Triangulation.  
* [0.x.54]*
   Given an input triangulation  [2.x.571]  this function makes a new flat   triangulation  [2.x.572]  which contains a single level with all active   cells of the input triangulation. If  [2.x.573]  and  [2.x.574]  are   different, only the smallest spacedim components of the vertices are   copied over. This is useful to create a Triangulation<2,3> out of a   Triangulation<2,2>, or to project a Triangulation<2,3> into a   Triangulation<2,2>, by neglecting the z components of the vertices.     No internal checks are performed on the vertices, which are assumed to   make sense topologically in the target  [2.x.575]  dimensional space. If   this is not the case, you will encounter problems when using the   triangulation later on.     All information about cell manifold_ids and material ids are copied from   one triangulation to the other, and only the boundary manifold_ids and   boundary_ids are copied over from the faces of  [2.x.576]  to the faces of    [2.x.577]  If you need to specify manifold ids on interior faces, they   have to be specified manually after the triangulation is created.     This function will fail if the input Triangulation is of type    [2.x.578]  as well as when the input   Triangulation contains hanging nodes.      [2.x.579]  in_tria The base input for a new flat triangulation.    [2.x.580]  out_tria The desired flattened triangulation constructed from   the in_tria.    
*  [2.x.581]  Since  [2.x.582]  and  [2.x.583]  have different spatial dimensions no   manifold objects are copied by this function: you must attach new   manifold objects to  [2.x.584]   
* [0.x.55]*
   Convert a triangulation consisting only of hypercube cells   (quadrilaterals, hexahedra) to a triangulation only consisting of   simplices (triangles, tetrahedra).     As an example, the following image shows how a set of three hexahedra   meshing one eighths of a sphere are subdivided into tetrahedra, and how   the curved surface is taken into account. Colors indicate how boundary   indicators are inherited:    [2.x.585]      In general, each quadrilateral in 2d is subdivided into eight triangles,   and each hexahedron in 3d into 24 tetrahedra as shown here:    [2.x.586]      Material ID and boundary IDs are inherited upon conversion.      [2.x.587]  in_tria The triangulation containing hex elements.    [2.x.588]  out_tria The converted triangulation containing tet elements.    
*  [2.x.589]  No manifold objects are copied by this function: you must     copy existing manifold objects from  [2.x.590]  to  [2.x.591]  e.g.,     with the following code:  
* [1.x.24]
*   
* [0.x.56]*
   Specialization of the above function for 1D: simply copy triangulation.  
* [0.x.57]*
   Namespace Airfoil contains classes and functions in order to create a   C-type mesh for the (flow) field around Joukowski or NACA airfoils.    
*  [2.x.592]   
* [0.x.58]*
     AdditionalData collects all settings that are required to generate a     airfoil triangulation with the functions  [2.x.593]     
* [0.x.59]*
       Type of the airfoil: either "NACA" or "Joukowksi" to choose airfoil       geometry among NACA and Joukowski airfoil.      
* [0.x.60]*
       NACA serial number defining the airfoil shape.            
*  [2.x.594]  Currently serial numbers with length 4 are supported.       A good overview of NACA serial numbers is presented in Wikipedia       (https://en.wikipedia.org/wiki/NACA_airfoil)      
* [0.x.61]*
       Center of Joukowski circle.            
*  [2.x.595]  A center on the x-axis leads to a symmetrical airfoil.      
* [0.x.62]*
       Chord length of the airfoil, i.e. distance from leading to trailing       edge.      
* [0.x.63]*
       Vertical distance from airfoil chord to upper boundary of the mesh       i.e. half of the total mesh height.      
* [0.x.64]*
       Length of mesh from the airfoil trailing edge to outflow boundary.      
* [0.x.65]*
       Factor defining the inclination HG of the coarse grid       The figure shows the upper coarse grid with two different inclinations
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - incline_factor = 0
* 

* 
* 

* 
* 
*  - > face HG
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - incline_factor = 0.5
* 
*  - > face HG'       Coordinate of point G' is defined by incline_factor after interpolation       G'(0) = G(0) + incline_factor (K(0)
* 
*  - G(0))       with incline_factor in [0,1).                          o-----G---G'--K                 /  |     |  /    |               /    o     | /     |             /    /    \  |/      |           o----o         H-------o      
* [0.x.66]*
       Factor to receive a finer mesh around the airfoil by increasing       bias_factor b.       Bias function: f(x) = tanh(bx) / tanh(x) with x in [0,1], leads to a       compression of values close to x = 1.      
* [0.x.67]*
       Number of global refinements.      
* [0.x.68]*
       Number of subdivisions along the airfoil in left block.      
* [0.x.69]*
       Number of subdivisions along the airfoil in middle block.      
* [0.x.70]*
       Number of subdivisions in block right of the airfoil.      
* [0.x.71]*
       Number of subdivisions normal to the airfoil contour.      
* [0.x.72]*
       Factor to enhance the approximation of the airfoil geometry that       happens when interpolating provided nonequidistant airfoil points to       equidistant airfoil points. When generating the required vector       consisting the equidistant airfoil points, it is interpolated between       nonequidistand airfoil points.       Increasing the provided nonequidistant airfoil points leads to       a better approximation of the airfoil geometry. Parameter       "airfoil_sampling_factor" thereby defines the relation of       provided_nonequidistant_points to required_equidistant_points.      
* [0.x.73]*
       Constructor.      
* [0.x.74]*
       This function adds the ParameterHandler entries.              [2.x.596]  prm Parameter handler.      
* [0.x.75]*
     Initialize the given triangulation with a flow field around an airfoil,     i.e., a mesh of C-Type approximating Joukowski or NACA (4 digit)     airfoils.         The user can specify the airfoil geometry and the mesh setup by providing     input parameters for the struct AdditionalData.     Thereby, the user can choose among different types of Joukowski or NACA     airfoils with variable chord length, far field size and mesh density.        
*  [2.x.597]  This function creates a refined mesh (number of global refinements           can be specified by the user). No manifold is attached. The           vertices in the final mesh are moved by this function to the           right position.        
*  [2.x.598]  This function is currently only implemented for 2D but the mesh           can of course be extruded into the third dimension using            [2.x.599]           [2.x.600]  tria The triangulation to be created. It needs to be empty                 upon calling this function.      [2.x.601]  additional_data Configuration of the mesh.         \htmlonly <style>div.image         img[src="https://www.dealii.org/images/grids/airfoils_naca_joukowski.png"]{width:50%;}</style>     \endhtmlonly      [2.x.602]     
* [0.x.76]*
     The same as above but periodic boundary conditions on the     upper and lower faces of the far field are applied.        
*  [2.x.603]  This function is currently only implemented for 2D.          [2.x.604]  tria The triangulation to be created. It needs to be empty     upon calling this function.      [2.x.605]  periodic_faces Periodic faces at upper and lower horizontal                           boundaries.      [2.x.606]  additional_data Configuration of the mesh.    
* [0.x.77]*
   Create a coordinate-parallel brick from the two diagonally opposite   corner points  [2.x.607]  and  [2.x.608]  The number of vertices in coordinate   direction  [2.x.609]  is given by <tt>repetitions[i]+1</tt>.    
*  [2.x.610]  This function connects internally 4/8 vertices to     quadrilateral/hexahedral cells and subdivides these into 2/5   triangular/tetrahedral cells.    
*  [2.x.611]  Currently, this function only works for `dim==spacedim`.    
*  [2.x.612]   
* [0.x.78]*
   Initialize the given triangulation with a hypercube (square in 2D and   cube in 3D) consisting of  [2.x.613]  cells in each direction.   The hypercube volume is the tensor product interval    [2.x.614]  in the present number of dimensions, where   the limits are given as arguments. They default to zero and unity, then   producing the unit hypercube.    
*  [2.x.615]  This function connects internally 4/8 vertices to   quadrilateral/hexahedral cells and subdivides these into 2/5   triangular/tetrahedral cells.    
*  [2.x.616]   
* [0.x.79]*
    [2.x.617]  Creating lower-dimensional meshes     Created from parts of higher-dimensional meshes.  
* [0.x.80]*
   This function implements a boundary subgrid extraction.  Given a   <dim,spacedim>-Triangulation (the "volume mesh") the function extracts a   subset of its boundary (the "surface mesh").  The boundary to be   extracted is specified by a list of boundary_ids.  If none is specified   the whole boundary will be extracted. The function is used in  [2.x.618] .     The function also builds a mapping linking the cells on the surface mesh   to the corresponding faces on the volume one. This mapping is the return   value of the function.    
*  [2.x.619]  The function builds the surface mesh by creating a    [2.x.620]  "coarse mesh"   from   the selected faces of the coarse cells of the volume mesh. It copies the   boundary indicators of these faces to the cells of the coarse surface   mesh. The surface mesh is then refined in the same way as the faces of   the volume mesh are. In order to ensure that the surface mesh has the   same vertices as the volume mesh, it is therefore important that you   assign appropriate boundary descriptions through    [2.x.621]  to the surface mesh object before calling   this function. If you don't, the refinement will happen under the   assumption that all faces are straight (i.e using the FlatManifold class)   rather than utilizing the Manifold object you may want to use to determine   the location of new vertices.      [2.x.622]  MeshType A type that satisfies the requirements of the    [2.x.623]  "MeshType concept".   The map that is returned will be between cell iterators pointing into the   container describing the surface mesh and face iterators of the volume   mesh container. If MeshType is DoFHandler, then the function will re-build   the triangulation underlying the second argument and return a map between   appropriate iterators into the MeshType arguments. However, the function   will not actually distribute degrees of freedom on this newly created   surface mesh.      [2.x.624]  dim The dimension of the cells of the volume mesh. For example,   if dim==2, then the cells are quadrilaterals that either live in the   plane, or form a surface in a higher-dimensional space. The dimension of   the cells of the surface mesh is consequently dim-1.    [2.x.625]  spacedim The dimension of the space in which both the volume and   the surface mesh live.      [2.x.626]  volume_mesh A container of cells that define the volume mesh.    [2.x.627]  surface_mesh A container whose associated triangulation will   be built to consist of the cells that correspond to the (selected portion   of) the boundary of the volume mesh.    [2.x.628]  boundary_ids A list of boundary indicators denoting that   subset of faces of volume cells for which this function should extract   the surface mesh. If left at its default, i.e., if the set is empty, then   the function operates on [1.x.25] boundary faces.      [2.x.629]  A map that for each cell of the surface mesh (key) returns an   iterator to the corresponding face of a cell of the volume mesh (value).   The keys include both active and non-active cells of the surface mesh.   The order of vertices of surface cells and the corresponding   volume faces may not match in order to ensure that each surface cell is   associated with an outward facing normal.   As a consequence, if you want to match quantities on the faces of the   domain cells and on the cells of the surface mesh, you may have to   translate between vertex locations or quadrature points.    
*  [2.x.630]  The algorithm outlined above assumes that all faces on higher   refinement levels always have exactly the same boundary indicator as   their parent face. Consequently, we can start with coarse level faces and   build the surface mesh based on that. It would not be very difficult to   extend the function to also copy boundary indicators from finer level   faces to their corresponding surface mesh cells, for example to   accommodate different geometry descriptions in the case of curved   boundaries (but this is not currently implemented).    
*  [2.x.631]  Since  [2.x.632]  and  [2.x.633]  have different spatial   dimensions no manifold objects are copied by this function: you must   attach new manifold objects to  [2.x.634]   
* [0.x.81]*
    [2.x.635]  Exceptions  
* [0.x.82]*
   Exception  
* [0.x.83]*
   Exception  
* [0.x.84]*
   Exception  
* [0.x.85]*
   Exception for input that is not properly oriented.  
* [0.x.86]