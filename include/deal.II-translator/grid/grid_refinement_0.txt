[0.x.0]*
 This namespace provides a collection of functions that aid in refinement and coarsening of triangulations. Despite the name of the namespace, the functions do not actually [1.x.0] the triangulation, but only [1.x.1]. In other words, they perform the "mark" part of the typical "solve-estimate-mark-refine" cycle of the adaptive finite element loop.
*  The functions in this namespace form two categories. There are the auxiliary functions refine() and coarsen(). More important for users are the other functions, which implement refinement strategies, as being found in the literature on adaptive finite element methods. For mathematical discussion of these methods, consider works by D&ouml;rfler, Morin, Nochetto, Rannacher, Stevenson, and others.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   Return a pair of double values of which the first is adjusted refinement   fraction of cells and the second is adjusted coarsening fraction of   cells.        [2.x.1]  current_n_cells The current cell number.      [2.x.2]  max_n_cells The maximal number of cells. If current cell   number  [2.x.3]  is already exceeded maximal cell number  [2.x.4]    max_n_cells, refinement fraction of cells will be set to zero and   coarsening fraction of cells will be adjusted to reduce cell number to @   max_n_cells. If cell number is going to be exceeded only upon refinement,   then refinement and coarsening fractions are going to be adjusted with a   same ratio in an attempt to reach the maximum number of cells. Be aware   though that through proliferation of refinement due to    [2.x.5]  this number is only an indicator. The   default value of this argument is to impose no limit on the number of   cells.      [2.x.6]  top_fraction_of_cells The requested fraction of active   cells to be refined.      [2.x.7]  bottom_fraction_of_cells The requested fraction of   active cells to be coarsened.    
*  [2.x.8]  Usually you do not need to call this function explicitly. Pass  [2.x.9]    max_n_cells to function refine_and_coarsen_fixed_number() or function   refine_and_coarsen_fixed_fraction() and they will call this function if   necessary.  
* [0.x.2]*
   This function provides a strategy to mark cells for refinement and   coarsening with the goal of providing predictable growth in   the size of the mesh by refining a given fraction of all cells.     The function takes a vector of refinement  [2.x.10]  and two values   between zero and one denoting the fractions of cells to be refined and   coarsened. It flags cells for further processing by    [2.x.11]  according to the   following greedy algorithm:      [2.x.12]       [2.x.13]  Sort the cells according to descending values of  [2.x.14]       [2.x.15]  Mark the  [2.x.16]  times    [2.x.17]  active cells with the largest   refinement criteria for refinement.      [2.x.18]  Mark the  [2.x.19]  times    [2.x.20]  active cells with the smallest   refinement criteria for coarsening.      [2.x.21]      As an example, with no coarsening, setting  [2.x.22]  to   1/3 will result in approximately doubling the number of cells in two   dimensions. That is because each of these 1/3 of cells will be replaced by   its four children, resulting in  [2.x.23]  cells, whereas the   remaining 2/3 of cells remains untouched
* 
*  -  thus yielding a total of    [2.x.24]  cells.   The same effect in three dimensions is achieved by refining   1/7th of the cells. These values are therefore frequently used because   they ensure that the cost of computations on subsequent meshes become   expensive sufficiently quickly that the fraction of time spent on   the coarse meshes is not too large. On the other hand, the fractions   are small enough that mesh adaptation does not refine too many cells   in each step.    
*  [2.x.25]  This function only sets the coarsening and refinement flags. The   mesh is not changed until you call    [2.x.26]       [2.x.27]  triangulation The triangulation whose cells this function   is supposed to mark for coarsening and refinement.      [2.x.28]  criteria The refinement criterion for each mesh cell. Entries   may not be negative.      [2.x.29]  top_fraction_of_cells The fraction of cells to be refined. If   this number is zero, no cells will be refined. If it equals one, the   result will be flagging for global refinement.      [2.x.30]  bottom_fraction_of_cells The fraction of cells to be   coarsened. If this number is zero, no cells will be coarsened.      [2.x.31]  max_n_cells This argument can be used to specify a maximal   number of cells. If this number is going to be exceeded upon refinement,   then refinement and coarsening fractions are going to be adjusted in an   attempt to reach the maximum number of cells. Be aware though that   through proliferation of refinement due to  [2.x.32]    this number is only an indicator. The default value of this argument is   to impose no limit on the number of cells.  
* [0.x.3]*
   This function provides a strategy to mark cells for refinement and   coarsening with the goal of controlling the reduction of   the error estimate.     Also known as the [1.x.2] or D&ouml;rfler marking,   this function computes the thresholds for refinement and coarsening   such that the  [2.x.33]  of cells getting flagged for refinement make   up for a certain fraction of the total error. We explain its operation   for refinement, coarsening works analogously.     Let [1.x.3] be the criterion of cell [1.x.4]. Then the   total error estimate is computed by the formula   [1.x.5]     If [1.x.6] is  [2.x.34]  then we refine the   smallest subset  [2.x.35]  of the Triangulation  [2.x.36]  such that   [1.x.7]     The algorithm is performed by the greedy algorithm described in   refine_and_coarsen_fixed_number().    
*  [2.x.37]  The often used formula with squares on the left and right is   recovered by actually storing the square of [1.x.8] in the   vector  [2.x.38]      From the point of view of implementation, this time we really need to   sort the array of criteria.  Just like the other strategy described   above, this function only computes the threshold values and then passes   over to refine() and coarsen().      [2.x.39]  tria The triangulation whose cells this function is   supposed to mark for coarsening and refinement.      [2.x.40]  criteria The refinement criterion computed on each mesh cell.   Entries may not be negative.      [2.x.41]  top_fraction The fraction of the total estimate which should   be refined. If this number is zero, no cells will be refined. If it   equals one, the result will be flagging for global refinement.      [2.x.42]  bottom_fraction The fraction of the estimate coarsened. If   this number is zero, no cells will be coarsened.      [2.x.43]  max_n_cells This argument can be used to specify a maximal   number of cells. If this number is going to be exceeded upon refinement,   then refinement and coarsening fractions are going to be adjusted in an   attempt to reach the maximum number of cells. Be aware though that   through proliferation of refinement due to  [2.x.44]    this number is only an indicator. The default value of this argument is   to impose no limit on the number of cells.      [2.x.45]  norm_type To determine thresholds, combined errors on   subsets of cells are calculated as norms of the criteria on these   cells. Different types of norms can be used for this purpose, from   which  [2.x.46]  and    [2.x.47]  are currently supported.  
* [0.x.4]*
   This function flags cells of a triangulation for refinement with the   aim to reach a grid that   is optimal with respect to an objective function that tries to balance   reducing the error and increasing the numerical cost when the mesh is   refined. Specifically, this function makes the assumption that if you   refine a cell  [2.x.48]  with error indicator  [2.x.49]  provided by the second   argument to this function, then the error on the children (for all   children together) will only be  [2.x.50]  where    [2.x.51]  is the third argument of this function. This makes the   assumption that the error is only a local property on a mesh and can be   reduced by local refinement
* 
*  -  an assumption that is true for the   interpolation operator, but not for the usual Galerkin projection,   although it is approximately true for elliptic problems where the Greens   function decays quickly and the error here is not too much affected by a   too coarse mesh somewhere else.     With this, we can define the objective function this function tries to   optimize. Let us assume that the mesh currently has  [2.x.52]  cells. Then, if   we refine the  [2.x.53]  cells with the largest errors, we expect to get (in  [2.x.54]    space dimensions)   [1.x.9]   cells ( [2.x.55]  are not refined, and each of the  [2.x.56]  cells we refine yield    [2.x.57]  child cells. On the other hand, with refining  [2.x.58]  cells, and using   the assumptions above, we expect that the error will be   [1.x.10]   where the first sum extends over  [2.x.59]  cells and the second over the    [2.x.60]  cells that will be refined. Note that  [2.x.61]  is an increasing   function of  [2.x.62]  whereas  [2.x.63]  is a decreasing function.     This function then tries to find that number  [2.x.64]  of cells to mark for   refinement for which the objective function   [1.x.11]   is minimal.     The rationale for this function is two-fold. First, compared to the   refine_and_coarsen_fixed_fraction() and refine_and_coarsen_fixed_number()   functions, this function has the property that if all refinement   indicators are the same (i.e., we have achieved a mesh where the error   per cell is equilibrated), then the entire mesh is refined. This is based   on the observation that a mesh with equilibrated error indicators is the   optimal mesh (i.e., has the least overall error) among all meshes with   the same number of cells. (For proofs of this, see R. Becker, M. Braack,   R. Rannacher: "Numerical simulation of laminar flames at low Mach number   with adaptive finite elements", Combustion Theory and Modelling, Vol. 3,   Nr. 3, p. 503-534 1999; and W. Bangerth, R. Rannacher: "Adaptive Finite   Element Methods for Differential Equations", Birkhauser, 2003.)     Second, the function uses the observation that ideally, the error behaves   like  [2.x.65]  with some constant  [2.x.66]  that depends   on the dimension and the finite element degree. It should
* 
*  - given optimal   mesh refinement
* 
*  - not depend so much on the regularity of the solution,   as it is based on the idea, that all singularities can be resolved by   refinement. Mesh refinement is then based on the idea that we want to   make  [2.x.67]  small. This corresponds to the functional  [2.x.68]    above.    
*  [2.x.69]  This function was originally implemented by Thomas Richter. It   follows a strategy described in T. Richter, "Parallel Multigrid Method   for Adaptive Finite Elements with Application to 3D Flow Problems", PhD   thesis, University of Heidelberg, 2005. See in particular Section 4.3,   pp. 42-43.  
* [0.x.5]*
   Mark all mesh cells for which the value in  [2.x.70]  exceeds  [2.x.71]    threshold for refinement, but only flag up to  [2.x.72]  cells.     The vector  [2.x.73]  contains a nonnegative value for each active cell,   ordered in the canonical order of  [2.x.74]      The cells are only flagged for refinement, they are not actually refined.   To do so, you have to call    [2.x.75]      This function does not implement a refinement strategy, it is more a   helper function for the actual strategies.  
* [0.x.6]*
   Mark all mesh cells for which the value in  [2.x.76]  is less than  [2.x.77]    threshold for coarsening.     The vector  [2.x.78]  contains a nonnegative value for each active cell,   ordered in the canonical order of  [2.x.79]      The cells are only flagged for coarsening, they are not actually   coarsened. To do so, you have to call    [2.x.80]      This function does not implement a refinement strategy, it is more a   helper function for the actual strategies.  
* [0.x.7]*
   An exception thrown if the vector with cell criteria contains negative   values  
* [0.x.8]*
   One of the threshold parameters causes trouble. Or the refinement and   coarsening thresholds overlap.  
* [0.x.9]