[0.x.0]*
 This namespace provides functions that assemble certain standard matrices for a given triangulation, using a given finite element, a given mapping and a quadrature formula.
* 

*  [1.x.0]
*  There exist two versions of almost all functions, one that takes an explicit Mapping argument and one that does not. The second one generally calls the first with an implicit  [2.x.0]  argument (i.e., with an argument of kind MappingQGeneric(1)). If your intend your code to use a different mapping than a (bi-/tri-)linear one, then you need to call the functions [1.x.1] mapping argument should be used.
*  All functions take a sparse matrix object to hold the matrix to be created. The functions assume that the matrix is initialized with a sparsity pattern (SparsityPattern) corresponding to the given degree of freedom handler, i.e. the sparsity structure is already as needed. You can do this by calling the  [2.x.1]  function.
*  Furthermore it is assumed that no relevant data is in the matrix. Some entries will be overwritten and some others will contain invalid data if the matrix wasn't empty before. Therefore you may want to clear the matrix before assemblage.
*  By default, all created matrices are `raw': they are not condensed, i.e. hanging nodes are not eliminated. The reason is that you may want to add several matrices and could then condense afterwards only once, instead of for every matrix. To actually do computations with these matrices, you have to condense the matrix using the  [2.x.2]  function; you also have to condense the right hand side accordingly and distribute the solution afterwards. Alternatively, you can give an optional argument AffineConstraints that writes cell matrix (and vector) entries with distribute_local_to_global into the global matrix and vector. This way, adding several matrices from different sources is more complicated and you should make sure that you do not mix different ways of applying constraints. Particular caution is necessary when the given AffineConstraints object contains inhomogeneous constraints: In that case, the matrix assembled this way must be the only matrix (or you need to assemble the [1.x.2] right hand side for [1.x.3] matrix you generate and add together).
*  If you want to use boundary conditions with the matrices generated by the functions of this namespace in addition to the ones in a possible AffineConstraints object, you have to use a function like <tt>apply_boundary_values</tt> with the matrix, solution, and right hand side.
* 

*  [1.x.4]
*  At present there are functions to create the following matrices:  [2.x.3]   [2.x.4]   [2.x.5]  create the matrix with entries  [2.x.6]  by numerical quadrature. Here, the  [2.x.7]  are the basis functions of the finite element space given.
*  A coefficient may be given to evaluate  [2.x.8]  instead.
*   [2.x.9]   [2.x.10]  create the matrix with entries  [2.x.11]  by numerical quadrature.
*  Again, a coefficient may be given to evaluate  [2.x.12]  instead.  [2.x.13] 
*  Make sure that the order of the Quadrature formula given to these functions is sufficiently high to compute the matrices with the required accuracy. For the choice of this quadrature rule you need to take into account the polynomial degree of the FiniteElement basis functions, the roughness of the coefficient  [2.x.14]  as well as the degree of the given  [2.x.15]  (if any).
*  Note, that for vector-valued elements the mass matrix and the laplace matrix is implemented in such a way that each component couples only with itself, i.e. there is no coupling of shape functions belonging to different components. If the degrees of freedom have been sorted according to their vector component (e.g., using  [2.x.16]  then the resulting matrices will be block diagonal.
*  If the finite element for which the mass matrix or the Laplace matrix is to be built has more than one component, the functions accept a single coefficient as well as a vector valued coefficient function. For the latter case, the number of components must coincide with the number of components of the system finite element.
* 

*  [1.x.5]
*  The create_boundary_mass_matrix() creates the matrix with entries  [2.x.17] , where  [2.x.18]  is the union of boundary parts with indicators contained in a  [2.x.19]  const Function<spacedim,number>*> passed to the function (i.e. if you want to set up the mass matrix for the parts of the boundary with indicators zero and 2, you pass the function a map with key type  [2.x.20]  as the parameter  [2.x.21]  containing the keys zero and 2). The size of the matrix is equal to the number of degrees of freedom that have support on the boundary, i.e. it is  [2.x.22] not [2.x.23]  a matrix on all degrees of freedom, but only a subset. (The  [2.x.24]  in the formula are the subset of basis functions which have at least part of their support on  [2.x.25] .) In order to determine which shape functions are to be considered, and in order to determine in which order, the function takes a  [2.x.26]  this object maps global DoF numbers to a numbering of the degrees of freedom located on the boundary, and can be obtained using the function  [2.x.27] 
*  In order to work, the function needs a matrix of the correct size, built on top of a corresponding sparsity pattern. Since we only work on a subset of the degrees of freedom, we can't use the matrices and sparsity patterns that are created for the entire set of degrees of freedom. Rather, you should use the  [2.x.28]  function to create the correct sparsity pattern, and build a matrix on top of it.
*  Note that at present there is no function that computes the mass matrix for  [2.x.29] all [2.x.30]  shape functions, though such a function would be trivial to implement.
* 

*  [1.x.6]
*  In many cases, you will not only want to build the matrix, but also a right hand side, which will give a vector with  [2.x.31] . For this purpose, each function exists in two versions, one only building the matrix and one also building the right hand side vector. If you want to create a right hand side vector without creating a matrix, you can use the  [2.x.32]  function. The use of the latter may be useful if you want to create many right hand side vectors.
* 

* 
*  [2.x.33] 

* 
* [0.x.1]*
   Assemble the mass matrix. If no coefficient is given (i.e., if the   pointer to a function object is zero as it is by default), the   coefficient is taken as being constant and equal to one.   In case you want to specify  [2.x.34]  and use the default argument   for the coefficient you have to specify the (unused) coefficient argument   as  [2.x.35] .     If the library is configured to use multithreading, this function works   in parallel.     The optional argument  [2.x.36]  allows to apply constraints on the   resulting matrix directly. Note, however, that this becomes difficult   when you have inhomogeneous constraints and later want to add several   such matrices, for example in time dependent settings such as the main   loop of  [2.x.37] .     See the general documentation of this namespace for more information.  
* [0.x.2]*
   Call the create_mass_matrix() function, see above, with   <tt>mapping=MappingQGeneric [2.x.38]   
* [0.x.3]*
   Assemble the mass matrix and a right hand side vector. If no coefficient   is given (i.e., if the pointer to a function object is zero as it is by   default), the coefficient is taken as being constant and equal to one.   In case you want to specify  [2.x.39]  and use the default argument   for the coefficient you have to specify the (unused) coefficient argument   as  [2.x.40] .     If the library is configured to use multithreading, this function works   in parallel.     The optional argument  [2.x.41]  allows to apply constraints on the   resulting matrix directly. Note, however, that this becomes difficult   when you have inhomogeneous constraints and later want to add several   such matrices, for example in time dependent settings such as the main   loop of  [2.x.42] .     See the general documentation of this namespace for more information.  
* [0.x.4]*
   Call the create_mass_matrix() function, see above, with   <tt>mapping=MappingQGeneric [2.x.43]   
* [0.x.5]*
   Same function as above, but for hp-objects.  
* [0.x.6]*
   Same function as above, but for hp-objects.  
* [0.x.7]*
   Same function as above, but for hp-objects.  
* [0.x.8]*
   Same function as above, but for hp-objects.  
* [0.x.9]*
   Assemble the mass matrix and a right hand side vector along the boundary.     The matrix is assumed to already be initialized with a suiting sparsity   pattern (the DoFHandler provides an appropriate function).     If the library is configured to use multithreading, this function works   in parallel.      [2.x.44]   [2.x.45]  an optional weight for the computation of the mass   matrix. If no weight is given, it is set to one.   In case you want to specify  [2.x.46]  and use the default argument   for the coefficient you have to specify the (unused) coefficient argument   as  [2.x.47] .      [2.x.48]   [2.x.49]  if the components in  [2.x.50]  and    [2.x.51]  do not coincide, this vector allows them to be remapped. If the   vector is not empty, it has to have one entry for each component in  [2.x.52]    dof. This entry is the component number in  [2.x.53]  that   should be used for this component in  [2.x.54]  By default, no remapping is   applied.      [2.x.55]  This function does not work for finite elements with cell-dependent   shape functions.  
* [0.x.10]*
   Call the create_boundary_mass_matrix() function, see above, with   <tt>mapping=MappingQGeneric [2.x.56]   
* [0.x.11]*
   Same function as above, but for hp-objects.  
* [0.x.12]*
   Same function as above, but for hp-objects.  
* [0.x.13]*
   Assemble the Laplace matrix. If no coefficient is given (i.e., if the   pointer to a function object is zero as it is by default), the   coefficient is taken as being constant and equal to one.   In case you want to specify  [2.x.57]  and use the default argument   for the coefficient you have to specify the (unused) coefficient argument   as  [2.x.58] .     If the library is configured to use multithreading, this function works   in parallel.     The optional argument  [2.x.59]  allows to apply constraints on the   resulting matrix directly. Note, however, that this becomes difficult   when you have inhomogeneous constraints and later want to add several   such matrices, for example in time dependent settings such as the main   loop of  [2.x.60] .     See the general documentation of this namespace for more information.  
* [0.x.14]*
   Call the create_laplace_matrix() function, see above, with   <tt>mapping=MappingQGeneric [2.x.61]   
* [0.x.15]*
   Assemble the Laplace matrix and a right hand side vector. If no   coefficient is given, it is assumed to be constant one.   In case you want to specify  [2.x.62]  and use the default argument   for the coefficient you have to specify the (unused) coefficient argument   as  [2.x.63] .     If the library is configured to use multithreading, this function works   in parallel.     The optional argument  [2.x.64]  allows to apply constraints on the   resulting matrix directly. Note, however, that this becomes difficult   when you have inhomogeneous constraints and later want to add several   such matrices, for example in time dependent settings such as the main   loop of  [2.x.65] .     See the general documentation of this namespace for more information.  
* [0.x.16]*
   Call the create_laplace_matrix() function, see above, with   <tt>mapping=MappingQGeneric [2.x.66]   
* [0.x.17]*
   Like the functions above, but for hp-objects.  
* [0.x.18]*
   Like the functions above, but for hp-objects.  
* [0.x.19]*
   Like the functions above, but for hp-objects.  
* [0.x.20]*
   Like the functions above, but for hp-objects.  
* [0.x.21]*
   Exception  
* [0.x.22]*
 Provide a collection of functions operating on matrices. These include the application of boundary conditions to a linear system of equations and others.
* 

*  [1.x.7]
*  The apply_boundary_values() functions modifies a linear system to incorporate the constraints that result from Dirichlet-type boundary conditions (or, more specifically: "strong" boundary conditions). To actually do this, the functions of this name in the current namespace require a list of degree of freedom indices along with the values these degrees of freedom should have. To see how to get such a list, see the discussion of the  [2.x.67]  function as one example.
*  There are two ways to incorporate fixed degrees of freedom such as boundary nodes into a linear system, as discussed below. Both operate at either the level of local contributions to the global linear system, or the global system itself. A third way, using  [2.x.68]  performs the same process as part of adding the local contributions of one cell into the global linear system (the "assembly" step) and is the method predominantly used in the tutorial programs today.
*   [2.x.69] 
* 

* 
*  [1.x.8]
*  In the first method, we first assemble the global linear system without respect for fixed degrees of freedom, and in a second step eliminate them again from the linear system. The inclusion into the assembly process is as follows: when the matrix and vectors are set up, a list of nodes subject to Dirichlet boundary conditions is made and matrix and vectors are modified accordingly. This is done by deleting all entries in the matrix in the line of this degree of freedom, setting the main diagonal entry to a suitable positive value and the right hand side element to a value so that the solution of the linear system will have the boundary value at this node. To decouple the remaining linear system of equations and to make the system symmetric again (at least if it was before), one Gauss elimination step is performed with this line, by adding this (now almost empty) line to all other lines which couple with the given degree of freedom and thus eliminating all coupling between this degree of freedom and others. Now the respective column also consists only of zeroes, apart from the main diagonal entry. Alternatively, the functions in this namespace take a boolean parameter that allows to omit this last step, if symmetry of the resulting linear system is not required. Note that usually even CG can cope with a non-symmetric linear system with this particular structure.
*  Finding which rows contain an entry in the column for which we are presently performing a Gauss elimination step is either difficult or very simple, depending on the circumstances. If the sparsity pattern is symmetric (whether the matrix is symmetric is irrelevant here), then we can infer the rows which have a nonzero entry in the present column by looking at which columns in the present row are nonempty. In this case, we only need to look into a fixed number of rows and need not search all rows. On the other hand, if the sparsity pattern is nonsymmetric, then we need to use an iterative solver which can handle nonsymmetric matrices in any case, so there may be no need to do the Gauss elimination anyway. In fact, this is the way the function works: it takes a parameter ( [2.x.70]  that specifies whether the sparsity pattern is symmetric; if so, then the column is eliminated and the right hand side is also modified accordingly. If not, then only the row is deleted and the column is not touched at all, and all right hand side values apart from the one corresponding to the present row remain unchanged.
*  If the sparsity pattern for your matrix is non-symmetric, you must set the value of this parameter to  [2.x.71]  in any case, since then we can't eliminate the column without searching all rows, which would be too expensive (if  [2.x.72]  be the number of rows, and  [2.x.73]  the number of nonzero elements per row, then eliminating one column is an <tt>O(N*log(m))</tt> operation, since searching in each row takes <tt>log(m)</tt> operations). If your sparsity pattern is symmetric, but your matrix is not, then you might specify  [2.x.74]  as well. If your sparsity pattern and matrix are both symmetric, you might want to specify  [2.x.75]  (the complexity of eliminating one row is then <tt>O(m*log(m))</tt>, since we only have to search  [2.x.76]  rows for the respective element of the column). Given the fact that  [2.x.77]  is roughly constant, irrespective of the discretization, and that the number of boundary nodes is <tt>sqrt(N)</tt> in 2d, the algorithm for symmetric sparsity patterns is <tt>O(sqrt(N)*m*log(m))</tt>, while it would be <tt>O(N*sqrt(N)*log(m))</tt> for the general case; the latter is too expensive to be performed.
*  It seems as if we had to make clear not to overwrite the lines of other boundary nodes when doing the Gauss elimination step. However, since we reset the right hand side when passing such a node, it is not a problem to change the right hand side values of other boundary nodes not yet processed. It would be a problem to change those entries of nodes already processed, but since the matrix entry of the present column on the row of an already processed node is zero, the Gauss step does not change the right hand side. We need therefore not take special care of other boundary nodes.
*  To make solving faster, we preset the solution vector with the right boundary values (as to why this is necessary, see the discussion below in the description of local elimination). It it not clear whether the deletion of coupling between the boundary degree of freedom and other dofs really forces the corresponding entry in the solution vector to have the right value when using iterative solvers, since their search directions may contain components in the direction of the boundary node. For this reason, we perform a very simple line balancing by not setting the main diagonal entry to unity, but rather to the value it had before deleting this line, or to the first nonzero main diagonal entry if it is zero for some reason. Of course we have to change the right hand side appropriately. This is not a very good strategy, but it at least should give the main diagonal entry a value in the right order of dimension, which makes the solution process a bit more stable. A refined algorithm would set the entry to the mean of the other diagonal entries, but this seems to be too expensive.
*  In some cases, it might be interesting to solve several times with the same matrix, but for different right hand sides or boundary values. A typical case would be the solution of a time-dependent problem in which the boundary values or right hand side change, but the matrix itself does not. One may then be tempted to just assemble the matrix once and just call the  [2.x.78]  function repeatedly on the same matrix object, with a right hand side vector newly formed in each time step. However, since the modification for boundary values of the right hand side vector depends on the original matrix, this is not possible without storing the original matrix somewhere, and in every time step initializing the system matrix with the unmodified matrix stored elsewhere.  [2.x.79]  does a variation of this process by storing building blocks from which the system matrix is composed, but the general principle is the same. Alternatively, one can use the constrained_linear_operator() function. In its documentation you can also find a formal (mathematical) description of the process of modifying the matrix and right hand side vectors for boundary values.
* 

*  [1.x.9]
*  The second way of handling boundary values is to modify the local matrix and vector contributions appropriately before transferring them into the global sparse matrix and vector. This is what local_apply_boundary_values() does. The advantage is that we save the call to the apply_boundary_values function (which is expensive because it has to work on sparse data structures). On the other hand, the local_apply_boundary_values() function is called many times, even if we only have a very small number of fixed boundary nodes, and the main drawback is that this function doesn't work as expected if there are hanging nodes that also need to be treated. The reason that this function doesn't work is that it is meant to be run before distribution into the global matrix, i.e. before hanging nodes are distributed; since hanging nodes can be constrained to a boundary node, the treatment of hanging nodes can add entries again to rows and columns corresponding to boundary values and that we have already vacated in the local elimination step. To make things worse, in 3d constrained nodes can even lie on the boundary. Thus, it is imperative that boundary node elimination happens  [2.x.80]  after hanging node elimination, but this can't be achieved with local elimination of boundary nodes unless there are no hanging node constraints at all.
*  Local elimination has one additional drawback: we don't have access to the solution vector, only to the local contributions to the matrix and right hand side. The problem with this is subtle, but can lead to very hard to find difficulties: when we eliminate a degree of freedom, we delete the row and column of this unknown, and set the diagonal entry to some positive value. To make the problem more or less well-conditioned, we set this diagonal entry to the absolute value of its prior value if that was non- zero, or to the average magnitude of all other nonzero diagonal elements. Then we set the right hand side value such that the resulting solution entry has the right value as given by the boundary values. Since we add these contributions up over all local contributions, the diagonal entry and the respective value in the right hand side are added up correspondingly, so that the entry in the solution of the linear system is still valid.
*  A problem arises, however, if the diagonal entries so chosen are not appropriate for the linear system. Consider, for example, a mixed Laplace problem with matrix <tt>[[A B][C^T 0]]</tt>, where we only specify boundary values for the second component of the solution. In the mixed formulation, the stress-strain tensor only appears in either the matrix  [2.x.81]  or  [2.x.82]  so one of them may be significantly larger or smaller than the other one. Now, if we eliminate boundary values, we delete some rows and columns, but we also introduce a few entries on the diagonal of the lower right block, so that we get the system <tt>[[A' B'][C'^T X]]</tt>. The diagonal entries in the matrix  [2.x.83]  will be of the same order of magnitude as those in  [2.x.84]  Now, if we solve this system in the Schur complement formulation, we have to invert the matrix <tt>X-C'^TA'^{-1}B'</tt>. Deleting rows and columns above makes sure that boundary nodes indeed have empty rows and columns in the Schur complement as well, except for the entries in  [2.x.85]  However, the entries in  [2.x.86]  may be of significantly different orders of magnitude than those in <tt>C'^TA'^{-1}B'</tt>! If this is the case, we may run into trouble with iterative solvers. For example, assume that we start with zero entries in the solution vector and that the entries in  [2.x.87]  are several orders of magnitude too small; in this case, iterative solvers will compute the residual vector in each step and form correction vectors, but since the entries in  [2.x.88]  are so small, the residual contributions for boundary nodes are really small, despite the fact that the boundary nodes are still at values close to zero and not in accordance with the prescribed boundary values. Since the residual is so small, the corrections the iterative solver computes are very small, and in the end the solver will indicate convergence to a small total residual with the boundary values still being significantly wrong.
*  We avoid this problem in the global elimination process described above by 'priming' the solution vector with the correct values for boundary nodes. However, we can't do this for the local elimination process. Therefore, if you experience a problem like the one above, you need to either increase the diagonal entries in  [2.x.89]  to a size that matches those in the other part of the Schur complement, or, simpler, prime the solution vector before you start the solver.
*  In conclusion, local elimination of boundary nodes only works if there are no hanging nodes and even then doesn't always work fully satisfactorily.
* 

* 
*  [2.x.90] 

* 
* [0.x.23]*
   Import namespace MatrixCreator for backward compatibility with older   versions of deal.II in which these namespaces were classes and class   MatrixTools was publicly derived from class MatrixCreator.  
* [0.x.24]*
   Apply Dirichlet boundary conditions to the system matrix and vectors as   described in the general documentation of this namespace.  
* [0.x.25]*
   Apply Dirichlet boundary conditions to the system matrix and vectors as   described in the general documentation of this namespace. This function   works for block sparse matrices and block vectors.  
* [0.x.26]*
   Apply Dirichlet boundary conditions to the system matrix and vectors as   described in the general documentation of this namespace. This function   works on the classes that are used to wrap PETSc objects.     [1.x.10] This function is not very efficient: it needs to   alternatingly read and write into the matrix, a situation that PETSc does   not handle well. In addition, we only get rid of rows corresponding to   boundary nodes, but the corresponding case of deleting the respective   columns (i.e. if  [2.x.91]  is  [2.x.92]  is not presently   implemented, and probably will never because it is too expensive without   direct access to the PETSc data structures. (This leads to the situation   where the action indicated by the default value of the last argument is   actually not implemented; that argument has  [2.x.93]  as its   default value to stay consistent with the other functions of same name in   this namespace.)     This function is used in  [2.x.94]  and  [2.x.95] .    
*  [2.x.96]  If the matrix is stored in parallel across multiple processors   using MPI, this function only touches rows that are locally stored and   simply ignores all other rows. In other words, each processor is   responsible for its own rows, and the  [2.x.97]  argument needs   to contain all locally owned rows of the matrix that you want to have   treated. (But it can also contain entries for degrees of freedom not   owned locally; these will simply be ignored.) Further, in the context of   parallel computations, you will get into trouble if you treat a row while   other processors still have pending writes or additions into the same   row. In other words, if another processor still wants to add something to   an element of a row and you call this function to zero out the row, then   the next time you call compress() may add the remote value to the zero   you just created. Consequently, you will want to call compress() after   you made the last modifications to a matrix and before starting to clear   rows.  
* [0.x.27]*
   Same as above but for the parallel BlockSparseMatrix.  
* [0.x.28]*
   Apply Dirichlet boundary conditions to the system matrix and vectors as   described in the general documentation of this namespace. This function   works on the classes that are used to wrap Trilinos objects.     [1.x.11] This function is not very efficient: it needs to   alternatingly read and write into the matrix, a situation that Trilinos   does not handle well. In addition, we only get rid of rows corresponding   to boundary nodes, but the corresponding case of deleting the respective   columns (i.e. if  [2.x.98]  is  [2.x.99]  is not presently   implemented, and probably will never because it is too expensive without   direct access to the Trilinos data structures. (This leads to the   situation where the action indicated by the default value of the last   argument is actually not implemented; that argument has  [2.x.100]    as its default value to stay consistent with the other functions of same   name in this namespace.)    
*  [2.x.101]  If the matrix is stored in parallel across multiple processors   using MPI, this function only touches rows that are locally stored and   simply ignores all other rows. In other words, each processor is   responsible for its own rows, and the  [2.x.102]  argument needs   to contain all locally owned rows of the matrix that you want to have   treated. (But it can also contain entries for degrees of freedom not   owned locally; these will simply be ignored.) Further, in the context of   parallel computations, you will get into trouble if you treat a row while   other processors still have pending writes or additions into the same   row. In other words, if another processor still wants to add something to   an element of a row and you call this function to zero out the row, then   the next time you call compress() may add the remote value to the zero   you just created. Consequently, you will want to call compress() after   you made the last modifications to a matrix and before starting to clear   rows.  
* [0.x.29]*
   This function does the same as the one above, except now working on block   structures.  
* [0.x.30]*
   Rather than applying boundary values to the global matrix and vector   after creating the global matrix, this function does so during assembly,   by modifying the local matrix and vector contributions. If you call this   function on all local contributions, the resulting matrix will have the   same entries, and the final call to apply_boundary_values() on the global   system will not be necessary.     Since this function does not have to work on the complicated data   structures of sparse matrices, it is relatively cheap. It may therefore   be a win if you have many fixed degrees of freedom (e.g. boundary nodes),   or if access to the sparse matrix is expensive (e.g. for block sparse   matrices, or for PETSc or Trilinos matrices). However, it doesn't work as   expected if there are also hanging nodes to be considered. More caveats   are listed in the general documentation of this namespace.      [2.x.103]   
* [0.x.31]*
   Exception  
* [0.x.32]