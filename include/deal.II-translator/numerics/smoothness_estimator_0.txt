[0.x.0]*
 A namespace for various smoothness estimation strategies for hp-adaptive FEM.
*  Smoothness estimation is one strategy to decide whether a cell with a large error estimate should undergo h- or p-refinement. Typical strategies decide to increase the polynomial degree on a cell if the solution is particularly smooth, whereas one would refine the mesh if the solution on the cell is singular, has kinks in some derivative, or is otherwise not particularly smooth. All of these strategies rely on a way to identify how "smooth" a function is on a given cell.

* 
* [0.x.1]*
   Smoothness estimation strategy based on the decay of Legendre expansion   coefficients.     In one dimension, the finite element solution on cell  [2.x.0]  with polynomial   degree  [2.x.1]  can be written as   [1.x.0]
*    where  [2.x.2]  are degrees of freedom and  [2.x.3]  are the corresponding   shape functions.  [2.x.4]  are Legendre polynomials on cell    [2.x.5] .  [2.x.6]  and  [2.x.7]  are coefficients and transformation   matrices from the Legendre expansion of each shape function. For practical   reasons, we will perform the calculation of these matrices and coefficients   only on the reference cell  [2.x.8] . We only have to calculate the   transformation matrices once this way. However, results are only applicable   if the mapping from the reference cell to the actual cell is affine. We use   the class  [2.x.9]  to determine all coefficients  [2.x.10] .     A function is analytic, i.e., representable by a power series, if and only   if their Legendre expansion coefficients decay as (see  [2.x.11] )   [1.x.1]   We determine their decay rate  [2.x.12]  by performing the linear regression   fit of   [1.x.2]   for  [2.x.13] , with  [2.x.14]  the polynomial degree of the finite element.   The rate of the decay  [2.x.15]  can be used to estimate the smoothness. For   example, one strategy to implement hp-refinement criteria is to perform   p-refinement if  [2.x.16]  (see  [2.x.17] ).  
* [0.x.2]*
     In this variant of the estimation strategy for higher dimensions, we will     consider all mode vectors  [2.x.18]  describing Legendre polynomials      [2.x.19]  and perform one least-squares fit over all     coefficients at once. If there are multiple coefficients corresponding to     the same absolute value of modes  [2.x.20] , we take the maximum     among those. Thus, the least-squares fit is performed on     [1.x.3]
*      for  [2.x.21]  and  [2.x.22] , with  [2.x.23]  the     polynomial degree of the finite element.         For a finite element approximation  [2.x.24]  this function writes the     decay rate for every cell into the output vector  [2.x.25]           [2.x.26]  [in] fe_legendre  [2.x.27]  object to calculate coefficients.     This object needs to be initialized to have at least  [2.x.28]  coefficients     in each direction for every finite element in the collection, where  [2.x.29]      is its polynomial degree.      [2.x.30]  [in] dof_handler A DoFHandler.      [2.x.31]  [in] solution A solution vector.      [2.x.32]  [out] smoothness_indicators A vector for smoothness indicators.      [2.x.33]  [in] regression_strategy Determines which norm will be used on the     subset of coefficients  [2.x.34]  with the same absolute value      [2.x.35] . Default is  [2.x.36]  for a maximum     approximation.      [2.x.37]  [in] smallest_abs_coefficient The smallest absolute value of the     coefficient to be used in linear regression. Note that Legendre     coefficients of some functions may have a repeating pattern of zero     coefficients (i.e. for functions that are locally symmetric or     antisymmetric about the midpoint of the element in any coordinate     direction). Thus this parameters allows to ignore small (in absolute     value) coefficients within the linear regression fit. In case there are     less than two nonzero coefficients, the returned value for this cell will     be  [2.x.38] .      [2.x.39]  [in] only_flagged_cells Smoothness indicators are usually used to     decide whether to perform h- or p-adaptation. So in most cases, we only     need to calculate those indicators on cells flagged for refinement or     coarsening. This parameter controls whether this particular subset or all     cells will be considered. By default, all cells will be considered. When     only flagged cells are supposed to be considered, smoothness indicators     will only be set on those vector entries of flagged cells; the others     will be set to a signaling NaN.         For more theoretical details see  [2.x.40]       [2.x.41]   [2.x.42] .    
* [0.x.3]*
     In this variant of the estimation strategy for higher dimensions, we only     consider modes in each coordinate direction, i.e., only mode vectors      [2.x.43]  with one nonzero entry. We perform the least-squares fit in     each coordinate direction separately and take the lowest decay rate      [2.x.44]  among them.         For a finite element approximation  [2.x.45]  this function writes the     decay rate for every cell into the output vector  [2.x.46]           [2.x.47]  [in] fe_legendre  [2.x.48]  object to calculate coefficients.     This object needs to be initialized to have at least  [2.x.49]  coefficients     in each direction, where  [2.x.50]  is the maximum polynomial degree to be used.      [2.x.51]  [in] dof_handler A DoFHandler      [2.x.52]  [in] solution A solution vector      [2.x.53]  [out] smoothness_indicators A vector for smoothness indicators      [2.x.54]  [in] coefficients_predicate A predicate to select Legendre     coefficients  [2.x.55] ,  [2.x.56]  for linear regression in each     coordinate direction. The user is responsible for updating the vector of     `flags` provided to this function. Note that its size is  [2.x.57] , where  [2.x.58]      is the polynomial degree of the FE basis on a given element. The default     implementation will use all Legendre coefficients in each coordinate     direction, i.e. set all elements of the vector to `true`.      [2.x.59]  [in] smallest_abs_coefficient The smallest absolute value of the     coefficient to be used in linear regression in each coordinate direction.     Note that Legendre coefficients of some functions may have a repeating     pattern of zero coefficients (i.e. for functions that are locally     symmetric or antisymmetric about the midpoint of the element in any     coordinate direction). Thus this parameters allows to ignore small (in     absolute value) coefficients within the linear regression fit. In case     there are less than two nonzero coefficients for a coordinate direction,     this direction will be skipped. If all coefficients are zero, the     returned value for this cell will be  [2.x.60] .      [2.x.61]  [in] only_flagged_cells Smoothness indicators are usually used to     decide whether to perform h- or p-adaptation. So in most cases, we only     need to calculate those indicators on cells flagged for refinement or     coarsening. This parameter controls whether this particular subset or all     cells will be considered. By default, all cells will be considered. When     only flagged cells are supposed to be considered, smoothness indicators     will only be set on those vector entries of flagged cells; the others     will be set to NaN.         For more theoretical details and the application within the deal.II     library see  [2.x.62] .    
* [0.x.4]*
     Returns a  [2.x.63]  object for Legendre series expansions with     the default configuration for smoothness estimation purposes.         For each finite element of the provided  [2.x.64]  we use as many     modes as its polynomial degree plus two. This includes the first Legendre     polynomial which is just a constant. Further for each element, we use a     Gaussian quadrature designed to yield exact results for the highest order     Legendre polynomial used.         As the Legendre expansion can only be performed on scalar fields, this     class does not operate on vector-valued finite elements and will     therefore throw an assertion. However, each component of a finite element     field can be treated as a scalar field, respectively, on which Legendre     expansions are again possible. For this purpose, the optional parameter      [2.x.65]  defines which component of each FiniteElement will be used.     The default value of  [2.x.66]  only applies to scalar FEs, in which     case it indicates that the sole component is to be decomposed. For     vector-valued FEs, a non-default value must be explicitly provided.    
* [0.x.5]*
   Smoothness estimation strategy based on the decay of Fourier expansion   coefficients.     From the definition, we can write our Fourier series expansion    [2.x.67]  of the finite element solution on cell  [2.x.68]  with polynomial   degree  [2.x.69]  as a matrix product   [1.x.4]
*    with  [2.x.70]  the degrees of freedom and  [2.x.71]  the corresponding shape   functions.  [2.x.72]  are exponential functions on cell  [2.x.73] .  [2.x.74]  and  [2.x.75]  are coefficients and transformation matrices from the   Fourier expansion of each shape function. For practical reasons, we will   perform the calculation of these matrices and coefficients only on the   reference cell  [2.x.76] . We only have to calculate the transformation   matrices once this way. However, results are only applicable if mapping   from the reference cell to the actual cell is linear. We use the class    [2.x.77]  to determine all coefficients  [2.x.78] .     If the finite element approximation on cell  [2.x.79]  is part of the Hilbert   space  [2.x.80] , then the following integral must exist for both the finite   element and spectral representation of our solution   [1.x.5]
*    The sum is finite only if the summands decay at least with order   [1.x.6]   for all  [2.x.81] . The additional factor stems from the fact that,   since we sum over all multi-indices  [2.x.82]  that are located on a   dim-dimensional sphere, we actually have, up to a constant,    [2.x.83]  modes located in each increment  [2.x.84]  that need to be taken into account. By a comparison of   exponents, we can rewrite this condition as   [1.x.7]     The next step is to estimate how fast these coefficients   decay with  [2.x.85] . Thus, we perform a least-squares fit   [1.x.8]   with regression coefficients  [2.x.86]  and  [2.x.87] . For simplification, we   apply a logarithm on our minimization problem   [1.x.9]   where  [2.x.88] . This is now a problem for which the optimality   conditions  [2.x.89] , are linear in  [2.x.90] . We can   write these conditions as follows:   [1.x.10]   Solving for  [2.x.91]  and  [2.x.92]  is just a linear regression fit and to do   that we will use  [2.x.93]      While we are not particularly interested in the actual value of    [2.x.94] , the formula above gives us a means to calculate the value of   the exponent  [2.x.95]  that we can then use to determine that    [2.x.96]  is in  [2.x.97]  with  [2.x.98] . The   decay rates  [2.x.99]  will suffice as our smoothness indicators and   will be calculated on each cell for any provided solution.    
*  [2.x.100]  An extensive demonstration of the use of these functions is   provided in  [2.x.101] .  
* [0.x.6]*
     In this variant of the estimation strategy for higher dimensions, we will     consider all mode vectors  [2.x.102]  describing Fourier polynomials      [2.x.103]  and perform one least-squares fit over all coefficients     at once. If there are multiple coefficients corresponding to the same     absolute value of modes  [2.x.104] , we take the maximum among those.     Thus, the least-squares fit is performed on     [1.x.11]     for  [2.x.105]  and  [2.x.106] , with  [2.x.107]  the     polynomial degree of the finite element. We exclude the  [2.x.108]      modes to avoid the singularity of the logarithm.         The  [2.x.109]  parameter determines which norm will be used     on the subset of coefficients  [2.x.110]  with the same absolute value      [2.x.111] . Default is  [2.x.112]  for a maximum     approximation.         For a provided solution vector  [2.x.113]  defined on a DoFHandler      [2.x.114]  this function returns a vector  [2.x.115]      with as many elements as there are cells where each element contains the     estimated regularity  [2.x.116] .         A series expansion object  [2.x.117]  has to be supplied, which needs     to be constructed with the same FECollection object as the  [2.x.118]          The parameter  [2.x.119]  allows to ignore small (in     absolute value) coefficients within the linear regression fit. In case     there are less than two nonzero coefficients for a coordinate direction,     this direction will be skipped. If all coefficients are zero, the     returned value for this cell will be  [2.x.120] .         Smoothness indicators are usually used to decide whether to perform h- or     p-adaptation. So in most cases, we only need to calculate those     indicators on cells flagged for refinement or coarsening. The parameter      [2.x.121]  controls whether this particular subset or all     cells will be considered. By default, all cells will be considered.     When only flagged cells are supposed to be considered, smoothness     indicators will only be set on those vector entries of flagged cells;     the others will be set to a signaling NaN.    
* [0.x.7]*
     In this variant of the estimation strategy for higher dimensions, we only     consider modes in each coordinate direction, i.e., only mode vectors      [2.x.122]  with one nonzero entry. We perform the least-squares fit in     each coordinate direction separately and take the lowest decay rate      [2.x.123]  among them.         The  [2.x.124]  parameter selects Fourier coefficients      [2.x.125] ,  [2.x.126]  for linear regression in each coordinate     direction. The user is responsible for updating the vector of `flags`     provided to this function. Note that its size is  [2.x.127] , where  [2.x.128]  is the     polynomial degree of the FE basis on a given element. The default     implementation will use all Fourier coefficients in each coordinate     direction, i.e., set all the elements of the vector to `true`.         For a provided solution vector  [2.x.129]  defined on a DoFHandler      [2.x.130]  this function returns a vector  [2.x.131]      with as many elements as there are cells where each element contains the     estimated regularity  [2.x.132] .         A series expansion object  [2.x.133]  has to be supplied, which needs     to be constructed with the same FECollection object as the  [2.x.134]          The parameter  [2.x.135]  allows to ignore small (in     absolute value) coefficients within the linear regression fit. In case     there are fewer than two nonzero coefficients for a coordinate direction,     this direction will be skipped. If all coefficients are zero, the     returned value for this cell will be  [2.x.136] .         Smoothness indicators are usually used to decide whether to perform h- or     p-adaptation. So in most cases, we only need to calculate those     indicators on cells flagged for refinement or coarsening. The parameter      [2.x.137]  controls whether this particular subset or all     cells will be considered. By default, all cells will be considered.     When only flagged cells are supposed to be considered, smoothness     indicators will only be set on those vector entries of flagged cells;     the others will be set to a signaling NaN.    
* [0.x.8]*
     Returns a  [2.x.138]  object for Fourier series expansions with     the default configuration for smoothness estimation purposes.         For each finite element of the provided  [2.x.139]  we use as many     modes as its polynomial degree plus two. Further for each element, we use     a 5-point Gaussian quarature iterated in each dimension by the maximal     wave number, which is the number of modes decreased by one since we start     with  [2.x.140] .         As the Fourier expansion can only be performed on scalar fields, this     class does not operate on vector-valued finite elements and will     therefore throw an assertion. However, each component of a finite element     field can be treated as a scalar field, respectively, on which Fourier     expansions are again possible. For this purpose, the optional parameter      [2.x.141]  defines which component of each FiniteElement will be used.     The default value of  [2.x.142]  only applies to scalar FEs, in which     case it indicates that the sole component is to be decomposed. For     vector-valued FEs, a non-default value must be explicitly provided.    
* [0.x.9]