[0.x.0]*
 This class provides an abstract interface to time dependent problems in that it addresses some of the most annoying aspects of this class of problems: data management. These problems frequently need large amounts of computer resources, most notably computing time, main memory and disk space. Main memory reduction is often the most pressing need, methods to implement it are almost always quite messy, though, quickly leading to code that stores and reloads data at places scattered all over the program, and which becomes unmaintainable sometimes. The present class tries to offer a more structured interface, albeit simple, which emerged in my mind after messing with my wave equation simulation for several months.
*  The design of this class is mostly tailored for the solution of time dependent partial differential equations where the computational meshes may differ between each two timesteps and where the computations on each time step take a rather long time compared with the overhead of this class. Since no reference to the class of problems is made within this class, it is not restricted to PDEs, though, and it seems likely that a solver for large ordinary matrix differential equations may successfully use the same setup and therefore this class.
* 

*  [1.x.0]
*  The general structure of a time dependent problem solver using a timestepping scheme is about the following: we have a collection of time step objects on which we solve our problem subsequently. In order to do so, we need knowledge of the data on zero or several previous timesteps (when using single or multiple step methods, that is) and maybe also some data of time steps ahead (for example the computational grid on these). Depending on the problem in question, a second loop over all timesteps may be done solving a dual problem, where the loop may run forward (one dual problem for each time step) or backward (using a global dual problem). Within one of these loops or using a separate loop, error estimators may be computed and the grids may be refined. Each of these loops are initiated by a call preparing each timestep object for the next loop, before actually starting the loop itself.
*  We will denote a complete set of all these loops with the term "sweep". Since this library is mostly about adaptive methods, it is likely that the last loop within a sweep will generate refined meshes and that we will perform another sweep on these refined meshes. A total run will therefore often be a sequence of several sweeps. The global setup therefore looks like this:

* 
* [1.x.1]
*  The user may specify that a loop shall run forward or backward (the latter being needed for the solution of global dual problems, for example).
*  Going from the global overview to a more local viewpoint, we note that when a loop visits one timestep (e.g. to solve the primal or dual problem, or to compute error information), we need information on this, one or more previous time steps and zero or more timesteps in the future. However, often it is not needed to know all information from these timesteps and it is often a computational requirement to delete data at the first possible time when it is no more needed. Likewise, data should be reloaded at the latest time possible.
*  In order to facilitate these principles, the concept of waking up and letting sleep a time step object was developed. Assume we have a time stepping scheme which needs to look ahead one time step and needs the data of the last two time steps, the following pseudocode describes what the central loop function of this class will do when we move from timestep  [2.x.0]  n-1 to timestep  [2.x.1] 

* 
* [1.x.2]
*  The signal number here denotes the distance of the timestep being sent the signal to the timestep where computations are done on. The calls to the  [2.x.2]  wake_up and  [2.x.3]  functions with signal 0 could in principle be absorbed into the function doing the computation; we use these redundant signals, however, in order to separate computations and data management from each other, allowing to put all stuff around grid management, data reload and storage into one set of functions and computations into another.
*  In the example above, possible actions might be: timestep <tt>n+1</tt> rebuilds the computational grid (there is a specialized class which can do this for you); timestep  [2.x.4]  builds matrices and sets solution vectors to the right size, maybe using an initial guess; then it does the computations; then it deletes the matrices since they are not needed by subsequent timesteps; timestep  [2.x.5]  deletes those data vectors which are only needed by one timestep ahead; timestep  [2.x.6]  deletes the remaining vectors and deletes the computational grid, somewhere storing information how to rebuild it eventually.
*  From the given sketch above, it is clear that each time step object sees the following sequence of events:

* 
* [1.x.3]
*  This pattern is repeated for each loop in each sweep.
*  For the different loops within each sweep, the numbers of timesteps to look ahead (i.e. the maximum signal number to the  [2.x.7]  function) and the look-behind (i.e. the maximum signal number to the  [2.x.8]  function) can be chosen separately. For example, it is usually only needed to look one time step behind when computing error estimation (in some cases, it may even be possible to not look ahead or back at all, in which case only signals zero will be sent), while one needs a look back of at least one for a timestepping method.
*  Finally, a note on the direction of look-ahead and look-back is in place: look-ahead always refers to the direction the loop is running in, i.e. for loops running forward,  [2.x.9]  is called for timestep objects with a greater time value than the one previously computed on, while  [2.x.10]  is called for timesteps with a lower time. If the loop runs in the opposite direction, e.g. when solving a global dual problem, this order is reversed.
* 

*  [1.x.4]
*  The main loop of a program using this class will usually look like the following one, taken modified from an application program that isn't distributed as part of the library:

* 
* [1.x.5]
*  Here,  [2.x.11]  is an object of type TimeDependent_Wave<dim>, which is a class derived from TimeDependent.  [2.x.12]   [2.x.13]  solve_primal_problem,  [2.x.14]   [2.x.15]  and  [2.x.16]  end_sweep are functions inherited from this class. They all do a loop over all timesteps within this object and call the respective function on each of these objects. For example, here are two of the functions as they are implemented by the library:

* 
* [1.x.6]
*  The latter function shows rather clear how most of the loops are invoked ( [2.x.17]   [2.x.18]   [2.x.19]   [2.x.20]  refine_grids and  [2.x.21]  all have this form, where the latter two give functions of the derived timestep class, rather than from the base class). The function  [2.x.22]  and the respective ones for the other operations defined by that class are only used to store the type of operation which the loop presently performed will do.
*  As can be seen, most of the work is done by the  [2.x.23]  function of this class, which takes the addresses of two functions which are used to initialize all timestep objects for the loop and to actually perform some action. The next parameter gives some information on the look-ahead and look-back and the last one denotes in which direction the loop is to be run.
*  Using lambda functions it is possible to do neat tricks, like the following in this case from the function  [2.x.24] 

* 
* [1.x.7]
*   [2.x.25]  is a function taking an argument, unlike all the other functions used above within the loops. However, in this special case the parameter was the same for all timesteps and known before the loop was started, so we fixed it and made a function object which to the outside world does not take parameters.
*  Since it is the central function of this class, we finally present a stripped down version of the  [2.x.26]  method, which is shown in order to provide a better understanding of the internals of this class. For brevity we have omitted the parts that deal with backward running loops as well as the checks whether wake-up and sleep operations act on timesteps outside <tt>0..n_timesteps-1</tt>.

* 
* [1.x.8]
* 

* 
* [0.x.1]*
   Structure holding the two basic entities that control a loop over all   time steps: how many time steps ahead of the present one we shall start   waking up timestep objects and how many timesteps behind we shall call   their  [2.x.27]  method.  
* [0.x.2]*
     Constructor; see the different fields for a description of the meaning     of the parameters.    
* [0.x.3]*
     This denotes the number of timesteps the timestepping algorithm needs     to look ahead. Usually, this number will be zero, since algorithms     looking ahead can't act as timestepping schemes since they can't     compute their data from knowledge of the past only and are therefore     global in time.         However, it may be necessary to look ahead in other circumstances, when     not wanting to access the data of the next time step(s), but for     example to know the next grid, the solution of a dual problem on the     next time level, etc.         Note that for a dual problem walking back in time, "looking ahead"     means looking towards smaller time values.         The value of this number determines, how many time steps ahead the time     step manager start to call the  [2.x.28]  function for each time step.    
* [0.x.4]*
     This is the opposite variable to the above one. It denotes the number     of time steps behind the present one for which we need to keep all data     in order to do the computations on the present time level.         For one step schemes (e.g. the Euler schemes, or the Crank-Nicolson     scheme), this value will be one.         The value of this number determines, how many time steps after having     done computations on a time level the time step manager will call the  [2.x.29]      sleep function for each time step.    
* [0.x.5]*
   Enum offering the different directions in which a loop executed by  [2.x.30]    do_loop may be run.  
* [0.x.6]*
     Go in the forward direction.    
* [0.x.7]*
     Go in the backward direction.    
* [0.x.8]*
   Constructor.  
* [0.x.9]*
   Destructor. This will delete the objects pointed to by the pointers given   to the <tt>insert_*</tt> and  [2.x.31]  functions, i.e. it will   delete the objects doing the computations on each time step.  
* [0.x.10]*
   Add a timestep at any position. The position is a pointer to an existing   time step object, or a null pointer denoting the end of the timestep   sequence. If  [2.x.32]  is non-null, the new time step will be inserted   before the respective element.     Note that by giving an object to this function, the TimeDependent object   assumes ownership of the object; it will therefore also take care of   deletion of the objects its manages.     There is another function,  [2.x.33]  which inserts a time step at   the end of the list.     Note that this function does not change the timestep numbers stored   within the other timestep objects, nor does it set the timestep number of   this new timestep. This is only done upon calling the  [2.x.34]    function. In not changing the timestep numbers, it is simpler to operate   on a space-time triangulation since one can always use the timestep   numbers that were used in the previous sweep.  
* [0.x.11]*
   Just like  [2.x.35]  but insert at the end.     This mechanism usually will result in a set-up loop like this  
* [1.x.9]
*   
* [0.x.12]*
   Delete a timestep. This is only necessary to call, if you want to delete   it between two sweeps; at the end of the lifetime of this object, care is   taken automatically of deletion of the time step objects. Deletion of the   object by the destructor is done through this function also.     Note that this function does not change the timestep numbers stored   within the other timestep objects. This is only done upon calling the  [2.x.36]    start_sweep function. In not changing the timestep numbers, it is simpler   to operate on a space-time triangulation since one can always use the   timestep numbers that were used in the previous sweep.  
* [0.x.13]*
   Solve the primal problem; uses the functions  [2.x.37]    and  [2.x.38]  of the TimeStepBase class through the  [2.x.39]    do_loop function of this class.     Look ahead and look back are determined by the  [2.x.40]    timestepping_data_primal object given to the constructor.  
* [0.x.14]*
   Solve the dual problem; uses the functions  [2.x.41]  and    [2.x.42]  of the TimeStepBase class through the  [2.x.43]    function of this class.     Look ahead and look back are determined by the  [2.x.44]    object given to the constructor.  
* [0.x.15]*
   Do a postprocessing round; uses the functions  [2.x.45]    and  [2.x.46]  of the TimeStepBase class through the  [2.x.47]    function of this class.     Look ahead and look back are determined by the  [2.x.48]    timestepping_data_postprocess object given to the constructor.  
* [0.x.16]*
   Do a loop over all timesteps, call the  [2.x.49]  at the beginning   and the  [2.x.50]  of each time step. The  [2.x.51]    determine how many timesteps in front and behind the present one the  [2.x.52]    wake_up and  [2.x.53]  functions are called.     To see how this function work, note that the function  [2.x.54]    solve_primal_problem only consists of the following call:  
* [1.x.10]
*      Note also, that the given class from which the two functions are taken   needs not necessarily be TimeStepBase, but it could also be a derived   class, that is  [2.x.55]  from a TimeStepBase. The function may   be a virtual function (even a pure one) of that class, which should help   if the actual class where it is implemented is one which is derived   through virtual base classes and thus unreachable by  [2.x.56]  from   the TimeStepBase class.     Instead of using the above form, you can equally well use   <tt>[args...](Xconst x){x->unary_function(args...);}</tt>   which lets the  [2.x.57]  function call the given function with the   specified parameters.  
* [0.x.17]*
   Initialize the objects for the next sweep. This function specifically   does the following: assign each time level the number it presently has   within the array (which may change, if time levels are inserted or   deleted) and transmit the number of the present sweep to these objects.     It also calls the  [2.x.58]  function of each time step object, after   the numbers above are set.     This function is virtual, so you may overload it. You should, however not   forget to call this function as well from your overwritten version, at   best at the beginning of your function since this is some kind of   "constructor-like" function, which should be called bottom-up.     The default implementation of this function calls  [2.x.59]  on all   time step objects.  
* [0.x.18]*
   Analogous to the above function, calling  [2.x.60]  of each time step   object. The same applies with respect to the  [2.x.61]  of this   function as for the previous one.    
*  [2.x.62]  This function does not guarantee that  [2.x.63]  is called for   successive time steps successively, rather the order of time step objects   for which the function is called is arbitrary. You should therefore not   assume that that function has been called for previous time steps   already. If in multithread mode, the  [2.x.64]  function of several   time steps may be called at once, so you should use synchronization   mechanisms if your program requires so.  
* [0.x.19]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.20]*
   Exception.  
* [0.x.21]*
   Vector holding pointers to the time level objects. This is the main data   this object operates on. Note that this object takes possession of the   objects pointed to by the pointers in this collection.  
* [0.x.22]*
   Number of the present sweep. This is reset by the  [2.x.65]  function   called at the outset of each sweep.  
* [0.x.23]*
   Some flags telling the  [2.x.66]  function what to do. See   the documentation of this struct for more information.  
* [0.x.24]*
   Some flags telling the  [2.x.67]  function what to do. See the   documentation of this struct for more information.  
* [0.x.25]*
   Some flags telling the  [2.x.68]  function what to do. See the   documentation of this struct for more information.  
* [0.x.26]*
   Do the work of <tt>end_sweep()</tt> for some timesteps only. This is   useful in multithread mode.  
* [0.x.27]*
 Base class for a time step in time dependent problems. This class provides barely more than the basic framework, defining the necessary virtual functions (namely  [2.x.69]  and  [2.x.70]  the interface to previous and following grids, and some functions to be called before a new loop over all time steps is started.

* 
* [0.x.28]*
   Enum denoting the type of problem which will have to be solved next.  
* [0.x.29]*
     Solve the primal problem next.    
* [0.x.30]*
     Solve the dual problem next.    
* [0.x.31]*
     Perform postprocessing next.    
* [0.x.32]*
   Constructor. Does nothing here apart from setting the time.  
* [0.x.33]*
   Destructor. At present, this does nothing.  
* [0.x.34]*
   The copy constructor is deleted to avoid shallow copies with unexpected   behavior.  
* [0.x.35]*
   The copy assignment operator is deleted to avoid shallow copies with   unexpected behavior.  
* [0.x.36]*
   Reconstruct all the data that is needed for this time level to work. This   function serves to reget all the variables and data structures to work   again after they have been send to sleep some time before, or at the   first time we visit this time level. In particular, it is used to   reconstruct the triangulation, degree of freedom handlers, to reload data   vectors in case they have been stored to disk, etc.     The actual implementation of this function does nothing.     Since this is an important task, you should call this function from your   own function, should you choose to overload it in your own class (which   likely is the case), preferably at the beginning so that your function   can take effect of the triangulation already existing.  
* [0.x.37]*
   This is the opposite function to  [2.x.71]  It is used to delete data or   save it to disk after they are no more needed for the present sweep.   Typical kinds of data for this are data vectors, degree of freedom   handlers, triangulation objects, etc. which occupy large amounts of   memory and may therefore be externalized.     By default, this function does nothing.  
* [0.x.38]*
   This function is called each time before a new sweep is started. You may   want to set up some fields needed in the course of the computations, and   so on. You should take good care, however, not to install large objects,   which should be deferred until the  [2.x.72]  function is called.     A typical action of this function would be sorting out names of temporary   files needed in the process of solving, etc.     At the time this function is called, the values of  [2.x.73]   [2.x.74]    sweep_no and the pointer to the previous and next time step object   already have their correct value.     The default implementation of this function does nothing.  
* [0.x.39]*
   This is the analogous to the above function, but it is called at the end   of a sweep. You will usually want to do clean-ups in this function, such   as deleting temporary files and the like.  
* [0.x.40]*
   Before the primal problem is solved on each time level, this function is   called (i.e. before the solution takes place on the first time level). By   default, this function sets the  [2.x.75]  variable of this class.   You may overload this function, but you should call this function within   your own one.  
* [0.x.41]*
   Same as above, but called before a round of dual problem solves.  
* [0.x.42]*
   Same as above, but called before a round of postprocessing steps.  
* [0.x.43]*
   This function is called by the manager object when solving the primal   problem on this time level is needed. It is called after the  [2.x.76]    function was called and before the  [2.x.77]  function will be called.   There is no default implementation for obvious reasons, so you have to   overload this function.  
* [0.x.44]*
   This function is called by the manager object when solving the dual   problem on this time level is needed. It is called after the  [2.x.78]    function was called and before the  [2.x.79]  function will be called.   There is a default implementation doing plain nothing since some problems   may not need solving a dual problem. However, it will abort the program   when being called anyway, since then you should really overload the   function.  
* [0.x.45]*
   This function is called by the manager object when postprocessing this   time level is needed. It is called after the  [2.x.80]  function was   called and before the  [2.x.81]  function will be called. There is a   default implementation doing plain nothing since some problems may not   need doing a postprocess step, e.g. if everything was already done when   solving the primal problem. However, it will abort the program when being   called anyway, since then you should really overload the function.  
* [0.x.46]*
   Return the time value of this time step.  
* [0.x.47]*
   Return the number of this time step. Note that this number may vary   between different sweeps, if timesteps are added or deleted.  
* [0.x.48]*
   Compute the time difference to the last time step. If this timestep is   the first one, this function will result in an exception. Though this   behavior seems a bit drastic, it is appropriate in most cases since if   there is no previous time step you will need special treatment anyway and   this way no invalid value is returned which could lead to wrong but   unnoticed results of your computation. (The only sensible value to return   in that case would not be zero, since valid computation can be done with   that, but would be a denormalized value such as  [2.x.82]  However, there is   not much difference in finding that the results of a computation are all   denormalized values or in getting an exception; in the latter case you at   least get the exact place where your problem lies.)  
* [0.x.49]*
   Return the time difference to the next time step. With regard to the case   that there is no next time step, the same applies as for the function   above.  
* [0.x.50]*
   Determine an estimate for the memory consumption (in bytes) of this   object.     You will want to overload this function in derived classes to compute the   amount memory used by the derived class, and add the result of this   function to your result.  
* [0.x.51]*
   Pointer to the previous time step object in the list.  
* [0.x.52]*
   Pointer to the next time step object in the list.  
* [0.x.53]*
   Number of the sweep we are presently in. This number is reset by the time   level manager before a sweep is started.  
* [0.x.54]*
   Number of the time step, counted from zero onwards. This number is reset   at the start of each sweep by the time level manager, since some time   steps may have been inserted or deleted after the previous sweep.  
* [0.x.55]*
   Discrete time this level operates on.  
* [0.x.56]*
   Variable storing whether the solution of a primal or a dual problem is   actual, or any of the other actions specified. This variable is set by   the <tt>init_for_*</tt> functions.  
* [0.x.57]*
   Reset the pointer to the previous time step; shall only be called by the   time level manager object.     This function is called at the set-up of the manager object and whenever   a timestep is inserted or deleted.  
* [0.x.58]*
   Reset the pointer to the next time step; shall only be called by the time   level manager object.     This function is called at the set-up of the manager object and whenever   a timestep is inserted or deleted.  
* [0.x.59]*
   Set the number this time step has in the list of timesteps. This function   is called by the time step management object at the beginning of each   sweep, to update information which may have changed due to addition or   deletion of time levels.  
* [0.x.60]*
   Set the number of the sweep we are presently in. This function is called   by the time level management object at start-up time of each sweep.  
* [0.x.61]*
 Namespace in which some classes are declared that encapsulate flags for the TimeStepBase_Tria() class. These used to be local data types of that class, but some compilers choked on some aspects, so we put them into a namespace of their own.

* 
* [0.x.62]*
   This structure is used to tell the TimeStepBase_Tria() class how grids   should be handled. It has flags defining the moments where grids shall be   re-made and when they may be deleted. Also, one variable states whether   grids should be kept in memory or should be deleted between to uses to   save memory.  
* [0.x.63]*
     Default constructor; yields an exception, so is not really usable.    
* [0.x.64]*
     Constructor; see the different fields for a description of the meaning     of the parameters.    
* [0.x.65]*
     This flag determines whether the  [2.x.83]  and  [2.x.84]  functions     shall delete and rebuild the triangulation.  While for small problems,     this is not necessary, for large problems it is indispensable to save     memory.  The reason for this is that there may be several hundred time     levels in memory, each with its own triangulation, which may require     large amounts if there are many cells on each. Having a total of     100.000.000 cells on all time levels taken together is not uncommon,     which makes this flag understandable.    
* [0.x.66]*
     This number denotes the parameter to the  [2.x.85]  function at which     it shall rebuild the grid. Obviously, it shall be less than or equal to     the  [2.x.86]  number passed to the time step management object; if     it is equal, then the grid is rebuilt the first time the  [2.x.87]      function is called. If  [2.x.88]  is  [2.x.89]  this     number has no meaning.    
* [0.x.67]*
     This is the opposite flag to the one above: it determines at which call     to  [2.x.90]  the grid shall be deleted.    
* [0.x.68]*
   This structure is used to tell the TimeStepBase_Tria() class how grids   should be refined. Before we explain all the different variables, fist   some terminology:    [2.x.91]     [2.x.92]  Correction: after having flagged some cells of the triangulation for   following some given criterion, we may want to change the number of   flagged cells on this grid according to another criterion that the number   of cells may be only a certain fraction more or less then the number of   cells on the previous grid. This change of refinement flags will be   called "correction" in the sequel.    [2.x.93]  Adaption: in order to make the change between one grid and the next   not to large, we may want to flag some additional cells on one of the two   grids such that there are not too grave differences. This process will be   called "adaption".    [2.x.94]        [1.x.11]      [2.x.95]     [2.x.96]   [2.x.97]  Cut the refinement of cells at a given   level. This flag does not influence the flagging of cells, so not more   cells on the coarser levels are flagged than usual. Rather, the flags are   all set, but when it comes to the actual refinement, the maximum   refinement level is truncated.     This option is only really useful when you want to compare global   refinement with adaptive refinement when you don't want the latter to   refine more than the global refinement.      [2.x.98]   [2.x.99]  When using cell number correction as   defined above, it may be worth while to start with this only in later   sweeps, not already in the first one. If this variable is zero, then   start with the first sweep, else with a higher one. The rationale for   only starting later is that we do not want to block the development of   grids at the beginning and only impose restrictions in the sweeps where   we start to be interested in the actual results of the computations.      [2.x.100]   [2.x.101]  If we want a more free process of grid   development, we may want to impose less rules for grids with few cells   also. This variable sets a lower bound for the cell number of grids where   corrections are to be performed.      [2.x.102]   [2.x.103]  Fraction of the number of cells by   which the number of cells of one grid may be higher than that on the   previous grid. Common values are 10 per cent (i.e. 0.1). The naming of   the variable results from the goal to define a target corridor for the   number of cells after refinement has taken place.      [2.x.104]   [2.x.105]  Fraction of the number of cells by   which the number of cells of one grid may be lower than that on the   previous grid. Common values are 5 per cent (i.e. 0.05). Usually this   number will be smaller than  [2.x.106]  since an increase   of the number of cells is not harmful (though it increases the numerical   amount of work needed to solve the problem) while a sharp decrease may   reduce the accuracy of the final result even if the time steps computed   before the decrease were computed to high accuracy.     Note however, that if you compute the dual problem as well, then the time   direction is reversed, so the two values defining the cell number   corridor should be about equal.      [2.x.107]   [2.x.108]  This is a list of pairs of number with   the following meaning: just as for  [2.x.109]  it may be   worth while to reduce the requirements upon grids if the have few cells.   The present variable stores a list of cell numbers along with some values   which tell us that the cell number corridor should be enlarged by a   certain factor. For example, if this list was <tt>((100 5) (200 3) (500   2))</tt>, this would mean that for grids with a cell number below 100,   the <tt>cell_number_corridor_*</tt> variables are to be multiplied by 5   before they are applied, for cell numbers below 200 they are to be   multiplied by 3, and so on.      [2.x.110]  is actually a vector of such list. Each entry   in this vector denotes the relaxation rules for one sweep. The last entry   defines the relaxation rules for all following sweeps. This scheme is   adopted to allow for stricter corrections in later sweeps while the   relaxations may be more generous in the first sweeps.     There is a static variable  [2.x.111]  which you   can use as a default value. It is an empty list and thus defines no   relaxations.      [2.x.112]   [2.x.113]  Usually, if you want the number of   cells to be corrected, the target corridor for the cell number is   computed and some additional cells are flagged or flags are removed. But   since the cell number resulting after flagging and deflagging can not be   easily computed, it will usually not be within the corridor. We therefore   need to iteratively get to our goal. Usually, three or four iterations   are needed, but using this variable, you can reduce the allowed number of   iterations; breaking the loop after two iterations yields good results   regularly. Setting the variable to zero will result in no correction   steps at all.      [2.x.114]   [2.x.115]  If a cell on the present grid is   flagged for refinement, also flag the corresponding cell on the previous   grid. This is useful if, for example, error indicators are computed for   space-time cells, but are stored for the second grid only. Now, since the   first grid has the same contributions to the indicators as the second, it   may be useful to flag both if necessary. This is done if the present   variable is set.      [2.x.116]   [2.x.117]  adapt the present grid to the previous one in the   sense defined above. What is actually done here is the following: if   going from the previous to the present grid would result in double   refinement or double coarsening of some cells, then we try to flag these   cells for refinement or coarsening such as to avoid the double step.   Obviously, more than double refinement of coarsening is also caught.     Grid adaption can try to avoid such changes between two grids, but it can   never promise that they don't occur. This is because the next grid may   change the present one, but then again there may be jumps in refinement   level between the present and the previous one; this could only be   avoided by looping iteratively through all grids, back and forth, until   nothing changes anymore, which is obviously impossible if there are many   time steps with very large grids.    [2.x.118]   
* [0.x.69]*
     Typedef of a data type describing some relaxations of the correction     process. See the general description of this class for more     information.    
* [0.x.70]*
     Default values for the relaxations: no relaxations.    
* [0.x.71]*
     Constructor. The default values are chosen such that almost no     restriction on the mesh refinement is imposed.    
* [0.x.72]*
     Maximum level of a cell in the triangulation of a time level. If it is     set to zero, then no limit is imposed on the number of refinements a     coarse grid cell may undergo. Usually, this field is used, if for some     reason you want to limit refinement in an adaptive process, for example     to avoid overly large numbers of cells or to compare with grids which     have a certain number of refinements.    
* [0.x.73]*
     First sweep to perform cell number correction steps on; for sweeps     before, cells are only flagged and no number-correction to previous     grids is performed.    
* [0.x.74]*
     Apply cell number correction with the previous time level only if there     are more than this number of cells.    
* [0.x.75]*
     Fraction by which the number of cells on a time level may differ from     the number on the previous time level (first: top deviation, second:     bottom deviation).    
* [0.x.76]*
      [2.x.119]     
* [0.x.77]*
     List of relaxations to the correction step.    
* [0.x.78]*
     Number of iterations to be performed to adjust the number of cells on a     time level to those on the previous one. Zero means: do no such     iteration.    
* [0.x.79]*
     Flag all cells which are flagged on this timestep for refinement on the     previous one also. This is useful in case the error indicator was     computed by integration over time-space cells, but are now associated     to a grid on a discrete time level. Since the error contribution comes     from both grids, however, it is appropriate to refine both grids.         Since the previous grid does not mirror the flags to the one before it,     this does not lead to an almost infinite growth of cell numbers. You     should use this flag with cell number correction switched on only,     however.         Mirroring is done after cell number correction is done, but before grid     adaption, so the cell number on this grid is not noticeably influenced     by the cells flagged additionally on the previous grid.    
* [0.x.80]*
     Adapt this grid to the previous one.    
* [0.x.81]*
     Exception    
* [0.x.82]*
   Structure given to the actual refinement function, telling it which   thresholds to take for coarsening and refinement. The actual refinement   criteria are loaded by calling the virtual function  [2.x.120]    get_tria_refinement_criteria.  
* [0.x.83]*
     Constructor    
* [0.x.84]*
     Threshold for refinement: cells having a larger value will be refined     (at least in the first round; subsequent steps of the refinement     process may flag other cells as well or remove the flag from cells with     a criterion higher than this threshold).    
* [0.x.85]*
     Same threshold for coarsening: cells with a smaller threshold will be     coarsened if possible.    
* [0.x.86]*
     Exception    
* [0.x.87]*
 Specialization of TimeStepBase which addresses some aspects of grid handling. In particular, this class is thought to make handling of grids available that are adaptively refined on each time step separately or with a loose coupling between time steps. It also takes care of deleting and rebuilding grids when memory resources are a point, through the  [2.x.121]  and  [2.x.122]  functions declared in the base class.
*  In addition to that, it offers functions which do some rather hairy refinement rules for time dependent problems, trying to avoid too much change in the grids between subsequent time levels, while also trying to retain the freedom of refining each grid separately. There are lots of flags and numbers controlling this function, which might drastically change the behavior of the function
* 
*  -  see the description of the flags for further information.

* 
* [0.x.88]*
   Typedef the data types of the TimeStepBase_Tria_Flags() namespace into   local scope.  
* [0.x.89]*
   Extension of the enum in the base class denoting the next action to be   done.  
* [0.x.90]*
     Perform grid refinement next.    
* [0.x.91]*
   Default constructor. Does nothing but throws an exception. We need to   have such a constructor in order to satisfy the needs of derived classes,   which take this class as a virtual base class and don't need to call this   constructor of they are not terminal classes. The compiler would like to   know a constructor to call anyway since it can't know that the class is   not terminal.  
* [0.x.92]*
   Constructor. Takes a coarse grid from which the grids on this time level   will be derived and some flags steering the behavior of this object.     The ownership of the coarse grid stays with the creator of this object.   However, it is locked from destruction to guarantee the lifetime of the   coarse grid is longer than it is needed by this object.     You need to give the general flags structure to this function since it is   needed anyway; the refinement flags can be omitted if you do not intend   to call the refinement function of this class.  
* [0.x.93]*
   Destructor. At present, this does not more than releasing the lock on the   coarse grid triangulation given to the constructor.  
* [0.x.94]*
   Reconstruct all the data that is needed for this time level to work. This   function serves to reget all the variables and data structures to work   again after they have been send to sleep some time before, or at the   first time we visit this time level. In particular, it is used to   reconstruct the triangulation, degree of freedom handlers, to reload data   vectors in case they have been stored to disk, etc. By default, this   function rebuilds the triangulation if the respective flag has been set   to destroy it in the  [2.x.123]  function. It does so also the first time we   hit this function and  [2.x.124]  equals   <tt>flags.wakeup_level_to_build_grid</tt>, independently of the value of   the mentioned flag. (Actually, it does so whenever the triangulation   pointer equals the Null pointer and the value of  [2.x.125]  is   right.)     Since this is an important task, you should call this function from your   own function, should you choose to overload it in your own class (which   likely is the case), preferably at the beginning so that your function   can take effect of the triangulation already existing.  
* [0.x.95]*
   This is the opposite function to  [2.x.126]  It is used to delete data or   save it to disk after they are no more needed for the present sweep.   Typical kinds of data for this are data vectors, degree of freedom   handlers, triangulation objects, etc. which occupy large amounts of   memory and may therefore be externalized.     By default, if the user specified so in the flags for this object, the   triangulation is deleted and the refinement history is saved such that the   respective  [2.x.127]  function can rebuild it. You should therefore call   this function from your overloaded version, preferably at the end so that   your function can use the triangulation as long as you need it.  
* [0.x.96]*
   Do the refinement according to the flags passed to the constructor of   this object and the data passed to this function. For a description of   the working of this function refer to the general documentation of this   class.     In fact, this function does not actually refine or coarsen the   triangulation, but only sets the respective flags. This is done because   usually you will not need the grid immediately afterwards but only in the   next sweep, so it suffices to store the flags and rebuild it the next   time we need it. Also, it may be that the next time step would like to   add or delete some flags, so we have to wait anyway with the use of this   grid.  
* [0.x.97]*
   Respective init function for the refinement loop; does nothing in the   default implementation, apart from setting  [2.x.128]  to  [2.x.129]    grid_refinement but can be overloaded.  
* [0.x.98]*
   Virtual function that should fill the vector with the refinement criteria   for the present triangulation. It is used within the  [2.x.130]    function to get the criteria for the present time step, since they can't   be passed through its argument when using the loop of the time step   management object.  
* [0.x.99]*
   The refinement flags of the triangulation are stored in a local variable   thus allowing a restoration. The coarsening flags are also stored.  
* [0.x.100]*
   Determine an estimate for the memory consumption (in bytes) of this   object.     You will want to overload this function in derived classes to compute the   amount memory used by the derived class, and add the result of this   function to your result.  
* [0.x.101]*
   Exception  
* [0.x.102]*
   Triangulation used at this time level. Since this is something that every   time stepping scheme needs to have, we can safely put it into the base   class. Note that the triangulation is frequently deleted and rebuilt by   the functions  [2.x.131]  and  [2.x.132]  to save memory, if such a behavior   is specified in the  [2.x.133]  structure.  
* [0.x.103]*
   Pointer to a grid which is to be used as the coarse grid for this time   level.  This pointer is set through the constructor; ownership remains   with the owner of this management object.  
* [0.x.104]*
   Some flags about how this time level shall behave. See the documentation   of this struct to find out more about that.  
* [0.x.105]*
   Flags controlling the refinement process; see the documentation of the   respective structure for more information.  
* [0.x.106]*
   Vectors holding the refinement and coarsening flags of the different   sweeps on this time level. The vectors therefore hold the history of the   grid.  
* [0.x.107]*
    [2.x.134]   
* [0.x.108]*
   Restore the grid according to the saved data. For this, the coarse grid   is copied and the grid is stepwise rebuilt using the saved flags.  
* [0.x.109]