[0.x.0]*
    [2.x.0]  Evaluation of functions and errors  
* [0.x.1]*
   Compute the cellwise error of the finite element solution.  Integrate the   difference between a reference function which is given as a continuous   function object, and a finite element function. The result of this   function is the vector  [2.x.1]  that contains one value per active   cell  [2.x.2]  of the triangulation. Each of the values of this vector  [2.x.3]    equals  
* [1.x.0]
*    where  [2.x.4]  denotes the norm chosen and  [2.x.5]  represents the exact solution.     It is assumed that the number of components of the function  [2.x.6]    exact_solution matches that of the finite element used by  [2.x.7]      To compute a global error norm of a finite element solution, use    [2.x.8]  with the output vector computed with   this function.      [2.x.9]  mapping The mapping that is used when integrating the   difference  [2.x.10] .    [2.x.11]  dof The DoFHandler object that describes the finite element   space in which the solution vector lives.    [2.x.12]  fe_function A vector with nodal values representing the   numerical approximation  [2.x.13] . This vector needs to correspond to the   finite element space represented by  [2.x.14]     [2.x.15]  exact_solution The exact solution that is used to compute the   error.    [2.x.16]  difference The vector of values  [2.x.17]  computed as above.    [2.x.18]  q The quadrature formula used to approximate the integral   shown above. Note that some quadrature formulas are more useful than   other in integrating  [2.x.19] . For example, it is known that the  [2.x.20]    approximation  [2.x.21]  to the exact solution  [2.x.22]  of a Laplace equation is   particularly accurate (in fact, superconvergent, i.e. accurate to higher   order) at the 4 Gauss points of a cell in 2d (or 8 points in 3d) that   correspond to a QGauss(2) object. Consequently, because a QGauss(2)   formula only evaluates the two solutions at these particular points,   choosing this quadrature formula may indicate an error far smaller than   it actually is.    [2.x.23]  norm The norm  [2.x.24]  shown above that should be computed. If the   norm is  [2.x.25]  then the finite element on which this   function is called needs to have at least dim vector components, and the   divergence will be computed on the first div components. This works, for   example, on the finite elements used for the mixed Laplace ( [2.x.26] ) and   the Stokes equations ( [2.x.27] ).    [2.x.28]  weight The additional argument  [2.x.29]  allows to evaluate   weighted norms.  The weight function may be scalar, establishing a   spatially variable weight in the domain for all components equally. This   may be used, for instance, to only integrate over parts of the domain.   The weight function may also be vector-valued, with as many components as   the finite element: Then, different components get different weights. A   typical application is when the error with respect to only one or a   subset of the solution variables is to be computed, in which case the   other components would have weight values equal to zero. The   ComponentSelectFunction class is particularly useful for this purpose as   it provides such a "mask" weight. The weight function is expected to be   positive, but negative values are not filtered. The default value of this   function, a null pointer, is interpreted as "no weighting function",   i.e., weight=1 in the whole domain for all vector components uniformly.    [2.x.30]  exponent This value denotes the  [2.x.31]  used in computing    [2.x.32] -norms and  [2.x.33] -norms. The value is ignored if a  [2.x.34]  other   than  [2.x.35]   [2.x.36]  or  [2.x.37]    is chosen.       See the general documentation of this namespace for more information.    
*  [2.x.38]  If the integration here happens over the cells of a    [2.x.39]  object, then this function computes   the vector elements  [2.x.40]  for an output vector with as many cells as   there are active cells of the triangulation object of the current   processor. However, not all active cells are in fact locally owned: some   may be ghost or artificial cells (see    [2.x.41]  "here"   and    [2.x.42]  "here").   The vector computed will, in the case of a distributed triangulation,   contain zeros for cells that are not locally owned. As a consequence, in   order to compute the [1.x.1]  [2.x.43]  error (for example), the errors   from different processors need to be combined, see    [2.x.44]      Instantiations for this template are provided for some vector types (see   the general documentation of the namespace), but only for InVectors as in   the documentation of the namespace, OutVector only Vector<double> and   Vector<float>.  
* [0.x.2]*
   Call the integrate_difference() function, see above, with   <tt>mapping=MappingQGeneric [2.x.45]   
* [0.x.3]*
   Same as above for hp.  
* [0.x.4]*
   Call the integrate_difference() function, see above, with   <tt>mapping=MappingQGeneric [2.x.46]   
* [0.x.5]*
   Take a Vector  [2.x.47]  of errors on each cell with   <tt>tria.n_active_cells()</tt> entries and return the global   error as given by  [2.x.48]      The  [2.x.49]  vector is typically an output produced by    [2.x.50]  and you normally want to supply the   same value for  [2.x.51]  as you used in  [2.x.52]      If the given Triangulation is a  [2.x.53]  entries   in  [2.x.54]  that do not correspond to locally owned cells are   assumed to be 0.0 and a parallel reduction using MPI is done to compute   the global error.      [2.x.55]  tria The Triangulation with active cells corresponding with the   entries in  [2.x.56]     [2.x.57]  cellwise_error Vector of errors on each active cell.    [2.x.58]  norm The type of norm to compute.    [2.x.59]  exponent The exponent  [2.x.60]  to use for  [2.x.61] -norms and    [2.x.62] -norms. The value is ignored if a  [2.x.63]  other   than  [2.x.64]   [2.x.65]  or  [2.x.66]    is chosen.    
*  [2.x.67]  Instantiated for type Vector<double> and Vector<float>.  
* [0.x.6]