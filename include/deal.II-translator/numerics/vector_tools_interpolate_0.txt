[0.x.0]*
    [2.x.0]  Interpolation and projection  
* [0.x.1]*
   Compute the interpolation of  [2.x.1]  at the support points to the   finite element space described by the Triangulation and FiniteElement   object with which the given DoFHandler argument is initialized. It is   assumed that the number of components of  [2.x.2]  matches that of the   finite element used by  [2.x.3]      Note that you may have to call <tt>hanging_nodes.distribute(vec)</tt>   with the hanging nodes from space  [2.x.4]  afterwards, to make the result   continuous again.     See the general documentation of this namespace for further information.  
* [0.x.2]*
   Same as above but in an hp-context.  
* [0.x.3]*
   Call the  [2.x.5]  function above with   <tt>mapping=MappingQGeneric [2.x.6]   
* [0.x.4]*
   Interpolate different finite element spaces. The interpolation of vector    [2.x.7]  (which is assumed to be ghosted, see    [2.x.8] )   is executed from the FE space represented by  [2.x.9]    to the vector  [2.x.10]  on FE space  [2.x.11]    The interpolation on each cell is represented by the matrix  [2.x.12]    Curved boundaries are neglected so far.     Note that you may have to call <tt>hanging_nodes.distribute(data_2)</tt>   with the hanging nodes from space  [2.x.13]  afterwards, to make the result   continuous again.    
*  [2.x.14]  Instantiations for this template are provided for some vector types   (see the general documentation of the namespace), but only the same   vector for InVector and OutVector. Other combinations must be   instantiated by hand.  
* [0.x.5]*
   This function is a kind of generalization or modification of the very   first interpolate() function in the series. It interpolates a set of   functions onto the finite element space defined by the DoFHandler argument,   where the determination which function to use on each cell is made   based on the material id (see    [2.x.15] )   of each cell.      [2.x.16]  mapping        The mapping to use to determine the location of     support points at which the functions are to be evaluated.    [2.x.17]  dof_handler    DoFHandler initialized with Triangulation and     FiniteElement objects and that defines the finite element space.    [2.x.18]  function_map   A  [2.x.19]  reflecting the correspondence between     material ids on those cells on which something should be interpolated,     and the functions to be interpolated onto the finite element space.    [2.x.20]  dst           The global finie element vector holding the     output of the interpolated values.    [2.x.21]  component_mask A mask of components that shall be interpolated.    
*  [2.x.22]  If the algorithm encounters a cell whose material id is not listed   in the given  [2.x.23]  then  [2.x.24]  will not be updated in the   respective degrees of freedom of the output vector. For example, if    [2.x.25]  was initialized to zero, then those zeros which correspond to   the missed material ids will still remain in  [2.x.26]  after calling   this function.    
*  [2.x.27]  Degrees of freedom located on faces between cells of different   material ids will get their value by that cell which was called last in   the respective loop over cells implemented in this function. Since the   order of cells is somewhat arbitrary, you cannot control it. However, if   you want to have control over the order in which cells are visited, let us   take a   look at the following example: Let  [2.x.28]  be a variable of interest which   is approximated by some CG finite element. Let  [2.x.29]   [2.x.30]  and  [2.x.31]  be   material ids of cells on the triangulation. Let 0: 0.0, 1: 1.0, 2: 2.0 be   the whole  [2.x.32]  that you want to pass to this function, where    [2.x.33]  is a material id and  [2.x.34]  is a value of  [2.x.35]  By using the   whole  [2.x.36]  you do not really know which values will be   assigned to the face DoFs. On the other hand, if you split the whole  [2.x.37]    function_map into three smaller independent objects 0: 0.0 and 1: 1.0 and   2: 2.0 and make three distinct calls of this function passing each of   these objects separately (the order depends on what you want to get   between cells), then each subsequent call will rewrite the intercell  [2.x.38]    dofs of the previous one.  
* [0.x.6]*
   Compute the interpolation of a  [2.x.39]   [2.x.40]  to a  [2.x.41]     [2.x.42]  where  [2.x.43]  and  [2.x.44]  represent different triangulations with   a common coarse grid.     dof1 and dof2 need to have the same finite element discretization.     Note that for continuous elements on grids with hanging nodes (i.e.   locally refined grids) this function does not give the expected output.   Indeed, the resulting output vector does not necessarily respect   continuity requirements at hanging nodes, due to local cellwise   interpolation.     For this case (continuous elements on grids with hanging nodes), please   use the interpolate_to_different_mesh function with an additional   AffineConstraints argument, see below, or make the field conforming   yourself by calling the  [2.x.45]  function of your   hanging node constraints object.    
*  [2.x.46]  This function works with  [2.x.47]  but   only if the parallel partitioning is the same for both meshes (see the    [2.x.48]    flag).  
* [0.x.7]*
   Compute the interpolation of a  [2.x.49]   [2.x.50]  to a  [2.x.51]     [2.x.52]  where  [2.x.53]  and  [2.x.54]  represent different triangulations with   a common coarse grid.     dof1 and dof2 need to have the same finite element discretization.      [2.x.55]  is a hanging node constraints object corresponding to  [2.x.56]    dof2. This object is particularly important when interpolating onto   continuous elements on grids with hanging nodes (locally refined grids):   Without it
* 
*  - due to cellwise interpolation
* 
*  - the resulting output vector   does not necessarily respect continuity requirements at hanging nodes.  
* [0.x.8]*
   The same function as above, but takes an InterGridMap object directly as   a parameter. Useful for interpolating several vectors at the same time.      [2.x.57]  has to be initialized via  [2.x.58]    pointing from a source DoFHandler to a destination DoFHandler.  
* [0.x.9]*
   Geometrical interpolation  
* [0.x.10]*
   Given a DoFHandler containing at least a spacedim vector field, this   function interpolates the Triangulation at the support points of a FE_Q()   finite element of the same degree as the degree of the required   components.     Curved manifold are respected, and the resulting VectorType will be   geometrically consistent. The resulting map is guaranteed to be   interpolatory at the support points of a FE_Q() finite element of the   same degree as the degree of the required components.     If the underlying finite element is an FE_Q(1)^spacedim, then the   resulting  [2.x.59]  is a finite element field representation of the   vertices of the Triangulation.     The optional ComponentMask argument can be used to specify what   components of the FiniteElement to use to describe the   geometry. If no mask is specified at construction time, then a   default-constructed mask is used, which is then interpreted as   saying that the first `spacedim` components of the FiniteElement   are assumed to represent the geometry of the problem.     This function is only implemented for FiniteElements where the specified   components are primitive.  
* [0.x.11]*
   Like the above function but also taking  [2.x.60]  as argument.   This will introduce an additional approximation between the true geometry   specified by the manifold if the degree of the mapping is lower than the   degree of the finite element in the DoFHandler  [2.x.61]  but more   importantly it allows to fill location vectors for mappings that do not   preserve vertex locations (like Eulerian mappings).  
* [0.x.12]