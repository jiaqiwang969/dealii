[0.x.0]*
    [2.x.0]  Evaluation of functions and errors  
* [0.x.1]*
   Evaluate a possibly vector-valued finite element function defined by the   given DoFHandler and nodal vector at the given point, and return the   (vector) gradient of this function through the last argument.     This is a wrapper function using a Q1-mapping for cell boundaries to call   the other point_gradient() function.     This function is not particularly cheap. This is because it first   needs to find which cell a given point is in, then find the point   on the reference cell that matches the given evaluation point,   and then evaluate the shape functions there. You probably do not   want to use this function to evaluate the solution at [1.x.0]   points. For this kind of application, the FEFieldFunction class   offers at least some optimizations. On the other hand, if you   want to evaluate [1.x.1] at the same point, you may   want to look at the  [2.x.1]    function.    
*  [2.x.2]  If the cell in which the point is found is not locally owned, an   exception of type  [2.x.3]  is thrown.    
*  [2.x.4]  This function needs to find the cell within which a point lies,     and this can only be done up to a certain numerical tolerance of course.     Consequently, for points that are on, or close to, the boundary of     a cell, you may get the gradient of the finite element field either     here or there, depending on which cell the point is found in. Since     the gradient is, for most elements, discontinuous from one cell or     the other, you will get unpredictable values for     points on or close to the boundary of the cell, as one would expect     when trying to evaluate point values of discontinuous functions.  
* [0.x.2]*
   Same as above for hp.    
*  [2.x.5]  If the cell in which the point is found is not locally owned, an   exception of type  [2.x.6]  is thrown.    
*  [2.x.7]  This function needs to find the cell within which a point lies,     and this can only be done up to a certain numerical tolerance of course.     Consequently, for points that are on, or close to, the boundary of     a cell, you may get the gradient of the finite element field either     here or there, depending on which cell the point is found in. Since     the gradient is, for most elements, discontinuous from one cell or     the other, you will get unpredictable values for     points on or close to the boundary of the cell, as one would expect     when trying to evaluate point values of discontinuous functions.  
* [0.x.3]*
   Evaluate a scalar finite element function defined by the given DoFHandler   and nodal vector at the given point, and return the gradient of this   function.     Compared with the other function of the same name, this is a wrapper   function using a Q1-mapping for cells.     This function is not particularly cheap. This is because it first   needs to find which cell a given point is in, then find the point   on the reference cell that matches the given evaluation point,   and then evaluate the shape functions there. You probably do not   want to use this function to evaluate the solution at [1.x.2]   points. For this kind of application, the FEFieldFunction class   offers at least some optimizations. On the other hand, if you   want to evaluate [1.x.3] at the same point, you may   want to look at the  [2.x.8]    function.    
*  [2.x.9]  If the cell in which the point is found is not locally owned, an   exception of type  [2.x.10]  is thrown.    
*  [2.x.11]  This function needs to find the cell within which a point lies,     and this can only be done up to a certain numerical tolerance of course.     Consequently, for points that are on, or close to, the boundary of     a cell, you may get the gradient of the finite element field either     here or there, depending on which cell the point is found in. Since     the gradient is, for most elements, discontinuous from one cell or     the other, you will get unpredictable values for     points on or close to the boundary of the cell, as one would expect     when trying to evaluate point values of discontinuous functions.  
* [0.x.4]*
   Same as above for hp.    
*  [2.x.12]  If the cell in which the point is found is not locally owned, an   exception of type  [2.x.13]  is thrown.    
*  [2.x.14]  This function needs to find the cell within which a point lies,     and this can only be done up to a certain numerical tolerance of course.     Consequently, for points that are on, or close to, the boundary of     a cell, you may get the gradient of the finite element field either     here or there, depending on which cell the point is found in. Since     the gradient is, for most elements, discontinuous from one cell or     the other, you will get unpredictable values for     points on or close to the boundary of the cell, as one would expect     when trying to evaluate point values of discontinuous functions.  
* [0.x.5]*
   Evaluate a possibly vector-valued finite element function defined by the   given DoFHandler and nodal vector at the given point, and return the   gradients of this function through the last argument.     Compared with the other function of the same name, this function uses an   arbitrary mapping for evaluation.     This function is not particularly cheap. This is because it first   needs to find which cell a given point is in, then find the point   on the reference cell that matches the given evaluation point,   and then evaluate the shape functions there. You probably do not   want to use this function to evaluate the solution at [1.x.4]   points. For this kind of application, the FEFieldFunction class   offers at least some optimizations. On the other hand, if you   want to evaluate [1.x.5] at the same point, you may   want to look at the  [2.x.15]    function.    
*  [2.x.16]  If the cell in which the point is found is not locally owned, an   exception of type  [2.x.17]  is thrown.    
*  [2.x.18]  This function needs to find the cell within which a point lies,     and this can only be done up to a certain numerical tolerance of course.     Consequently, for points that are on, or close to, the boundary of     a cell, you may get the gradient of the finite element field either     here or there, depending on which cell the point is found in. Since     the gradient is, for most elements, discontinuous from one cell or     the other, you will get unpredictable values for     points on or close to the boundary of the cell, as one would expect     when trying to evaluate point values of discontinuous functions.  
* [0.x.6]*
   Same as above for hp.    
*  [2.x.19]  If the cell in which the point is found is not locally owned, an   exception of type  [2.x.20]  is thrown.    
*  [2.x.21]  This function needs to find the cell within which a point lies,     and this can only be done up to a certain numerical tolerance of course.     Consequently, for points that are on, or close to, the boundary of     a cell, you may get the gradient of the finite element field either     here or there, depending on which cell the point is found in. Since     the gradient is, for most elements, discontinuous from one cell or     the other, you will get unpredictable values for     points on or close to the boundary of the cell, as one would expect     when trying to evaluate point values of discontinuous functions.  
* [0.x.7]*
   Evaluate a scalar finite element function defined by the given DoFHandler   and nodal vector at the given point, and return the gradient of this   function.     Compared with the other function of the same name, this function uses an   arbitrary mapping for evaluation.     This function is not particularly cheap. This is because it first   needs to find which cell a given point is in, then find the point   on the reference cell that matches the given evaluation point,   and then evaluate the shape functions there. You probably do not   want to use this function to evaluate the solution at [1.x.6]   points. For this kind of application, the FEFieldFunction class   offers at least some optimizations. On the other hand, if you   want to evaluate [1.x.7] at the same point, you may   want to look at the  [2.x.22]    function.    
*  [2.x.23]  If the cell in which the point is found is not locally owned, an   exception of type  [2.x.24]  is thrown.    
*  [2.x.25]  This function needs to find the cell within which a point lies,     and this can only be done up to a certain numerical tolerance of course.     Consequently, for points that are on, or close to, the boundary of     a cell, you may get the gradient of the finite element field either     here or there, depending on which cell the point is found in. Since     the gradient is, for most elements, discontinuous from one cell or     the other, you will get unpredictable values for     points on or close to the boundary of the cell, as one would expect     when trying to evaluate point values of discontinuous functions.  
* [0.x.8]*
   Same as above for hp.    
*  [2.x.26]  If the cell in which the point is found is not locally owned, an   exception of type  [2.x.27]  is thrown.    
*  [2.x.28]  This function needs to find the cell within which a point lies,     and this can only be done up to a certain numerical tolerance of course.     Consequently, for points that are on, or close to, the boundary of     a cell, you may get the gradient of the finite element field either     here or there, depending on which cell the point is found in. Since     the gradient is, for most elements, discontinuous from one cell or     the other, you will get unpredictable values for     points on or close to the boundary of the cell, as one would expect     when trying to evaluate point values of discontinuous functions.  
* [0.x.9]