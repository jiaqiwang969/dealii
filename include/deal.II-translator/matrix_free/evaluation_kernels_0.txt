[0.x.0]*
   This struct performs the evaluation of function values, gradients and   Hessians for tensor-product finite elements. The operation is used for   both the symmetric and non-symmetric case, which use different apply   functions 'values', 'gradients' in the individual coordinate   directions. The apply functions for values are provided through one of   the template classes EvaluatorTensorProduct which in turn are selected   from the  [2.x.0]  template argument.     There are two specialized implementation classes   FEEvaluationImplCollocation (for Gauss-Lobatto elements where the nodal   points and the quadrature points coincide and the 'values' operation is   identity) and FEEvaluationImplTransformToCollocation (which can be   transformed to a collocation space and can then use the identity in these   spaces), which both allow for shorter code.  
* [0.x.1]*
   Specialization for  [2.x.1]  which cannot use the   sum-factorization kernels.  
* [0.x.2]*
   This struct implements the change between two different bases. This is an   ingredient in the FEEvaluationImplTransformToCollocation class where we   first transform to the appropriate basis where we can compute the   derivative through collocation techniques.     This class allows for dimension-independent application of the operation,   implemented by template recursion. It has been tested up to 6D.  
* [0.x.3]*
     This applies the transformation that contracts over the rows of the     coefficient array, generating values along the columns of the     coefficient array.          [2.x.2]  n_components The number of vector components.      [2.x.3]  transformation_matrix The coefficient matrix handed in as a                         vector, using  [2.x.4]  rows and  [2.x.5]                          columns if interpreted as a matrix.      [2.x.6]  values_in    The array of the input of size basis_size_1^dim. It                         may alias with values_out      [2.x.7]  values_out   The array of size basis_size_2^dim where the results                         of the transformation are stored. It may alias with                         the values_in array.      [2.x.8]  basis_size_1_variable In case the template argument basis_size_1     is zero, the size of the first basis can alternatively be passed in as a     run time argument. The template argument takes precedence in case it is     nonzero for efficiency reasons.      [2.x.9]  basis_size_2_variable In case the template argument basis_size_1     is zero, the size of the second basis can alternatively be passed in as a     run time argument.    
* [0.x.4]*
     This applies the transformation that contracts over the columns of the     coefficient array, generating values along the rows of the coefficient     array.          [2.x.10]  n_components The number of vector components.      [2.x.11]  transformation_matrix The coefficient matrix handed in as a                         vector, using  [2.x.12]  rows and  [2.x.13]                          columns if interpreted as a matrix.      [2.x.14]  add_into_result Define whether the result should be added into the                         array  [2.x.15]  (if true) or overwrite the                         previous content. The result is undefined in case                         values_in and values_out point to the same array and                          [2.x.16]  is true, in which case an                         exception is thrown.      [2.x.17]  values_in    The array of the input of size basis_size_2^dim. It                         may alias with values_out. Note that the previous                         content of  [2.x.18]  is overwritten within the                         function.      [2.x.19]  values_out   The array of size basis_size_1^dim where the results                         of the transformation are stored. It may alias with                         the  [2.x.20]  array.      [2.x.21]  basis_size_1_variable In case the template argument basis_size_1     is zero, the size of the first basis can alternatively be passed in as a     run time argument. The template argument takes precedence in case it is     nonzero for efficiency reasons.      [2.x.22]  basis_size_2_variable In case the template argument basis_size_1     is zero, the size of the second basis can alternatively be passed in as a     run time argument.    
* [0.x.5]*
     This operation applies a mass-matrix-like operation, consisting of a     do_forward() operation, multiplication by the coefficients in the     quadrature points, and the do_backward() operation.          [2.x.23]  n_components The number of vector components.      [2.x.24]  transformation_matrix The coefficient matrix handed in as a                         vector, using  [2.x.25]  rows and  [2.x.26]                          columns if interpreted as a matrix.      [2.x.27]  coefficients The array of coefficients by which the result is                         multiplied. Its length must be either                         basis_size_2^dim or n_components*basis_size_2^dim.      [2.x.28]  values_in    The array of the input of size basis_size_2^dim. It                         may alias with values_out.      [2.x.29]  scratch_data Array to hold temporary data during the operation.                         Must be of length basis_size_2^dim.      [2.x.30]  values_out   The array of size basis_size_1^dim where the results                         of the transformation are stored. It may alias with                         the values_in array.    
* [0.x.6]*
   This struct performs the evaluation of function values, gradients and   Hessians for tensor-product finite elements. This a specialization for   elements where the nodal points coincide with the quadrature points like   FE_Q shape functions on Gauss-Lobatto elements integrated with   Gauss-Lobatto quadrature. The assumption of this class is that the shape   'values' operation is identity, which allows us to write shorter code.     In literature, this form of evaluation is often called spectral   evaluation, spectral collocation or simply collocation, meaning the same   location for shape functions and evaluation space (quadrature points).  
* [0.x.7]*
   This struct performs the evaluation of function values, gradients and   Hessians for tensor-product finite elements. This a specialization for   symmetric basis functions about the mid point 0.5 of the unit interval   with the same number of quadrature points as degrees of freedom. In that   case, we can first transform the basis to one that has the nodal points   in the quadrature points (i.e., the collocation space) and then perform   the evaluation of the first and second derivatives in this transformed   space, using the identity operation for the shape values.  
* [0.x.8]*
   This class chooses an appropriate evaluation strategy based on the   template parameters and the shape_info variable which contains runtime   parameters for the strategy underlying  [2.x.31]  i.e.   this calls  [2.x.32]     [2.x.33]  or    [2.x.34]  with   appropriate template parameters. In case the template parameters   fe_degree and n_q_points_1d contain valid information (i.e. fe_degree>-1   and n_q_points_1d>0), we simply pass these values to the respective   template specializations.  Otherwise, we perform a runtime matching of   the runtime parameters to find the correct specialization. This matching   currently supports  [2.x.35]  and  [2.x.36] .  
* [0.x.9]*
   This class chooses an appropriate evaluation strategy based on the   template parameters and the shape_info variable which contains runtime   parameters for the strategy underlying  [2.x.37]  i.e.   this calls  [2.x.38]     [2.x.39]  or    [2.x.40]  with   appropriate template parameters. In case the template parameters   fe_degree and n_q_points_1d contain valid information (i.e. fe_degree>-1   and n_q_points_1d>0), we simply pass these values to the respective   template specializations.  Otherwise, we perform a runtime matching of   the runtime parameters to find the correct specialization. This matching   currently supports  [2.x.41]  and  [2.x.42] .  
* [0.x.10]*
     Interpolate the values on the cell quadrature points onto a face.    
* [0.x.11]*
   This struct implements the action of the inverse mass matrix operation   using an FEEvaluationBaseData argument.  
* [0.x.12]*
   This struct implements the action of the inverse mass matrix operation   using an FEEvaluationBaseData argument.  
* [0.x.13]*
     Version for degree =
* 
*  -     
* [0.x.14]*
   This struct implements the action of the inverse mass matrix operation   using an FEEvaluationBaseData argument.  
* [0.x.15]