[0.x.0]*
 The ParameterHandler class provides a standard interface to an input file which provides at run-time for program parameters such as time step sizes, geometries, right hand sides etc. The input for the program is given in files, streams or strings in memory using text like  
* [1.x.0]
*  Input may be sorted into subsection trees in order to give the input a logical structure, and input files may include other files.
*  The ParameterHandler class is discussed in  [2.x.0] ,  [2.x.1] , and  [2.x.2] .
*  [1.x.1]
*  In order to use the facilities of a ParameterHandler object, one first has to make known the different entries the input file may or may not contain. This is done in the following way:
*   
* [1.x.2]
*  Each entry is declared using the function declare_entry(). The first parameter is the name of the entry (in short: the entry). The second is the default answer to be taken in case the entry is not specified in the input file. The third parameter is a regular expression which the input (and the default answer) has to match.  Several such regular expressions are defined in Patterns. This parameter can be omitted, in which case it will default to  [2.x.3]  i.e. a pattern that matches every input string. The fourth parameter can be used to document the intent or expected format of an entry; its value is printed as a comment when writing all entries of a ParameterHandler object using the print_parameters() function to allow for easier understanding of a parameter file. It can be omitted as well, in which case no such documentation will be printed.
*  Entries may be located in subsections which form a kind of input tree. For example input parameters for linear solver routines should be classified in a subsection named <tt>Linear solver</tt> or any other suitable name. This is accomplished in the following way:

* 
* [1.x.3]
* 
*  Subsections may be nested. For example a nonlinear solver may have a linear solver as member object. Then the function call tree would be something like (if the class <tt>NonLinEq</tt> has a member variables <tt>eq</tt> of type <tt>LinEq</tt>):

* 
* [1.x.4]
* 
*  For class member functions which declare the different entries we propose to use the common name <tt>declare_parameters</tt>. In normal cases this method can be <tt>static</tt> since the entries will not depend on any previous knowledge. Classes for which entries should logically be grouped into subsections should declare these subsections themselves. If a class has two or more member variables of the same type both of which should have their own parameters, this parent class' method <tt>declare_parameters</tt> is responsible to group them into different subsections:

* 
* [1.x.5]
* 
* 

*  [1.x.6]
*  For the first example above the input file would look like the following:  
* [1.x.7]
*  The words <tt>subsection</tt>, <tt>set</tt> and <tt>end</tt> may be either written in lowercase or uppercase letters. Leading and trailing whitespace is removed, multiple whitespace is condensed into only one. Since the latter applies also to the name of an entry, an entry name will not be recognized if in the declaration multiple whitespace is used.
*  In entry names and values the following characters are not allowed: <tt>\#</tt>, <tt>{</tt>, <tt>}</tt>, <tt>|</tt>. Their use is reserved for the MultipleParameterLoop class.
*  Comments starting with \# are skipped.
*  Continuation lines are allowed by means of the character <tt>\\</tt>, which must be the last character (aside from whitespace, which is ignored) of the line. When a line is a continuation (i.e., the previous line ended in a <tt>\\</tt>), then, unlike the default behavior of the <tt>C</tt> preprocessor, all whitespace at the beginning of the line is ignored.
*  We propose to use the following scheme to name entries: start the first word with a capital letter and use lowercase letters further on. The same applies to the possible entry values to the right of the <tt>=</tt> sign.
* 

*  [1.x.8]
*  An input file can include other include files using the syntax  
* [1.x.9]
*  The file so referenced is searched for relative to the current directory (not relative to the directory in which the including parameter file is located, since this is not known to all three versions of the parse_input() function).
* 

*  [1.x.10]
*  In order to read input there are three possibilities: reading from an  [2.x.4]  object, reading from a file of which the name is given and reading from a string in memory in which the lines are separated by <tt> [2.x.5]  characters. These possibilities are used as follows:  
* [1.x.11]
*  You can use several sources of input successively. Entries which are changed more than once will be overwritten every time they are used.
*  You should not try to declare entries using declare_entry() and enter_subsection() with as yet unknown subsection names after using parse_input(). The results in this case are unspecified.
*  If an error occurs upon reading the input, error messages are written to  [2.x.6]  and the reader function returns with a return value of  [2.x.7] . This is opposed to almost all other functions in deal.II, which would normally throw an exception if an error occurs; this difference in behavior is a relic of the fact that this class predates deal.II and had previously been written for a different project.
* 

*  [1.x.12]
*  An alternative to using the hand-written input files shown above is to use the graphical user interface (GUI) that accompanies this class.
*  See [1.x.13] for further details.
*  [1.x.14]
*  Each class gets its data out of a ParameterHandler object by calling the get()  member functions like this:  
* [1.x.15]
*  get() returns the value of the given entry. If the entry was not specified in the input source(s), the default value is returned. You have to enter and leave subsections exactly as you did when declaring subsections. You may choose the order in which to traverse the subsection tree.
*  It is possible to avoid calls to enter_subsection() and leave_subsection() by supplying get() with a vector of strings representing the path from which to get a value. For example, the following two versions of get_parameters() will produce the same result:  
* [1.x.16]
* 
*   
* [1.x.17]
* 
*  The latter method allows the ParameterHandler reference to be  [2.x.8] 
*  It is guaranteed that only entries matching the given regular expression are returned, i.e. an input entry value which does not match the regular expression is not stored.
*  You can use get() to retrieve the parameter in text form, get_integer() to get an integer or get_double() to get a double. You can also use get_bool(). It will cause an internal error if the string could not be converted to an integer, double or a bool. This should, though, not happen if you correctly specified the regular expression for this entry; you should not try to get out an integer or a double from an entry for which no according regular expression was set. The internal error is raised through the Assert() macro family which only works in debug mode.
*  If you want to print out all user selectable features, use the print_parameters() function. It is generally a good idea to print all parameters at the beginning of a log file, since this way input and output are together in one file which makes matching at a later time easier. Additionally, the function also print those entries which have not been modified in the input file and are thus set to default values; since default values may change in the process of program development, you cannot know the values of parameters not specified in the input file.
* 

* 
*  [1.x.18]
*  It is often convenient to have something happen as soon as a parameter value is read. This could be a check that it is valid
* 
*  -  say, that a file that is listed in the parameter file exists
* 
*  -  or to initiate something else in response, such as setting a variable outside the ParameterHandler (as in the example shown below). In almost all cases, this "action" could also be initiated once all parameters are read via parse_input(), but it is sometimes [1.x.19] to do it right away.
*  This is facilitated by the add_action() function that can be called after declaring a parameter via declare_entry(). "Actions" are in essence pointers to functions that will be called for parameters that have associated actions. These functions take the value of a parameter as argument, and can then do whatever they want with it
* 
*  -  e.g., save it somewhere outside the ParameterHandler object. (Exactly when the action is called is described in the documentation of the add_action() function.) Of course, in C++ one doesn't usually pass around the address of a function, but an action can be a function-like object (taking a string as argument) that results from calling such as a [1.x.20] that has the form

* 
* [1.x.21]
*  and that is attached to a specific parameter.
*  A typical example of such an action would be as follows: let's assume that you have a program that declares a parameter for the number of iterations it is going to run, say

* 
* [1.x.22]
*  then one could obtain this parameter from a parameter file using a code snippet in  [2.x.9]  as follows:

* 
* [1.x.23]
* 
*  This two-step process
* 
*  -  first declaring the parameter, and later reading it
* 
*  -  is a bit cumbersome because one has to first declare [1.x.24] parameters and at a later time retrieve them from the ParameterHandler object. In large programs, these two things also often happen in different functions.
*  To avoid this, it would be nice if we could put both the declaration and the retrieval into the same place. This can be done via actions, and the function would then look like this:

* 
* [1.x.25]
*  Here, the action consists of a lambda function that takes the value for this parameter as a string, and then converts it to an integer to store in the variable where it belongs. This action is executed inside the call to  [2.x.10] , and so there is now no longer a need to extract the parameter's value at a later time. Furthermore, the code that sets the member variable is located right next to the place where the parameter is actually declared, so we no longer need to have two separate parts of the code base that deal with input parameters.
*  Of course, it is possible to execute far more involved actions than just setting a member variable as shown above, even though that is a typical case.
* 

*  [1.x.26]
*  We propose that every class which gets data out of a ParameterHandler object provides a function named <tt>get_parameters</tt>. This should be declared <tt>virtual</tt>. <tt>get_parameters</tt> functions in derived classes should call the  [2.x.11]  function.
* 

*  [1.x.27]
*  Experience has shown that in programs defining larger numbers of parameters (more than, say, fifty) it is advantageous to define an additional class holding these parameters. This class is more like a C-style structure, having a large number of variables, usually public. It then has at least two functions, which declare and parse the parameters. In the main program, the main class has an object of this parameter class and delegates declaration and parsing of parameters to this object.
*  The advantage of this approach is that you can keep out the technical details (declaration and parsing) out of the main class and additionally don't clutter up your main class with dozens or more variables denoting the parameters.
* 

* 
*  [1.x.28]
*  This is the code:  
* [1.x.29]
* 
* 

*  This is the input file (named "prmtest.prm"):  
* [1.x.30]
* 
*  And here is the output of the program:  
* [1.x.31]
* 
* 

* 
*  [1.x.32]
*  Here is some more internal information about the representation of parameters:
*  Logically, parameters and the nested sections they are arranged in can be thought of as a hierarchical directory structure, or a tree. Take, for example, the following code declaring a set of parameters and sections they live in:  
* [1.x.33]
* 
*  We can think of the parameters so arranged as a file system in which every parameter is a directory. The name of this directory is the name of the parameter, and in this directory lie files that describe the parameter. These files are at the time of writing this documentation (other fields, such as those indicating "actions" may also exist in each directory):
* 

* 
* 
*  -  [2.x.12] : The content of this file is the current value of this parameter; initially, the content of the file equals the default value of the parameter.
* 

* 
* 
*  -  [2.x.13] : The content of this file is the default value of the parameter.
* 

* 
* 
*  -  [2.x.14] : A textual representation of the pattern that describes the parameter's possible values.
* 

* 
* 
*  -  [2.x.15] : A number that indexes the  [2.x.16]  object that is used to describe the parameter.
* 

* 
* 
*  -  [2.x.17] : The content of this file is the documentation given for a parameter as the last argument of the  [2.x.18]  call. With the exception of the  [2.x.19]  file, the contents of files are never changed after declaration of a parameter.
*  Alternatively, a directory in this file system may not have a file called  [2.x.20]  in it. In that case, the directory represents a subsection as declared above, and the directory's name will correspond to the name of the subsection. It will then have no files in it at all, but it may have further directories in it: some of these directories will be parameters (indicates by the presence of files) or further nested subsections.
*  Given this explanation, the code above will lead to a hierarchical representation of data that looks like this (the content of files is indicated at the right in a different font):
*   [2.x.21] 
*  Once parameters have been read in, the contents of the  [2.x.22]  "files" may be different while the other files remain untouched.
*  Using the  [2.x.23]  function with  [2.x.24]  as second argument, we can get a complete representation of this data structure in XML. It will look like this:  
* [1.x.34]
*  This representation closely resembles the directory/file structure discussed above. The only difference is that directory and file names are mangled: since they should only contain letters and numbers, every character in their names that is not a letter or number is replaced by an underscore followed by its two-digit hexadecimal representation. In addition, the special name "value" is mangled when used as the name of a parameter, given that this name is also used to name special files in the hierarchy structure. Finally, the entire tree is wrapped into a tag  [2.x.25]  to satisfy the XML requirement that there be only a single top-level construct in each file.
*  The tree structure (and its XML representation) is what the graphical user interface (see above) uses to represent parameters like a directory/file collection.
* 

* 

* 
*  [2.x.26] 

* 
* [0.x.1]*
   List of possible output formats used for functions like    [2.x.27]  The options can be categorized into   two groups:
* 

* 
* 

* 
* 

* 
* 
*  - format options: PRM, LaTeX, Description, XML, JSON
* 

* 
* 

* 
* 

* 
* 
*  - stylistic options: Short, KeepDeclarationOrder     Only one format option may be specified at the time. Any function that   accepts an OutputStyle as an option will throw if you specify more than   one.     A number of shortcuts of commonly used option combinations are provided.   E.g., ShortPRM prints the parameters in the PRM format, while skipping the   documentation.  
* [0.x.2]*
     Default stylistic style: print documentation and sort all parameters     alphabetically.    
* [0.x.3]*
     Write input for ParameterHandler without comments or changed default     values.    
* [0.x.4]*
     Keep the order of the parameters as they have been declared.    
* [0.x.5]*
     Write human readable output suitable to be read by      [2.x.28]  again.    
* [0.x.6]*
     Write human readable output suitable to be read by      [2.x.29]  again.          [2.x.30]  Use `PRM` instead of `Text`.    
* [0.x.7]*
     Write parameters as a LaTeX table.    
* [0.x.8]*
     Write out declared parameters with description and possible values.        
*  [2.x.31]  This format is not suitable to be read back again.    
* [0.x.9]*
     Write out everything as an [1.x.35] file suitable to be read     by  [2.x.32]  again.         See the general documentation of this class for an example of output.    
* [0.x.10]*
     Write out everything as a [1.x.36] file suitable to be     read by  [2.x.33]  again.    
* [0.x.11]*
     Write the content of ParameterHandler without comments or changed default     values.    
* [0.x.12]*
     Write the content of ParameterHandler without comments or changed default     values.          [2.x.34]  Use `ShortPRM` instead of `ShortText`.    
* [0.x.13]*
     Write the content of ParameterHandler without comments or changed default     values as a XML file.    
* [0.x.14]*
     Write the content of ParameterHandler without comments or changed default     values as a JSON file.    
* [0.x.15]*
     Write the content of ParameterHandler without comments or changed default     values as a LaTeX file.    
* [0.x.16]*
   Constructor.  
* [0.x.17]*
   Destructor. Declare this only to have a virtual destructor, which is   safer as we have virtual functions.  It actually does nothing   spectacular.  
* [0.x.18]*
   Inhibit automatic CopyConstructor.  
* [0.x.19]*
   Inhibit automatic assignment operator.  
* [0.x.20]*
   Parse each line from a stream until the stream returns the <tt>eof</tt>   condition or error to provide values for known parameter fields. The second   argument can be used to denote the name of the file (if that's what the   input stream represents) we are reading from; this is only used when   creating output for exceptions.     If non-empty  [2.x.35]  is provided, the ParameterHandler object   will stop parsing lines after encountering  [2.x.36]  .   This is handy when adding extra data that shall be parsed manually.     If  [2.x.37]  is  [2.x.38] , the parameter handler   will skip undefined sections and entries. This is useful for partially   parsing a parameter file, for example to obtain only the spatial dimension   of the problem. By default all entries and subsections are expected to be   declared.     The function sets the value of all parameters it encounters in the   input file to the provided value. Parameters not explicitly listed   in the input file are left at the value they previously held, which   will be the default value provided to declare_entry() unless one   has previously read a different input file.     Each parameter value is matched against the pattern for this   parameter that was provided to declare_entry(), and for each parameter   all associated actions that may previously have been set by   add_action() are executed. If a parameter does not satisfy its   pattern, or if an associated action throws an exception, then the   value provided for the parameter is not set and the current   object reverts to the subsection it was in before the current   function was called. No further processing of the input stream   occurs, that is everything that comes after the parameter whose   value does not satisfy its pattern is ignored.  
* [0.x.21]*
   Parse input from a specified parameter file  [2.x.39]  independently   of the type of input file (prm, xml, json) being used. The code path   selected by this function is extracted from the ending of the filename,   so the user has to make sure that the content of the input file is   consistent with its name.     The parameter  [2.x.40]  will only be used for parameter files of .prm type.   See the other parse_input function for documentation.     The user can specify whether parameters in the input file not added to the   parameter handler will be skipped by  [2.x.41]  (enables partial   parsing), and whether the code will assert that all parameters of the   parameter handler declared with flag `has_to_be_set=true` are indeed found   in the input file.     If the function is called with `skip_undefined=true`, it is recommended to   also set `assert_mandatory_entries_are_found=true`. For example, this   ensures that parameters with typos in the input file will not be skipped,   while such mistakes would otherwise remain unrecognized.  
* [0.x.22]*
   Parse input from a string to populate known parameter fields. The lines   in the string must be separated by <tt> [2.x.42]  characters.     The function in essence reads the entire file into a stream and   then calls the other parse_input() function with that stream. See   there for more information.  
* [0.x.23]*
   Parse input from an XML stream to populate known parameter fields. This   could be from a file originally written by the print_parameters() function   using the XML output style and then modified by hand as necessary, or from   a file written using this method and then modified by the graphical   parameter GUI (see the general documentation of this class).  
* [0.x.24]*
   Parse input from a JSON stream to populate known parameter fields. This   could be from a file originally written by the print_parameters() function   using the JSON output style and then modified by hand as necessary, or from   a separate program that knows how to write JSON format for ParameterHandler   input.  
* [0.x.25]*
   Clear all contents.  
* [0.x.26]*
   Declare a new entry with name <tt>entry</tt>, default and for which any   input has to match the <tt>pattern</tt> (default: any pattern).     The function generates an exception of type ExcValueDoesNotMatchPattern   if the default value doesn't match the given pattern, using the C++ throw   mechanism. However, this exception is only generated [1.x.37] the   entry has been created; if you have code where no sensible default value   for a parameter is possible, you can then catch and ignore this   exception.     The parameter  [2.x.43]  defaulting to an empty string is used   to add a documenting text to each entry which will be printed as a comment   when this class is asked to write out all declarations to a stream using   the print_parameters() function.     The parameter  [2.x.44]  can be used in order to declare this   parameter as a parameter whose default value has to be overwritten by   one of the methods provided by this class. Whether a parameter has been set   successfully can be queried by the functions get_entries_wrongly_not_set()   and assert_that_entries_have_been_set().    
*  [2.x.45]  An entry can be declared more than once without generating an   error, for example to override an earlier default value.  
* [0.x.27]*
   Attach an action to the parameter with name  [2.x.46]  in the current   section. The action needs to be a function-like object that takes the   value of the parameter as a (string) argument. See the general   documentation of this class for a longer description of actions, as well as   examples.     The action is executed in three different circumstances:
* 

* 
* 

* 
* 

* 
* 
*  - With the default value of the parameter with name  [2.x.47]  at     the end of the current function. This is useful because it allows     for the action to execute whatever it needs to do at least once     for each parameter, even those that are not actually specified in     the input file (and thus remain at their default values).
* 

* 
* 

* 
* 

* 
* 
*  - Within the  [2.x.48]  functions that explicitly     set a value for a parameter.
* 

* 
* 

* 
* 

* 
* 
*  - Within the parse_input() function and similar functions such     as parse_input_from_string(). Here, the action is executed     whenever the parameter with which it is associated is read     from the input, after it has been established that the value     so read matches the pattern that corresponds to this parameter,     and before the value is actually saved.     It is valid to add multiple actions to the same parameter. They will   in that case be executed in the same order in which they were added.    
*  [2.x.49]  Actions may modify all sorts of variables in their scope. The    only thing an action should not modify is the ParameterHandler object    it is attached to. In other words, it is not allowed to enter or    leave sections of the current ParameterHandler object. It is, in    principle, acceptable to call  [2.x.50]  and related    functions on other parameters in the current section, but since    there is no guarantee about the order in which they will be read    from an input file, you will not want to rely on the values these    functions would return.    
*  [2.x.51]  Throwing an exception in an action is generally not a good    idea, but yields fundamentally the same result as if one tries to    read a parameter from a file for which the value does not satisfy    the pattern associated with the parameter. In other words, the    value just read is discarded, and  [2.x.52]     stops to read any further content from the file. See     [2.x.53]  for more information.  
* [0.x.28]*
   Declare a new entry name  [2.x.54]  set its default value to the content of   the variable  [2.x.55]  and create an action that will fill  [2.x.56]    parameter with updated values when a file is parsed, or the entry is set   to a new value.     By default, the pattern to use is obtained by calling the function    [2.x.57]  but a custom one can be used.     The parameter  [2.x.58]  can be used in order to declare this   parameter as a parameter whose default value has to be overwritten by   one of the methods provided by this class. Whether a parameter has been set   successfully can be queried by the functions get_entries_wrongly_not_set()   and assert_that_entries_have_been_set().  
* [0.x.29]*
   Create an alias for an existing entry. This provides a way to refer to a   parameter in the input file using an alternate name. The alias will be in   the current section, and the referenced entry needs to be an existing   entry in the current section.     The primary purpose of this function is to allow for a backward   compatible way of changing names in input files of applications for which   backward compatibility is important. This can be achieved by changing the   name of the parameter in the call to declare_entry(), and then creating   an alias that maps the old name to the new name. This way, old input   files can continue to refer to parameters under the old name, and they   will automatically be mapped to the new parameter name.     It is valid to set the same parameter multiple times in an input file.   The value that will ultimately be chosen in such cases is simply the last   value set. This rule also applies to aliases, where the final value of a   parameter is the last value set either through the current name of the   parameter or through any of its possible multiple aliases. For example,   if you have an input file that looks like  
* [1.x.38]
*    where  [2.x.59]  is an alias declared via  
* [1.x.39]
*    then the final value for the parameter called  [2.x.60]  will be   2, not 1.      [2.x.61]  existing_entry_name The name of an existing parameter in the   current section that the alias should refer to.    [2.x.62]  alias_name An alternate name for the parameter referenced by the   first argument.    [2.x.63]  alias_is_deprecated If true, mark the alias as deprecated. This   will then be listed in the description of the alias if you call   print_parameters(), and you will get a warning on the screen when reading   an input file that contains this deprecated alias. The purpose of this   argument is to be able to allow the use of an old name for a parameter   (see above) but make it clear that this old name will eventually be   removed.  
* [0.x.30]*
   Enter a subsection. If it does not yet exist, create it.  
* [0.x.31]*
   Leave present subsection.  
* [0.x.32]*
   Check whether a subsection or a subsection path exists in current tree.   The input parameter  [2.x.64]  is assumed to be relative to the   currently selected path.  
* [0.x.33]*
   Return value of entry  [2.x.65]   If the entry was changed,   then the changed value is returned, otherwise the default value. If the   value of an undeclared entry is required, an  [2.x.66]  will fail.  
* [0.x.34]*
   Return value of entry  [2.x.67]   If the entry was changed,   then the changed value is returned, otherwise the default value. If the   value of an undeclared entry is required, an  [2.x.68]  will fail.   If  [2.x.69]  is non-empty, the value will be gotten   from the subsection represented by that path instead of the current   subsection. The first string in  [2.x.70]  must be the name   of a subsection of the current section, and each next string must be the   name of a subsection of the one before it.  
* [0.x.35]*
   Return value of entry  [2.x.71]  as  [2.x.72] . (A long   int is chosen so that even very large unsigned values can be returned by   this function).  
* [0.x.36]*
   Return value of entry  [2.x.73]  as  [2.x.74] . (A long   int is chosen so that even very large unsigned values can be returned by   this function).   If  [2.x.75]  is non-empty, the value will be gotten   from the subsection represented by that path instead of the current   subsection.  
* [0.x.37]*
   Return value of entry  [2.x.76]  as  [2.x.77]   
* [0.x.38]*
   Return value of entry  [2.x.78]  as  [2.x.79]    If  [2.x.80]  is non-empty, the value will be gotten   from the subsection represented by that path instead of the current   subsection.  
* [0.x.39]*
   Return value of entry  [2.x.81]  as  [2.x.82]  The entry may   be "true" or "yes" for  [2.x.83]  "false" or "no" for  [2.x.84]    respectively.  
* [0.x.40]*
   Return value of entry  [2.x.85]  as  [2.x.86]  The entry may   be "true" or "yes" for  [2.x.87]  "false" or "no" for  [2.x.88]    respectively.   If  [2.x.89]  is non-empty, the value will be gotten   from the subsection represented by that path instead of the current   subsection.  
* [0.x.41]*
   Change the value presently stored for <tt>entry_name</tt> to the one   given in the second argument.     The parameter must already exist in the present subsection.     The function throws an exception of type ExcValueDoesNotMatchPattern if   the new value does not conform to the pattern for this entry.  
* [0.x.42]*
   Same as above, but an overload where the second argument is a character   pointer. This is necessary, since otherwise the call to    [2.x.90]  will be mapped to the function taking one   string and a bool as arguments, which is certainly not what is most often   intended.     The function throws an exception of type ExcValueDoesNotMatchPattern if   the new value does not conform to the pattern for this entry.  
* [0.x.43]*
   Change the value presently stored for <tt>entry_name</tt> to the one   given in the second argument.     The parameter must already exist in the present subsection.     The function throws an exception of type ExcValueDoesNotMatchPattern if   the new value does not conform to the pattern for this entry.  
* [0.x.44]*
   Change the value presently stored for <tt>entry_name</tt> to the one   given in the second argument.     The parameter must already exist in the present subsection.     For internal purposes, the new value needs to be converted to a string.   This is done using 16 digits of accuracy, so the set value and the one   you can get back out using get_double() may differ in the 16th digit.     The function throws an exception of type ExcValueDoesNotMatchPattern if   the new value does not conform to the pattern for this entry.  
* [0.x.45]*
   Change the value presently stored for <tt>entry_name</tt> to the one   given in the second argument.     The parameter must already exist in the present subsection.     The function throws an exception of type ExcValueDoesNotMatchPattern if   the new value does not conform to the pattern for this entry.  
* [0.x.46]*
   Print all parameters with the given  [2.x.91]  to  [2.x.92]      Before printing, all current parameters and subsections are sorted   alphabetically by default.   This behavior can be disabled setting the optional parameter  [2.x.93]    to <tt>KeepDeclarationOrder</tt>: in this case entries are printed in the   same order as they have been declared.     In <tt>PRM</tt>, <tt>XML</tt>, and <tt>JSON</tt> format, the output is   formatted in such a way that it is   possible to use it for later input again. This is most useful to record   the parameters for a specific run, since if you output the parameters   using this function into a log file, you can always recover the results   by simply copying the output to your input file.     Besides the name and value of each entry, the output also contains the   default value of entries if it is different from the actual value, as   well as the documenting string given to the declare_entry() function if   available.     By using the flag <tt>Short</tt> in combination with <tt>PRM</tt>,   <tt>XML</tt>, <tt>JSON</tt>, or <tt>LaTeX</tt> (or by using the shortcuts   <tt>ShortPRM</tt>, <tt>ShortXML</tt>, <tt>ShortJSON</tt>, or   <tt>ShortLaTeX</tt>), a reduced output can be generated, only containing   the values and skipping the documentation.     In <tt>XML</tt> format, the output starts with one root element   <tt>ParameterHandler</tt> in order to get a valid XML document and all   subsections under it.     In <tt>LaTeX</tt> format, the output contains the same information but in   a format so that the resulting file can be input into a latex document   such as a manual for the code for which this object handles run-time   parameters. The various sections of parameters are then represented by   latex section and subsection commands as well as by nested enumerations.     You can reference specific parameter sections and individual parameters   by the labels that are generated automatically for each entry. The   labels have the format  [2.x.94]    and  [2.x.95] . Because   special characters can appear in the section and entry names, these   will be "mangled". Here, all characters except  [2.x.96]    are replaced by  [2.x.97]  is the two-digit   ascii code of the character in hexadecimal encoding (so a space becomes    [2.x.98]  for example).     While this function escapes special LaTeX-specific characters (backslash,   underscore, etc.) in most of the output (names, default values, etc.),   the documentation string is passed as-is. This means you can use math   environments and other formatting in the description, but you need   to escape quotes, backslashes, underscores, etc. yourself.     In addition, all parameter names are listed with  [2.x.99]    statements in two indices called  [2.x.100]  (where the name of   each parameter is listed in the index) and  [2.x.101]    where parameter names are listed sorted by the section in which they   exist. By default, the LaTeX program ignores these  [2.x.102]    commands, but they can be used to generate an index by using the   following commands in the preamble of the latex file:  
* [1.x.40]
*    and at the end of the file this:  
* [1.x.41]
*   
* [0.x.47]*
   Print all parameters to the file given by  [2.x.103]  with the given output   style  [2.x.104]      This function deduces the output format from the extension of the specified   filename. Supported extensions are `prm`, `xml`, `tex`, and `json`. Hence,   it is not necessary to specify an output format via the  [2.x.105]  argument   as long as one of these extensions is added to the filename. If an output   format is specified in the  [2.x.106]  parameter nevertheless, the output   format has to be consistent with the filename extension.     If no extension is specified or the extension is not supported, the   output format is deduced from the  [2.x.107]  argument.     If neither the extension is supported, nor does the  [2.x.108]  parameter   contain a format specification, an assertion is thrown.      [2.x.109]  filename The output file name.    [2.x.110]  style The style with which output is produced.  
* [0.x.48]*
   Print parameters to a logstream. This function allows to print all   parameters into a log-file. Sections will be indented in the usual log-   file style.     All current parameters and subsections are sorted   alphabetically by default.   This behavior can be disabled setting the optional parameter  [2.x.111]    to <tt>KeepDeclarationOrder</tt>: in this case entries are printed in the   same order as they have been declared.    
*  [2.x.112]  All style settings in  [2.x.113]  not related to the ordering are     ignored.  
* [0.x.49]*
   Log parameters in the present subsection. The subsection is determined by   the <tt>subsection_path</tt> member variable. This variable is controlled   by entering and leaving subsections through the enter_subsection() and   leave_subsection() functions.     All current parameters and subsections are sorted   alphabetically by default.   This behavior can be disabled setting the optional parameter  [2.x.114]    to <tt>KeepDeclarationOrder</tt>: in this case entries are printed in the   same order as they have been declared.    
*  [2.x.115]  All style settings in  [2.x.116]  not related to the ordering are     ignored.     In most cases, you will not want to use this function directly, but have   it called recursively by the previous function.  
* [0.x.50]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.51]*
   Write the data of this object to a stream for the purpose of   serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.52]*
   Read the data of this object from a stream for the purpose of   serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.53]*
   Write and read the data of this object from a stream for the purpose   of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.54]*
   Test for equality.  
* [0.x.55]*
   Return a set of parameter names (including subsection names) corresponding   to those entries of the parameter handler that have not been set by one of   the functions parsing parameters from an input file or by an explicit call   to one of the set() functions, but that have been declared as mandatory   parameters that must be set (through the last argument of the   declare_entry() function or add_parameter() function).  
* [0.x.56]*
   Asserts that those entries of the parameter handler with flag   `has_to_be_set = true` have been set. An exception is invoked   if at least one of these parameters has not been set.  
* [0.x.57]*
    [2.x.117]  Exceptions    [2.x.118]   
* [0.x.58]*
   Exception  
* [0.x.59]*
   Exception  
* [0.x.60]*
   Exception  
* [0.x.61]*
   Exception  
* [0.x.62]*
   Exception for when there are an unequal number of 'subsection' and 'end'   statements. The first argument is the name of the file and the second   argument is a formatted list of the subsection path before and after   entering the parser.  
* [0.x.63]*
   Exception for when, during parsing of a parameter file, the parser   encounters a subsection in the file that was not previously declared.  
* [0.x.64]*
   General exception for a line that could not be parsed, taking, as   arguments, the line number, file name, and a brief description of why the   line cannot be parsed.  
* [0.x.65]*
   Exception for an entry in a parameter file that does not match the   provided pattern. The arguments are, in order, the line number, file   name, entry value, entry name, and a description of the pattern.  
* [0.x.66]*
   Exception for when an XML file cannot be read at all. This happens when   there is no top-level XML element called "ParameterHandler" or when there   are multiple top level elements.  
* [0.x.67]*
   Exception for when an entry in an XML parameter file does not match the   provided pattern. The arguments are, in order, the entry value, entry   name, and a description of the pattern.      [2.x.119]  Use ExcValueDoesNotMatchPattern instead of ExcInvalidEntryForPatternXML.  
* [0.x.68]*
   Exception for when the file given in an include statement cannot be   open. The arguments are, in order, the line number of the include   statement, current parameter file name, and the name of the file intended   for inclusion.  
* [0.x.69]*
   The separator used when accessing elements of a path into the parameter   tree.  
* [0.x.70]*
   Path of presently selected subsections; empty list means top level  
* [0.x.71]*
   The complete tree of sections and entries. See the general documentation   of this class for a description how data is stored in this variable.     The variable is a pointer so that we can use an incomplete type, rather   than having to include all of the property_tree stuff from boost. This   works around a problem with gcc 4.5.  
* [0.x.72]*
   A map that stores a pair of boolean variables for each entry   added to the parameter handler. The first bool describes whether the   parameter has to be set according to the last argument of the functions   declare_entry() or add_parameter(), and the second bool contains the   information whether the parameter has been set by any of the functions   parsing input parameters or by a set function of this class.  
* [0.x.73]*
   A list of patterns that are used to describe the parameters of this   object. Every nodes in the property tree corresponding to a parameter   stores an index into this array.  
* [0.x.74]*
   A list of actions that are associated with parameters. These   are added by the add_action() function. Nodes in the property   tree corresponding to individual parameters   store indices into this array in order to reference specific actions.  
* [0.x.75]*
   Return the string that identifies the current path into the property   tree. This is only a path, i.e. it is not terminated by the   path_separator character.     This function simply calls collate_path_string() with    [2.x.120]  as argument  
* [0.x.76]*
   Given the name of an entry as argument, the function computes a full path   into the parameter tree using the current subsection.  
* [0.x.77]*
   This function computes a full path into the parameter tree given a path   from the current subsection and the name of an entry.  
* [0.x.78]*
   Scan one line of input. <tt>input_filename</tt> and   <tt>current_line_n</tt> are the name of the input file and the number of   the line presently scanned (these are used in exception messages to show   where parse errors occurred). This function will raise an exception if   the line contains an undeclared subsection or entry, if the line's entry   does not match its given pattern, or if the line could not be understood   as a valid parameter file expression.     The function modifies its argument, but also takes it by value, so the   caller's variable is not changed.     If  [2.x.121]  is  [2.x.122] , the parser   will skip undefined sections and entries. This is useful for partially   parsing a parameter file, for example to obtain only the spatial dimension   of the problem. By default all entries and subsections are expected to be   declared.  
* [0.x.79]*
   Print out the parameters of the subsection given by the    [2.x.123]  argument, as well as all subsections   within it recursively. This function is called from the   print_parameters() function, and is implemented for all  [2.x.124]    arguments other than XML and JSON (where we can output the   entire set of parameters via BOOST functions). The  [2.x.125]    argument indicates how many spaces the output should be indented,   so that subsections properly nest inside the output of higher   sections.  
* [0.x.80]*
 Global operator which returns an object in which all bits are set which are either set in the first or the second argument. This operator exists since if it did not then the result of the bit-or <tt>operator |</tt> would be an integer which would in turn trigger a compiler warning when we tried to assign it to an object of type  [2.x.126] 

* 
* [0.x.81]*
 The class MultipleParameterLoop offers an easy possibility to test several parameter sets during one run of the program. For this it uses the ParameterHandler class to read in data in a standardized form, searches for variant entry values and performs a loop over all combinations of parameters.
*  Variant entry values are given like this:  
* [1.x.42]
*  The loop will then perform three runs of the program, one for each value of <tt>Time step size</tt>, while all other parameters are as specified or with their default value. If there are several variant entry values in the input, a loop is performed for each combination of variant values:  
* [1.x.43]
*  will result in four runs of the programs, with time step 0.1 and 0.2 for each of the two solvers.
*  In addition to variant entries, this class also supports [1.x.44] that look like this:  
* [1.x.45]
*  This indicates that if there are variant entries producing a total of four different runs, then we will write their results to the files <tt>ofile.1</tt>, <tt>ofile.2</tt>, <tt>ofile.3</tt> and <tt>ofile.4</tt>, respectively. Array entries do not generate multiple runs of the main loop themselves, but if there are variant entries, then in the [1.x.46]th run of the main loop, also the [1.x.47]th value of an array is returned.
*  Since the different variants are constructed in the order of declaration, not in the order in which the variant entries appear in the input file, it may be difficult to guess the mapping between the different variants and the appropriate entry in an array. You will have to check the order of declaration, or use only one variant entry.
*  It is guaranteed that only selections which match the regular expression (pattern) given upon declaration of an entry are given back to the program. If a variant value does not match the regular expression, the default value is stored and an error is issued. Before the first run of the loop, all possible values are checked for their conformance, so that the error is issued at the very beginning of the program.
* 

*  [1.x.48]
*  The usage of this class is similar to the ParameterHandler class. First the entries and subsections have to be declared, then a loop is performed in which the different parameter sets are set, a new instance of a user class is created which is then called. Taking the classes of the example for the ParameterHandler class, the extended program would look like this:  
* [1.x.49]
* 
*  As can be seen, first a new helper class has to be set up. This must contain a virtual constructor for a problem class. You can also derive your problem class from  [2.x.127]  and let <tt>create_new</tt> clear all member variables. If you have access to all inherited member variables in some way this is the recommended procedure. A third possibility is to use multiple inheritance and derive a helper class from both the  [2.x.128]  and the problem class. In any case, <tt>create_new</tt> has to provide a clean problem object which is the problem in the second and third possibility.
*  The derived class also has to provide for member functions which declare the entries and which run the program. Running the program includes getting the parameters out of the ParameterHandler object.
*  After defining an object of this helper class and an object of the MultipleParameterLoop class, the entries have to be declared in the same way as for the ParameterHandler class. Then the input has to be read. Finally the loop is called. This executes the following steps:  
* [1.x.50]
*  <tt>UserObject</tt> is the parameter to the <tt>loop</tt> function. <tt>create_new</tt> is given the number of the run (starting from one) to enable naming output files differently for each run.
* 

*  [1.x.51]
*  Variant values are specified like <tt>prefix{ v1 | v2 | v3 | ... }postfix</tt>. Whitespace to the right of the opening brace <tt>{</tt> is ignored as well as to the left of the closing brace <tt>}</tt> while whitespace on the respectively other side is not ignored. Whitespace around the mid symbols <tt>|</tt> is also ignored. The empty selection <tt>prefix{ v1 | }postfix</tt> is also allowed and produces the strings <tt>prefixv1postfix</tt> and <tt>prefixpostfix</tt>.
*  The syntax for array values is equal, apart from the double braces: <tt>prefix{{ v1 | v2 | v3 }}postfix</tt>.
* 

*  [1.x.52]
*  Given the above extensions to the example program for the ParameterHandler and the following input file  
* [1.x.53]
*  this is the output:  
* [1.x.54]
*  Since <tt>create_new</tt> gets the number of the run it would also be possible to output the number of the run.
* 

* 

* 
*  [2.x.129] 

* 
* [0.x.82]*
   This is the class the helper class or the problem class has to be derived   of.  
* [0.x.83]*
     Destructor. It doesn't actually do anything, but is declared to force     derived classes to have a virtual destructor.    
* [0.x.84]*
     <tt>create_new</tt> must provide a clean object, either by creating a     new one or by cleaning an old one.    
* [0.x.85]*
     Get the parameters and run any necessary action.    
* [0.x.86]*
   Constructor  
* [0.x.87]*
   Destructor. Declare this only to have a virtual destructor, which is   safer as we have virtual functions. It actually does nothing spectacular.  
* [0.x.88]*
   Read input from a stream until the stream returns the <tt>eof</tt>   condition or error. The second argument can be used to denote the name of   the file (if that's what the input stream represents) we are reading   from; this is only used when creating output for error messages.     If non-empty  [2.x.130]  is provided, the ParameterHandler object   will stop parsing lines after encountering  [2.x.131]  .   This is handy when adding extra data that shall be parsed manually.     If  [2.x.132]  is  [2.x.133] , the parameter handler   will skip undefined sections and entries. This is useful for partially   parsing a parameter file, for example to obtain only the spatial dimension   of the problem. By default all entries and subsections are expected to be   declared.    
*  [2.x.134]  This is the only overload of the three <tt>parse_input</tt>   functions implemented by ParameterHandler overridden with new behavior by   this class. This is because the other two <tt>parse_input</tt> functions   just reformat their inputs and then call this version.  
* [0.x.89]*
   Overriding virtual functions which are overloaded (like    [2.x.135]  which has two different sets of input   argument types) causes the non-overridden functions to be hidden. Get   around this by explicitly using both variants of    [2.x.136]  and then overriding the one we care about.  
* [0.x.90]*
   run the central loop.  
* [0.x.91]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.92]*
   An object in the list of entries with multiple values.  
* [0.x.93]*
     Declare what a multiple entry is: a variant entry (in curly braces     <tt>{</tt>, <tt>}</tt>) or an array (in double curly braces     <tt>{{</tt>, <tt>}}</tt>).    
* [0.x.94]*
       A variant entry.      
* [0.x.95]*
       An array entry.      
* [0.x.96]*
     Constructor    
* [0.x.97]*
     Construct an object with given subsection path, name and value. The     splitting up into the different variants is done later by     <tt>split_different_values</tt>.    
* [0.x.98]*
     Split the entry value into the different branches.    
* [0.x.99]*
     Path to variant entry.    
* [0.x.100]*
     Name of entry.    
* [0.x.101]*
     Original variant value.    
* [0.x.102]*
     List of entry values constructed out of what was given in the input     file.    
* [0.x.103]*
     Store whether this entry is a variant entry or an array.    
* [0.x.104]*
     Determine an estimate for the memory consumption (in bytes) of this     object.    
* [0.x.105]*
   List of variant entry values.  
* [0.x.106]*
   Number of branches constructed from the different combinations of the   variants. This obviously equals the number of runs to be performed.  
* [0.x.107]*
   Initialize the different branches, i.e.  construct the combinations.  
* [0.x.108]*
   Traverse the section currently set by   enter_subsection()/leave_subsection() and see which of the entries are   variant or array entries. Then fill the multiple_choices variable using   this information.  
* [0.x.109]*
   Transfer the entry values for one run to the entry tree.  
* [0.x.110]