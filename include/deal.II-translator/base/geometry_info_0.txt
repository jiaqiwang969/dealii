[0.x.0]*
 A class that can represent the kinds of objects a triangulation is made up of: vertices, lines, quads and hexes.
*  The class is rather primitive: it only stores a single integer that represents the dimensionality of the object represented. In other words, this class is useful primarily as a way to pass around an object whose data type explains what it does (unlike just passing around an integer), and for providing symbolic names for these objects such as  [2.x.0]  instead of an integer zero.
*  Since the ability to identify such objects with the integral dimension of the object represented, this class provides conversion operators to and from unsigned integers.

* 
* [0.x.1]*
   An enumeration providing symbolic names for the objects that can be   represented by this class. The numeric values of these symbolic names   equal the geometric dimensionality of the represented objects to make   conversion from and to integer variables simpler.  
* [0.x.2]*
     A vertex.    
* [0.x.3]*
     A line.    
* [0.x.4]*
     A quadrilateral.    
* [0.x.5]*
     A hexahedron.    
* [0.x.6]*
   Constructor. Initialize the object with the given argument representing a   vertex, line, etc.  
* [0.x.7]*
   Constructor. Initialize the object with an integer that should represent   the dimensionality of the geometric object in question. This will usually   be a number between zero (a vertex) and three (a hexahedron).  
* [0.x.8]*
   Return the integral dimension of the object currently represented, i.e.   zero for a vertex, one for a line, etc.  
* [0.x.9]*
   The object currently represented.  
* [0.x.10]*
 A class that provides possible choices for isotropic and anisotropic refinement flags in the current space dimension.
*  This general template is unused except in some weird template constructs. Actual use is made, however, of the specializations  [2.x.1] ,  [2.x.2] , and  [2.x.3] .
* 

* 
*  [2.x.4] 

* 
* [0.x.11]*
   Possible values for refinement cases in the current dimension.     Note the construction of the values: the lowest bit describes a cut of   the x-axis, the second to lowest bit corresponds to a cut of the y-axis   and the third to lowest bit corresponds to a cut of the z-axis. Thus, the   following relations hold (among others):    
* [1.x.0]
*      Only those cuts that are reasonable in a given space dimension are   offered, of course.     In addition, the tag  [2.x.5]  denotes isotropic   refinement in the space dimension selected by the template argument of   this class.     If you choose anisotropic refinement, for example by passing as argument   to  [2.x.6]    one of the flags  [2.x.7]   [2.x.8]     [2.x.9]  or a combination of these, then keep in mind   that refining in x-, y-, or z-direction happens with regard to the    [2.x.10] local [2.x.11]  coordinate system of the cell. In other words, these   flags determine which edges and faces of the cell will be cut into new   edges and faces. On the other hand, this process is independent of   how the cell is oriented within the  [2.x.12] global [2.x.13]  coordinate system,   and you should not assume any particular orientation of the cell's   local coordinate system within the global coordinate system of the   space it lives in.  
* [0.x.12]*
     Do not perform refinement.    
* [0.x.13]*
     Perform isotropic refinement. This implies     refining in all coordinate directions. For the     current general template class
* 
*  -  which is never used     because there are specializations for the 1d, 2d, and 3d     cases
* 
*  - , we simply set this number to a value that has     all bits set. The specializations in     RefinementPossibilities<1>, RefinementPossibilities<2>,     and RefinementPossibilities<3> set the corresponding `enum` element     to more reasonable values.    
* [0.x.14]*
 A class that provides possible choices for isotropic and anisotropic refinement flags in the current space dimension.
*  This specialization is used for  [2.x.14] , where it offers refinement in x-direction.
* 

* 
*  [2.x.15] 

* 
* [0.x.15]*
   Possible values for refinement cases in the current dimension.     Note the construction of the values: the lowest bit describes a cut of   the x-axis, the second to lowest bit corresponds to a cut of the y-axis   and the third to lowest bit corresponds to a cut of the z-axis. Thus, the   following relations hold (among others):    
* [1.x.1]
*      Only those cuts that are reasonable in a given space dimension are   offered, of course.     In addition, the tag  [2.x.16]  denotes isotropic   refinement in the space dimension selected by the template argument of   this class.     If you choose anisotropic refinement, for example by passing as argument   to  [2.x.17]    one of the flags  [2.x.18]   [2.x.19]     [2.x.20]  or a combination of these, then keep in mind   that refining in x-, y-, or z-direction happens with regard to the    [2.x.21] local [2.x.22]  coordinate system of the cell. In other words, these   flags determine which edges and faces of the cell will be cut into new   edges and faces. On the other hand, this process is independent of   how the cell is oriented within the  [2.x.23] global [2.x.24]  coordinate system,   and you should not assume any particular orientation of the cell's   local coordinate system within the global coordinate system of the   space it lives in.  
* [0.x.16]*
     Do not refine.    
* [0.x.17]*
     Perform a cut in the x-direction.    
* [0.x.18]*
     Perform isotropic refinement.    
* [0.x.19]*
 A class that provides possible choices for isotropic and anisotropic refinement flags in the current space dimension.
*  This specialization is used for  [2.x.25] , where it offers refinement in x- and y-direction separately, as well as isotropic refinement in both directions at the same time.
* 

* 
*  [2.x.26] 

* 
* [0.x.20]*
   Possible values for refinement cases in the current dimension.     Note the construction of the values: the lowest bit describes a cut of   the x-axis, the second to lowest bit corresponds to a cut of the y-axis   and the third to lowest bit corresponds to a cut of the z-axis. Thus, the   following relations hold (among others):    
* [1.x.2]
*      Only those cuts that are reasonable in a given space dimension are   offered, of course.     In addition, the tag  [2.x.27]  denotes isotropic   refinement in the space dimension selected by the template argument of   this class.     If you choose anisotropic refinement, for example by passing as argument   to  [2.x.28]    one of the flags  [2.x.29]   [2.x.30]     [2.x.31]  or a combination of these, then keep in mind   that refining in x-, y-, or z-direction happens with regard to the    [2.x.32] local [2.x.33]  coordinate system of the cell. In other words, these   flags determine which edges and faces of the cell will be cut into new   edges and faces. On the other hand, this process is independent of   how the cell is oriented within the  [2.x.34] global [2.x.35]  coordinate system,   and you should not assume any particular orientation of the cell's   local coordinate system within the global coordinate system of the   space it lives in.  
* [0.x.21]*
     Do not refine.    
* [0.x.22]*
     Perform a cut in the x-direction.    
* [0.x.23]*
     Perform a cut in the y-direction.    
* [0.x.24]*
     Perform cuts in the x- and y-directions.    
* [0.x.25]*
     Perform isotropic refinement.    
* [0.x.26]*
 A class that provides possible choices for isotropic and anisotropic refinement flags in the current space dimension.
*  This specialization is used for  [2.x.36] , where it offers refinement in x-, y- and z-direction separately, as well as combinations of these and isotropic refinement in all directions at the same time.
* 

* 
*  [2.x.37] 

* 
* [0.x.27]*
   Possible values for refinement cases in the current dimension.     Note the construction of the values: the lowest bit describes a cut of   the x-axis, the second to lowest bit corresponds to a cut of the y-axis   and the third to lowest bit corresponds to a cut of the z-axis. Thus, the   following relations hold (among others):    
* [1.x.3]
*      Only those cuts that are reasonable in a given space dimension are   offered, of course.     In addition, the tag  [2.x.38]  denotes isotropic   refinement in the space dimension selected by the template argument of   this class.     If you choose anisotropic refinement, for example by passing as argument   to  [2.x.39]    one of the flags  [2.x.40]   [2.x.41]     [2.x.42]  or a combination of these, then keep in mind   that refining in x-, y-, or z-direction happens with regard to the    [2.x.43] local [2.x.44]  coordinate system of the cell. In other words, these   flags determine which edges and faces of the cell will be cut into new   edges and faces. On the other hand, this process is independent of   how the cell is oriented within the  [2.x.45] global [2.x.46]  coordinate system,   and you should not assume any particular orientation of the cell's   local coordinate system within the global coordinate system of the   space it lives in.  
* [0.x.28]*
     Do not refine.    
* [0.x.29]*
     Perform a cut in the x-direction.    
* [0.x.30]*
     Perform a cut in the y-direction.    
* [0.x.31]*
     Perform a cut in the x and y-directions.    
* [0.x.32]*
     Perform a cut in the z-direction.    
* [0.x.33]*
     Perform a cuts in the x- and y-directions.    
* [0.x.34]*
     Perform a cuts in the x- and y-directions.    
* [0.x.35]*
     Perform a cuts in the x-, y-, and z-directions.    
* [0.x.36]*
     Perform isotropic refinement.    
* [0.x.37]*
 A class storing the possible anisotropic and isotropic refinement cases of an object with  [2.x.47]  dimensions (for example, for a line  [2.x.48]  in whatever space dimension we are, for a quad  [2.x.49] , etc.). Possible values of this class are the ones listed in the enumeration declared within the base class; see there for more information.
* 

* 
*  [2.x.50] 

* 
* [0.x.38]*
   Default constructor. Initialize the refinement case with no_refinement.  
* [0.x.39]*
   Constructor. Take and store a value indicating a particular refinement   from the list of possible refinements specified in the base class.  
* [0.x.40]*
   Constructor. Take and store a value indicating a particular refinement as   a bit field. To avoid implicit conversions to and from integral values,   this constructor is marked as explicit.  
* [0.x.41]*
   Return the numeric value stored by this class. While the presence of this   operator might seem dangerous, it is useful in cases where one would like   to have code like <tt>switch (refinement_flag)... case    [2.x.51]  ... </tt>, which can be written as    [2.x.52] .   Another application is to use an object of the current type as an index   into an array; however, this use is deprecated as it assumes a certain   mapping from the symbolic flags defined in the RefinementPossibilities   base class to actual numerical values (the array indices).  
* [0.x.42]*
   Return the union of the refinement flags represented by the current   object and the one given as argument.  
* [0.x.43]*
   Return the intersection of the refinement flags represented by the   current object and the one given as argument.  
* [0.x.44]*
   Return the negation of the refinement flags represented by the current   object. For example, in 2d, if the current object holds the flag    [2.x.53] ;   if the current value is  [2.x.54]  then the result   will be  [2.x.55] ; etc.  
* [0.x.45]*
   Return the flag that corresponds to cutting a cell along the axis given   as argument. For example, if  [2.x.56]  then the returned value is    [2.x.57]   
* [0.x.46]*
   Return the amount of memory occupied by an object of this type.  
* [0.x.47]*
   Read or write the data of this object to or from a stream for the purpose   of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.48]*
   Exception.  
* [0.x.49]*
   Store the refinement case as a bit field with as many bits as are   necessary in any given dimension.  
* [0.x.50]*
   A class that provides all possible situations a face (in the current   space dimension  [2.x.58]  might be subdivided into subfaces. For    [2.x.59]  they correspond to the cases   given in  [2.x.60] . However,    [2.x.61]  includes the refinement cases of    [2.x.62] , but additionally some subface   possibilities a face might be subdivided into which occur through   repeated anisotropic refinement steps performed on one of two neighboring   cells.     This general template is unused except in some weird template constructs.   Actual is made, however, of the specializations    [2.x.63] ,    [2.x.64]  and    [2.x.65] .    
*  [2.x.66]   
* [0.x.51]*
     Possible cases of faces being subdivided into subface.    
* [0.x.52]*
       Do not refine.      
* [0.x.53]*
       Refine isotropically.      
* [0.x.54]*
   A class that provides all possible situations a face (in the current   space dimension  [2.x.67]  might be subdivided into subfaces.     For  [2.x.68]  we provide a dummy implementation only.    
*  [2.x.69]   
* [0.x.55]*
     Possible cases of faces being subdivided into subface.         Dummy implementation.    
* [0.x.56]*
       Do not refine.      
* [0.x.57]*
       Refine isotropically.      
* [0.x.58]*
   A class that provides all possible situations a face (in the current   space dimension  [2.x.70]  might be subdivided into subfaces.     For  [2.x.71]  there are no faces. Thereby, there are no subface   possibilities.    
*  [2.x.72]   
* [0.x.59]*
     Possible cases of faces being subdivided into subface.         In 1d there are no faces, thus no subface possibilities.    
* [0.x.60]*
       Do not refine.      
* [0.x.61]*
       Refine isotropically.      
* [0.x.62]*
   A class that provides all possible situations a face (in the current   space dimension  [2.x.73]  might be subdivided into subfaces.     This specialization is used for  [2.x.74] , where it offers the   following possibilities: a face (line) being refined   ( [2.x.75] ).    
*  [2.x.76]   
* [0.x.63]*
     Possible cases of faces being subdivided into subface.         In 2d there are following possibilities: a face (line) being refined     ( [2.x.77] ).    
* [0.x.64]*
       Do not refine.      
* [0.x.65]*
       Cut in the x-direction.      
* [0.x.66]*
       Refine isotropically.      
* [0.x.67]*
   A class that provides all possible situations a face (in the current   space dimension  [2.x.78]  might be subdivided into subfaces.     This specialization is used for dim=3, where it offers following   possibilities: a face (quad) being refined in x- or y-direction (in the   face-intern coordinate system) separately, ( [2.x.79]  or   ( [2.x.80]  which   corresponds to ( [2.x.81] ). Additionally, it offers the   possibilities a face can have through repeated anisotropic refinement   steps performed on one of the two neighboring cells.  It might be   possible for example, that a face (quad) is refined with    [2.x.82]  and afterwards the left child is again refined with    [2.x.83] , so that there are three active subfaces. Note,   however, that only refinement cases are allowed such that each line on a   face between two hexes has not more than one hanging node. Furthermore,   it is not allowed that two neighboring hexes are refined such that one of   the hexes refines the common face with  [2.x.84]  and the other   hex refines that face with  [2.x.85] . In fact,    [2.x.86]  takes care of this   situation and ensures that each face of a refined cell is completely   contained in a single face of neighboring cells.     The following drawings explain the SubfacePossibilities and give the   corresponding subface numbers:  
* [1.x.4]
*     
*  [2.x.87]   
* [0.x.68]*
     Possible cases of faces being subdivided into subface.         See documentation to the SubfacePossibilities<3> for more details on     the subface possibilities.    
* [0.x.69]*
   A class that provides all possible cases a face (in the current space   dimension  [2.x.88]  might be subdivided into subfaces.    
*  [2.x.89]   
* [0.x.70]*
     Constructor. Take and store a value indicating a particular subface     possibility in the list of possible situations specified in the base     class.    
* [0.x.71]*
     Return the numeric value stored by this class. While the presence of     this operator might seem dangerous, it is useful in cases where one     would like to have code like <code>switch (subface_case)... case      [2.x.90]  ... </code>, which can be written as <code>switch      [2.x.91]  Another application     is to use an object of the current type as an index into an array;     however, this use is deprecated as it assumes a certain mapping from     the symbolic flags defined in the SubfacePossibilities base class to     actual numerical values (the array indices).    
* [0.x.72]*
     Return the amount of memory occupied by an object of this type.    
* [0.x.73]*
     Exception.    
* [0.x.74]*
     Store the refinement case as a bit field with as many bits as are     necessary in any given dimension.    
* [0.x.75]*
 This class provides a description of zero-dimensional cells. It has been superseded by the ReferenceCell class
* 
*  -  see there for more information.
*  Topological description of zero dimensional cells, i.e. points. This class might not look too useful but often is if in a certain dimension we would like to enquire information about objects with dimension one lower than the present, e.g. about faces.
*  This class contains as static members information on vertices and faces of a  [2.x.92]  grid cell. The interface is the same for all dimensions. If a value is of no use in a low dimensional cell, it is (correctly) set to zero, e.g. #max_children_per_face in 1d.
*  This information should always replace hard-coded numbers of vertices, neighbors and so on, since it can be used dimension independently.
* 

* 
*  [2.x.93] 

* 
* [0.x.76]*
   Maximum number of children of a cell, i.e. the number of children of an   isotropically refined cell.     If a cell is refined anisotropically, the actual number of children may   be less than the value given here.  
* [0.x.77]*
   Number of faces a cell has.  
* [0.x.78]*
   Return an object that can be thought of as an array containing all   indices from zero to `faces_per_cell`. This allows to write code   using range-based for loops of the following kind:  
* [1.x.5]
*    Here, we are looping over all faces of all cells, with `face_index`   taking on all valid indices.     Of course, since this class is for the case `dim==0`, the   returned object is actually an empty array.  
* [0.x.79]*
   Maximum number of children of a refined face, i.e. the number of children   of an isotropically refined face.     If a cell is refined anisotropically, the actual number of children may   be less than the value given here.  
* [0.x.80]*
   Return the number of children of a cell (or face) refined with   <tt>ref_case</tt>. Since we are concerned here with points, the number of   children is equal to one.  
* [0.x.81]*
   Number of vertices a cell has.  
* [0.x.82]*
   Return an object that can be thought of as an array containing all   indices from zero to `vertices_per_cell`. This allows to write code   using range-based for loops of the following kind:  
* [1.x.6]
*    Here, we are looping over all vertices of all cells, with `vertex_index`   taking on all valid indices.     Of course, since this class is for the case `dim==0`, the   returned object is a array with just one entry: zero. That's   because an of dimension zero is really just a single point,   corresponding to a vertex itself.  
* [0.x.83]*
   Map face vertex number to cell vertex number, i.e. give the cell vertex   number of the <tt>vertex</tt>th vertex of face <tt>face</tt>, e.g.    [2.x.94]  see the image   under point N4 in the 2d section of this class's documentation.     Through the <tt>face_orientation</tt>, <tt>face_flip</tt> and   <tt>face_rotation</tt> arguments this function handles faces oriented in   the standard and non-standard orientation. <tt>face_orientation</tt>   defaults to <tt>true</tt>, <tt>face_flip</tt> and <tt>face_rotation</tt>   default to <tt>false</tt> (standard orientation). In 2d only   <tt>face_flip</tt> is considered. See this    [2.x.95]  "glossary"   article for more information.     As the children of a cell are ordered according to the vertices of the   cell, this call is passed down to the child_cell_on_face() function.   Hence this function is simply a wrapper of child_cell_on_face() giving it   a suggestive name.     Of course, since this class is for the case `dim==0`, this function   is not implemented.  
* [0.x.84]*
   Map face line number to cell line number, i.e. give the cell line number   of the <tt>line</tt>th line of face <tt>face</tt>, e.g.    [2.x.96]      Through the <tt>face_orientation</tt>, <tt>face_flip</tt> and   <tt>face_rotation</tt> arguments this function handles faces oriented in   the standard and non-standard orientation. <tt>face_orientation</tt>   defaults to <tt>true</tt>, <tt>face_flip</tt> and <tt>face_rotation</tt>   default to <tt>false</tt> (standard orientation) and has no effect in 2d.     Of course, since this class is for the case `dim==0`, this function   is not implemented.  
* [0.x.85]*
   Number of vertices each face has. Since this is not useful in one   dimension, we provide a useless number (in the hope that a compiler may   warn when it sees constructs like <tt>for (i=0; i<vertices_per_face;   ++i)</tt>, at least if  [2.x.97]  is an <tt>unsigned int</tt>.  
* [0.x.86]*
   Number of lines each face has.  
* [0.x.87]*
   Number of quads on each face.  
* [0.x.88]*
   Number of lines of a cell.  
* [0.x.89]*
   Number of quadrilaterals of a cell.  
* [0.x.90]*
   Number of hexahedra of a cell.  
* [0.x.91]*
   Rearrange vertices for UCD output.  For a cell being written in UCD   format, each entry in this field contains the number of a vertex in   <tt>deal.II</tt> that corresponds to the UCD numbering at this location.     Typical example: write a cell and arrange the vertices, such that UCD   understands them.    
* [1.x.7]
*      As the vertex numbering in deal.II versions <= 5.1 happened to coincide   with the UCD numbering, this field can also be used like a   old_to_lexicographic mapping.  
* [0.x.92]*
   Rearrange vertices for OpenDX output.  For a cell being written in OpenDX   format, each entry in this field contains the number of a vertex in   <tt>deal.II</tt> that corresponds to the DX numbering at this location.     Typical example: write a cell and arrange the vertices, such that OpenDX   understands them.    
* [1.x.8]
*   
* [0.x.93]*
 This class provides dimension independent information to all topological structures that make up the unit, or  [2.x.98]  "reference cell". This class has been superseded by the ReferenceCell class
* 
*  -  see there for more information.
* 

*  It is the one central point in the library where information about the numbering of vertices, lines, or faces of the reference cell is collected. Consequently, the information of this class is used extensively in the geometric description of Triangulation objects, as well as in various other parts of the code. In particular, it also serves as the focus of writing code in a dimension independent way; for example, instead of writing a loop over vertices 0<=v<4 in 2d, one would write it as  [2.x.99]  thus allowing the code to work in 3d as well without changes.
*  The most frequently used parts of the class are its static members like vertices_per_cell, faces_per_cell, etc. However, the class also offers information about more abstract questions like the orientation of faces, etc. The following documentation gives a textual description of many of these concepts.
* 

*  [1.x.9]
*  From version 5.2 onwards deal.II is based on a numbering scheme that uses a lexicographic ordering (with x running fastest) wherever possible, hence trying to adopt a kind of 'canonical' ordering.
*  The ordering of vertices and faces (lines) in 2d is defined by
* 

* 
* 
*  - Vertices are numbered in lexicographic ordering
* 

* 
* 
*  - Faces (lines in 2d): first the two faces with normals in x- and then y-direction. For each two faces: first the face with normal in negative coordinate direction, then the one with normal in positive direction, i.e. the faces are ordered according to their normals pointing in
* 
*  - , x,
* 
*  - , y direction.
* 

* 
* 
*  - The direction of a line is represented by the direction of point 0 towards point 1 and is always in one of the coordinate directions
* 

* 
* 
*  - Face lines in 3d are ordered, such that the induced 2d local coordinate system (x,y) implies (right hand rule) a normal in face normal direction, see N2/.
*  The resulting numbering of vertices and faces (lines) in 2d as well as the directions of lines is shown in the following.

* 
* [1.x.10]
* 
*  Note that the orientation of lines has to be correct upon construction of a grid; however, it is automatically preserved upon refinement.
*  Further we define that child lines have the same direction as their parent, i.e. that <tt>line->child(0)->vertex(0)==line->vertex(0)</tt> and <tt>line->child(1)->vertex(1)==line->vertex(1)</tt>. This also implies, that the first sub-line (<tt>line->child(0)</tt>) is the one at vertex(0) of the old line.
*  Similarly we define, that the four children of a quad are adjacent to the vertex with the same number of the old quad.
*  Note that information about several of these conventions can be extracted at run- or compile-time from the member functions and variables of the present class.
* 

*  [1.x.11]
*  When explicit coordinates are required for points in a cell (e.g for quadrature formulae or the point of definition of trial functions), we define the following coordinate system for the unit cell:

* 
* [1.x.12]
* 
*  Here, vertex 0 is the origin of the coordinate system, vertex 1 has coordinates <tt>(1,0)</tt>, vertex 2 at <tt>(0,1)</tt> and vertex 3 at <tt>(1,1)</tt>. The  [2.x.100]  function can be used to query this information at run-time.
* 

*  [1.x.13]
*  By convention, we will use the following numbering conventions for vertices, lines and faces of hexahedra in three space dimensions. Before giving these conventions we declare the following sketch to be the standard way of drawing 3d pictures of hexahedra:

* 
* [1.x.14]
*  The left part of the picture shows the left, bottom and back face of the cube, while the right one shall be the top, right and front face. You may recover the whole cube by moving the two parts together into one.
*  Note again that information about several of the following conventions can be extracted at run- or compile-time from the member functions and variables of the present class.
*  [1.x.15]
*  The ordering of vertices in 3d is defined by the same rules as in the 2d case. In particular, the following is still true:
* 

* 
* 
*  - Vertices are numbered in lexicographic ordering.
*  Hence, the vertices are numbered as follows

* 
* [1.x.16]
* 
*  We note, that first the vertices on the bottom face (z=0) are numbered exactly the same way as are the vertices on a quadrilateral. Then the vertices on the top face (z=1) are numbered similarly by moving the bottom face to the top. Again, the  [2.x.101]  function can be used to query this information at run-time.
* 

*  [1.x.17]
*  Here, the same holds as for the vertices:
* 

* 
* 
*  - Line ordering in 3d:  [2.x.102]   [2.x.103] first the lines of face (z=0) in 2d line ordering,  [2.x.104] then the lines of face (z=1) in 2d line ordering,  [2.x.105] finally the lines in z direction in lexicographic ordering  [2.x.106] 

* 
* [1.x.18]
*  As in 2d lines are directed in coordinate directions.

* 
* [1.x.19]
* 
*  The fact that edges (just as vertices and faces) are entities that are stored in their own right rather than constructed from cells each time they are needed, means that adjacent cells actually have pointers to edges that are thus shared between them. This implies that the convention that sets of parallel edges have parallel directions is not only a local condition. Before a list of cells is passed to an object of the Triangulation class for creation of a triangulation, you therefore have to make sure that cells are oriented in a compatible fashion, so that edge directions are globally according to above convention. However, the GridReordering class can do this for you, by reorienting cells and edges of an arbitrary list of input cells that need not be already sorted.
*  [1.x.20]
*  The numbering of faces in 3d is defined by a rule analogous to 2d:
* 

* 
* 
*  - Faces (quads in 3d): first the two faces with normals in x-, then y- and z-direction. For each two faces: first the face with normal in negative coordinate direction, then the one with normal in positive direction, i.e. the faces are ordered according to their normals pointing in
* 
*  - , x,
* 
*  - , y,
* 

* 
* 
*  - , z direction.
*  Therefore, the faces are numbered in the ordering: left, right, front, back, bottom and top face:

* 
* [1.x.21]
* 
*  The  [2.x.107] standard [2.x.108]  direction of the faces is such, that the induced 2d local coordinate system (x,y) implies (right hand rule) a normal in face normal direction, see N2a).  In the following we show the local coordinate system and the numbering of face lines:  [2.x.109]   [2.x.110]  Faces 0 and 1: 
* [1.x.22]
* 
*   [2.x.111]  Faces 2 and 3: 
* [1.x.23]
* 
*   [2.x.112]  Faces 4 and 5: 
* [1.x.24]
*   [2.x.113] 
*  The face line numbers (0,1,2,3) correspond to following cell line numbers.  [2.x.114]   [2.x.115]  Face 0: lines 8, 10, 0, 4;  [2.x.116]  Face 1: lines 9, 11, 1, 5;  [2.x.117]  Face 2: lines 2, 6, 8, 9;  [2.x.118]  Face 3: lines 3, 7, 10, 11;  [2.x.119]  Face 4: lines 0, 1, 2, 3;  [2.x.120]  Face 5: lines 4, 5, 6, 7;  [2.x.121]  You can get these numbers using the  [2.x.122]  function.
*  The face normals can be deduced from the face orientation by applying the right hand side rule (x,y
* 
-> normal).  We note, that in the standard orientation of faces in 2d, faces 0 and 2 have normals that point into the cell, and faces 1 and 3 have normals pointing outward. In 3d, faces 0, 2, and 4 have normals that point into the cell, while the normals of faces 1, 3, and 5 point outward. This information, again, can be queried from  [2.x.123] 
*  However, it turns out that a significant number of 3d meshes cannot satisfy this convention. This is due to the fact that the face convention for one cell already implies something for the neighbor, since they share a common face and fixing it for the first cell also fixes the normal vectors of the opposite faces of both cells. It is easy to construct cases of loops of cells for which this leads to cases where we cannot find orientations for all faces that are consistent with this convention.
*  For this reason, above convention is only what we call the  [2.x.124] standard orientation [2.x.125] . deal.II actually allows faces in 3d to have either the standard direction, or its opposite, in which case the lines that make up a cell would have reverted orders, and the above line equivalences would not hold any more. You can ask a cell whether a given face has standard orientation by calling <tt>cell->face_orientation(face_no)</tt>: if the result is  [2.x.126]  then the face has standard orientation, otherwise its normal vector is pointing the other direction. There are not very many places in application programs where you need this information actually, but a few places in the library make use of this. Note that in 2d, the result is always  [2.x.127]  More information on the topic can be found in this  [2.x.128]  "glossary" article.
*  In order to allow all kinds of meshes in 3d, including  [2.x.129] Moebius [2.x.130] -loops, a face might even be rotated looking from one cell, whereas it is according to the standard looking at it from the neighboring cell sharing that particular face. In order to cope with this, two flags <tt>face_flip</tt> and <tt>face_rotation</tt> are available, to represent rotations by 180 and 90 degree, respectively. Setting both flags amounts to a rotation of 270 degrees (all counterclockwise). You can ask the cell for these flags like for the <tt>face_orientation</tt>. In order to enable rotated faces, even lines can deviate from their standard direction in 3d. This information is available as the <tt>line_orientation</tt> flag for cells and faces in 3d. Again, this is something that should be internal to the library and application program will probably never have to bother about it. For more information on this see also  [2.x.131]  "this glossary entry".
* 

*  [1.x.25]
*  The eight children of an isotropically refined cell are numbered according to the vertices they are adjacent to:

* 
* [1.x.26]
* 
*  Taking into account the orientation of the faces, the following children are adjacent to the respective faces:  [2.x.132]   [2.x.133]  Face 0: children 0, 2, 4, 6;  [2.x.134]  Face 1: children 1, 3, 5, 7;  [2.x.135]  Face 2: children 0, 4, 1, 5;  [2.x.136]  Face 3: children 2, 6, 3, 7;  [2.x.137]  Face 4: children 0, 1, 2, 3;  [2.x.138]  Face 5: children 4, 5, 6, 7.  [2.x.139]  You can get these numbers using the  [2.x.140]  function. As each child is adjacent to the vertex with the same number these numbers are also given by the  [2.x.141]  function.
*  Note that, again, the above list only holds for faces in their standard orientation. If a face is not in standard orientation, then the children at positions 1 and 2 (counting from 0 to 3) would be swapped. In fact, this is what the child_cell_on_face and the face_to_cell_vertices functions of GeometryInfo<3> do, when invoked with a <tt>face_orientation=false</tt> argument.
*  The information which child cell is at which position of which face is most often used when computing jump terms across faces with hanging nodes, using objects of type FESubfaceValues. Sitting on one cell, you would look at a face and figure out which child of the neighbor is sitting on a given subface between the present and the neighboring cell. To avoid having to query the standard orientation of the faces of the two cells every time in such cases, you should use a function call like <tt>cell->neighbor_child_on_subface(face_no,subface_no)</tt>, which returns the correct result both in 2d (where face orientations are immaterial) and 3d (where it is necessary to use the face orientation as additional argument to  [2.x.142] 
*  For anisotropic refinement, the child cells can not be numbered according to adjacent vertices, thus the following conventions are used:

* 
* [1.x.27]
* 
* 

* 
* [1.x.28]
* 
* 

* 
* [1.x.29]
* 
* 

* 
* [1.x.30]
* 
* 

* 
* [1.x.31]
* 
* 

* 
* [1.x.32]
* 
*  This information can also be obtained by the  [2.x.143]  function.
*  [1.x.33]
*  We define the following coordinate system for the explicit coordinates of the vertices of the unit cell:

* 
* [1.x.34]
* 
*  By the convention laid down as above, the vertices have the following coordinates (lexicographic, with x running fastest):  [2.x.144]   [2.x.145]  Vertex 0: <tt>(0,0,0)</tt>;  [2.x.146]  Vertex 1: <tt>(1,0,0)</tt>;  [2.x.147]  Vertex 2: <tt>(0,1,0)</tt>;  [2.x.148]  Vertex 3: <tt>(1,1,0)</tt>;  [2.x.149]  Vertex 4: <tt>(0,0,1)</tt>;  [2.x.150]  Vertex 5: <tt>(1,0,1)</tt>;  [2.x.151]  Vertex 6: <tt>(0,1,1)</tt>;  [2.x.152]  Vertex 7: <tt>(1,1,1)</tt>.  [2.x.153] 
* 

* 
* 

* 
*  [2.x.154]  Instantiations for this template are provided for dimensions 1,2,3,4, and there is a specialization for dim=0 (see the section on  [2.x.155]  in the manual).
* 

* 
*  [2.x.156] 

* 
* [0.x.94]*
   Maximum number of children of a refined cell, i.e. the number of children   of an isotropically refined cell.     If a cell is refined anisotropically, the actual number of children may   be less than the value given here.  
* [0.x.95]*
   Number of faces of a cell.  
* [0.x.96]*
   Return an object that can be thought of as an array containing all   indices from zero to `faces_per_cell`. This allows to write code   using range-based for loops of the following kind:  
* [1.x.35]
*    Here, we are looping over all faces of all cells, with `face_index`   taking on all valid indices for faces (zero and one in 1d, zero   through three in 2d, and zero through 5 in 3d).      [2.x.157]  CPP11  
* [0.x.97]*
   Maximum number of children of a refined face, i.e. the number of children   of an isotropically refined face.     If a cell is refined anisotropically, the actual number of children may   be less than the value given here.  
* [0.x.98]*
   Number of vertices of a cell.  
* [0.x.99]*
   Return an object that can be thought of as an array containing all   indices from zero to `vertices_per_cell`. This allows to write code   using range-based for loops of the following kind:  
* [1.x.36]
*    Here, we are looping over all vertices of all cells, with `vertex_index`   taking on all valid indices.      [2.x.158]  CPP11  
* [0.x.100]*
   Number of vertices on each face.  
* [0.x.101]*
   Number of lines on each face.  
* [0.x.102]*
   Number of quads on each face.  
* [0.x.103]*
   Number of lines of a cell.     The formula to compute this makes use of the fact that when going from   one dimension to the next, the object of the lower dimension is copied   once (thus twice the old number of lines) and then a new line is inserted   between each vertex of the old object and the corresponding one in the   copy.  
* [0.x.104]*
   Number of quadrilaterals of a cell.     This number is computed recursively just as the previous one, with the   exception that new quads result from connecting an original line and its   copy.  
* [0.x.105]*
   Number of hexahedra of a cell.  
* [0.x.106]*
   Rearrange vertices for UCD output.  For a cell being written in UCD   format, each entry in this field contains the number of a vertex in   <tt>deal.II</tt> that corresponds to the UCD numbering at this location.     Typical example: write a cell and arrange the vertices, such that UCD   understands them.    
* [1.x.37]
*      As the vertex numbering in deal.II versions <= 5.1 happened to coincide   with the UCD numbering, this field can also be used like a   old_to_lexicographic mapping.  
* [0.x.107]*
   Rearrange vertices for OpenDX output.  For a cell being written in OpenDX   format, each entry in this field contains the number of a vertex in   <tt>deal.II</tt> that corresponds to the DX numbering at this location.     Typical example: write a cell and arrange the vertices, such that OpenDX   understands them.    
* [1.x.38]
*   
* [0.x.108]*
   This field stores for each vertex to which faces it belongs. In any given   dimension, the number of faces is equal to the dimension. The first index   in this 2D-array runs over all vertices, the second index over  [2.x.159]    faces to which the vertex belongs.     The order of the faces for each vertex is such that the first listed face   bounds the reference cell in [1.x.39] direction, the second in [1.x.40]   direction, and so on.  
* [0.x.109]*
   Return the number of children of a cell (or face) refined with   <tt>ref_case</tt>.  
* [0.x.110]*
   Return the number of subfaces of a face refined according to    [2.x.160]   [2.x.161]   
* [0.x.111]*
   Given a face on the reference element with a    [2.x.162]   [2.x.163]  this   function returns the ratio between the area of the  [2.x.164]  th   subface and the area(=1) of the face.     E.g. for  [2.x.165]  the ratio is 1/4 for each of the   subfaces.  
* [0.x.112]*
   Given a cell refined with the  [2.x.166]   [2.x.167]    cell_refinement_case return the  [2.x.168]  of the  [2.x.169]    face_no th face.  
* [0.x.113]*
   Given the SubfaceCase  [2.x.170]  of the  [2.x.171]  th face,   return the smallest RefinementCase of the cell, which corresponds to that   refinement of the face.  
* [0.x.114]*
   Given a cell refined with the RefinementCase  [2.x.172]    return the RefinementCase of the  [2.x.173]  th face.  
* [0.x.115]*
   Return the minimal / smallest RefinementCase of the cell, which ensures   refinement of line  [2.x.174]   
* [0.x.116]*
   This field stores which child cells are adjacent to a certain face of the   mother cell.     For example, in 2D the layout of a cell is as follows:  
* [1.x.41]
*    Vertices and faces are indicated with their numbers, faces also with   their directions.     Now, when refined, the layout is like this:  
* [1.x.42]
*      Thus, the child cells on face 0 are (ordered in the direction of the   face) 0 and 2, on face 3 they are 2 and 3, etc.     For three spatial dimensions, the exact order of the children is laid   down in the general documentation of this class.     Through the <tt>face_orientation</tt>, <tt>face_flip</tt> and   <tt>face_rotation</tt> arguments this function handles faces oriented in   the standard and non-standard orientation. <tt>face_orientation</tt>   defaults to <tt>true</tt>, <tt>face_flip</tt> and <tt>face_rotation</tt>   default to <tt>false</tt> (standard orientation) and has no effect in 2d.   The concept of face orientations is explained in this    [2.x.175]  "glossary"   entry.     In the case of anisotropically refined cells and faces, the  [2.x.176]    RefinementCase of the face, <tt>face_ref_case</tt>, might have an   influence on which child is behind which given subface, thus this is an   additional argument, defaulting to isotropic refinement of the face.  
* [0.x.117]*
   Map line vertex number to cell vertex number, i.e. give the cell vertex   number of the <tt>vertex</tt>th vertex of line <tt>line</tt>, e.g.    [2.x.177]      The order of the lines, as well as their direction (which in turn   determines which is the first and which the second vertex on a line) is   the canonical one in deal.II, as described in the general documentation   of this class.     For <tt>dim=2</tt> this call is simply passed down to the   face_to_cell_vertices() function.  
* [0.x.118]*
   Map face vertex number to cell vertex number, i.e. give the cell vertex   number of the <tt>vertex</tt>th vertex of face <tt>face</tt>, e.g.    [2.x.178]  see the image   under point N4 in the 2d section of this class's documentation.     Through the <tt>face_orientation</tt>, <tt>face_flip</tt> and   <tt>face_rotation</tt> arguments this function handles faces oriented in   the standard and non-standard orientation. <tt>face_orientation</tt>   defaults to <tt>true</tt>, <tt>face_flip</tt> and <tt>face_rotation</tt>   default to <tt>false</tt> (standard orientation). In 2d only   <tt>face_flip</tt> is considered. See this    [2.x.179]  "glossary"   article for more information.     As the children of a cell are ordered according to the vertices of the   cell, this call is passed down to the child_cell_on_face() function.   Hence this function is simply a wrapper of child_cell_on_face() giving it   a suggestive name.  
* [0.x.119]*
   Map face line number to cell line number, i.e. give the cell line number   of the <tt>line</tt>th line of face <tt>face</tt>, e.g.    [2.x.180]      Through the <tt>face_orientation</tt>, <tt>face_flip</tt> and   <tt>face_rotation</tt> arguments this function handles faces oriented in   the standard and non-standard orientation. <tt>face_orientation</tt>   defaults to <tt>true</tt>, <tt>face_flip</tt> and <tt>face_rotation</tt>   default to <tt>false</tt> (standard orientation) and has no effect in 2d.  
* [0.x.120]*
   Map the vertex index  [2.x.181]  of a face in standard orientation to one   of a face with arbitrary  [2.x.182]   [2.x.183]  and  [2.x.184]    face_rotation. The values of these three flags default to <tt>true</tt>,   <tt>false</tt> and <tt>false</tt>, respectively. this combination   describes a face in standard orientation.     This function is only implemented in 3D.  
* [0.x.121]*
   Map the vertex index  [2.x.185]  of a face with arbitrary  [2.x.186]    face_orientation,  [2.x.187]  and  [2.x.188]  to a face in standard   orientation. The values of these three flags default to <tt>true</tt>,   <tt>false</tt> and <tt>false</tt>, respectively. this combination   describes a face in standard orientation.     This function is only implemented in 3D.  
* [0.x.122]*
   Map the line index  [2.x.189]  of a face in standard orientation to one of a   face with arbitrary  [2.x.190]   [2.x.191]  and  [2.x.192]    face_rotation. The values of these three flags default to <tt>true</tt>,   <tt>false</tt> and <tt>false</tt>, respectively. this combination   describes a face in standard orientation.     This function is only implemented in 3D.  
* [0.x.123]*
   Map the vertex index  [2.x.193]  of a line in standard orientation to one of a   face with arbitrary  [2.x.194]  The value of this flag default to   <tt>true</tt>.  
* [0.x.124]*
   Decompose the vertex index in a quad into a pair of a line index and a   vertex index within this line.    
*  [2.x.195]  Which line is selected is not of importance (and not exposed on     purpose).  
* [0.x.125]*
   Decompose the vertex index in a hex into a pair of a quad index and a   vertex index within this quad.    
*  [2.x.196]  Which quad is selected is not of importance (and not exposed on     purpose).  
* [0.x.126]*
   Decompose the line index in a hex into a pair of a quad index and a line   index within this quad.    
*  [2.x.197]  Which quad is selected is not of importance (and not exposed on     purpose).  
* [0.x.127]*
   Map the line index  [2.x.198]  of a face with arbitrary  [2.x.199]     [2.x.200]  and  [2.x.201]  to a face in standard orientation. The   values of these three flags default to <tt>true</tt>, <tt>false</tt> and   <tt>false</tt>, respectively. this combination describes a face in   standard orientation.     This function is only implemented in 3D.  
* [0.x.128]*
   Return the position of the  [2.x.202]  vertex on the unit cell. The order of   vertices is the canonical one in deal.II, as described in the general   documentation of this class.  
* [0.x.129]*
   Given a point  [2.x.203]  in unit coordinates, return the number of the child   cell in which it would lie in. If the point lies on the interface of two   children, return any one of their indices. The result is always less than    [2.x.204]      The order of child cells is described the general documentation of this   class.  
* [0.x.130]*
   Given coordinates  [2.x.205]  on the unit cell, return the values of the   coordinates of this point in the coordinate system of the given child.   Neither original nor returned coordinates need actually be inside the   cell, we simply perform a scale-and-shift operation with a shift that   depends on the number of the child.  
* [0.x.131]*
   The reverse function to the one above: take a point in the coordinate   system of the child, and transform it to the coordinate system of the   mother cell.  
* [0.x.132]*
   Return true if the given point is inside the unit cell of the present   space dimension.  
* [0.x.133]*
   Return true if the given point is inside the unit cell of the present   space dimension. This function accepts an additional parameter which   specifies how much the point position may actually be outside the true   unit cell. This is useful because in practice we may often not be able to   compute the coordinates of a point in reference coordinates exactly, but   only up to numerical roundoff.     The tolerance parameter may be less than zero, indicating that the point   should be safely inside the cell.  
* [0.x.134]*
   Projects a given point onto the unit cell, i.e. each coordinate outside   [0..1] is modified to lie within that interval.  
* [0.x.135]*
   Return the infinity norm of the vector between a given point  [2.x.206]    outside the unit cell to the closest unit cell boundary. For points   inside the cell, this is defined as zero.  
* [0.x.136]*
   Compute the value of the  [2.x.207] -th  [2.x.208] -linear (i.e. (bi-,tri-)linear) shape   function at location  [2.x.209] .  
* [0.x.137]*
   Compute the gradient of the  [2.x.210] -th  [2.x.211] -linear (i.e. (bi-,tri-)linear)   shape function at location  [2.x.212] .  
* [0.x.138]*
   For a (bi-, tri-)linear mapping from the reference cell, face, or edge to   the object specified by the given vertices, compute the alternating form   of the transformed unit vectors vertices. For an object of dimensionality    [2.x.213]  there are  [2.x.214]  vectors with  [2.x.215]  components each, and   the alternating form is a tensor of rank spacedim-dim that corresponds to   the wedge product of the  [2.x.216]  unit vectors, and it corresponds to the   volume and normal vectors of the mapping from reference element to the   element described by the vertices.     For example, if dim==spacedim==2, then the alternating form is a scalar   (because spacedim-dim=0) and its value equals  [2.x.217] , where  [2.x.218]  is a   vector that is rotated to the right by 90 degrees from  [2.x.219] . If   dim==spacedim==3, then the result is again a scalar with value  [2.x.220] , where  [2.x.221]  are   the images of the unit vectors at a vertex of the unit dim-dimensional   cell under transformation to the dim-dimensional cell in spacedim-   dimensional space. In both cases, i.e. for dim==2 or 3, the result   happens to equal the determinant of the Jacobian of the mapping from   reference cell to cell in real space. Note that it is the actual   determinant, not its absolute value as often used in transforming   integrals from one coordinate system to another. In particular, if the   object specified by the vertices is a parallelogram (i.e. a linear   transformation of the reference cell) then the computed values are the   same at all vertices and equal the (signed) area of the cell; similarly,   for parallel-epipeds, it is the volume of the cell.     Likewise, if we have dim==spacedim-1 (e.g. we have a quad in 3d space, or   a line in 2d), then the alternating product denotes the normal vector   (i.e. a rank-1 tensor, since spacedim-dim=1) to the object at each   vertex, where the normal vector's magnitude denotes the area element of   the transformation from the reference object to the object given by the   vertices. In particular, if again the mapping from reference object to   the object under consideration here is linear (not bi- or trilinear),   then the returned vectors are all %parallel, perpendicular to the mapped   object described by the vertices, and have a magnitude equal to the   area/volume of the mapped object. If dim=1, spacedim=2, then the returned   value is  [2.x.222] , where  [2.x.223]  is the image of the   sole unit vector of a line mapped to the line in 2d given by the   vertices; if dim=2, spacedim=3, then the returned values are  [2.x.224]  where  [2.x.225]  are the two three-dimensional vectors that are   tangential to the quad mapped into three-dimensional space.     This function is used in order to determine how distorted a cell is (see   the entry on    [2.x.226]  "distorted cells"   in the glossary).  
* [0.x.139]*
   For each face of the reference cell, this field stores the coordinate   direction in which its normal vector points. In <tt>dim</tt> dimension   these are the <tt>2*dim</tt> first entries of <tt>{0,0,1,1,2,2,3,3}</tt>.     Note that this is only the coordinate number. The actual direction of the   normal vector is obtained by multiplying the unit vector in this   direction with #unit_normal_orientation.  
* [0.x.140]*
   Orientation of the unit normal vector of a face of the reference cell. In   <tt>dim</tt> dimension these are the <tt>2*dim</tt> first entries of   <tt>{-1,1,-1,1,-1,1,-1,1}</tt>.     Each value is either <tt>1</tt> or <tt>-1</tt>, corresponding to a normal   vector pointing in the positive or negative coordinate direction,   respectively.     Note that this is only the  [2.x.227] standard orientation [2.x.228]  of faces. At   least in 3d, actual faces of cells in a triangulation can also have the   opposite orientation, depending on a flag that one can query from the   cell it belongs to. For more information, see the    [2.x.229]  "glossary"   entry on face orientation.  
* [0.x.141]*
   Unit normal vector (Point<dim>) of a face of the reference cell.     Note that this is only the  [2.x.230] standard orientation [2.x.231]  of faces. At   least in 3d, actual faces of cells in a triangulation can also have the   opposite orientation, depending on a flag that one can query from the   cell it belongs to. For more information, see the    [2.x.232]  "glossary"   entry on face orientation.  
* [0.x.142]*
   Unit tangential vectors (array of `dim-1` elements of Point<dim>) of a   face of the reference cell, arranged in a right-hand coordinate system   such that the cross product between the two vectors return the unit   normal vector.     Note that this is only the  [2.x.233] standard orientation [2.x.234]  of faces. At   least in 3d, actual faces of cells in a triangulation can also have the   opposite orientation, depending on a flag that one can query from the   cell it belongs to. For more information, see the    [2.x.235]  "glossary"   entry on face orientation.  
* [0.x.143]*
   List of numbers which denotes which face is opposite to a given face. Its   entries are the first <tt>2*dim</tt> entries of <tt>{ 1, 0, 3, 2, 5, 4,   7, 6}</tt>.  
* [0.x.144]*
   Exception  
* [0.x.145]*
   Exception  
* [0.x.146]