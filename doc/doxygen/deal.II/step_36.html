<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_36.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-36 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">The step-36 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_4.html">step-4</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#EigenvaluesandDirichletboundaryconditions">Eigenvalues and Dirichlet boundary conditions</a>
        <li><a href="#Implementationdetails">Implementation details</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeEigenvalueProblemcodeclasstemplate">The <code>EigenvalueProblem</code> class template</a>
        <li><a href="#ImplementationofthecodeEigenvalueProblemcodeclass">Implementation of the <code>EigenvalueProblem</code> class</a>
      <ul>
        <li><a href="#EigenvalueProblemEigenvalueProblem">EigenvalueProblem::EigenvalueProblem</a>
        <li><a href="#EigenvalueProblemmake_grid_and_dofs">EigenvalueProblem::make_grid_and_dofs</a>
        <li><a href="#EigenvalueProblemassemble_system">EigenvalueProblem::assemble_system</a>
        <li><a href="#EigenvalueProblemsolve">EigenvalueProblem::solve</a>
        <li><a href="#EigenvalueProblemoutput_results">EigenvalueProblem::output_results</a>
        <li><a href="#EigenvalueProblemrun">EigenvalueProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Runningtheproblem">Running the problem</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br  />
</p>
<p><em>This program was contributed by Toby D. Young and Wolfgang Bangerth. </em></p>
<p><a class="anchor" id="Preamble"></a> <a class="anchor" id="Preamble"></a></p><h1>Preamble</h1>
<p>The problem we want to solve in this example is an eigenspectrum problem. Eigenvalue problems appear in a wide context of problems, for example in the computation of electromagnetic standing waves in cavities, vibration modes of drum membranes, or oscillations of lakes and estuaries. One of the most enigmatic applications is probably the computation of stationary or quasi-static wave functions in quantum mechanics. The latter application is what we would like to investigate here, though the general techniques outlined in this program are of course equally applicable to the other applications above.</p>
<p>Eigenspectrum problems have the general form </p><p class="formulaDsp">
\begin{align*} L \Psi &amp;= \varepsilon \Psi \qquad &amp;&amp;\text{in}\ \Omega\quad, \\ \Psi &amp;= 0 &amp;&amp;\text{on}\ \partial\Omega\quad, \end{align*}
</p>
<p> where the Dirichlet boundary condition on \(\Psi=\Psi(\mathbf x)\) could also be replaced by Neumann or Robin conditions; \(L\) is an operator that generally also contains differential operators.</p>
<p>Under suitable conditions, the above equations have a set of solutions \(\Psi_\ell,\varepsilon_\ell\), \(\ell\in {\cal I}\), where \(\cal I\) can be a finite or infinite set (and in the latter case it may be a discrete or sometimes at least in part a continuous set). In either case, let us note that there is no longer just a single solution, but a set of solutions (the various eigenfunctions and corresponding eigenvalues) that we want to compute. The problem of numerically finding all eigenvalues (eigenfunctions) of such eigenvalue problems is a formidable challenge. In fact, if the set \(\cal I\) is infinite, the challenge is of course intractable. Most of the time however we are really only interested in a small subset of these values (functions); and fortunately, the interface to the SLEPc library that we will use for this tutorial program allows us to select which portion of the eigenspectrum and how many solutions we want to solve for.</p>
<p>In this program, the eigenspectrum solvers we use are classes provided by deal.II that wrap around the linear algebra implementation of the <a href="http://www.grycap.upv.es/slepc/" target="_top">SLEPc</a> library; SLEPc itself builds on the <a href="http://www.mcs.anl.gov/petsc/" target="_top">PETSc</a> library for linear algebra contents.</p>
<p><a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The basic equation of stationary quantum mechanics is the Schr√∂dinger equation which models the motion of particles in an external potential \(V(\mathbf x)\). The particle is described by a wave function \(\Psi(\mathbf x)\) that satisfies a relation of the (nondimensionalized) form </p><p class="formulaDsp">
\begin{align*} [-\Delta + V(\mathbf x)] \Psi(\mathbf x) &amp;= \varepsilon \Psi(\mathbf x) \qquad &amp;&amp;\text{in}\ \Omega\quad, \\ \Psi &amp;= 0 &amp;&amp;\text{on}\ \partial\Omega\quad. \end{align*}
</p>
<p> As a consequence, this particle can only exist in a certain number of eigenstates that correspond to the energy eigenvalues \(\varepsilon_\ell\) admitted as solutions of this equation. The orthodox (Copenhagen) interpretation of quantum mechanics posits that, if a particle has energy \(\varepsilon_\ell\) then the probability of finding it at location \(\mathbf x\) is proportional to \(|\Psi_\ell(\mathbf x)|^2\) where \(\Psi_\ell\) is the eigenfunction that corresponds to this eigenvalue.</p>
<p>In order to numerically find solutions to this equation, i.e. a set of pairs of eigenvalues/eigenfunctions, we use the usual finite element approach of multiplying the equation from the left with test functions, integrating by parts, and searching for solutions in finite dimensional spaces by approximating \(\Psi(\mathbf x)\approx\Psi_h(\mathbf x)=\sum_{j}\phi_j(\mathbf x)\tilde\psi_j\), where \(\tilde\psi\) is a vector of expansion coefficients. We then immediately arrive at the following equation that discretizes the continuous eigenvalue problem: </p><p class="formulaDsp">
\[ \sum_j [(\nabla\phi_i, \nabla\phi_j)+(V(\mathbf x)\phi_i,\phi_j)] \tilde{\psi}_j = \varepsilon_h \sum_j (\phi_i, \phi_j) \tilde{\psi}_j\quad. \]
</p>
<p> In matrix and vector notation, this equation then reads: </p><p class="formulaDsp">
\[ A \tilde{\Psi} = \varepsilon_h M \tilde{\Psi} \quad, \]
</p>
<p> where \(A\) is the stiffness matrix arising from the differential operator \(L\), and \(M\) is the mass matrix. The solution to the eigenvalue problem is an eigenspectrum \(\varepsilon_{h,\ell}\), with associated eigenfunctions \(\Psi_\ell=\sum_j \phi_j\tilde{\psi}_j\).</p>
<p><a class="anchor" id="EigenvaluesandDirichletboundaryconditions"></a></p><h3>Eigenvalues and Dirichlet boundary conditions</h3>
<p>In this program, we use Dirichlet boundary conditions for the wave function \(\Psi\). What this means, from the perspective of a finite element code, is that only the interior degrees of freedom are real degrees of <em>freedom</em>: the ones on the boundary are not free but are forced to have a zero value, after all. On the other hand, the finite element method gains much of its power and simplicity from the fact that we just do the same thing on every cell, without having to think too much about where a cell is, whether it bounds on a less refined cell and consequently has a hanging node, or is adjacent to the boundary. All such checks would make the assembly of finite element linear systems unbearably difficult to write and even more so to read.</p>
<p>Consequently, of course, when you distribute degrees of freedom with your <a class="el" href="classDoFHandler.html">DoFHandler</a> object, you don't care whether some of the degrees of freedom you enumerate are at a Dirichlet boundary. They all get numbers. We just have to take care of these degrees of freedom at a later time when we apply boundary values. There are two basic ways of doing this (either using <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a> <em>after</em> assembling the linear system, or using <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> <em>during</em> assembly; see the <a class="el" href="group__constraints.html">constraints module</a> for more information), but both result in the same: a linear system that has a total number of rows equal to the number of <em>all</em> degrees of freedom, including those that lie on the boundary. However, degrees of freedom that are constrained by Dirichlet conditions are separated from the rest of the linear system by zeroing out the corresponding row and column, putting a single positive entry on the diagonal, and the corresponding Dirichlet value on the right hand side.</p>
<p>If you assume for a moment that we had renumbered degrees of freedom in such a way that all of those on the Dirichlet boundary come last, then the linear system we would get when solving a regular PDE with a right hand side would look like this: </p><p class="formulaDsp">
\begin{align*} \begin{pmatrix} A_i &amp; 0 \\ 0 &amp; D_b \end{pmatrix} \begin{pmatrix} U_i \\ U_b \end{pmatrix} = \begin{pmatrix} F_i \\ F_b \end{pmatrix}. \end{align*}
</p>
<p> Here, subscripts \(i\) and \(b\) correspond to interior and boundary degrees of freedom, respectively. The interior degrees of freedom satisfy the linear system \(A_i U_i=F_i\) which yields the correct solution in the interior, and boundary values are determined by \(U_b = D_b^{-1} F_b\) where \(D_b\) is a diagonal matrix that results from the process of eliminating boundary degrees of freedom, and \(F_b\) is chosen in such a way that \(U_{b,j}=D_{b,jj}^{-1} F_{b,j}\) has the correct boundary values for every boundary degree of freedom \(j\). (For the curious, the entries of the matrix \(D_b\) result from adding modified local contributions to the global matrix where for the local matrices the diagonal elements, if non-zero, are set to their absolute value; otherwise, they are set to the average of absolute values of the diagonal. This process guarantees that the entries of \(D_b\) are positive and of a size comparable to the rest of the diagonal entries, ensuring that the resulting matrix does not incur unreasonable losses of accuracy due to roundoff involving matrix entries of drastically different size. The actual values that end up on the diagonal are difficult to predict and you should treat them as arbitrary and unpredictable, but positive.)</p>
<p>For "regular" linear systems, this all leads to the correct solution. On the other hand, for eigenvalue problems, this is not so trivial. There, eliminating boundary values affects both matrices \(A\) and \(M\) that we will solve with in the current tutorial program. After elimination of boundary values, we then receive an eigenvalue problem that can be partitioned like this: </p><p class="formulaDsp">
\begin{align*} \begin{pmatrix} A_i &amp; 0 \\ 0 &amp; D_A \end{pmatrix} \begin{pmatrix} \tilde\Psi_i \\ \tilde\Psi_b \end{pmatrix} = \epsilon_h \begin{pmatrix} M_i &amp; 0 \\ 0 &amp; D_M \end{pmatrix} \begin{pmatrix} \tilde\Psi_i \\ \tilde\Psi_b \end{pmatrix}. \end{align*}
</p>
<p> This form makes it clear that there are two sets of eigenvalues: the ones we care about, and spurious eigenvalues from the separated problem </p><p class="formulaDsp">
\[ D_A \tilde \Psi_b = \epsilon_h D_M \Psi_b. \]
</p>
<p> These eigenvalues are spurious since they result from an eigenvalue system that operates only on boundary nodes &ndash; nodes that are not real degrees of <em>freedom</em>. Of course, since the two matrices \(D_A,D_M\) are diagonal, we can exactly quantify these spurious eigenvalues: they are \(\varepsilon_{h,j}=D_{A,jj}/D_{M,jj}\) (where the indices \(j\) corresponds exactly to the degrees of freedom that are constrained by Dirichlet boundary values).</p>
<p>So how does one deal with them? The fist part is to recognize when our eigenvalue solver finds one of them. To this end, the program computes and prints an interval within which these eigenvalues lie, by computing the minimum and maximum of the expression \(\varepsilon_{h,j}=D_{A,jj}/D_{M,jj}\) over all constrained degrees of freedom. In the program below, this already suffices: we find that this interval lies outside the set of smallest eigenvalues and corresponding eigenfunctions we are interested in and compute, so there is nothing we need to do here.</p>
<p>On the other hand, it may happen that we find that one of the eigenvalues we compute in this program happens to be in this interval, and in that case we would not know immediately whether it is a spurious or a true eigenvalue. In that case, one could simply scale the diagonal elements of either matrix after computing the two matrices, thus shifting them away from the frequency of interest in the eigen-spectrum. This can be done by using the following code, making sure that all spurious eigenvalues are exactly equal to \(1.234\cdot 10^5\): </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; dof_handler.n_dofs(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>))</div>
<div class="line">    {</div>
<div class="line">      stiffness_matrix.set(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, 1.234e5);</div>
<div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.set(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, 1);</div>
<div class="line">    }</div>
</div><!-- fragment --><p> However, this strategy is not pursued here as the spurious eigenvalues we get from our program as-is happen to be greater than the lowest five that we will calculate and are interested in.</p>
<p><a class="anchor" id="Implementationdetails"></a></p><h3>Implementation details</h3>
<p>The program below is essentially just a slightly modified version of <a class="el" href="step_4.html">step-4</a>. The things that are different are the following:</p>
<ul>
<li>
<p class="startli">The main class (named <code>EigenvalueProblem</code>) now no longer has a single solution vector, but a whole set of vectors for the various eigenfunctions we want to compute. Moreover, the <code>main</code> function, which has the top-level control over everything here, initializes and finalizes the interface to SLEPc and PETSc simultaneously via <code>SlepcInitialize</code> and <code>SlepFinalize</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">We use PETSc matrices and vectors as in <a class="el" href="step_17.html">step-17</a> and <a class="el" href="step_18.html">step-18</a> since that is what the SLEPc eigenvalue solvers require.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The function <code>EigenvalueProblem::solve</code> is entirely different from anything seen so far in the tutorial, as it does not just solve a linear system but actually solves the eigenvalue problem. It is built on the SLEPc library, and more immediately on the deal.II SLEPc wrappers in the class <a class="el" href="classSLEPcWrappers_1_1SolverKrylovSchur.html">SLEPcWrappers::SolverKrylovSchur</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">We use the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class to describe a few input parameters, such as the exact form of the potential \(V({\mathbf x})\), the number of global refinement steps of the mesh, or the number of eigenvalues we want to solve for. We could go much further with this but stop at making only a few of the things that one could select at run time actual input file parameters. In order to see what could be done in this regard, take a look at <a class="el" href="step_29.html">step-29</a> and <a class="el" href="step_33.html">step-33</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">We use the <a class="el" href="classFunctionParser.html">FunctionParser</a> class to make the potential \(V(\mathbf x)\) a run-time parameter that can be specified in the input file as a formula.</p>
<p class="endli"></p>
</li>
</ul>
<p>The rest of the program follows in a pretty straightforward way from <a class="el" href="step_4.html">step-4</a>.</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>As mentioned in the introduction, this program is essentially only a slightly revised version of <a class="el" href="step_4.html">step-4</a>. As a consequence, most of the following include files are as used there, or at least as used already in previous tutorial programs:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2function__parser_8h.html">deal.II/base/function_parser.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
</div><!-- fragment --><p><a class="el" href="classIndexSet.html">IndexSet</a> is used to set the size of each <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div>
</div><!-- fragment --><p>PETSc appears here because SLEPc depends on this library:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div>
</div><!-- fragment --><p>And then we need to actually import the interfaces for solvers that SLEPc provides:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2slepc__solver_8h.html">deal.II/lac/slepc_solver.h</a>&gt;</span></div>
</div><!-- fragment --><p>We also need some standard C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
</div><!-- fragment --><p>Finally, as in previous programs, we import all the deal.II class and function names into the namespace into which everything in this program will go:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceStep36.html">Step36</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
</div><!-- fragment --><p><a class="anchor" id="ThecodeEigenvalueProblemcodeclasstemplate"></a> </p><h3>The <code>EigenvalueProblem</code> class template</h3>
<p>Following is the class declaration for the main class template. It looks pretty much exactly like what has already been shown in <a class="el" href="step_4.html">step-4</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>EigenvalueProblem</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file);</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span>         make_grid_and_dofs();</div>
<div class="line">  <span class="keywordtype">void</span>         assemble_system();</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line">  <span class="keywordtype">void</span>         output_results() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>;</div>
<div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>;</div>
<div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div>
</div><!-- fragment --><p>With these exceptions: For our eigenvalue problem, we need both a stiffness matrix for the left hand side as well as a mass matrix for the right hand side. We also need not just one solution function, but a whole set of these for the eigenfunctions we want to compute, along with the corresponding eigenvalues:</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix</a>             stiffness_matrix, <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div>
<div class="line">std::vector&lt;PETScWrappers::MPI::Vector&gt; eigenfunctions;</div>
<div class="line">std::vector&lt;double&gt;                     <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>;</div>
</div><!-- fragment --><p>And then we need an object that will store several run-time parameters that we will specify in an input file :</p>
<div class="fragment"><div class="line"><a class="code" href="classParameterHandler.html">ParameterHandler</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>;</div>
</div><!-- fragment --><p>Finally, we will have an object that contains "constraints" on our degrees of freedom. This could include hanging node constraints if we had adaptively refined meshes (which we don't have in the current program). Here, we will store the constraints for boundary nodes \(U_i=0\).</p>
<div class="fragment"><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeEigenvalueProblemcodeclass"></a> </p><h3>Implementation of the <code>EigenvalueProblem</code> class</h3>
<p><a class="anchor" id="EigenvalueProblemEigenvalueProblem"></a> </p><h4>EigenvalueProblem::EigenvalueProblem</h4>
<p>First up, the constructor. The main new part is handling the run-time input parameters. We need to declare their existence first, and then read their values from the input file whose name is specified as an argument to this function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">EigenvalueProblem&lt;dim&gt;::EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file)</div>
<div class="line">  : <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>(1)</div>
<div class="line">  , dof_handler(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">{</div>
</div><!-- fragment --><p>TODO investigate why the minimum number of refinement steps required to obtain the correct eigenvalue degeneracies is 6</p>
<div class="fragment"><div class="line">  <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.declare_entry(</div>
<div class="line">    <span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;5&quot;</span>,</div>
<div class="line">    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 20),</div>
<div class="line">    <span class="stringliteral">&quot;The number of times the 1-cell coarse mesh should &quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;be refined globally for our computations.&quot;</span>);</div>
<div class="line">  <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.declare_entry(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>,</div>
<div class="line">                           <span class="stringliteral">&quot;5&quot;</span>,</div>
<div class="line">                           <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 100),</div>
<div class="line">                           <span class="stringliteral">&quot;The number of eigenvalues/eigenfunctions &quot;</span></div>
<div class="line">                           <span class="stringliteral">&quot;to be computed.&quot;</span>);</div>
<div class="line">  <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.declare_entry(<span class="stringliteral">&quot;Potential&quot;</span>,</div>
<div class="line">                           <span class="stringliteral">&quot;0&quot;</span>,</div>
<div class="line">                           <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div>
<div class="line">                           <span class="stringliteral">&quot;A functional description of the potential.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.parse_input(prm_file);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemmake_grid_and_dofs"></a> </p><h4>EigenvalueProblem::make_grid_and_dofs</h4>
<p>The next function creates a mesh on the domain \([-1,1]^d\), refines it as many times as the input file calls for, and then attaches a <a class="el" href="classDoFHandler.html">DoFHandler</a> to it and initializes the matrices and vectors to their correct sizes. We also build the constraints that correspond to the boundary values \(u|_{\partial\Omega}=0\).</p>
<p>For the matrices, we use the PETSc wrappers. These have the ability to allocate memory as necessary as non-zero entries are added. This seems inefficient: we could as well first compute the sparsity pattern, initialize the matrices with it, and as we then insert entries we can be sure that we do not need to re-allocate memory and free the one used previously. One way to do that would be to use code like this: </p><div class="CodeFragmentInTutorialComment"> <div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></div>
<div class="line">   dsp (dof_handler.n_dofs(),</div>
<div class="line">        dof_handler.n_dofs());</div>
<div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div>
<div class="line">dsp.compress ();</div>
<div class="line">stiffness_matrix.reinit (dsp);</div>
<div class="line"><a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit (dsp);</div>
</div><!-- fragment --> </div><p> instead of the two <code><a class="el" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit()</a></code> calls for the stiffness and mass matrices below.</p>
<p>This doesn't quite work, unfortunately. The code above may lead to a few entries in the non-zero pattern to which we only ever write zero entries; most notably, this holds true for off-diagonal entries for those rows and columns that belong to boundary nodes. This shouldn't be a problem, but for whatever reason, PETSc's ILU preconditioner, which we use to solve linear systems in the eigenvalue solver, doesn't like these extra entries and aborts with an error message.</p>
<p>In the absence of any obvious way to avoid this, we simply settle for the second best option, which is have PETSc allocate memory as necessary. That said, since this is not a time critical part, this whole affair is of no further importance.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::make_grid_and_dofs()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>, -1, 1);</div>
<div class="line">  <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.refine_global(</div>
<div class="line">    <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.get_integer(<span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>));</div>
<div class="line">  dof_handler.distribute_dofs(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a>(dof_handler, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>);</div>
<div class="line">  <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line"> </div>
<div class="line">  stiffness_matrix.reinit(dof_handler.n_dofs(),</div>
<div class="line">                          dof_handler.n_dofs(),</div>
<div class="line">                          dof_handler.max_couplings_between_dofs());</div>
<div class="line">  <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(dof_handler.n_dofs(),</div>
<div class="line">                     dof_handler.n_dofs(),</div>
<div class="line">                     dof_handler.max_couplings_between_dofs());</div>
</div><!-- fragment --><p>The next step is to take care of the eigenspectrum. In this case, the outputs are eigenvalues and eigenfunctions, so we set the size of the list of eigenfunctions and eigenvalues to be as large as we asked for in the input file. When using a <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>, the <a class="el" href="classVector.html">Vector</a> is initialized using an <a class="el" href="classIndexSet.html">IndexSet</a>. <a class="el" href="classIndexSet.html">IndexSet</a> is used not only to resize the <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> but it also associates an index in the <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> with a degree of freedom (see <a class="el" href="step_40.html">step-40</a> for a more detailed explanation). The function <a class="el" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set()</a> creates an <a class="el" href="classIndexSet.html">IndexSet</a> where every valid index is part of the set. Note that this program can only be run sequentially and will throw an exception if used in parallel.</p>
<div class="fragment"><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> eigenfunction_index_set = dof_handler.locally_owned_dofs();</div>
<div class="line">  eigenfunctions.resize(</div>
<div class="line">    <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.get_integer(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>));</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; eigenfunctions.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">    eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>].<a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(eigenfunction_index_set, MPI_COMM_WORLD);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>.resize(eigenfunctions.size());</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemassemble_system"></a> </p><h4>EigenvalueProblem::assemble_system</h4>
<p>Here, we assemble the global stiffness and mass matrices from local contributions \(A^K_{ij} = \int_K \nabla\varphi_i(\mathbf x) \cdot \nabla\varphi_j(\mathbf x) + V(\mathbf x)\varphi_i(\mathbf x)\varphi_j(\mathbf x)\) and \(M^K_{ij} = \int_K \varphi_i(\mathbf x)\varphi_j(\mathbf x)\) respectively. This function should be immediately familiar if you've seen previous tutorial programs. The only thing new would be setting up an object that described the potential \(V(\mathbf x)\) using the expression that we got from the input file. We then need to evaluate this object at the quadrature points on each cell. If you've seen how to evaluate function objects (see, for example the coefficient in <a class="el" href="step_5.html">step-5</a>), the code here will also look rather familiar.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::assemble_system()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                          quadrature_formula,</div>
<div class="line">                          <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                            <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_stiffness_matrix(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div>
<div class="line">  potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div>
<div class="line">                       <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div>
<div class="line">                       <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;double&gt; potential_values(<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.active_cell_iterators())</div>
<div class="line">    {</div>
<div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">      cell_stiffness_matrix = 0;</div>
<div class="line">      cell_mass_matrix      = 0;</div>
<div class="line"> </div>
<div class="line">      potential.<a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(fe_values.get_quadrature_points(),</div>
<div class="line">                           potential_values);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q_point)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">            {</div>
<div class="line">              cell_stiffness_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=           </div>
<div class="line">                (fe_values.shape_grad(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) *    </div>
<div class="line">                   fe_values.shape_grad(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point)    </div>
<div class="line">                 +                                     </div>
<div class="line">                 potential_values[q_point] *           </div>
<div class="line">                   fe_values.shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) * </div>
<div class="line">                   fe_values.shape_value(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point)   </div>
<div class="line">                 ) *                                   </div>
<div class="line">                fe_values.JxW(q_point);                </div>
<div class="line"> </div>
<div class="line">              cell_mass_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=              </div>
<div class="line">                (fe_values.shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) * </div>
<div class="line">                 fe_values.shape_value(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point)   </div>
<div class="line">                 ) *                                 </div>
<div class="line">                fe_values.JxW(q_point);              </div>
<div class="line">            }</div>
</div><!-- fragment --><p>Now that we have the local matrix contributions, we transfer them into the global objects and take care of zero boundary constraints:</p>
<div class="fragment"><div class="line">  <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_stiffness_matrix,</div>
<div class="line">                                         <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                         stiffness_matrix);</div>
<div class="line">  <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_mass_matrix,</div>
<div class="line">                                         <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                         <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>At the end of the function, we tell PETSc that the matrices have now been fully assembled and that the sparse matrix representation can now be compressed as no more entries will be added:</p>
<div class="fragment"><div class="line">stiffness_matrix.compress(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
<div class="line"><a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.compress(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
</div><!-- fragment --><p>Before leaving the function, we calculate spurious eigenvalues, introduced to the system by zero Dirichlet constraints. As discussed in the introduction, the use of Dirichlet boundary conditions coupled with the fact that the degrees of freedom located at the boundary of the domain remain part of the linear system we solve, introduces a number of spurious eigenvalues. Below, we output the interval within which they all lie to ensure that we can ignore them should they show up in our computations.</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">std::numeric_limits&lt;double&gt;::max</a>(),</div>
<div class="line">         max_spurious_eigenvalue = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">std::numeric_limits&lt;double&gt;::max</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; dof_handler.n_dofs(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>))</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> ev         = stiffness_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) / <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>);</div>
<div class="line">        min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeae4878b1e562785c1c196238a3f14e0">std::min</a>(min_spurious_eigenvalue, ev);</div>
<div class="line">        max_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">std::max</a>(max_spurious_eigenvalue, ev);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;   Spurious eigenvalues are all in the interval &quot;</span></div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; min_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;,&quot;</span></div>
<div class="line">            &lt;&lt; max_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemsolve"></a> </p><h4>EigenvalueProblem::solve</h4>
<p>This is the key new functionality of the program. Now that the system is set up, here is a good time to actually solve the problem: As with other examples this is done using a "solve" routine. Essentially, it works as in other programs: you set up a <a class="el" href="classSolverControl.html">SolverControl</a> object that describes the accuracy to which we want to solve the linear systems, and then we select the kind of solver we want. Here we choose the Krylov-Schur solver of SLEPc, a pretty fast and robust choice for this kind of problem:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">EigenvalueProblem&lt;dim&gt;::solve</a>()</div>
<div class="line">{</div>
</div><!-- fragment --><p>We start here, as we normally do, by assigning convergence control we want:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(dof_handler.n_dofs(), 1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-9);</div>
<div class="line"><a class="code" href="classSLEPcWrappers_1_1SolverKrylovSchur.html">SLEPcWrappers::SolverKrylovSchur</a> eigensolver(solver_control);</div>
</div><!-- fragment --><p>Before we actually solve for the eigenfunctions and -values, we have to also select which set of eigenvalues to solve for. Lets select those eigenvalues and corresponding eigenfunctions with the smallest real part (in fact, the problem we solve here is symmetric and so the eigenvalues are purely real). After that, we can actually let SLEPc do its work:</p>
<div class="fragment"><div class="line">eigensolver.set_which_eigenpairs(EPS_SMALLEST_REAL);</div>
<div class="line"> </div>
<div class="line">eigensolver.set_problem_type(EPS_GHEP);</div>
<div class="line"> </div>
<div class="line">eigensolver.solve(stiffness_matrix,</div>
<div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>,</div>
<div class="line">                  <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>,</div>
<div class="line">                  eigenfunctions,</div>
<div class="line">                  eigenfunctions.size());</div>
</div><!-- fragment --><p>The output of the call above is a set of vectors and values. In eigenvalue problems, the eigenfunctions are only determined up to a constant that can be fixed pretty arbitrarily. Knowing nothing about the origin of the eigenvalue problem, SLEPc has no other choice than to normalize the eigenvectors to one in the \(l_2\) (vector) norm. Unfortunately this norm has little to do with any norm we may be interested from a eigenfunction perspective: the \(L_2(\Omega)\) norm, or maybe the \(L_\infty(\Omega)\) norm.</p>
<p>Let us choose the latter and rescale eigenfunctions so that they have \(\|\phi_i(\mathbf x)\|_{L^\infty(\Omega)}=1\) instead of \(\|\Phi\|_{l_2}=1\) (where \(\phi_i\) is the \(i\)th eigen<em>function</em> and \(\Phi_i\) the corresponding vector of nodal values). For the \(Q_1\) elements chosen here, we know that the maximum of the function \(\phi_i(\mathbf x)\) is attained at one of the nodes, so \(\max_{\mathbf x}\phi_i(\mathbf x)=\max_j (\Phi_i)_j\), making the normalization in the \(L_\infty\) norm trivial. Note that this doesn't work as easily if we had chosen \(Q_k\) elements with \(k&gt;1\): there, the maximum of a function does not necessarily have to be attained at a node, and so \(\max_{\mathbf x}\phi_i(\mathbf x)\ge\max_j (\Phi_i)_j\) (although the equality is usually nearly true).</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; eigenfunctions.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">  eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>] /= eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>].<a class="code" href="classTensor.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a>();</div>
</div><!-- fragment --><p>Finally return the number of iterations it took to converge:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">return</span> solver_control.last_step();</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemoutput_results"></a> </p><h4>EigenvalueProblem::output_results</h4>
<p>This is the last significant function of this program. It uses the <a class="el" href="classDataOut.html">DataOut</a> class to generate graphical output from the eigenfunctions for later visualization. It works as in many of the other tutorial programs.</p>
<p>The whole collection of functions is then output as a single VTK file.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line"> </div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; eigenfunctions.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>],</div>
<div class="line">                             std::string(<span class="stringliteral">&quot;eigenfunction_&quot;</span>) +</div>
<div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>));</div>
</div><!-- fragment --><p>The only thing worth discussing may be that because the potential is specified as a function expression in the input file, it would be nice to also have it as a graphical representation along with the eigenfunctions. The process to achieve this is relatively straightforward: we build an object that represents \(V(\mathbf x)\) and then we interpolate this continuous function onto the finite element space. The result we also attach to the <a class="el" href="classDataOut.html">DataOut</a> object for visualization.</p>
<div class="fragment"><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> projected_potential(dof_handler.n_dofs());</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div>
<div class="line">    potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div>
<div class="line">                         <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div>
<div class="line">                         <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div>
<div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, potential, projected_potential);</div>
<div class="line">  }</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(projected_potential, <span class="stringliteral">&quot;interpolated_potential&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">  std::ofstream <a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>(<span class="stringliteral">&quot;eigenvectors.vtk&quot;</span>);</div>
<div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(<a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemrun"></a> </p><h4>EigenvalueProblem::run</h4>
<p>This is the function which has the top-level control over everything. It is almost exactly the same as in <a class="el" href="step_4.html">step-4</a>:</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">EigenvalueProblem&lt;dim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line">    make_grid_and_dofs();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells() &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    assemble_system();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations = <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solver converged in &quot;</span> &lt;&lt; n_iterations &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    output_results();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;      Eigenvalue &quot;</span> &lt;&lt; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>]</div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step36</span></div>
</div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespaceStep36.html">Step36</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div>
</div><!-- fragment --><p>This program can only be run in serial. Otherwise, throw an exception.</p>
<div class="fragment"><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div>
<div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div>
<div class="line">                <span class="stringliteral">&quot;This program can only be run in serial, use ./step-36&quot;</span>));</div>
<div class="line"> </div>
<div class="line">  EigenvalueProblem&lt;2&gt; <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>(<span class="stringliteral">&quot;step-36.prm&quot;</span>);</div>
<div class="line">  <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>.run();</div>
<div class="line">}</div>
</div><!-- fragment --><p>All the while, we are watching out if any exceptions should have been generated. If that is so, we panic...</p>
<div class="fragment"><div class="line"><span class="keywordflow">catch</span> (<a class="code" href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">std::exception</a> &amp;exc)</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">catch</span> (...)</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
</div><!-- fragment --><p>If no exceptions are thrown, then we tell the program to stop monkeying around and exit nicely:</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;   Job done.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Runningtheproblem"></a></p><h3>Running the problem</h3>
<p>The problem's input is parameterized by an input file <code>step-36.prm</code> which could, for example, contain the following text:</p>
<div class="fragment"><div class="line"><a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Global <a class="code" href="distributed__0_8txt.html#a1a9fea1222a1f75ee681b6805de5f7fc">mesh</a> <a class="code" href="quadrature__point__data__0_8txt.html#a35c4177ef651238576ebc1395f9e116e">refinement</a> <a class="code" href="solver__cg__0_8txt.html#ab8dd1e5e6028b76d234561ae8e1d22bc">steps</a>         = 5</div>
<div class="line"><a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>/eigenfunctions = 5</div>
<div class="line"><a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Potential                            = 0</div>
</div><!-- fragment --><p>Here, the potential is zero inside the domain, and we know that the eigenvalues are given by \(\lambda_{(mn)}=\frac{\pi^2}{4}(m^2+n^2)\) where \(m,n\in{\mathbb N^+}\). Eigenfunctions are sines and cosines with \(m\) and \(n\) periods in \(x\) and \(y\) directions. This matches the output our program generates: </p><div class="fragment"><div class="line"><a class="code" href="work__stream__0_8txt.html#a2252e3964ca906e132dfb7ffa15c79b8">examples</a>/<a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>-36&gt; make <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a></div>
<div class="line">============================ Running <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>-36</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>:       1024</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 1089</div>
<div class="line">   Solver <a class="code" href="slepc__solver__0_8txt.html#a571efee620e9221401b6a7460c561d1a">converged</a> <a class="code" href="coding__conventions__0_8txt.html#ad83f9d9d8b603ed71c3483de199bc7a7">in</a> 67 <a class="code" href="dofs_2dof__handler__0_8txt.html#aae1f8d9ad7eda22eb5458605a6db742d">iterations</a>.</div>
<div class="line"> </div>
<div class="line">      Eigenvalue 0 : 4.93877</div>
<div class="line">      Eigenvalue 1 : 12.3707</div>
<div class="line">      Eigenvalue 2 : 12.3707</div>
<div class="line">      Eigenvalue 3 : 19.8027</div>
<div class="line">      Eigenvalue 4 : 24.837</div>
<div class="line"> </div>
<div class="line">   Job <a class="code" href="multithreading__0_8txt.html#a1f10342dea7040f4c9a27bde8019d1a2">done</a>.  </div>
</div><!-- fragment --><p> These eigenvalues are exactly the ones that correspond to pairs \((m,n)=(1,1)\), \((1,2)\) and \((2,1)\), \((2,2)\), and \((3,1)\). A visualization of the corresponding eigenfunctions would look like this:</p>
<table width="80%">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.0.png" alt="" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.1.png" alt="" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.2.png" alt="" class="inline"/>  </td></tr>
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.3.png" alt="" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.4.png" alt="" class="inline"/> </td><td></td></tr>
</table>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>It is always worth playing a few games in the playground! So here goes with a few suggestions:</p>
<ul>
<li>
<p class="startli">The potential used above (called the <em>infinite well</em> because it is a flat potential surrounded by infinitely high walls) is interesting because it allows for analytically known solutions. Apart from that, it is rather boring, however. That said, it is trivial to play around with the potential by just setting it to something different in the input file. For example, let us assume that we wanted to work with the following potential in 2d: </p><p class="formulaDsp">
\[ V(x,y) = \left\{ \begin{array}{ll} -100 &amp; \text{if}\ \sqrt{x^2+y^2}&lt;\frac 34 \ \text{and} \ xy&gt;0 \\ -5 &amp; \text{if}\ \sqrt{x^2+y^2}&lt;\frac 34 \ \text{and} \ xy\le 0 \\ 0 &amp; \text{otherwise} \end{array} \right.\quad. \]
</p>
<p> In other words, the potential is -100 in two sectors of a circle of radius 0.75, -5 in the other two sectors, and zero outside the circle. We can achieve this by using the following in the input file : </p><div class="fragment"><div class="line"><a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Potential = <span class="keywordflow">if</span> (<a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>^2 + <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa2626b9a8731384418b99aaadfc1d365">y</a>^2 &lt; 0.75^2, <span class="keywordflow">if</span> (<a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>*<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa2626b9a8731384418b99aaadfc1d365">y</a> &gt; 0, -100, -5), 0)</div>
</div><!-- fragment --><p> If in addition we also increase the mesh refinement by one level, we get the following results: </p><div class="fragment"><div class="line"><a class="code" href="work__stream__0_8txt.html#a2252e3964ca906e132dfb7ffa15c79b8">examples</a>/<a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>-36&gt; make <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a></div>
<div class="line">============================ Running <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>-36</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>:       4096</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 4225</div>
<div class="line"> </div>
<div class="line">   Eigenvalue 0 : -74.2562</div>
<div class="line">   Eigenvalue 1 : -72.7322</div>
<div class="line">   Eigenvalue 2 : -42.7406</div>
<div class="line">   Eigenvalue 3 : -42.2232</div>
<div class="line">   Eigenvalue 4 : -37.0744</div>
</div><!-- fragment --><p class="interli">The output file also contains an interpolated version of the potential, which looks like this (note that as expected the lowest few eigenmodes have probability densities \(|\Psi(\mathbf x)|^2\) that are significant only where the potential is the lowest, i.e. in the top right and bottom left sector of inner circle of the potential):</p>
<p class="interli"><img src="https://www.dealii.org/images/steps/developer/step-36.mod.potential.png" alt="" class="inline"/></p>
<p class="interli">The first five eigenfunctions are now like this:</p>
<table width="80%">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.0.png" alt="" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.1.png" alt="" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.2.png" alt="" class="inline"/>  </td></tr>
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.3.png" alt="" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.4.png" alt="" class="inline"/> </td><td></td></tr>
</table>
<p class="endli"></p>
</li>
<li>
<p class="startli">In our derivation of the problem we have assumed that the particle is confined to a domain \(\Omega\) and that at the boundary of this domain its probability \(|\Psi|^2\) of being is zero. This is equivalent to solving the eigenvalue problem on all of \({\mathbb R}^d\) and assuming that the energy potential is finite only inside a region \(\Omega\) and infinite outside. It is relatively easy to show that \(|\Psi(\mathbf x)|^2\) at all locations \(\mathbf x\) where \(V(\mathbf x)=\infty\). So the question is what happens if our potential is not of this form, i.e. there is no bounded domain outside of which the potential is infinite? In that case, it may be worth to just consider a very large domain at the boundary of which \(V(\mathbf x)\) is at least very large, if not infinite. Play around with a few cases like this and explore how the spectrum and eigenfunctions change as we make the computational region larger and larger.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">What happens if we investigate the simple harmonic oscillator problem \(V(\mathbf x)=c|\mathbf x|^2\)? This potential is exactly of the form discussed in the previous paragraph and has hyper spherical symmetry. One may want to use a large spherical domain with a large outer radius, to approximate the whole-space problem (say, by invoking <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The plots above show the wave function \(\Psi(\mathbf x)\), but the physical quantity of interest is actually the probability density \(|\Psi(\mathbf x)|^2\) for the particle to be at location \(\mathbf x\). Some visualization programs can compute derived quantities from the data in an input file, but we can also do so right away when creating the output file. The facility to do that is the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> class that can be used in conjunction with the <a class="el" href="classDataOut.html">DataOut</a> class. Examples of how this can be done can be found in <a class="el" href="step_29.html">step-29</a> and <a class="el" href="step_33.html">step-33</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">What happens if the particle in the box has internal degrees of freedom? For example, if the particle were a spin- \(1/2\) particle? In that case, we may want to start solving a vector-valued problem instead.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Our implementation of the deal.II library here uses the <a class="el" href="namespacePETScWrappers.html">PETScWrappers</a> and <a class="el" href="namespaceSLEPcWrappers.html">SLEPcWrappers</a> and is suitable for running on serial machine architecture. However, for larger grids and with a larger number of degrees-of-freedom, we may want to run our application on parallel architectures. A parallel implementation of the above code can be particularly useful here since the generalized eigenspectrum problem is somewhat more expensive to solve than the standard problems considered in most of the earlier tutorials. Fortunately, modifying the above program to be MPI compliant is a relatively straightforward procedure. A sketch of how this can be done can be found in <a class="el" href="step_17.html">step-17</a>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Finally, there are alternatives to using the SLEPc eigenvalue solvers. deal.II has interfaces to one of them, ARPACK (see <a href="../../external-libs/arpack.html">the ARPACK configuration page</a> for setup instructions), implemented in the <a class="el" href="classArpackSolver.html">ArpackSolver</a> class. Here is a short and quick overview of what one would need to change to use it, provided you have a working installation of ARPACK and deal.II has been configured properly for it (see the deal.II <a href="../../readme.html" target="body">README</a> file):</p>
<p class="interli">First, in order to use the ARPACK interfaces, we can go back to using standard deal.II matrices and vectors, so we start by replacing the PETSc and SLEPc headers </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2slepc__solver_8h.html">deal.II/lac/slepc_solver.h</a>&gt;</span></div>
</div><!-- fragment --><p> with these: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2arpack__solver_8h.html">deal.II/lac/arpack_solver.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/compressed_sparsity_pattern.h&gt;</span></div>
</div><!-- fragment --><p> ARPACK allows complex eigenvalues, so we will also need </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;complex&gt;</span></div>
</div><!-- fragment --><p class="interli">Secondly, we switch back to the deal.II matrix and vector definitions in the main class: </p><div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a>                     <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>;</div>
<div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>                stiffness_matrix, <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div>
<div class="line">std::vector&lt;Vector&lt;double&gt; &gt;        eigenfunctions;</div>
<div class="line">std::vector&lt;std::complex&lt;double&gt;&gt;   <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>;</div>
</div><!-- fragment --><p> and initialize them as usual in <code>make_grid_and_dofs()</code>: </p><div class="fragment"><div class="line"><a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>.reinit (dof_handler.n_dofs(),</div>
<div class="line">                         dof_handler.n_dofs(),</div>
<div class="line">                         dof_handler.max_couplings_between_dofs());</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> (dof_handler, <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line"><a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">condense</a> (<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line"><a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>.compress();</div>
<div class="line"> </div>
<div class="line">stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a> (<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line"><a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit (<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
</div><!-- fragment --><p class="endli">For solving the eigenvalue problem with ARPACK, we finally need to modify <code><a class="el" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve()</a></code>: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">EigenvalueProblem&lt;dim&gt;::solve</a> ()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (dof_handler.n_dofs(), 1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-9);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> <a class="code" href="precondition__block__base__0_8txt.html#aba039b811c123042272605d7c7c7c726">inverse</a>;</div>
<div class="line">  <a class="code" href="precondition__block__base__0_8txt.html#aba039b811c123042272605d7c7c7c726">inverse</a>.initialize (stiffness_matrix);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_arnoldi_vectors = 2*<a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>.size() + 2;</div>
<div class="line">  <a class="code" href="structArpackSolver_1_1AdditionalData.html">ArpackSolver::AdditionalData</a> additional_data(num_arnoldi_vectors);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classArpackSolver.html">ArpackSolver</a> eigensolver (solver_control, additional_data);</div>
<div class="line">  eigensolver.solve (stiffness_matrix,</div>
<div class="line">                     <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>,</div>
<div class="line">                     <a class="code" href="precondition__block__base__0_8txt.html#aba039b811c123042272605d7c7c7c726">inverse</a>,</div>
<div class="line">                     <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>,</div>
<div class="line">                     eigenfunctions,</div>
<div class="line">                     <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>.size());</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>=0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>&lt;eigenfunctions.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">    eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>] /= eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>].<a class="code" href="classTensor.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a> ();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> solver_control.last_step ();</div>
<div class="line">}</div>
</div><!-- fragment --><p> Note how we have used an exact decomposition (using <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>) as a preconditioner to ARPACK. </p>
</li>
</ul>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2009 - 2021 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div>
<div class="line"><span class="comment"> * the top level directory of deal.II.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Authors: Toby D. Young, Polish Academy of Sciences,</span></div>
<div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2function__parser_8h.html">deal.II/base/function_parser.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2slepc__solver_8h.html">deal.II/lac/slepc_solver.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceStep36.html">Step36</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>EigenvalueProblem</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file);</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span>         make_grid_and_dofs();</div>
<div class="line">    <span class="keywordtype">void</span>         assemble_system();</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line">    <span class="keywordtype">void</span>         output_results() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>;</div>
<div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>;</div>
<div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix</a>             stiffness_matrix, <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div>
<div class="line">    std::vector&lt;PETScWrappers::MPI::Vector&gt; eigenfunctions;</div>
<div class="line">    std::vector&lt;double&gt;                     <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a86885edfb652da041a42028c469d32b0">eigenvalues</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <a class="code" href="classStep36_1_1EigenvalueProblem.html#afc4425b6db4a59064e94bc1e1f56684d">EigenvalueProblem&lt;dim&gt;::EigenvalueProblem</a>(<span class="keyword">const</span> std::string &amp;prm_file)</div>
<div class="line">    : <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>(1)</div>
<div class="line">    , dof_handler(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.declare_entry(</div>
<div class="line">      <span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;5&quot;</span>,</div>
<div class="line">      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 20),</div>
<div class="line">      <span class="stringliteral">&quot;The number of times the 1-cell coarse mesh should &quot;</span></div>
<div class="line">      <span class="stringliteral">&quot;be refined globally for our computations.&quot;</span>);</div>
<div class="line">    <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.declare_entry(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>,</div>
<div class="line">                             <span class="stringliteral">&quot;5&quot;</span>,</div>
<div class="line">                             <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 100),</div>
<div class="line">                             <span class="stringliteral">&quot;The number of eigenvalues/eigenfunctions &quot;</span></div>
<div class="line">                             <span class="stringliteral">&quot;to be computed.&quot;</span>);</div>
<div class="line">    <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.declare_entry(<span class="stringliteral">&quot;Potential&quot;</span>,</div>
<div class="line">                             <span class="stringliteral">&quot;0&quot;</span>,</div>
<div class="line">                             <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div>
<div class="line">                             <span class="stringliteral">&quot;A functional description of the potential.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.parse_input(prm_file);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::make_grid_and_dofs()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>, -1, 1);</div>
<div class="line">    <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.refine_global(</div>
<div class="line">      <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.get_integer(<span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>));</div>
<div class="line">    dof_handler.distribute_dofs(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a>(dof_handler, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>);</div>
<div class="line">    <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line"> </div>
<div class="line">    stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(dof_handler.n_dofs(),</div>
<div class="line">                            dof_handler.n_dofs(),</div>
<div class="line">                            dof_handler.max_couplings_between_dofs());</div>
<div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(dof_handler.n_dofs(),</div>
<div class="line">                       dof_handler.n_dofs(),</div>
<div class="line">                       dof_handler.max_couplings_between_dofs());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> eigenfunction_index_set = dof_handler.locally_owned_dofs();</div>
<div class="line">    eigenfunctions.resize(</div>
<div class="line">      <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.get_integer(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>));</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; eigenfunctions.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">      eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>].<a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(eigenfunction_index_set, MPI_COMM_WORLD);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a86885edfb652da041a42028c469d32b0">eigenvalues</a>.resize(eigenfunctions.size());</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::assemble_system()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                            quadrature_formula,</div>
<div class="line">                            <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                              <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_stiffness_matrix(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div>
<div class="line">    potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div>
<div class="line">                         <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div>
<div class="line">                         <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;double&gt; potential_values(<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.active_cell_iterators())</div>
<div class="line">      {</div>
<div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">        cell_stiffness_matrix = 0;</div>
<div class="line">        cell_mass_matrix      = 0;</div>
<div class="line"> </div>
<div class="line">        potential.<a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(fe_values.get_quadrature_points(),</div>
<div class="line">                             potential_values);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q_point)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">              {</div>
<div class="line">                cell_stiffness_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=           </div>
<div class="line">                  (fe_values.shape_grad(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) *    </div>
<div class="line">                     fe_values.shape_grad(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point)    </div>
<div class="line">                   +                                     </div>
<div class="line">                   potential_values[q_point] *           </div>
<div class="line">                     fe_values.shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) * </div>
<div class="line">                     fe_values.shape_value(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point)   </div>
<div class="line">                   ) *                                   </div>
<div class="line">                  fe_values.JxW(q_point);                </div>
<div class="line"> </div>
<div class="line">                cell_mass_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=              </div>
<div class="line">                  (fe_values.shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) * </div>
<div class="line">                   fe_values.shape_value(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point)   </div>
<div class="line">                   ) *                                 </div>
<div class="line">                  fe_values.JxW(q_point);              </div>
<div class="line">              }</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_stiffness_matrix,</div>
<div class="line">                                               <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                               stiffness_matrix);</div>
<div class="line">        <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_mass_matrix,</div>
<div class="line">                                               <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                               <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    stiffness_matrix.<a class="code" href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">compress</a>(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
<div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.compress(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">std::numeric_limits&lt;double&gt;::max</a>(),</div>
<div class="line">           max_spurious_eigenvalue = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">std::numeric_limits&lt;double&gt;::max</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; dof_handler.n_dofs(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>))</div>
<div class="line">        {</div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> ev         = stiffness_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) / <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>);</div>
<div class="line">          min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeae4878b1e562785c1c196238a3f14e0">std::min</a>(min_spurious_eigenvalue, ev);</div>
<div class="line">          max_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">std::max</a>(max_spurious_eigenvalue, ev);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Spurious eigenvalues are all in the interval &quot;</span></div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; min_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;,&quot;</span></div>
<div class="line">              &lt;&lt; max_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">EigenvalueProblem&lt;dim&gt;::solve</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(dof_handler.n_dofs(), 1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-9);</div>
<div class="line">    <a class="code" href="classSLEPcWrappers_1_1SolverKrylovSchur.html">SLEPcWrappers::SolverKrylovSchur</a> eigensolver(solver_control);</div>
<div class="line"> </div>
<div class="line">    eigensolver.set_which_eigenpairs(EPS_SMALLEST_REAL);</div>
<div class="line"> </div>
<div class="line">    eigensolver.set_problem_type(EPS_GHEP);</div>
<div class="line"> </div>
<div class="line">    eigensolver.solve(stiffness_matrix,</div>
<div class="line">                      <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>,</div>
<div class="line">                      <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a86885edfb652da041a42028c469d32b0">eigenvalues</a>,</div>
<div class="line">                      eigenfunctions,</div>
<div class="line">                      eigenfunctions.size());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; eigenfunctions.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">      eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>] /= eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>].<a class="code" href="base_2tensor_8h.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> solver_control.last_step();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line"> </div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; eigenfunctions.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>],</div>
<div class="line">                               std::string(<span class="stringliteral">&quot;eigenfunction_&quot;</span>) +</div>
<div class="line">                                 <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>));</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> projected_potential(dof_handler.n_dofs());</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div>
<div class="line">      potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div>
<div class="line">                           <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div>
<div class="line">                           <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div>
<div class="line">      <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, potential, projected_potential);</div>
<div class="line">    }</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(projected_potential, <span class="stringliteral">&quot;interpolated_potential&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">    std::ofstream <a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>(<span class="stringliteral">&quot;eigenvectors.vtk&quot;</span>);</div>
<div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(<a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">EigenvalueProblem&lt;dim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line">    make_grid_and_dofs();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells() &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    assemble_system();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations = <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solver converged in &quot;</span> &lt;&lt; n_iterations &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    output_results();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a86885edfb652da041a42028c469d32b0">eigenvalues</a>.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;      Eigenvalue &quot;</span> &lt;&lt; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a86885edfb652da041a42028c469d32b0">eigenvalues</a>[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>]</div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step36</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespaceStep36.html">Step36</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div>
<div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div>
<div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-36&quot;</span>));</div>
<div class="line"> </div>
<div class="line">      EigenvalueProblem&lt;2&gt; <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>(<span class="stringliteral">&quot;step-36.prm&quot;</span>);</div>
<div class="line">      <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>.run();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">catch</span> (<a class="code" href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">std::exception</a> &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;   Job done.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p><br  />
 This tutorial depends on <a class="el" href="step_4.html">step-4</a> .  
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a><a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#EigenvaluesandDirichletboundaryconditions">Eigenvalues and Dirichlet boundary conditions</a><a href="#EigenvaluesandDirichletboundaryconditions">Eigenvalues and Dirichlet boundary conditions</a>
        <li><a href="#Implementationdetails">Implementation details</a><a href="#Implementationdetails">Implementation details</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a><a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeEigenvalueProblemcodeclasstemplate">The <code>EigenvalueProblem</code> class template</a><a href="#ThecodeEigenvalueProblemcodeclasstemplate">The <code>EigenvalueProblem</code> class template</a>
        <li><a href="#ImplementationofthecodeEigenvalueProblemcodeclass">Implementation of the <code>EigenvalueProblem</code> class</a><a href="#ImplementationofthecodeEigenvalueProblemcodeclass">Implementation of the <code>EigenvalueProblem</code> class</a>
      <ul>
        <li><a href="#EigenvalueProblemEigenvalueProblem">EigenvalueProblem::EigenvalueProblem</a><a href="#EigenvalueProblemEigenvalueProblem">EigenvalueProblem::EigenvalueProblem</a>
        <li><a href="#EigenvalueProblemmake_grid_and_dofs">EigenvalueProblem::make_grid_and_dofs</a><a href="#EigenvalueProblemmake_grid_and_dofs">EigenvalueProblem::make_grid_and_dofs</a>
        <li><a href="#EigenvalueProblemassemble_system">EigenvalueProblem::assemble_system</a><a href="#EigenvalueProblemassemble_system">EigenvalueProblem::assemble_system</a>
        <li><a href="#EigenvalueProblemsolve">EigenvalueProblem::solve</a><a href="#EigenvalueProblemsolve">EigenvalueProblem::solve</a>
        <li><a href="#EigenvalueProblemoutput_results">EigenvalueProblem::output_results</a><a href="#EigenvalueProblemoutput_results">EigenvalueProblem::output_results</a>
        <li><a href="#EigenvalueProblemrun">EigenvalueProblem::run</a><a href="#EigenvalueProblemrun">EigenvalueProblem::run</a>
      </ul>
        <li><a href="#Thecodemaincodefunction">The <code>main</code> function</a><a href="#Thecodemaincodefunction">The <code>main</code> function</a>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a><a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Runningtheproblem">Running the problem</a><a href="#Runningtheproblem">Running the problem</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a><a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <br  />
 <br  />
 <em>This program was contributed by Toby D. Young and Wolfgang Bangerth. </em> <a class="anchor" id="Preamble"></a><a class="anchor" id="Preamble"></a></p><h1>Preamble</h1>
<p>The problem we want to solve in this example is an eigenspectrumproblem. Eigenvalue problems appear in a wide context of problems, forexample in the computation of electromagnetic standing waves incavities, vibration modes of drum membranes, or oscillations of lakesand estuaries. One of the most enigmatic applications is probably thecomputation of stationary or quasi-static wave functions in quantummechanics. The latter application is what we would like to investigatehere, though the general techniques outlined in this program are ofcourse equally applicable to the other applications above. Eigenspectrum problems have the general form </p><p class="formulaDsp">
\begin{align*} L \Psi &amp;= \varepsilon \Psi \qquad &amp;&amp;\text{in}\ \Omega\quad, \\ \Psi &amp;= 0 &amp;&amp;\text{on}\ \partial\Omega\quad, \end{align*}
</p>
<p> where the Dirichlet boundary condition on \(\Psi=\Psi(\mathbf x)\) could also bereplaced by Neumann or Robin conditions; \(L\) is an operator that generallyalso contains differential operators. Under suitable conditions, the above equations have a set of solutions \(\Psi_\ell,\varepsilon_\ell\) , \(\ell\in {\cal I}\) , where \(\cal I\) canbe a finite or infinite set (and in the latter case it may be a discrete orsometimes at least in part a continuous set). In either case, let us note thatthere isno longer just a single solution, but a set of solutions (the variouseigenfunctions and corresponding eigenvalues) that we want tocompute. The problem of numerically finding all eigenvalues(eigenfunctions) of such eigenvalue problems is a formidablechallenge. In fact, if the set \(\cal I\) is infinite, the challenge isof course intractable. Most of the time however we are really onlyinterested in a small subset of these values (functions); andfortunately, the interface to the SLEPc library that we will use forthis tutorial program allows us to select which portion of theeigenspectrum and how many solutions we want to solve for. In this program, the eigenspectrum solvers we use are classes providedby deal.II that wrap around the linear algebra implementation of the<a href="http://www.grycap.upv.es/slepc/" target="_top">SLEPc</a>library; SLEPc itself builds on the <a href="http://www.mcs.anl.gov/petsc/" target="_top">PETSc</a> libraryfor linear algebra contents. <a class="anchor" id="Intro"></a><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>The basic equation of stationary quantum mechanics is theSchr√∂dinger equation which models the motion of particles in anexternal potential \(V(\mathbf x)\) . The particle is described by a wavefunction \(\Psi(\mathbf x)\) that satisfies a relation of the(nondimensionalized) form </p><p class="formulaDsp">
\begin{align*} [-\Delta + V(\mathbf x)] \Psi(\mathbf x) &amp;= \varepsilon \Psi(\mathbf x) \qquad &amp;&amp;\text{in}\ \Omega\quad, \\ \Psi &amp;= 0 &amp;&amp;\text{on}\ \partial\Omega\quad. \end{align*}
</p>
<p> As a consequence, this particle can only exist in a certain number ofeigenstates that correspond to the energy eigenvalues \(\varepsilon_\ell\) admitted as solutions of this equation. Theorthodox (Copenhagen) interpretation of quantum mechanics posits that, if aparticle has energy \(\varepsilon_\ell\) then the probability of findingit at location \(\mathbf x\) is proportional to \(|\Psi_\ell(\mathbf x)|^2\) where \(\Psi_\ell\) is the eigenfunction that corresponds to thiseigenvalue. In order to numerically find solutions to this equation, i.e. a set ofpairs of eigenvalues/eigenfunctions, we use the usual finite elementapproach of multiplying the equation from the left with test functions,integrating by parts, and searching for solutions in finitedimensional spaces by approximating \(\Psi(\mathbf x)\approx\Psi_h(\mathbf x)=\sum_{j}\phi_j(\mathbf x)\tilde\psi_j\) ,where \(\tilde\psi\) is a vector of expansion coefficients. We thenimmediately arrive at the following equation that discretizes thecontinuous eigenvalue problem: </p><p class="formulaDsp">
\[ \sum_j [(\nabla\phi_i, \nabla\phi_j)+(V(\mathbf x)\phi_i,\phi_j)] \tilde{\psi}_j = \varepsilon_h \sum_j (\phi_i, \phi_j) \tilde{\psi}_j\quad. \]
</p>
<p> Inmatrix and vector notation, this equation then reads: </p><p class="formulaDsp">
\[ A \tilde{\Psi} = \varepsilon_h M \tilde{\Psi} \quad, \]
</p>
<p> where \(A\) isthe stiffness matrix arising from the differential operator \(L\) , and \(M\) is the mass matrix. The solution to the eigenvalue problem is aneigenspectrum \(\varepsilon_{h,\ell}\) , with associated eigenfunctions \(\Psi_\ell=\sum_j \phi_j\tilde{\psi}_j\) .</p>
<p><a class="anchor" id="EigenvaluesandDirichletboundaryconditions"></a></p><h3>Eigenvalues and Dirichlet boundary conditions</h3>
<p>In this program, we use Dirichlet boundary conditions for the wavefunction \(\Psi\) . What this means, from the perspective of a finiteelement code, is that only the interior degrees of freedom are realdegrees of <em>freedom</em>: the ones on the boundary are not free butare forced to have a zero value, after all. On the other hand, thefinite element method gains much of its power and simplicity fromthe fact that we just do the same thing on every cell, withouthaving to think too much about where a cell is, whether it boundson a less refined cell and consequently has a hanging node, or isadjacent to the boundary. All such checks would make the assemblyof finite element linear systems unbearably difficult to write andeven more so to read. Consequently, of course, when you distribute degrees of freedom withyour <a class="el" href="classDoFHandler.html">DoFHandler</a> object, you don't care whether some of the degreesof freedom you enumerate are at a Dirichlet boundary. They all getnumbers. We just have to take care of these degrees of freedom at alater time when we apply boundary values. There are two basic waysof doing this (either using <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a> <em>after</em> assembling the linear system, or using <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> <em>during</em> assembly;see the <a class="el" href="group__constraints.html">constraints module</a> for more information),but both result in the same: a linear system that has a totalnumber of rows equal to the number of <em>all</em> degrees of freedom,including those that lie on the boundary. However, degrees offreedom that are constrained by Dirichlet conditions are separatedfrom the rest of the linear system by zeroing out the correspondingrow and column, putting a single positive entry on the diagonal,and the corresponding Dirichlet value on the right hand side. If you assume for a moment that we had renumbered degrees of freedomin such a way that all of those on the Dirichlet boundary come last,then the linear system we would get when solving a regular PDE witha right hand side would look like this: </p><p class="formulaDsp">
\begin{align*} \begin{pmatrix} A_i &amp; 0 \\ 0 &amp; D_b \end{pmatrix} \begin{pmatrix} U_i \\ U_b \end{pmatrix} = \begin{pmatrix} F_i \\ F_b \end{pmatrix}. \end{align*}
</p>
<p> Here, subscripts \(i\) and \(b\) correspond to interior and boundarydegrees of freedom, respectively. The interior degrees of freedomsatisfy the linear system \(A_i U_i=F_i\) which yields the correctsolution in the interior, and boundary values are determined by \(U_b = D_b^{-1} F_b\) where \(D_b\) is a diagonal matrix that resultsfrom the process of eliminating boundary degrees of freedom, and \(F_b\) is chosen in such a way that \(U_{b,j}=D_{b,jj}^{-1} F_{b,j}\) has the correct boundary values for every boundary degree of freedom \(j\) . (For the curious, the entries of thematrix \(D_b\) result from adding modified local contributions to theglobal matrix where for the local matrices the diagonal elements, if non-zero,are set to their absolute value; otherwise, they are set to the average ofabsolute values of the diagonal. This process guarantees that the entriesof \(D_b\) are positive and of a size comparable to the rest of the diagonalentries, ensuring that the resulting matrix does not incur unreasonablelosses of accuracy due to roundoff involving matrix entries of drasticallydifferent size. The actual values that end up on the diagonal are difficultto predict and you should treat them as arbitrary and unpredictable, butpositive.) For "regular" linear systems, this all leads to the correct solution.On the other hand, for eigenvalue problems, this is not so trivial.There, eliminating boundary values affects both matrices \(A\) and \(M\) that we will solve with in the current tutorial program.After elimination of boundary values, we then receive an eigenvalueproblem that can be partitioned like this: </p><p class="formulaDsp">
\begin{align*} \begin{pmatrix} A_i &amp; 0 \\ 0 &amp; D_A \end{pmatrix} \begin{pmatrix} \tilde\Psi_i \\ \tilde\Psi_b \end{pmatrix} = \epsilon_h \begin{pmatrix} M_i &amp; 0 \\ 0 &amp; D_M \end{pmatrix} \begin{pmatrix} \tilde\Psi_i \\ \tilde\Psi_b \end{pmatrix}. \end{align*}
</p>
<p> This form makes it clear that there are two sets of eigenvalues:the ones we care about, and spurious eigenvalues from theseparated problem </p><p class="formulaDsp">
\[ D_A \tilde \Psi_b = \epsilon_h D_M \Psi_b. \]
</p>
<p>@_fakenlThese eigenvalues are spurious since they result from an eigenvaluesystem that operates only on boundary nodes</p>
<ul>
<li>nodes that are notreal degrees of <em>freedom</em>.Of course, since the two matrices \(D_A,D_M\) are diagonal, we canexactly quantify these spurious eigenvalues: they are \(\varepsilon_{h,j}=D_{A,jj}/D_{M,jj}\) (where the indices \(j\) corresponds exactly to the degrees of freedom that are constrainedby Dirichlet boundary values). So how does one deal with them? The fist part is to recognize when oureigenvalue solver finds one of them. To this end, the program computesand prints an interval within which these eigenvalues lie, by computingthe minimum and maximum of the expression \(\varepsilon_{h,j}=D_{A,jj}/D_{M,jj}\) over all constrained degrees of freedom. In the program below, thisalready suffices: we find that this interval lies outside the set ofsmallest eigenvalues and corresponding eigenfunctions we are interestedin and compute, so there is nothing we need to do here. On the other hand, it may happen that we find that one of the eigenvalueswe compute in this program happens to be in this interval, and in thatcase we would not know immediately whether it is a spurious or a trueeigenvalue. In that case, one could simply scale the diagonal elements ofeither matrix after computing the two matrices,thus shifting them away from the frequency of interest in the eigen-spectrum.This can be done by using the following code, making sure that all spuriouseigenvalues are exactly equal to \(1.234\cdot 10^5\) : <div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; dof_handler.n_dofs(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">  <span class="keywordflow">if</span> (<a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>))</div>
<div class="line">    {</div>
<div class="line">      stiffness_matrix.<a class="code" href="classSparseMatrix.html#a3e77fcfbd1fa3ac83ef4ff2951b24ce3">set</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, 1.234e5);</div>
<div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.set(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, 1);</div>
<div class="line">    }</div>
</div><!-- fragment --> However, this strategy is not pursued here as the spurious eigenvalueswe get from our program as-is happen to be greater than the lowestfive that we will calculate and are interested in.</li>
</ul>
<p><a class="anchor" id="Implementationdetails"></a></p><h3>Implementation details</h3>
<p>The program below is essentially just a slightly modified version of <a class="el" href="step_4.html">step-4</a> . The things that are different are the following: </p><ul>
<li>
</li>
</ul>
<p><br  />
  The main class (named <code>EigenvalueProblem</code> ) now nolonger has a single solution vector, but a whole set of vectors forthe various eigenfunctions we want to compute. Moreover, the <code>main</code> function, which has the top-level control overeverything here, initializes and finalizes the interface to SLEPc andPETSc simultaneously via <code>SlepcInitialize</code> and <code>SlepFinalize</code> .  <br  />
  We use PETSc matrices and vectors as in <a class="el" href="step_17.html">step-17</a> and <a class="el" href="step_18.html">step-18</a> since that is what the SLEPc eigenvalue solversrequire.  <br  />
  The function <code>EigenvalueProblem::solve</code> is entirelydifferent from anything seen so far in the tutorial, as it does notjust solve a linear system but actually solves the eigenvalue problem.It is built on the SLEPc library, and more immediately on the deal.IISLEPc wrappers in the class <a class="el" href="classSLEPcWrappers_1_1SolverKrylovSchur.html">SLEPcWrappers::SolverKrylovSchur</a>. <br  />
  We use the <a class="el" href="classParameterHandler.html">ParameterHandler</a> class to describe a few inputparameters, such as the exact form of the potential \(V({\mathbf x})\) , the number of global refinement steps of the mesh,or the number of eigenvalues we want to solve for. We could go muchfurther with this but stop at making only a few of the things that onecould select at run time actual input file parameters. In order to seewhat could be done in this regard, take a look at <a class="el" href="step_29.html">@ref step_29 </a>step-29"  " and <a class="el" href="step_33.html">step-33</a> .   We use the <a class="el" href="classFunctionParser.html">FunctionParser</a> class to make the potential \(V(\mathbf x)\) a run-time parameter that can be specified in the input file as aformula.   <br  />
 The rest of the program follows in a pretty straightforward way from <a class="el" href="step_4.html">step-4</a> .</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>As mentioned in the introduction, this program is essentially only a slightly revised version of <a class="el" href="step_4.html">step-4</a> . As a consequence, most of the following include files are as used there, or at least as used already in previous tutorial programs:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2function__parser_8h.html">deal.II/base/function_parser.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
</div><!-- fragment --><p><a class="el" href="classIndexSet.html">IndexSet</a> is used to set the size of each <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>: <br  />
</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div>
</div><!-- fragment --><p>PETSc appears here because SLEPc depends on this library:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div>
</div><!-- fragment --><p>And then we need to actually import the interfaces for solvers that SLEPc provides:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2slepc__solver_8h.html">deal.II/lac/slepc_solver.h</a>&gt;</span></div>
</div><!-- fragment --><p>We also need some standard C++:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
</div><!-- fragment --><p>Finally, as in previous programs, we import all the deal.II class and function names into the namespace into which everything in this program will go:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceStep36.html">Step36</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
</div><!-- fragment --><p><a class="anchor" id="ThecodeEigenvalueProblemcodeclasstemplate"></a> </p><h3>The <code>EigenvalueProblem</code> class template</h3>
<p>Following is the class declaration for the main class template. It looks pretty much exactly like what has already been shown in <a class="el" href="step_4.html">step-4</a> :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keyword">class </span>EigenvalueProblem</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file);</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a>();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span>         make_grid_and_dofs();</div>
<div class="line">  <span class="keywordtype">void</span>         assemble_system();</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line">  <span class="keywordtype">void</span>         output_results() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>;</div>
<div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>;</div>
<div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div>
</div><!-- fragment --><p>With these exceptions: For our eigenvalue problem, we need both a stiffness matrix for the left hand side as well as a mass matrix for the right hand side. We also need not just one solution function, but a whole set of these for the eigenfunctions we want to compute, along with the corresponding eigenvalues:</p>
<div class="fragment"><div class="line"><a class="code" href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix</a>             stiffness_matrix, <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div>
<div class="line">std::vector&lt;PETScWrappers::MPI::Vector&gt; eigenfunctions;</div>
<div class="line">std::vector&lt;double&gt;                     <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>;</div>
</div><!-- fragment --><p>And then we need an object that will store several run-time parameters that we will specify in an input file :</p>
<div class="fragment"><div class="line"><a class="code" href="classParameterHandler.html">ParameterHandler</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>;</div>
</div><!-- fragment --><p>Finally, we will have an object that contains "constraints" on our degrees of freedom. This could include hanging node constraints if we had adaptively refined meshes (which we don't have in the current program). Here, we will store the constraints for boundary nodes \(U_i=0\) .</p>
<div class="fragment"><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p><a class="anchor" id="ImplementationofthecodeEigenvalueProblemcodeclass"></a> </p><h3>Implementation of the <code>EigenvalueProblem</code> class</h3>
<pre class="fragment">&lt;a name="EigenvalueProblemEigenvalueProblem"&gt;&lt;/a&gt;  &lt;h4&gt;EigenvalueProblem::EigenvalueProblem&lt;/h4&gt;
</pre><p>First up, the constructor. The main new part is handling the run-time input parameters. We need to declare their existence first, and then read their values from the input file whose name is specified as an argument to this function:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">EigenvalueProblem&lt;dim&gt;::EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file)</div>
<div class="line">  : <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>(1)</div>
<div class="line">  , dof_handler(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">{</div>
</div><!-- fragment --><p>TODO investigate why the minimum number of refinement steps required to obtain the correct eigenvalue degeneracies is 6</p>
<div class="fragment"><div class="line">  <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.declare_entry(</div>
<div class="line">    <span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>,</div>
<div class="line">    <span class="stringliteral">&quot;5&quot;</span>,</div>
<div class="line">    <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 20),</div>
<div class="line">    <span class="stringliteral">&quot;The number of times the 1-cell coarse mesh should &quot;</span></div>
<div class="line">    <span class="stringliteral">&quot;be refined globally for our computations.&quot;</span>);</div>
<div class="line">  <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.declare_entry(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>,</div>
<div class="line">                           <span class="stringliteral">&quot;5&quot;</span>,</div>
<div class="line">                           <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 100),</div>
<div class="line">                           <span class="stringliteral">&quot;The number of eigenvalues/eigenfunctions &quot;</span></div>
<div class="line">                           <span class="stringliteral">&quot;to be computed.&quot;</span>);</div>
<div class="line">  <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.declare_entry(<span class="stringliteral">&quot;Potential&quot;</span>,</div>
<div class="line">                           <span class="stringliteral">&quot;0&quot;</span>,</div>
<div class="line">                           <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div>
<div class="line">                           <span class="stringliteral">&quot;A functional description of the potential.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.parse_input(prm_file);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemmake_grid_and_dofs"></a> </p><h4>EigenvalueProblem::make_grid_and_dofs</h4>
<p>The next function creates a mesh on the domain \([-1,1]^d\) , refines it as many times as the input file calls for, and then attaches a <a class="el" href="classDoFHandler.html">DoFHandler</a> to it and initializes the matrices and vectors to their correct sizes. We also build the constraints that correspond to the boundary values \(u|_{\partial\Omega}=0\) . <br  />
 For the matrices, we use the PETSc wrappers. These have the ability to allocate memory as necessary as non-zero entries are added. This seems inefficient: we could as well first compute the sparsity pattern, initialize the matrices with it, and as we then insert entries we can be sure that we do not need to re-allocate memory and free the one used previously. One way to do that would be to use code like this: </p><div class="CodeFragmentInTutorialComment"></div><div class="CodeFragmentInTutorialComment"><div class="fragment"><div class="line"><a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></div>
<div class="line">   dsp (dof_handler.n_dofs(),</div>
<div class="line">        dof_handler.n_dofs());</div>
<div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> (dof_handler, dsp);</div>
<div class="line">dsp.compress ();</div>
<div class="line">stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a> (dsp);</div>
<div class="line"><a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit (dsp);</div>
</div><!-- fragment --></div><div class="CodeFragmentInTutorialComment"> </div><p> instead of the two <code><a class="el" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit()</a></code> calls for the stiffness and mass matrices below. <br  />
 This doesn't quite work, unfortunately. The code above may lead to a few entries in the non-zero pattern to which we only ever write zero entries; most notably, this holds true for off-diagonal entries for those rows and columns that belong to boundary nodes. This shouldn't be a problem, but for whatever reason, PETSc's ILU preconditioner, which we use to solve linear systems in the eigenvalue solver, doesn't like these extra entries and aborts with an error message. <br  />
 In the absence of any obvious way to avoid this, we simply settle for the second best option, which is have PETSc allocate memory as necessary. That said, since this is not a time critical part, this whole affair is of no further importance.</p>
<div class="fragment"><div class="line">   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">   <span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::make_grid_and_dofs()</div>
<div class="line">   {</div>
<div class="line">     <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>,</div>
<div class="line">  </div>
<div class="line">-1, 1);</div>
<div class="line">     <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.refine_global(</div>
<div class="line">       <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.get_integer(<span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>));</div>
<div class="line">     dof_handler.distribute_dofs(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>);</div>
<div class="line">  </div>
<div class="line">     <a class="code" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a>(dof_handler, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>);</div>
<div class="line">     <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line">  </div>
<div class="line">     stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(dof_handler.n_dofs(),</div>
<div class="line">                             dof_handler.n_dofs(),</div>
<div class="line">                             dof_handler.max_couplings_between_dofs());</div>
<div class="line">     <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(dof_handler.n_dofs(),</div>
<div class="line">                        dof_handler.n_dofs(),</div>
<div class="line">                        dof_handler.max_couplings_between_dofs());</div>
</div><!-- fragment --><p>The next step is to take care of the eigenspectrum. In this case, the outputs are eigenvalues and eigenfunctions, so we set the size of the list of eigenfunctions and eigenvalues to be as large as we asked for in the input file. When using a <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a>, the <a class="el" href="classVector.html">Vector</a> is initialized using an <a class="el" href="classIndexSet.html">IndexSet</a>. <a class="el" href="classIndexSet.html">IndexSet</a> is used not only to resize the <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> but it also associates an index in the <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">PETScWrappers::MPI::Vector</a> with a degree of freedom (see <a class="el" href="step_40.html">step-40</a> for a more detailed explanation). The function <a class="el" href="classIndexSet.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set()</a> creates an <a class="el" href="classIndexSet.html">IndexSet</a> where every valid index is part of the set. Note that this program can only be run sequentially and will throw an exception if used in parallel.</p>
<div class="fragment"><div class="line">  <a class="code" href="classIndexSet.html">IndexSet</a> eigenfunction_index_set = dof_handler.locally_owned_dofs();</div>
<div class="line">  eigenfunctions.resize(</div>
<div class="line">    <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.get_integer(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>));</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; eigenfunctions.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">    eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>].<a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(eigenfunction_index_set, MPI_COMM_WORLD);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>.resize(eigenfunctions.size());</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemassemble_system"></a> </p><h4>EigenvalueProblem::assemble_system</h4>
<p>Here, we assemble the global stiffness and mass matrices from local contributions \(A^K_{ij} = \int_K \nabla\varphi_i(\mathbf x) \cdot \nabla\varphi_j(\mathbf x) + V(\mathbf x)\varphi_i(\mathbf x)\varphi_j(\mathbf x)\) and \(M^K_{ij} = \int_K \varphi_i(\mathbf x)\varphi_j(\mathbf x)\) respectively. This function should be immediately familiar if you've seen previous tutorial programs. The only thing new would be setting up an object that described the potential \(V(\mathbf x)\) using the expression that we got from the input file. We then need to evaluate this object at the quadrature points on each cell. If you've seen how to evaluate function objects (see, for example the coefficient in <a class="el" href="step_5.html">step-5</a> ), the code here will also look rather familiar.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::assemble_system()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                          quadrature_formula,</div>
<div class="line">                          <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                            <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_stiffness_matrix(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div>
<div class="line">  potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div>
<div class="line">                       <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div>
<div class="line">                       <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div>
<div class="line"> </div>
<div class="line">  std::vector&lt;double&gt; potential_values(<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>);</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.active_cell_iterators())</div>
<div class="line">    {</div>
<div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">      cell_stiffness_matrix = 0;</div>
<div class="line">      cell_mass_matrix      = 0;</div>
<div class="line"> </div>
<div class="line">      potential.<a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(fe_values.get_quadrature_points(),</div>
<div class="line">                           potential_values);</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q_point)</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">            {</div>
<div class="line">              cell_stiffness_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=           </div>
<div class="line">                (fe_values.shape_grad(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point)    </div>
<div class="line">                   fe_values.shape_grad(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point)    </div>
<div class="line">                 +                                     </div>
<div class="line">                 potential_values[q_point]           </div>
<div class="line">                   fe_values.shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) </div>
<div class="line">                   fe_values.shape_value(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point)   </div>
<div class="line">                 )                                   </div>
<div class="line">                fe_values.JxW(q_point);                </div>
<div class="line"> </div>
<div class="line">              cell_mass_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=              </div>
<div class="line">                (fe_values.shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) </div>
<div class="line">                 fe_values.shape_value(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point)   </div>
<div class="line">                 )                                 </div>
<div class="line">                fe_values.JxW(q_point);              </div>
<div class="line">            }</div>
</div><!-- fragment --><p>Now that we have the local matrix contributions, we transfer them into the global objects and take care of zero boundary constraints:</p>
<div class="fragment"><div class="line">  <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_stiffness_matrix,</div>
<div class="line">                                         <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                         stiffness_matrix);</div>
<div class="line">  <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_mass_matrix,</div>
<div class="line">                                         <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                         <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>At the end of the function, we tell PETSc that the matrices have now been fully assembled and that the sparse matrix representation can now be compressed as no more entries will be added:</p>
<div class="fragment"><div class="line">stiffness_matrix.<a class="code" href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">compress</a>(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
<div class="line"><a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.compress(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
</div><!-- fragment --><p>Before leaving the function, we calculate spurious eigenvalues, introduced to the system by zero Dirichlet constraints. As discussed in the introduction, the use of Dirichlet boundary conditions coupled with the fact that the degrees of freedom located at the boundary of the domain remain part of the linear system we solve, introduces a number of spurious eigenvalues. Below, we output the interval within which they all lie to ensure that we can ignore them should they show up in our computations.</p>
<div class="fragment"><div class="line">     <span class="keywordtype">double</span> min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">std::numeric_limits&lt;double&gt;::max</a>(),</div>
<div class="line">            max_spurious_eigenvalue =</div>
<div class="line">  </div>
<div class="line">-<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">std::numeric_limits&lt;double&gt;::max</a>();</div>
<div class="line">  </div>
<div class="line">     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; dof_handler.n_dofs(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">       <span class="keywordflow">if</span> (<a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>))</div>
<div class="line">         {</div>
<div class="line">           <span class="keyword">const</span> <span class="keywordtype">double</span> ev         = stiffness_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) / <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>);</div>
<div class="line">           min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeae4878b1e562785c1c196238a3f14e0">std::min</a>(min_spurious_eigenvalue, ev);</div>
<div class="line">           max_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">std::max</a>(max_spurious_eigenvalue, ev);</div>
<div class="line">         }</div>
<div class="line">  </div>
<div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;   Spurious eigenvalues are all in the interval &quot;</span></div>
<div class="line">               &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; min_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;,&quot;</span></div>
<div class="line">               &lt;&lt; max_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">   }</div>
</div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemsolve"></a> </p><h4>EigenvalueProblem::solve</h4>
<p>This is the key new functionality of the program. Now that the system is set up, here is a good time to actually solve the problem: As with other examples this is done using a "solve" routine. Essentially, it works as in other programs: you set up a <a class="el" href="classSolverControl.html">SolverControl</a> object that describes the accuracy to which we want to solve the linear systems, and then we select the kind of solver we want. Here we choose the Krylov-Schur solver of SLEPc, a pretty fast and robust choice for this kind of problem:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">EigenvalueProblem&lt;dim&gt;::solve</a>()</div>
<div class="line">{</div>
</div><!-- fragment --><p>We start here, as we normally do, by assigning convergence control we want:</p>
<div class="fragment"><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(dof_handler.n_dofs(), 1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-9);</div>
<div class="line"><a class="code" href="classSLEPcWrappers_1_1SolverKrylovSchur.html">SLEPcWrappers::SolverKrylovSchur</a> eigensolver(solver_control);</div>
</div><!-- fragment --><p>Before we actually solve for the eigenfunctions and</p>
<ul>
<li>alues, we have to also select which set of eigenvalues to solve for. Lets select those eigenvalues and corresponding eigenfunctions with the smallest real part (in fact, the problem we solve here is symmetric and so the eigenvalues are purely real). After that, we can actually let SLEPc do its work:</li>
</ul>
<div class="fragment"><div class="line">eigensolver.set_which_eigenpairs(EPS_SMALLEST_REAL);</div>
<div class="line"> </div>
<div class="line">eigensolver.set_problem_type(EPS_GHEP);</div>
<div class="line"> </div>
<div class="line">eigensolver.solve(stiffness_matrix,</div>
<div class="line">                  <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>,</div>
<div class="line">                  <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>,</div>
<div class="line">                  eigenfunctions,</div>
<div class="line">                  eigenfunctions.size());</div>
</div><!-- fragment --><p>The output of the call above is a set of vectors and values. In eigenvalue problems, the eigenfunctions are only determined up to a constant that can be fixed pretty arbitrarily. Knowing nothing about the origin of the eigenvalue problem, SLEPc has no other choice than to normalize the eigenvectors to one in the \(l_2\) (vector) norm. Unfortunately this norm has little to do with any norm we may be interested from a eigenfunction perspective: the \(L_2(\Omega)\) norm, or maybe the \(L_\infty(\Omega)\) norm. <br  />
 Let us choose the latter and rescale eigenfunctions so that they have \(\|\phi_i(\mathbf x)\|_{L^\infty(\Omega)}=1\) instead of \(\|\Phi\|_{l_2}=1\) (where \(\phi_i\) is the \(i\) th eigen<em>function</em> and \(\Phi_i\) the corresponding vector of nodal values). For the \(Q_1\) elements chosen here, we know that the maximum of the function \(\phi_i(\mathbf x)\) is attained at one of the nodes, so \(\max_{\mathbf x}\phi_i(\mathbf x)=\max_j (\Phi_i)_j\) , making the normalization in the \(L_\infty\) norm trivial. Note that this doesn't work as easily if we had chosen \(Q_k\) elements with \(k&gt;1\) : there, the maximum of a function does not necessarily have to be attained at a node, and so \(\max_{\mathbf x}\phi_i(\mathbf x)\ge\max_j (\Phi_i)_j\) (although the equality is usually nearly true).</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; eigenfunctions.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">  eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>] /= eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>].<a class="code" href="classTensor.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a>();</div>
</div><!-- fragment --><p>Finally return the number of iterations it took to converge:</p>
<div class="fragment"><div class="line">  <span class="keywordflow">return</span> solver_control.last_step();</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemoutput_results"></a> </p><h4>EigenvalueProblem::output_results</h4>
<p>This is the last significant function of this program. It uses the <a class="el" href="classDataOut.html">DataOut</a> class to generate graphical output from the eigenfunctions for later visualization. It works as in many of the other tutorial programs. <br  />
 The whole collection of functions is then output as a single VTK file.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword"></span>{</div>
<div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line"> </div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; eigenfunctions.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>],</div>
<div class="line">                             std::string(<span class="stringliteral">&quot;eigenfunction_&quot;</span>) +</div>
<div class="line">                               <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>));</div>
</div><!-- fragment --><p>The only thing worth discussing may be that because the potential is specified as a function expression in the input file, it would be nice to also have it as a graphical representation along with the eigenfunctions. The process to achieve this is relatively straightforward: we build an object that represents \(V(\mathbf x)\) and then we interpolate this continuous function onto the finite element space. The result we also attach to the <a class="el" href="classDataOut.html">DataOut</a> object for visualization.</p>
<div class="fragment"><div class="line">  <a class="code" href="classVector.html">Vector&lt;double&gt;</a> projected_potential(dof_handler.n_dofs());</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div>
<div class="line">    potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div>
<div class="line">                         <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div>
<div class="line">                         <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div>
<div class="line">    <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, potential, projected_potential);</div>
<div class="line">  }</div>
<div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(projected_potential, <span class="stringliteral">&quot;interpolated_potential&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">  std::ofstream <a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>(<span class="stringliteral">&quot;eigenvectors.vtk&quot;</span>);</div>
<div class="line">  data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(<a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="anchor" id="EigenvalueProblemrun"></a> </p><h4>EigenvalueProblem::run</h4>
<p>This is the function which has the top-level control over everything. It is almost exactly the same as in <a class="el" href="step_4.html">step-4</a> :</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">EigenvalueProblem&lt;dim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line">    make_grid_and_dofs();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells() &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    assemble_system();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations = <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solver converged in &quot;</span> &lt;&lt; n_iterations &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    output_results();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;      Eigenvalue &quot;</span> &lt;&lt; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>]</div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step36</span></div>
</div><!-- fragment --><p><a class="anchor" id="Thecodemaincodefunction"></a> </p><h3>The <code>main</code> function</h3>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>*argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespaceStep36.html">Step36</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div>
</div><!-- fragment --><p>This program can only be run in serial. Otherwise, throw an exception.</p>
<div class="fragment"><div class="line">  <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div>
<div class="line">              <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div>
<div class="line">                <span class="stringliteral">&quot;This program can only be run in serial, use ./step-36&quot;</span>));</div>
<div class="line"> </div>
<div class="line">  EigenvalueProblem&lt;2&gt; <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>(<span class="stringliteral">&quot;step-36.prm&quot;</span>);</div>
<div class="line">  <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>.run();</div>
<div class="line">}</div>
</div><!-- fragment --><p>All the while, we are watching out if any exceptions should have been generated. If that is so, we panic...</p>
<div class="fragment"><div class="line"><span class="keywordflow">catch</span> (<a class="code" href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">std::exception</a> &amp;exc)</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"><span class="keywordflow">catch</span> (...)</div>
<div class="line">  {</div>
<div class="line">    std::cerr &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
</div><!-- fragment --><p>If no exceptions are thrown, then we tell the program to stop monkeying around and exit nicely:</p>
<div class="fragment"><div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;   Job done.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Runningtheproblem"></a></p><h3>Running the problem</h3>
<p>The problem's input is parameterized by an input file <code>step-36.prm</code> which could, for example, contain the following text: </p><div class="fragment"><div class="line"><a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Global <a class="code" href="distributed__0_8txt.html#a1a9fea1222a1f75ee681b6805de5f7fc">mesh</a> <a class="code" href="quadrature__point__data__0_8txt.html#a35c4177ef651238576ebc1395f9e116e">refinement</a> <a class="code" href="solver__cg__0_8txt.html#ab8dd1e5e6028b76d234561ae8e1d22bc">steps</a>         = 5</div>
<div class="line"><a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>/eigenfunctions = 5</div>
<div class="line"><a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Potential                            = 0</div>
</div><!-- fragment --><p>Here, the potential is zero inside the domain, and we know that theeigenvalues are given by \(\lambda_{(mn)}=\frac{\pi^2}{4}(m^2+n^2)\) where \(m,n\in{\mathbb N^+}\) . Eigenfunctions are sines and cosines with \(m\) and \(n\) periods in \(x\) and \(y\) directions. This matches the output our programgenerates: </p><div class="fragment"><div class="line"><a class="code" href="work__stream__0_8txt.html#a2252e3964ca906e132dfb7ffa15c79b8">examples</a>/<a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>-36&gt; make <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a></div>
<div class="line">============================ Running <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>-36</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>:       1024</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 1089</div>
<div class="line">   Solver <a class="code" href="slepc__solver__0_8txt.html#a571efee620e9221401b6a7460c561d1a">converged</a> <a class="code" href="coding__conventions__0_8txt.html#ad83f9d9d8b603ed71c3483de199bc7a7">in</a> 67 <a class="code" href="dofs_2dof__handler__0_8txt.html#aae1f8d9ad7eda22eb5458605a6db742d">iterations</a>.</div>
<div class="line">  </div>
<div class="line">      Eigenvalue 0 : 4.93877</div>
<div class="line">      Eigenvalue 1 : 12.3707</div>
<div class="line">      Eigenvalue 2 : 12.3707</div>
<div class="line">      Eigenvalue 3 : 19.8027</div>
<div class="line">      Eigenvalue 4 : 24.837</div>
<div class="line">  </div>
<div class="line">   Job <a class="code" href="multithreading__0_8txt.html#a1f10342dea7040f4c9a27bde8019d1a2">done</a>.  </div>
</div><!-- fragment --><p> These eigenvalues are exactly the ones thatcorrespond to pairs \((m,n)=(1,1)\) , \((1,2)\) and \((2,1)\) , \((2,2)\) , and \((3,1)\) . A visualization of the corresponding eigenfunctions wouldlook like this: </p><table width="80%">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.0.png" alt="" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.1.png" alt="" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.2.png" alt="" class="inline"/>  </td></tr>
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.3.png" alt="" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-36.default.eigenfunction.4.png" alt="" class="inline"/> </td><td></td></tr>
</table>
<p><br  />
 <a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>It is always worth playing a few games in the playground! So here goeswith a few suggestions: </p><ul>
<li>
</li>
</ul>
<p><br  />
  The potential used above (called the <em>infinite well</em> becauseit is a flat potential surrounded by infinitely high walls) isinteresting because it allows for analytically known solutions. Apartfrom that, it is rather boring, however. That said, it is trivial toplay around with the potential by just setting it to somethingdifferent in the input file. For example, let us assume that we wantedto work with the following potential in2d: </p><p class="formulaDsp">
\[ V(x,y) = \left\{ \begin{array}{ll} -100 &amp; \text{if}\ \sqrt{x^2+y^2}&lt;\frac 34 \ \text{and} \ xy&gt;0 \\ -5 &amp; \text{if}\ \sqrt{x^2+y^2}&lt;\frac 34 \ \text{and} \ xy\le 0 \\ 0 &amp; \text{otherwise} \end{array} \right.\quad. \]
</p>
<p>@_fakenlIn other words, the potential is</p>
<ul>
<li>00 in two sectors of a circle of radius0.75,</li>
<li>in the other two sectors, and zero outside the circle. We can achievethis by using the following in the input file : <div class="fragment"><div class="line"><a class="code" href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a> Potential = <span class="keywordflow">if</span> (<a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>^2 + <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa2626b9a8731384418b99aaadfc1d365">y</a>^2 &lt; 0.75^2, <span class="keywordflow">if</span> (<a class="code" href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a>*<a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#aa2626b9a8731384418b99aaadfc1d365">y</a> &gt; 0,</div>
<div class="line">  </div>
<div class="line">-100,</div>
<div class="line">  </div>
<div class="line">-5), 0)</div>
</div><!-- fragment --> If in addition we also increase the mesh refinement by one level, we get thefollowing results: <div class="fragment"><div class="line"><a class="code" href="work__stream__0_8txt.html#a2252e3964ca906e132dfb7ffa15c79b8">examples</a>/<a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>-36&gt; make <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a></div>
<div class="line">============================ Running <a class="code" href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a>-36</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a> <a class="code" href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a>:       4096</div>
<div class="line">   <a class="code" href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Number</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a> <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> <a class="code" href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a>: 4225</div>
<div class="line">  </div>
<div class="line">   Eigenvalue 0 :</div>
<div class="line">  </div>
<div class="line">-74.2562</div>
<div class="line">   Eigenvalue 1 :</div>
<div class="line">  </div>
<div class="line">-72.7322</div>
<div class="line">   Eigenvalue 2 :</div>
<div class="line">  </div>
<div class="line">-42.7406</div>
<div class="line">   Eigenvalue 3 :</div>
<div class="line">  </div>
<div class="line">-42.2232</div>
<div class="line">   Eigenvalue 4 :</div>
<div class="line">  </div>
<div class="line">-37.0744</div>
</div><!-- fragment --></li>
</ul>
<p>The output file also contains an interpolated version of the potential, whichlooks like this (note that as expected the lowest few eigenmodes haveprobability densities \(|\Psi(\mathbf x)|^2\) that are significant only where thepotential is the lowest, i.e. in the top right and bottom left sector of innercircle of the potential): <img src="https://www.dealii.org/images/steps/developer/step-36.mod.potential.png" alt="" class="inline"/> <br  />
 The first five eigenfunctions are now like this: </p><table width="80%">
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.0.png" alt="" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.1.png" alt="" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.2.png" alt="" class="inline"/>  </td></tr>
<tr>
<td><img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.3.png" alt="" class="inline"/> </td><td><img src="https://www.dealii.org/images/steps/developer/step-36.mod.eigenfunction.4.png" alt="" class="inline"/> </td><td></td></tr>
</table>
<p><br  />
  In our derivation of the problem we have assumed that theparticle is confined to a domain \(\Omega\) and that at the boundary ofthis domain its probability \(|\Psi|^2\) of being is zero. This isequivalent to solving the eigenvalue problem on all of \({\mathbb R}^d\) and assuming that the energy potential is finite only inside a region \(\Omega\) and infinite outside. It is relatively easy to show that \(|\Psi(\mathbf x)|^2\) at all locations \(\mathbf x\) where \(V(\mathbf x)=\infty\) . So the question is what happens if our potential is not ofthis form, i.e. there is no bounded domain outside of which thepotential is infinite? In that case, it may be worth to just considera very large domain at the boundary of which \(V(\mathbf x)\) is atleast very large, if not infinite. Play around with a few cases likethis and explore how the spectrum and eigenfunctions change as we makethe computational region larger and larger.  What happens if we investigate the simple harmonic oscillatorproblem \(V(\mathbf x)=c|\mathbf x|^2\) ? This potential is exactly ofthe form discussed in the previous paragraph and has hyper sphericalsymmetry. One may want to use a large spherical domain with a largeouter radius, to approximate the whole-space problem (say, by invoking <a class="el" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>). <br  />
  The plots above show the wave function \(\Psi(\mathbf x)\) , but thephysical quantity of interest is actually the probability density \(|\Psi(\mathbf x)|^2\) for the particle to be at location \(\mathbf x\) .Some visualization programs can compute derived quantities from the data inan input file, but we can also do so right away when creating the outputfile. The facility to do that is the <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> class that canbe used in conjunction with the <a class="el" href="classDataOut.html">DataOut</a> class. Examples of how thiscan be done can be found in <a class="el" href="step_29.html">step-29</a> and <a class="el" href="step_33.html">step-33</a> .  What happens if the particle in the box has internal degrees offreedom? For example, if the particle were a spin- \(1/2\) particle? Inthat case, we may want to start solving a vector-valued probleminstead.  Our implementation of the deal.II library here uses thePETScWrappers and <a class="el" href="namespaceSLEPcWrappers.html">SLEPcWrappers</a> and is suitable for running on serialmachine architecture. However, for larger grids and with a largernumber of degrees-of-freedom, we may want to run our application onparallel architectures. A parallel implementation of the above codecan be particularly useful here since the generalized eigenspectrumproblem is somewhat more expensive to solve than the standard problemsconsidered in most of the earlier tutorials. Fortunately, modifying the aboveprogram to be MPI compliant is a relatively straightforwardprocedure. A sketch of how this can be done can be found in <a class="el" href="step_17.html">@ref step_17 </a>step-17"  ".  Finally, there are alternatives to using the SLEPc eigenvaluesolvers. deal.II has interfaces to one of them, ARPACK (see <a href="../../external-libs/arpack.html">the ARPACK configuration page</a> forsetup instructions), implemented in the <a class="el" href="classArpackSolver.html">ArpackSolver</a> class. Here is a short andquick overview of what one would need to change to use it, provided you have aworking installation of ARPACK and deal.II has been configured properly for it(see the deal.II <a href="../../readme.html" target="body">README</a> file): First, in order to use the ARPACK interfaces, we can go back to using standarddeal.II matrices and vectors, so we start by replacing the PETSc and SLEPcheaders </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2slepc__solver_8h.html">deal.II/lac/slepc_solver.h</a>&gt;</span></div>
</div><!-- fragment --><p> with these: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2arpack__solver_8h.html">deal.II/lac/arpack_solver.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__direct_8h.html">deal.II/lac/sparse_direct.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;deal.II/lac/compressed_sparsity_pattern.h&gt;</span></div>
</div><!-- fragment --><p> ARPACK allows complex eigenvalues, so we will also need </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;complex&gt;</span></div>
</div><!-- fragment --><p>Secondly, we switch back to the deal.II matrix and vector definitions in themain class: </p><div class="fragment"><div class="line"><a class="code" href="classSparsityPattern.html">SparsityPattern</a>                     <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>;</div>
<div class="line"><a class="code" href="classSparseMatrix.html">SparseMatrix&lt;double&gt;</a>                stiffness_matrix, <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div>
<div class="line">std::vector&lt;Vector&lt;double&gt; &gt;        eigenfunctions;</div>
<div class="line">std::vector&lt;std::complex&lt;double&gt;&gt;   <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>;</div>
</div><!-- fragment --><p> and initialize them as usual in <code>make_grid_and_dofs()</code> : </p><div class="fragment"><div class="line"><a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>.reinit (dof_handler.n_dofs(),</div>
<div class="line">                         dof_handler.n_dofs(),</div>
<div class="line">                         dof_handler.max_couplings_between_dofs());</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a> (dof_handler, <a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line"><a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">condense</a> (<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line"><a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>.compress();</div>
<div class="line"> </div>
<div class="line">stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a> (<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
<div class="line"><a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit (<a class="code" href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a>);</div>
</div><!-- fragment --><p>For solving the eigenvalue problem with ARPACK, we finally need to modify <code><a class="el" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve()</a></code> : </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">EigenvalueProblem&lt;dim&gt;::solve</a> ()</div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a> solver_control (dof_handler.n_dofs(), 1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-9);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a> <a class="code" href="precondition__block__base__0_8txt.html#aba039b811c123042272605d7c7c7c726">inverse</a>;</div>
<div class="line">  <a class="code" href="precondition__block__base__0_8txt.html#aba039b811c123042272605d7c7c7c726">inverse</a>.initialize (stiffness_matrix);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_arnoldi_vectors = 2*<a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>.size() + 2;</div>
<div class="line">  <a class="code" href="structArpackSolver_1_1AdditionalData.html">ArpackSolver::AdditionalData</a> additional_data(num_arnoldi_vectors);</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="classArpackSolver.html">ArpackSolver</a> eigensolver (solver_control, additional_data);</div>
<div class="line">  eigensolver.solve (stiffness_matrix,</div>
<div class="line">                     <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>,</div>
<div class="line">                     <a class="code" href="precondition__block__base__0_8txt.html#aba039b811c123042272605d7c7c7c726">inverse</a>,</div>
<div class="line">                     <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>,</div>
<div class="line">                     eigenfunctions,</div>
<div class="line">                     <a class="code" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a>.size());</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>=0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>&lt;eigenfunctions.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">    eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>] /= eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>].<a class="code" href="classTensor.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a> ();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> solver_control.last_step ();</div>
<div class="line">}</div>
</div><!-- fragment --><p> Note how we have used an exact decomposition (using <a class="el" href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a>) as apreconditioner to ARPACK.  <br  />
</p>
<p><a class="anchor" id="PlainProg"></a></p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/* ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Copyright (C) 2009 - 2021 by the deal.II authors</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * This file is part of the deal.II library.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute</span></div>
<div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General</span></div>
<div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either</span></div>
<div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div>
<div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at</span></div>
<div class="line"><span class="comment"> * the top level directory of deal.II.</span></div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * ---------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"> *</span></div>
<div class="line"><span class="comment"> * Authors: Toby D. Young, Polish Academy of Sciences,</span></div>
<div class="line"><span class="comment"> *          Wolfgang Bangerth, Texas A&amp;M University</span></div>
<div class="line"><span class="comment"> */</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2logstream_8h.html">deal.II/base/logstream.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2function_8h.html">deal.II/base/function.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2function__parser_8h.html">deal.II/base/function_parser.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2parameter__handler_8h.html">deal.II/base/parameter_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="base_2index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__sparse__matrix_8h.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2petsc__vector_8h.html">deal.II/lac/petsc_vector.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="lac_2slepc__solver_8h.html">deal.II/lac/slepc_solver.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceStep36.html">Step36</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keyword">class </span>EigenvalueProblem</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    EigenvalueProblem(<span class="keyword">const</span> std::string &amp;prm_file);</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span>         make_grid_and_dofs();</div>
<div class="line">    <span class="keywordtype">void</span>         assemble_system();</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line">    <span class="keywordtype">void</span>         output_results() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>;</div>
<div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>          <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>;</div>
<div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>    dof_handler;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix</a>             stiffness_matrix, <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>;</div>
<div class="line">    std::vector&lt;PETScWrappers::MPI::Vector&gt; eigenfunctions;</div>
<div class="line">    std::vector&lt;double&gt;                     <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a86885edfb652da041a42028c469d32b0">eigenvalues</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classParameterHandler.html">ParameterHandler</a> <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>;</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <a class="code" href="classStep36_1_1EigenvalueProblem.html#afc4425b6db4a59064e94bc1e1f56684d">EigenvalueProblem&lt;dim&gt;::EigenvalueProblem</a>(<span class="keyword">const</span> std::string &amp;prm_file)</div>
<div class="line">    : <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>(1)</div>
<div class="line">    , dof_handler(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.declare_entry(</div>
<div class="line">      <span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>,</div>
<div class="line">      <span class="stringliteral">&quot;5&quot;</span>,</div>
<div class="line">      <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 20),</div>
<div class="line">      <span class="stringliteral">&quot;The number of times the 1-cell coarse mesh should &quot;</span></div>
<div class="line">      <span class="stringliteral">&quot;be refined globally for our computations.&quot;</span>);</div>
<div class="line">    <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.declare_entry(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>,</div>
<div class="line">                             <span class="stringliteral">&quot;5&quot;</span>,</div>
<div class="line">                             <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 100),</div>
<div class="line">                             <span class="stringliteral">&quot;The number of eigenvalues/eigenfunctions &quot;</span></div>
<div class="line">                             <span class="stringliteral">&quot;to be computed.&quot;</span>);</div>
<div class="line">    <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.declare_entry(<span class="stringliteral">&quot;Potential&quot;</span>,</div>
<div class="line">                             <span class="stringliteral">&quot;0&quot;</span>,</div>
<div class="line">                             <a class="code" href="classPatterns_1_1Anything.html">Patterns::Anything</a>(),</div>
<div class="line">                             <span class="stringliteral">&quot;A functional description of the potential.&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.parse_input(prm_file);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::make_grid_and_dofs()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a>(<a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>, -1, 1);</div>
<div class="line">    <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.refine_global(</div>
<div class="line">      <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.get_integer(<span class="stringliteral">&quot;Global mesh refinement steps&quot;</span>));</div>
<div class="line">    dof_handler.distribute_dofs(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a>(dof_handler, <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>);</div>
<div class="line">    <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>();</div>
<div class="line"> </div>
<div class="line">    stiffness_matrix.<a class="code" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a>(dof_handler.n_dofs(),</div>
<div class="line">                            dof_handler.n_dofs(),</div>
<div class="line">                            dof_handler.max_couplings_between_dofs());</div>
<div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.reinit(dof_handler.n_dofs(),</div>
<div class="line">                       dof_handler.n_dofs(),</div>
<div class="line">                       dof_handler.max_couplings_between_dofs());</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> eigenfunction_index_set = dof_handler.locally_owned_dofs();</div>
<div class="line">    eigenfunctions.resize(</div>
<div class="line">      <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.get_integer(<span class="stringliteral">&quot;Number of eigenvalues/eigenfunctions&quot;</span>));</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; eigenfunctions.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">      eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>].<a class="code" href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">reinit</a>(eigenfunction_index_set, MPI_COMM_WORLD);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a86885edfb652da041a42028c469d32b0">eigenvalues</a>.resize(eigenfunctions.size());</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::assemble_system()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>.<a class="code" href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">degree</a> + 1);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values(<a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>,</div>
<div class="line">                            quadrature_formula,</div>
<div class="line">                            <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> |</div>
<div class="line">                              <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a> = <a class="code" href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a>.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>();</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_stiffness_matrix(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> cell_mass_matrix(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>, <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;types::global_dof_index&gt; <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>(<a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>);</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div>
<div class="line">    potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div>
<div class="line">                         <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div>
<div class="line">                         <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;double&gt; potential_values(<a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a> : dof_handler.active_cell_iterators())</div>
<div class="line">      {</div>
<div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(<a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>);</div>
<div class="line">        cell_stiffness_matrix = 0;</div>
<div class="line">        cell_mass_matrix      = 0;</div>
<div class="line"> </div>
<div class="line">        potential.<a class="code" href="classFunction.html#a562fc1114e95e702e6696721f71528db">value_list</a>(fe_values.get_quadrature_points(),</div>
<div class="line">                             potential_values);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0; q_point &lt; <a class="code" href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a>; ++q_point)</div>
<div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> = 0; <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a> &lt; <a class="code" href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a>; ++<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>)</div>
<div class="line">              {</div>
<div class="line">                cell_stiffness_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=           </div>
<div class="line">                  (fe_values.shape_grad(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) *    </div>
<div class="line">                     fe_values.shape_grad(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point)    </div>
<div class="line">                   +                                     </div>
<div class="line">                   potential_values[q_point] *           </div>
<div class="line">                     fe_values.shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) * </div>
<div class="line">                     fe_values.shape_value(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point)   </div>
<div class="line">                   ) *                                   </div>
<div class="line">                  fe_values.JxW(q_point);                </div>
<div class="line"> </div>
<div class="line">                cell_mass_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>) +=              </div>
<div class="line">                  (fe_values.shape_value(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, q_point) * </div>
<div class="line">                   fe_values.shape_value(<a class="code" href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a>, q_point)   </div>
<div class="line">                   ) *                                 </div>
<div class="line">                  fe_values.JxW(q_point);              </div>
<div class="line">              }</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a>-&gt;get_dof_indices(<a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>);</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_stiffness_matrix,</div>
<div class="line">                                               <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                               stiffness_matrix);</div>
<div class="line">        <a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_mass_matrix,</div>
<div class="line">                                               <a class="code" href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a>,</div>
<div class="line">                                               <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>);</div>
<div class="line">      }</div>
<div class="line"> </div>
<div class="line">    stiffness_matrix.<a class="code" href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">compress</a>(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
<div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>.compress(<a class="code" href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">double</span> min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">std::numeric_limits&lt;double&gt;::max</a>(),</div>
<div class="line">           max_spurious_eigenvalue = -<a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">std::numeric_limits&lt;double&gt;::max</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; dof_handler.n_dofs(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">      <span class="keywordflow">if</span> (<a class="code" href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a>.<a class="code" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>))</div>
<div class="line">        {</div>
<div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> ev         = stiffness_matrix(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>) / <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>, <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>);</div>
<div class="line">          min_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeae4878b1e562785c1c196238a3f14e0">std::min</a>(min_spurious_eigenvalue, ev);</div>
<div class="line">          max_spurious_eigenvalue = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">std::max</a>(max_spurious_eigenvalue, ev);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Spurious eigenvalues are all in the interval &quot;</span></div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; min_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;,&quot;</span></div>
<div class="line">              &lt;&lt; max_spurious_eigenvalue &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">EigenvalueProblem&lt;dim&gt;::solve</a>()</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control(dof_handler.n_dofs(), 1<a class="code" href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a>-9);</div>
<div class="line">    <a class="code" href="classSLEPcWrappers_1_1SolverKrylovSchur.html">SLEPcWrappers::SolverKrylovSchur</a> eigensolver(solver_control);</div>
<div class="line"> </div>
<div class="line">    eigensolver.set_which_eigenpairs(EPS_SMALLEST_REAL);</div>
<div class="line"> </div>
<div class="line">    eigensolver.set_problem_type(EPS_GHEP);</div>
<div class="line"> </div>
<div class="line">    eigensolver.solve(stiffness_matrix,</div>
<div class="line">                      <a class="code" href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">mass_matrix</a>,</div>
<div class="line">                      <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a86885edfb652da041a42028c469d32b0">eigenvalues</a>,</div>
<div class="line">                      eigenfunctions,</div>
<div class="line">                      eigenfunctions.size());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; eigenfunctions.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">      eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>] /= eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>].<a class="code" href="base_2tensor_8h.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> solver_control.last_step();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> EigenvalueProblem&lt;dim&gt;::output_results()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div>
<div class="line"> </div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; eigenfunctions.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(eigenfunctions[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>],</div>
<div class="line">                               std::string(<span class="stringliteral">&quot;eigenfunction_&quot;</span>) +</div>
<div class="line">                                 <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>));</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> projected_potential(dof_handler.n_dofs());</div>
<div class="line">    {</div>
<div class="line">      <a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;</a> potential;</div>
<div class="line">      potential.<a class="code" href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">initialize</a>(<a class="code" href="classFunctionParser.html">FunctionParser&lt;dim&gt;::default_variable_names</a>(),</div>
<div class="line">                           <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a>.get(<span class="stringliteral">&quot;Potential&quot;</span>),</div>
<div class="line">                           <span class="keyword">typename</span> <a class="code" href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser&lt;dim&gt;::ConstMap</a>());</div>
<div class="line">      <a class="code" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a>(dof_handler, potential, projected_potential);</div>
<div class="line">    }</div>
<div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(projected_potential, <span class="stringliteral">&quot;interpolated_potential&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>();</div>
<div class="line"> </div>
<div class="line">    std::ofstream <a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>(<span class="stringliteral">&quot;eigenvectors.vtk&quot;</span>);</div>
<div class="line">    data_out.<a class="code" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a>(<a class="code" href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a>);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">EigenvalueProblem&lt;dim&gt;::run</a>()</div>
<div class="line">  {</div>
<div class="line">    make_grid_and_dofs();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells:       &quot;</span></div>
<div class="line">              &lt;&lt; <a class="code" href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a>.n_active_cells() &lt;&lt; std::endl</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom: &quot;</span> &lt;&lt; dof_handler.n_dofs()</div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    assemble_system();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_iterations = <a class="code" href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a>();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;   Solver converged in &quot;</span> &lt;&lt; n_iterations &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span></div>
<div class="line">              &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    output_results();</div>
<div class="line"> </div>
<div class="line">    std::cout &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> = 0; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt; <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a86885edfb652da041a42028c469d32b0">eigenvalues</a>.size(); ++<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>)</div>
<div class="line">      std::cout &lt;&lt; <span class="stringliteral">&quot;      Eigenvalue &quot;</span> &lt;&lt; <a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a> &lt;&lt; <span class="stringliteral">&quot; : &quot;</span> &lt;&lt; <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a86885edfb652da041a42028c469d32b0">eigenvalues</a>[<a class="code" href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a>]</div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">} <span class="comment">// namespace Step36</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>;</div>
<div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespaceStep36.html">Step36</a>;</div>
<div class="line"> </div>
<div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">      <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<a class="code" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a>(MPI_COMM_WORLD) == 1,</div>
<div class="line">                  <a class="code" href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">ExcMessage</a>(</div>
<div class="line">                    <span class="stringliteral">&quot;This program can only be run in serial, use ./step-36&quot;</span>));</div>
<div class="line"> </div>
<div class="line">      EigenvalueProblem&lt;2&gt; <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>(<span class="stringliteral">&quot;step-36.prm&quot;</span>);</div>
<div class="line">      <a class="code" href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a>.run();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">catch</span> (<a class="code" href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">std::exception</a> &amp;exc)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      std::cerr &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">      <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; std::endl &lt;&lt; <span class="stringliteral">&quot;   Job done.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="apolynomial__0_8txt_html_af1258c87f1d73d29bd17331843ac1d25"><div class="ttname"><a href="polynomial__0_8txt.html#af1258c87f1d73d29bd17331843ac1d25">i</a></div><div class="ttdeci">namespace in which classes relating to the description of d polynomial spaces are declared ***Base class for all D polynomials A polynomial is represented in this class by its coefficients which are set through the constructor or by derived classes There are two paths for evaluation of polynomials One is based on the coefficients which are evaluated through the Horner scheme which is a robust general purpose scheme An alternative and more stable evaluation of high degree polynomials with roots in the unit interval is provided by a product in terms of the roots This form is available for special polynomials such as Lagrange polynomials or Legendre polynomials and used with the respective constructor To obtain this more stable evaluation form the constructor with the roots in form of a Lagrange polynomial must be used In case a manipulation is done that changes the roots the representation is switched to the coefficient form This class is a typical example of a possible template argument for the TensorProductPolynomials class **Constructor The coefficients of the polynomial are passed as and denote the i e the first element of the array denotes the constant the second the linear and so on The degree of the polynomial represented by this object is thus the number of elements in the&lt; tt &gt; coefficient&lt;/tt &gt; array minus one **Constructor creating a zero polynomial of degree *[2.x.3] *Constructor for a Lagrange polynomial and its point of evaluation The idea is to where j is the evaluation point specified as argument and the support points contain all the evaluation is based on products of the whereas the Horner scheme is used for polynomials in the coefficient form **Return the values and the derivatives of the Polynomial at point&lt; tt &gt; x&lt;/tt &gt;&lt; tt &gt; i</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__0_8txt_source.html#l00024">polynomial_0.txt:24</a></div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_a79cbe2f02f8dfb85026c71d783dbb703"><div class="ttname"><a href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut_DoFData::add_data_vector</a></div><div class="ttdeci">void add_data_vector(const VectorType &amp;data, const std::vector&lt; std::string &gt; &amp;names, const DataVectorType type=type_automatic, const std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt; &amp;data_component_interpretation=std::vector&lt; DataComponentInterpretation::DataComponentInterpretation &gt;())</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out__dof__data_8h_source.html#l01096">data_out_dof_data.h:1096</a></div></div>
<div class="ttc" id="aclassIndexSet_html"><div class="ttname"><a href="classIndexSet.html">IndexSet</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2index__set_8h_source.html#l00068">index_set.h:68</a></div></div>
<div class="ttc" id="aclassPETScWrappers_1_1SparseMatrix_html"><div class="ttname"><a href="classPETScWrappers_1_1SparseMatrix.html">PETScWrappers::SparseMatrix</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2petsc__sparse__matrix_8h_source.html#l00051">petsc_sparse_matrix.h:51</a></div></div>
<div class="ttc" id="aclassFEValues_html_a21f914e63d588e2652a9514620653d77"><div class="ttname"><a href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit</a></div><div class="ttdeci">void reinit(const TriaIterator&lt; DoFCellAccessor&lt; dim, spacedim, level_dof_access &gt;&gt; &amp;cell)</div></div>
<div class="ttc" id="adofs_2dof__handler__0_8txt_html_aae1f8d9ad7eda22eb5458605a6db742d"><div class="ttname"><a href="dofs_2dof__handler__0_8txt.html#aae1f8d9ad7eda22eb5458605a6db742d">iterations</a></div><div class="ttdeci">this information can therefore be used upon construction of the SparsityPattern object The returned number is not really the maximum number but an estimate based on the finite element and the maximum number of cells meeting at a vertex The number holds for the constrained matrix as well The determination of the number of couplings can be done by simple picture drawing An example can be found in the implementation of this function *This function is most often used to determine the maximal row length for sparsity patterns while the estimates returned by this function are rather accurate in they are often significantly too high leading the SparsityPattern class to allocate much too much memory in some cases Unless someone comes around to improving the present function for d there is not very much one can do about these cases The typical way to work around this problem is to use an intermediate compressed sparsity pattern that only allocates memory on demand Refer to the[2.x.89] and[2.x.90] example programs on how to do this The problem is also discussed in the documentation of the module on *[2.x.91] *Return the number of degrees of freedom located on the boundary another dof on the boundary can couple with The number is the same as for all cells on this level are further then this function returns[2.x.98] so that loops of the kind **have zero iterations</div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler__0_8txt_source.html#l00175">dof_handler_0.txt:175</a></div></div>
<div class="ttc" id="afe_2fe__values_8h_html"><div class="ttname"><a href="fe_2fe__values_8h.html">fe_values.h</a></div></div>
<div class="ttc" id="anamespaceVectorTools_html_a761f008bdeb7d94a69205ae824deefad"><div class="ttname"><a href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">VectorTools::interpolate</a></div><div class="ttdeci">void interpolate(const Mapping&lt; dim, spacedim &gt; &amp;mapping, const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const Function&lt; spacedim, typename VectorType::value_type &gt; &amp;function, VectorType &amp;vec, const ComponentMask &amp;component_mask=ComponentMask())</div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a></div><div class="ttdeci">@ update_gradients</div><div class="ttdoc">Shape function gradients.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00077">fe_update_flags.h:77</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_afec1b694405cadb2d251275096ad3563"><div class="ttname"><a href="distributed__0_8txt.html#afec1b694405cadb2d251275096ad3563">output</a></div><div class="ttdeci">if we even only hold bytes per line in this sparsity we ll need GB for this object even if every single line is empty Of only million lines will be non for which we need MB plus whatever is necessary to store the actual column indices of nonzero entries Let s say we have a moderately complex problem with entries per for each of which we store the column index worth then we ll need bytes for each of the million lines that correspond to the degrees of freedom we for a total of GB And we ll need bytes for each of the million lines that we don t for a total of GB It is clear that this ratio doesn t become any better if we go to even higher numbers of processors *The solution to this problem is to really only use any memory at all for those parts of the linear system that we or need for some other reason For all other we must know that they but we can not set up any part of our data structure To this there exists a class called IndexSet that denotes a set of indices which we care for and for which we may have to allocate memory The data structures for sparsity patterns constraint matrices matrices and vector can be initialized with these IndexSet objects to really only care for those rows or entries that correspond to indices in the index set and not care about all others These objects will then ask how many indices exist in the set allocate memory for each one of and when you want to access data for global degree of freedom[2.x.28] you will be redirected to the result of calling[2.x.29] with index[2.x.30] instead Accessing data for elements[2.x.31] for which[2.x.32] is false will yield an error *The remaining question is how to identify the set of indices that correspond to degrees of freedom we need to worry about on each processor To this you can use the[2.x.33] function to get at all the indices a processor owns Note that this is a subset of the degrees of freedom that are defined on the locally owned one sometimes needs the set of all degrees of freedom on the locally owned subdomain as well as the adjacent ghost cells This information is provided by the[2.x.35] function ***A typical parallel application is dealing with two different kinds of parallel but there are of course different vector types that can each represent both ghosted vectors are typically used for data output</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00059">distributed_0.txt:59</a></div></div>
<div class="ttc" id="anamespaceLocalIntegrators_1_1L2_html_a1c15243765304a803037988b5561627d"><div class="ttname"><a href="namespaceLocalIntegrators_1_1L2.html#a1c15243765304a803037988b5561627d">LocalIntegrators::L2::mass_matrix</a></div><div class="ttdeci">void mass_matrix(FullMatrix&lt; double &gt; &amp;M, const FEValuesBase&lt; dim &gt; &amp;fe, const double factor=1.)</div><div class="ttdef"><b>Definition:</b> <a href="integrators_2l2_8h_source.html#l00056">l2.h:56</a></div></div>
<div class="ttc" id="afunctions__0_8txt_html_ae902d012155474413712116e310bba66"><div class="ttname"><a href="functions__0_8txt.html#ae902d012155474413712116e310bba66">problem</a></div><div class="ttdeci">namespace ::x *For time dependent boundary conditions and or right hand side functions may also change with time Since at a given time step one is usually only interested in the spatial dependence of a it would be awkward if one had to pass a value for the time variable to all methods that use function objects For the[2.x.3] function would have to take a time argument which it can use when it wants to query the value of the boundary function at a given time step it would also have to do so if we are considering a stationary problem</div><div class="ttdef"><b>Definition:</b> <a href="functions__0_8txt_source.html#l00011">functions_0.txt:11</a></div></div>
<div class="ttc" id="aA-headers_2exceptions__0_8txt_html_a8fba07b9a84b89e6be225f5f95c3e355"><div class="ttname"><a href="A-headers_2exceptions__0_8txt.html#a8fba07b9a84b89e6be225f5f95c3e355">run</a></div><div class="ttdeci">the program is just and one can not intelligently work around that *It is sometimes useful to change the behavior of the[2.x.6] macro from aborting a program to throwing exceptions On the other exceptions are not allowed to propagate out of destructors of classes For this there is a variant of the called[2.x.7] that can be used in destructors These use cases are discussed further down below on this page **Dynamic such as whether an output file can be written to *These are things that shouldn t be checked because it is not guaranteed that a program for which the condition is satisfied in a debug mode run</div><div class="ttdef"><b>Definition:</b> <a href="A-headers_2exceptions__0_8txt_source.html#l00022">exceptions_0.txt:22</a></div></div>
<div class="ttc" id="aclassFE__Q_html"><div class="ttname"><a href="classFE__Q.html">FE_Q&lt; dim &gt;</a></div></div>
<div class="ttc" id="anamespaceUtilities_html_a6195c5f009ea8c7c536c6ffdf108c32f"><div class="ttname"><a href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a></div><div class="ttdeci">std::string int_to_string(const unsigned int value, const unsigned int digits=numbers::invalid_unsigned_int)</div><div class="ttdef"><b>Definition:</b> <a href="base_2utilities_8cc_source.html#l00473">utilities.cc:473</a></div></div>
<div class="ttc" id="anamespacedealii_html"><div class="ttname"><a href="namespacedealii.html">dealii</a></div><div class="ttdef"><b>Definition:</b> <a href="doc_2doxygen_2headers_2namespace__dealii_8h_source.html#l00026">namespace_dealii.h:26</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a></div><div class="ttdeci">@ update_values</div><div class="ttdoc">Shape function values.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00070">fe_update_flags.h:70</a></div></div>
<div class="ttc" id="aiterators__0_8txt_html_a6cf0880ba2af3a1be4aacdbbd4b90f9c"><div class="ttname"><a href="iterators__0_8txt.html#a6cf0880ba2af3a1be4aacdbbd4b90f9c">triangulation</a></div><div class="ttdeci">where BaseIterator usually is one of thestandard iterators discussed above *The FilteredIterator gets an additional Predicate in its constructor and willskip all objects where this Predicate evaluates to&lt; tt &gt; false&lt;/tt &gt; Acollection of predicates already implemented can be found in the namespaceIteratorFilters ***IteratorsLoops Iterating over objects *All iterators of the same kind and iterating over thesame kind of geometrical objects traverse the mesh in the sameorder Take this code all iterators will always point to the same mesh even though&lt; tt &gt; DoFHandler&lt;/tt &gt; and&lt; tt &gt; Triangulation&lt;/tt &gt; are very different and even if the DoFHandlers are handling different finite the difference is only in the Accessor As mentioned the order in which iterators traverse the forest ofobjects is actually well but application programs should notassume any such but rather consider this an implementation detailof the library *Corresponding to above the order in which iterators traverse activeobjects is the same for all iterators in the following the difference to the previous example being that here we only consider active but theyare really rather dumb Their magic only lies in the fact that they point tosome useful in this case the Accessor For they point to anactual object that stores some data On the other the deal II when do not return a reference to an actual but returnan object that knows how to get at the data that represents cells In thisobject doesn t store itself where the vertices of a cell are or what its neighborsare it knows how to tease this sort of information from out of thearrays and tables and lists that the Triangulation class sets up to describe amesh *Accessing data that characterizes a cell is always done through the i e the expression[2.x.10] grants access to[1.x.6] attributes of this Accessor Examples of properties you can query from aniterator are ***Since dereferencing iterators yields accessor these calls are tomember etc These in turn figure out the relevant datafrom the various data structures that store this data How this is actuallydone and what data structures are used is not really of concern to authors ofapplications in deal II In by hiding the actual data structureswe are able to store data in an efficient not necessarily in a way thatmakes it easily accessible or understandable to application writers ***IteratorsTypedefs Kinds of accessors *Depending on what sort of data you want to there are different kindsof accessor and hexes that make up a triangulation</div><div class="ttdef"><b>Definition:</b> <a href="iterators__0_8txt_source.html#l00063">iterators_0.txt:63</a></div></div>
<div class="ttc" id="astep-1_8cc_html_ae66f6b31b5ad750f1fe042a706a4e3d4"><div class="ttname"><a href="step-1_8cc.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a></div><div class="ttdeci">int main()</div><div class="ttdef"><b>Definition:</b> <a href="step-1_8cc_source.html#l00086">step-1.cc:86</a></div></div>
<div class="ttc" id="aclassTriangulation_html"><div class="ttname"><a href="classTriangulation.html">Triangulation&lt; dim &gt;</a></div></div>
<div class="ttc" id="agrid_2tria_8h_html"><div class="ttname"><a href="grid_2tria_8h.html">tria.h</a></div></div>
<div class="ttc" id="asolver__cg__0_8txt_html_ab8dd1e5e6028b76d234561ae8e1d22bc"><div class="ttname"><a href="solver__cg__0_8txt.html#ab8dd1e5e6028b76d234561ae8e1d22bc">steps</a></div><div class="ttdeci">*This class implements the preconditioned Conjugate but is used in many other tutorial programs as well Like all other solver it can work on any kind of vector and matrix as long as they satisfy certain and defaults to *[2.x.2] **This version of CG is taken from D Braess s book Finite Elements It requires a symmetric the projected matrix[2.x.4] is tri diagonal Since the projection is the eigenvalues of[2.x.5] approximate those of the original preconditioned matrix[2.x.6] In after[2.x.7] steps</div><div class="ttdef"><b>Definition:</b> <a href="solver__cg__0_8txt_source.html#l00010">solver_cg_0.txt:10</a></div></div>
<div class="ttc" id="abase_2parameter__handler_8h_html"><div class="ttname"><a href="base_2parameter__handler_8h.html">parameter_handler.h</a></div></div>
<div class="ttc" id="afe_2fe__q_8h_html"><div class="ttname"><a href="fe_2fe__q_8h.html">fe_q.h</a></div></div>
<div class="ttc" id="agroup__constraints_html_ga06c0301bc74dd4c67a3d1db1000647f3"><div class="ttname"><a href="group__constraints.html#ga06c0301bc74dd4c67a3d1db1000647f3">DoFTools::make_zero_boundary_constraints</a></div><div class="ttdeci">void make_zero_boundary_constraints(const DoFHandler&lt; dim, spacedim &gt; &amp;dof, const types::boundary_id boundary_id, AffineConstraints&lt; number &gt; &amp;zero_boundary_constraints, const ComponentMask &amp;component_mask=ComponentMask())</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__constraints_8cc_source.html#l03450">dof_tools_constraints.cc:3450</a></div></div>
<div class="ttc" id="ainclude_2deal_8II_2base_2utilities_8h_html"><div class="ttname"><a href="include_2deal_8II_2base_2utilities_8h.html">utilities.h</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_aa2626b9a8731384418b99aaadfc1d365"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#aa2626b9a8731384418b99aaadfc1d365">y</a></div><div class="ttdeci">this leads to a degree of flexibility in computations that cannot be matched by auto differentiation For one could perform the permanent substitution[2.x.86] and then recompute[2.x.87] for several different values of[2.x.88] One could also post factum express an interdependency between x and y</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00347">automatic_and_symbolic_differentiation_0.txt:347</a></div></div>
<div class="ttc" id="aclassSparseMatrix_html"><div class="ttname"><a href="classSparseMatrix.html">SparseMatrix&lt; double &gt;</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_aafea668ad0c451ac7a0fae0f558c36d7"><div class="ttname"><a href="distributed__0_8txt.html#aafea668ad0c451ac7a0fae0f558c36d7">cells</a></div><div class="ttdeci">in the area occupied by these artificial cells</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00037">distributed_0.txt:37</a></div></div>
<div class="ttc" id="aclassStep36_1_1EigenvalueProblem_html_afc4425b6db4a59064e94bc1e1f56684d"><div class="ttname"><a href="classStep36_1_1EigenvalueProblem.html#afc4425b6db4a59064e94bc1e1f56684d">Step36::EigenvalueProblem::EigenvalueProblem</a></div><div class="ttdeci">EigenvalueProblem(const std::string &amp;prm_file)</div><div class="ttdef"><b>Definition:</b> <a href="step-36_8cc_source.html#l00084">step-36.cc:84</a></div></div>
<div class="ttc" id="aclassFunction_html_a562fc1114e95e702e6696721f71528db"><div class="ttname"><a href="classFunction.html#a562fc1114e95e702e6696721f71528db">Function&lt; dim &gt;::value_list</a></div><div class="ttdeci">virtual void value_list(const std::vector&lt; Point&lt; dim &gt;&gt; &amp;points, std::vector&lt; double &gt; &amp;values, const unsigned int component=0) const</div></div>
<div class="ttc" id="alac_2arpack__solver_8h_html"><div class="ttname"><a href="lac_2arpack__solver_8h.html">arpack_solver.h</a></div></div>
<div class="ttc" id="agroup__Vectors_html_ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b"><div class="ttname"><a href="group__Vectors.html#ga40c50779cd14ba89bbf0bd9b4561964cad11ac5bd2488371d9fa940c84241f82b">VectorOperation::add</a></div><div class="ttdeci">@ add</div><div class="ttdef"><b>Definition:</b> <a href="lac_2vector__operation_8h_source.html#l00056">vector_operation.h:56</a></div></div>
<div class="ttc" id="alac_2affine__constraints_8h_html"><div class="ttname"><a href="lac_2affine__constraints_8h.html">affine_constraints.h</a></div></div>
<div class="ttc" id="aparameter__handler__0_8txt_html_ad919e2b915d8e8226aef004c2d8399a8"><div class="ttname"><a href="parameter__handler__0_8txt.html#ad919e2b915d8e8226aef004c2d8399a8">exception</a></div><div class="ttdeci">since default values may change in the process of program you cannot know the values of parameters not specified in the input file ****It is often convenient to have something happen as soon as a parameter value is read This could be a check that it is valid that a file that is listed in the parameter file exists **or to initiate something else in such as setting a variable outside the this action could also be initiated once all parameters are read via but it is sometimes[1.x.19] to do it right away *This is facilitated by the and can then do whatever they want with it **e save it somewhere outside the ParameterHandler in C one doesn t usually pass around the address of a but an action can be a function like object(taking a string as argument) that results from calling such as a[1.x.20] that has the form **[1.x.21] *and that is attached to a specific parameter. *A typical example of such an action would be as follows the content of the file equals the default value of the parameter the contents of files are never changed after declaration of a parameter a directory in this file system may not have a file called[2.x.20] in it In that the directory represents a subsection as declared and the directory s name will correspond to the name of the subsection It will then have no files in it at but it may have further directories in the code above will lead to a hierarchical representation of data that looks like this(the content of files is indicated at the right in a different font) this is only used when creating output for exceptions If non empty[2.x.35] is the ParameterHandler object will stop parsing lines after encountering[2.x.36] This is handy when adding extra data that shall be parsed manually If[2.x.37] the parameter handler will skip undefined sections and entries This is useful for partially parsing a parameter for example to obtain only the spatial dimension of the problem By default all entries and subsections are expected to be declared The function sets the value of all parameters it encounters in the input file to the provided value Parameters not explicitly listed in the input file are left at the value they previously which will be the default value provided to and for each parameter all associated actions that may previously have been set by or if an associated action throws an exception</div><div class="ttdef"><b>Definition:</b> <a href="parameter__handler__0_8txt_source.html#l00241">parameter_handler_0.txt:241</a></div></div>
<div class="ttc" id="aclassDataOut__DoFData_html_a6ed7c846331069f406b8c9933c37fda4"><div class="ttname"><a href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">DataOut_DoFData::attach_dof_handler</a></div><div class="ttdeci">void attach_dof_handler(const DoFHandler&lt; dim, spacedim &gt; &amp;)</div></div>
<div class="ttc" id="anamespaceLAPACKSupport_html_a1a9009db0d9a77923a7031b549b9b638a86885edfb652da041a42028c469d32b0"><div class="ttname"><a href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a86885edfb652da041a42028c469d32b0">LAPACKSupport::eigenvalues</a></div><div class="ttdeci">@ eigenvalues</div><div class="ttdoc">Eigenvalue vector is filled.</div><div class="ttdef"><b>Definition:</b> <a href="lac_2lapack__support_8h_source.html#l00071">lapack_support.h:71</a></div></div>
<div class="ttc" id="aclassDoFHandler_html"><div class="ttname"><a href="classDoFHandler.html">DoFHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="dofs_2dof__handler_8h_source.html#l00266">dof_handler.h:266</a></div></div>
<div class="ttc" id="aclassFEValues_html"><div class="ttname"><a href="classFEValues.html">FEValues&lt; dim &gt;</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a></div><div class="ttdeci">@ update_quadrature_points</div><div class="ttdoc">Transformed quadrature points.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00116">fe_update_flags.h:116</a></div></div>
<div class="ttc" id="aclassFiniteElementData_html_a2cbf5ad6b464871261dbd054bced18a8"><div class="ttname"><a href="classFiniteElementData.html#a2cbf5ad6b464871261dbd054bced18a8">FiniteElementData::degree</a></div><div class="ttdeci">const unsigned int degree</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__base_8h_source.html#l00428">fe_base.h:428</a></div></div>
<div class="ttc" id="anumerics_2vector__tools_8h_html"><div class="ttname"><a href="numerics_2vector__tools_8h.html">vector_tools.h</a></div></div>
<div class="ttc" id="abase_2function_8h_html"><div class="ttname"><a href="base_2function_8h.html">function.h</a></div></div>
<div class="ttc" id="aclassSparseMatrix_html_a231105aa86cca488901d94b1e1b55ac7"><div class="ttname"><a href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">SparseMatrix::compress</a></div><div class="ttdeci">void compress(::VectorOperation::values)</div></div>
<div class="ttc" id="amultithreading__0_8txt_html_a33468e75b7ea6d2e64b7e88c6ff1217a"><div class="ttname"><a href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a></div><div class="ttdeci">namespace are implemented the way they are More information on their implementation can be found in the[2.x.72] WorkStream paper To see the WorkStream class used in practice on tasks like the ones outlined above take a look at or[2.x.78] tutorial programs *To begin given the brief description the way the[2.x.79] function could then be written is like this(note that this is not quite the correct syntax, as will be described below) we recycle these objects after they have been used by[2.x.101] and feed them back into another instance of[2.x.102]</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00171">multithreading_0.txt:171</a></div></div>
<div class="ttc" id="abase_2index__set_8h_html"><div class="ttname"><a href="base_2index__set_8h.html">index_set.h</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html_a373fbdacd8c486e675b8d2bff8943192"><div class="ttname"><a href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global</a></div><div class="ttdeci">void distribute_local_to_global(const InVector &amp;local_vector, const std::vector&lt; size_type &gt; &amp;local_dof_indices, OutVector &amp;global_vector) const</div><div class="ttdef"><b>Definition:</b> <a href="lac_2affine__constraints_8h_source.html#l02250">affine_constraints.h:2250</a></div></div>
<div class="ttc" id="abase_2logstream_8h_html"><div class="ttname"><a href="base_2logstream_8h.html">logstream.h</a></div></div>
<div class="ttc" id="aconstraints__0_8txt_html_a5abc878123b65e2a7a16e57bba0e282e"><div class="ttname"><a href="constraints__0_8txt.html#a5abc878123b65e2a7a16e57bba0e282e">constraints</a></div><div class="ttdeci">******This module deals with constraints on degrees of freedom The central class to deal with constraints is the AffineConstraints class *Constraints typically come from several for one usually enforces them by requiring that degrees of freedom on the boundary have particular for example[2.x.3] if the boundary condition[2.x.4] requires that the finite element solution[2.x.5] at the location of degree of freedom has the value Such constraints are generated by those versions of the[2.x.6] function that take a AffineConstraints for example no normal as happens in flow problems and is handled by the[2.x.11] function or prescribed tangential as happens in electromagnetic problems and is handled by the[2.x.13] function For the former imagine for example that we are at at vertex where the normal vector has the form[2.x.14] and that and[2.x.17] components of the flow field at this vertex are associated with degrees of and Then the no normal flux condition means that we need to have the condition[2.x.18] The prescribed tangential component leads to similar constraints though there is often something on the right hand side ****If you have hanging node constraints</div><div class="ttdef"><b>Definition:</b> <a href="constraints__0_8txt_source.html#l00020">constraints_0.txt:20</a></div></div>
<div class="ttc" id="anumerics_2matrix__tools_8h_html"><div class="ttname"><a href="numerics_2matrix__tools_8h.html">matrix_tools.h</a></div></div>
<div class="ttc" id="aclassDataOutInterface_html_acad99726038e4fca7f605fdffb3317e4"><div class="ttname"><a href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">DataOutInterface::write_vtk</a></div><div class="ttdeci">void write_vtk(std::ostream &amp;out) const</div><div class="ttdef"><b>Definition:</b> <a href="data__out__base_8cc_source.html#l07221">data_out_base.cc:7221</a></div></div>
<div class="ttc" id="agroup__constraints_html_gaf78e864edbfba7e0a7477457bfb96b26"><div class="ttname"><a href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a></div><div class="ttdeci">void make_sparsity_pattern(const DoFHandler&lt; dim, spacedim &gt; &amp;dof_handler, SparsityPatternType &amp;sparsity_pattern, const AffineConstraints&lt; number &gt; &amp;constraints=AffineConstraints&lt; number &gt;(), const bool keep_constrained_dofs=true, const types::subdomain_id subdomain_id=numbers::invalid_subdomain_id)</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__sparsity_8cc_source.html#l00064">dof_tools_sparsity.cc:64</a></div></div>
<div class="ttc" id="avector__tools__point__value__0_8txt_html_ac7a5c2ceb5c739d5b51cc7e0eee8100a"><div class="ttname"><a href="vector__tools__point__value__0_8txt.html#ac7a5c2ceb5c739d5b51cc7e0eee8100a">solve</a></div><div class="ttdeci">*Assembling of right hand sides **Create a right hand side vector for a point source at point[2.x.1] In other it creates a vector[2.x.2] so that[2.x.3] where[2.x.4] are the shape functions described by[2.x.5] and[2.x.6] is the point at which the delta function is located Prior content of the given[2.x.7] vector is deleted This function is for the case of a scalar finite element This function is typically used in one of these two with different values for right hand sides or and then evaluate the solution at the same point every time You could do this by calling[2.x.8] after each solve</div><div class="ttdef"><b>Definition:</b> <a href="vector__tools__point__value__0_8txt_source.html#l00015">vector_tools_point_value_0.txt:15</a></div></div>
<div class="ttc" id="aclassFunctionParser_html_a2426bdaf98de531415477667097235b8"><div class="ttname"><a href="classFunctionParser.html#a2426bdaf98de531415477667097235b8">FunctionParser::ConstMap</a></div><div class="ttdeci">std::map&lt; std::string, double &gt; ConstMap</div><div class="ttdef"><b>Definition:</b> <a href="base_2function__parser_8h_source.html#l00315">function_parser.h:315</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_gae9a45f517af1401c50811a11083f9114"><div class="ttname"><a href="group__Exceptions.html#gae9a45f517af1401c50811a11083f9114">StandardExceptions::ExcMessage</a></div><div class="ttdeci">static ::ExceptionBase &amp; ExcMessage(std::string arg1)</div></div>
<div class="ttc" id="aclassSparseMatrix_html_afa7ae4d32bda6035661c9cccfe185597"><div class="ttname"><a href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">SparseMatrix::reinit</a></div><div class="ttdeci">virtual void reinit(const SparsityPattern &amp;sparsity)</div></div>
<div class="ttc" id="anamespaceinternal_html_a38181f4582ff69679bda7d8e31c37291"><div class="ttname"><a href="namespaceinternal.html#a38181f4582ff69679bda7d8e31c37291">internal::reinit</a></div><div class="ttdeci">void reinit(MatrixBlock&lt; MatrixType &gt; &amp;v, const BlockSparsityPattern &amp;p)</div><div class="ttdef"><b>Definition:</b> <a href="lac_2matrix__block_8h_source.html#l00656">matrix_block.h:656</a></div></div>
<div class="ttc" id="aclassDataOut_html_a087f63e22f0614bca326dbdca288c646"><div class="ttname"><a href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches</a></div><div class="ttdeci">virtual void build_patches(const unsigned int n_subdivisions=0)</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2data__out_8cc_source.html#l01071">data_out.cc:1071</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_a69730bc7f91dd1be17fd083a66514e73"><div class="ttname"><a href="coding__conventions__0_8txt.html#a69730bc7f91dd1be17fd083a66514e73">freedom</a></div><div class="ttdeci">their purpose is merely to keepdeal II as uniform as possible Uniformity reduces the number of bugs weproduce because we for always assume that input arguments comebefore output arguments of a function call They also simplify reading codebecause some things become clear already by looking at the style a piece ofcode is without having to look up the exact definition of something **deal II uses[2.x.2] to normalize indentation Astyle file is provided at ***Before a you should run **on each of your files This will make sure indentation is conforming to thestyle guidelines outlined in this page *This is cumbersome and more you can just run **in whatever directory you set up the library to be compiled to indent allsource files that have been changed recently If you want to make sure thatthe indenting is correct for all your you might want to set up apre commit hook One way to do is to copy[2.x.4] to[2.x.5] and make sure it isexecutable *If the system you are working on has more than one version of[2.x.6] degrees of freedom</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00018">coding_conventions_0.txt:18</a></div></div>
<div class="ttc" id="atrilinos__sparse__matrix__0_8txt_html_ab4e34663c28496ee1b07f40fd5d00fa1"><div class="ttname"><a href="trilinos__sparse__matrix__0_8txt.html#ab4e34663c28496ee1b07f40fd5d00fa1">sparsity_pattern</a></div><div class="ttdeci">all column elements of a row are stored on the same processor in any case The vector&lt; tt &gt; n_entries_per_row&lt;/tt &gt; specifies the number of entries in each row of the newly generated matrix **This function is initializes the Trilinos Epetra matrix according to the specified sparsity_pattern</div><div class="ttdef"><b>Definition:</b> <a href="trilinos__sparse__matrix__0_8txt_source.html#l00162">trilinos_sparse_matrix_0.txt:162</a></div></div>
<div class="ttc" id="aclassDynamicSparsityPattern_html"><div class="ttname"><a href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2dynamic__sparsity__pattern_8h_source.html#l00340">dynamic_sparsity_pattern.h:340</a></div></div>
<div class="ttc" id="aclassSparsityPattern_html"><div class="ttname"><a href="classSparsityPattern.html">SparsityPattern</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2sparsity__pattern_8h_source.html#l00900">sparsity_pattern.h:900</a></div></div>
<div class="ttc" id="adofs_2dof__tools_8h_html"><div class="ttname"><a href="dofs_2dof__tools_8h.html">dof_tools.h</a></div></div>
<div class="ttc" id="aclassArpackSolver_html"><div class="ttname"><a href="classArpackSolver.html">ArpackSolver</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2arpack__solver_8h_source.html#l00158">arpack_solver.h:158</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html_a5a1bc1bb2d705b582889ebaa24bcae5c"><div class="ttname"><a href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense</a></div><div class="ttdeci">void condense(SparsityPattern &amp;sparsity) const</div></div>
<div class="ttc" id="aclassSparseMatrix_html_a3e77fcfbd1fa3ac83ef4ff2951b24ce3"><div class="ttname"><a href="classSparseMatrix.html#a3e77fcfbd1fa3ac83ef4ff2951b24ce3">SparseMatrix::set</a></div><div class="ttdeci">void set(const size_type i, const size_type j, const number value)</div></div>
<div class="ttc" id="aA-headers_2exceptions__0_8txt_html_a602682024ec652b990be121b5665f8ce"><div class="ttname"><a href="A-headers_2exceptions__0_8txt.html#a602682024ec652b990be121b5665f8ce">set</a></div><div class="ttdeci">&lt;/tt &gt; **If the&lt; tt &gt;&lt;/tt &gt; preprocessor directive is set</div><div class="ttdef"><b>Definition:</b> <a href="A-headers_2exceptions__0_8txt_source.html#l00031">exceptions_0.txt:31</a></div></div>
<div class="ttc" id="aslepc__solver__0_8txt_html_a571efee620e9221401b6a7460c561d1a"><div class="ttname"><a href="slepc__solver__0_8txt.html#a571efee620e9221401b6a7460c561d1a">converged</a></div><div class="ttdeci">this is due to a round off but handle that it may be more than specified by ignoring any extras By default one eigenvector eigenvalue pair is computed **Same as but here a composite method for solving the for real and values *[2.x.16] *Same as but here a composite method for solving the system[2.x.17] with real matrices[2.x.18] and imaginary eigenpairs *[2.x.19] *Set the initial vector space for the solver By SLEPc initializes the starting vector or the initial subspace randomly **Set the spectral transformation to be used **Set target eigenvalues in the spectrum to be computed By no target is set **Indicate which part of the spectrum is to be computed By default largest magnitude eigenvalues are computed *For other allowed values see the SLEPc documentation **Specify the type of the eigenspectrum problem This can be used to exploit known symmetries of the matrices that make up the standard generalized eigenspectrum problem By default a non Hermitian problem is assumed *For other allowed values see the SLEPc documentation **Take the information provided from SLEPc and checks it against deal II s own SolverControl objects to see if convergence has been reached **Exception Standard exception **Exception SLEPc error with error number **Exception Convergence failure on the number of eigenvectors **Access to the object that controls convergence **Reference to the object that controls convergence of the iterative solver **Copy of the MPI communicator object to be used for the solver **Solve the linear system for[2.x.22] eigenstates Parameter[2.x.23] contains the actual number of eigenstates that have converged</div><div class="ttdef"><b>Definition:</b> <a href="slepc__solver__0_8txt_source.html#l00072">slepc_solver_0.txt:72</a></div></div>
<div class="ttc" id="avector__valued__0_8txt_html_a2b24e414d1a0d32deea919c5e8899811"><div class="ttname"><a href="vector__valued__0_8txt.html#a2b24e414d1a0d32deea919c5e8899811">x</a></div><div class="ttdeci">([1.x.8]&lt; sub &gt;1&lt;/sub &gt;, [1.x.9]&lt; sub &gt;2&lt;/sub &gt;, [1.x.10]&lt; sub &gt;3&lt;/sub &gt;)&lt; sup &gt;T&lt;/sup &gt; and[1.x.11] accordingly. Then, we can write the simplified equation in coordinates as[1.x.12] We see, that this is just three copies of the bilinear form of the Laplacian, one applied to each component(this is where the formulation with the[2.x.33] is more exciting, and we want to derive a framework that applies to that one as well). We can make this weak form a system of differential equations again by choosing special test functions:first, choose[1.x.13]=([1.x.14]&lt; sub &gt;1&lt;/sub &gt;, 0, 0)&lt; sup &gt;T&lt;/sup &gt;, then[1.x.15]=(0, [1.x.16]&lt; sub &gt;2&lt;/sub &gt;, 0)&lt; sup &gt;T&lt;/sup &gt;, and finally[1.x.17]=(0, 0, [1.x.18]&lt; sub &gt;3&lt;/sub &gt;)&lt; sup &gt;T&lt;/sup &gt;. writing the outcomes below each other, we obtain the system[1.x.19] where we used the standard inner product notation[2.x.34] . It is important for our understanding, that we keep in mind that the latter form as a system of PDE is completely equivalent to the original definition of the bilinear form[1.x.20]([1.x.21], [1.x.22]), which does not immediately exhibit this system structure. Let us close by writing the full system of the elastic equation with symmetric gradient[1.x.23]:[1.x.24] Very formally, if we believe in operator valued matrices, we can rewrite this in the form[1.x.25]&lt; sup &gt;T&lt;/sup &gt;[1.x.26]=[1.x.27]&lt; sup &gt;T&lt;/sup &gt;[1.x.28] or[1.x.29] *[1.x.30] Now, let us consider a more complex example, the mixed Laplace equations discussed in[2.x.35] in three dimensions:[1.x.31] **Here, we have four solution components:the scalar pressure[2.x.36] and the vector-valued velocity[2.x.37] with three vector components. Note as important difference to the previous example, that the vector space[1.x.32] is not just simply a copy of three identical spaces/*A systematic way to get a weak or variational form for this and other vector problems is to first consider it as a problem where the operators and solution variables are written in vector and matrix form. For the example, this would read as follows:[1.x.33] **This makes it clear that the solution[1.x.34] *indeed has four components. We note that we could change the ordering of the solution components[2.x.38] and[2.x.39] inside[2.x.40] if we also change columns of the matrix operator.*Next, we need to think about test functions[2.x.41] . We want to multiply both sides of the equation with them, then integrate over[2.x.42] . The result should be a scalar equality. We can achieve this by choosing[2.x.43] also vector valued as[1.x.35] **It is convenient to multiply the matrix-vector equation by the test function from the left, since this way we automatically get the correct matrix later on(in the linear system, the matrix is also multiplied from the right with the solution variable, not from the left), whereas if we multiplied from the right then the matrix so assembled is the transpose of the one we really want. *With this in mind, let us multiply by[2.x.44] and integrate to get the following equation which has to hold for all test functions[2.x.45] :[1.x.36] *or equivalently:[1.x.37] ***We get the final form by integrating by part the second term:[1.x.38] **It is this form that we will later use in assembling the discrete weak form into a matrix and a right hand side vector:the form in which we have solution and test functions[2.x.46] that each consist of a number of vector components that we can extract. **[2.x.47] VVFEs[1.x.39] *Once we have settled on a bilinear form and a functional setting, we need to find a way to describe the vector-valued finite element spaces from which we draw solution and test functions. This is where the FESystem class comes in:it composes vector-valued finite element spaces from simpler ones. In the example of the elasticity problem, we need[2.x.48] copies of the same element, for instance **[1.x.40] *This will generate a vector valued space of dimension[2.x.49], where each component is a continuous bilinear element of type FE_Q. It will have[2.x.50] times as many basis functions as the corresponding FE_Q, and each of these basis functions is a basis function of FE_Q, lifted into one of the components of the vector. *For the mixed Laplacian, the situation is more complex. First, we have to settle on a pair of discrete spaces[2.x.51] . One option would be the stable Raviart-Thomas pair **[1.x.41] *The first element in this system is already a vector valued element of dimension[2.x.52], while the second is a regular scalar element. *Alternatively to using the stable Raviart-Thomas pair, we could consider a stabilized formulation for the mixed Laplacian, for instance the LDG method. There, we have the option of using the same spaces for velocity components and pressure, namely **[1.x.42] *This system just has[2.x.53] equal copies of the same discontinuous element, which not really reflects the structure of the system. Therefore, we prefer **[1.x.43] *Here, we have a system of two elements, one vector-valued and one scalar, very much like with the[2.x.54] . Indeed, in many codes, the two can be interchanged. This element also allows us easily to switch to an LDG method with lower order approximation in the velocity, namely **[1.x.44] *It must be pointed out, that this element is different from **[1.x.45] *While the constructor call is very similar to[2.x.55], the result actually resembles more[2.x.56] in that this element produces[2.x.57] independent components. A more detailed comparison of the resulting FESystem objects is below. *[1.x.46] *FESystem has a few internal variables which reflect the internal structure set up by the constructor. These can then also be used by application programs to give structure to matrix assembling and linear algebra. We give the names and values of these variables for the examples above in the following table:&lt; table border=&quot;1&quot;&gt;&lt; tr &gt;&lt; th &gt;System Element&lt;/th &gt;[2.x.58][2.x.59][2.x.60]&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.61]&lt;/td &gt;&lt; td &gt;1&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.62]&lt;/td &gt;&lt; td &gt;2&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.63]&lt;/td &gt;&lt; td &gt;2&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.64]&lt;/td &gt;&lt; td &gt;1&lt;/td &gt;&lt;/tr &gt;&lt; tr &gt;&lt; td &gt;[2.x.65]&lt;/td &gt;&lt; td &gt;2&lt;/td &gt;&lt;/tr &gt;&lt;/table &gt; *From this table, it is clear that the FESystem reflects a lot of the structure of the system of differential equations in the cases of the[2.x.66] and the[2.x.67], in that we have a vector valued and a scalar variable. On the other hand, the convoluted elements do not have this structure and we have to reconstruct it somehow when assembling systems, as described below. *At this point, it is important to note that nesting of two FESystem object can give the whole FESystem a richer structure than just concatenating them. This structure can be exploited by application programs, but is not automatically so. *[2.x.68] VVAssembling[1.x.47] The next step is to assemble the linear system. How to do this for the simple case of a scalar problem has been shown in many tutorial programs, starting with[2.x.69] . Here we will show how to do it for vector problems. Corresponding to the different characterizations of weak formulations above and the different system elements created, we have a few options which are outlined below. *The whole concept is probably best explained by showing an example illustrating how the local contribution of a cell to the weak form of above mixed Laplace equations could be assembled. *[1.x.48] This is essentially how[2.x.70] does it:**[1.x.49] **So here 's what is happening:[2.x.71][2.x.72] The first thing we do is to declare &quot;extractors&quot;(see the FEValuesExtractors namespace). These are objects that don 't do much except store which components of a vector-valued finite element constitute a single scalar component, or a tensor of rank 1(i.e. what we call a &quot;physical vector&quot;, always consisting of[2.x.73] components). Here, we declare an object that represents the velocities consisting of[2.x.74] components starting at component zero, and the extractor for the pressure, which is a scalar component at position[2.x.75] . *[2.x.76] We then do our usual loop over all cells, shape functions, and quadrature points. In the innermost loop, we compute the local contribution of a pair of shape functions to the global matrix and right hand side vector. Recall that the cell contributions to the bilinear form(i.e. neglecting boundary terms) looked as follows, based on shape functions[2.x.77] :[1.x.50] *whereas the implementation looked like this:*[1.x.51] *The similarities are pretty obvious. *[2.x.78] Essentially, what happens in above code is this:when you do[2.x.79], a so-called &quot;view&quot; is created, i.e. an object that unlike the full FEValues object represents not all components of a finite element, but only the one(s) represented by the extractor object[2.x.80] or[2.x.81] . *[2.x.82] These views can then be asked for information about these individual components. For example, when you write[2.x.83] you get the value of the pressure component of the[2.x.84] th shape function[2.x.85] at the[2.x.86] th quadrature point. Because the extractor[2.x.87] represents a scalar component, the results of the operator[2.x.88] is a scalar number. On the other hand, the call[2.x.89] would produce the value of a whole set of[2.x.90] components, which would be of type[2.x.91] . *[2.x.92] Other things that can be done with views is to ask for the gradient of a particular shape function 's components described by an extractor. For example,[2.x.93] would represent the gradient of the scalar pressure component, which is of type[2.x.94], whereas the gradient of the velocities components,[2.x.95] is a[2.x.96], i.e. a matrix[2.x.97] that consists of entries[2.x.98] . Finally, both scalar and vector views can be asked for the second derivatives(&quot;Hessians&quot;) and vector views can be asked for the symmetric gradient, defined as[2.x.99] as well as the divergence[2.x.100] .[2.x.101] Other examples of using extractors and views are shown in tutorial programs[2.x.102],[2.x.103],[2.x.104] and several other programs. ***[2.x.105] In the current context, when we talk about a vector(for example in extracting the velocity components above), we mean the word in the sense physics uses it:it has[2.x.106] components that behave in specific ways under coordinate system transformations. Examples include velocity or displacement fields. This is opposed to how mathematics uses the word &quot;vector&quot;(and how we use this word in other contexts in the library, for example in the Vector class), where it really stands for a collection of numbers. An example of this latter use of the word could be the set of concentrations of chemical species in a flame x</div><div class="ttdef"><b>Definition:</b> <a href="vector__valued__0_8txt_source.html#l00090">vector_valued_0.txt:90</a></div></div>
<div class="ttc" id="adistributed__0_8txt_html_a1a9fea1222a1f75ee681b6805de5f7fc"><div class="ttname"><a href="distributed__0_8txt.html#a1a9fea1222a1f75ee681b6805de5f7fc">mesh</a></div><div class="ttdeci">********clusters ***deal II can use multiple machines connected via MPI to parallelize in addition to the parallelization within a shared memory machine discussed in the[2.x.4] module There are essentially two ways to utilize multiple but only a share of the global sparsity and solution vector is stored on each machine ****The mesh and DoF handler are also i e each processor stores only a share of the cells and degrees of freedom No processor has knowledge of the entire mesh</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00025">distributed_0.txt:25</a></div></div>
<div class="ttc" id="aclassQGauss_html"><div class="ttname"><a href="classQGauss.html">QGauss</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2quadrature__lib_8h_source.html#l00039">quadrature_lib.h:39</a></div></div>
<div class="ttc" id="aclassFunctionParser_html_aac973d1e4fc6912ccf833c108894e414"><div class="ttname"><a href="classFunctionParser.html#aac973d1e4fc6912ccf833c108894e414">FunctionParser::initialize</a></div><div class="ttdeci">void initialize(const std::string &amp;vars, const std::vector&lt; std::string &gt; &amp;expressions, const ConstMap &amp;constants, const bool time_dependent=false)</div><div class="ttdef"><b>Definition:</b> <a href="function__parser_8cc_source.html#l00094">function_parser.cc:94</a></div></div>
<div class="ttc" id="abase_2quadrature__lib_8h_html"><div class="ttname"><a href="base_2quadrature__lib_8h.html">quadrature_lib.h</a></div></div>
<div class="ttc" id="afe__evaluation__0_8txt_html_a8f384576a64c89a6fa8352847523e340"><div class="ttname"><a href="fe__evaluation__0_8txt.html#a8f384576a64c89a6fa8352847523e340">n_q_points</a></div><div class="ttdeci">FE_Q with hanging node constraints connects to more neighbors than a FE_DGQ for and cells which need data exchange are put in different positions inside the cell loop Of if the exact same and then the order is going to be the same because the algorithm is deterministic *dim Dimension in which this class is to be used *fe_degree Degree of the tensor product finite element with fe_degree degrees of freedom per coordinate direction Can be set to **if the degree is not known at compile but performance will usually be worse by a factor of *n_q_points_1d Number of points in the quadrature formula defaults to fe_degree *n_components Number of vector components when solving a system of PDEs If the same operation is applied to several components of a they can be applied simultaneously with one usually[2.x.339] or[2.x.340] Defaults to[2.x.341] double ******An alias to the base class **An underlying number type specified as template argument **The type of function e g VectorizedArrayType for e g Tensor&lt; 1, dim, VectorizedArrayType &gt; for n_q_points</div><div class="ttdef"><b>Definition:</b> <a href="fe__evaluation__0_8txt_source.html#l00537">fe_evaluation_0.txt:537</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html"><div class="ttname"><a href="classAffineConstraints.html">AffineConstraints&lt; double &gt;</a></div></div>
<div class="ttc" id="afe_2fe__update__flags_8h_html_aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85"><div class="ttname"><a href="fe_2fe__update__flags_8h.html#aa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a></div><div class="ttdeci">@ update_JxW_values</div><div class="ttdoc">Transformed quadrature weights.</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__update__flags_8h_source.html#l00124">fe_update_flags.h:124</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_a680d8b0d6d9162296d224196cfd47028"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#a680d8b0d6d9162296d224196cfd47028">parameters</a></div><div class="ttdeci">and situations where one is given a parameter dependent problem[2.x.4] and wants to form derivatives with regards to the parameters[2.x.5]</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00010">automatic_and_symbolic_differentiation_0.txt:10</a></div></div>
<div class="ttc" id="alac_2full__matrix_8h_html"><div class="ttname"><a href="lac_2full__matrix_8h.html">full_matrix.h</a></div></div>
<div class="ttc" id="anamespaceGridGenerator_html_acea0cbcd68e52ce8113d1134b87de403"><div class="ttname"><a href="namespaceGridGenerator.html#acea0cbcd68e52ce8113d1134b87de403">GridGenerator::hyper_cube</a></div><div class="ttdeci">void hyper_cube(Triangulation&lt; dim, spacedim &gt; &amp;tria, const double left=0., const double right=1., const bool colorize=false)</div></div>
<div class="ttc" id="alac_2petsc__sparse__matrix_8h_html"><div class="ttname"><a href="lac_2petsc__sparse__matrix_8h.html">petsc_sparse_matrix.h</a></div></div>
<div class="ttc" id="amultithreading__0_8txt_html_a1f10342dea7040f4c9a27bde8019d1a2"><div class="ttname"><a href="multithreading__0_8txt.html#a1f10342dea7040f4c9a27bde8019d1a2">done</a></div><div class="ttdeci">if only one is the scheduler would first completely execute task before doing or the other way around This model is able to execute much more efficiently in particular if a large number of tasks is available for see for example the discussion below in section[2.x.20] Abstractions for tasks are a high level description of what needs to be done</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00034">multithreading_0.txt:34</a></div></div>
<div class="ttc" id="abase_2function__parser_8h_html"><div class="ttname"><a href="base_2function__parser_8h.html">function_parser.h</a></div></div>
<div class="ttc" id="afe__q__0_8txt_html_a1a8eaafa20c4d8c9ab128b62a984738c"><div class="ttname"><a href="fe__q__0_8txt.html#a1a8eaafa20c4d8c9ab128b62a984738c">degrees</a></div><div class="ttdeci">*Implementation of a scalar Lagrange finite element[2.x.0] that yields the finite element space of piecewise polynomials of degree[2.x.1] in each coordinate direction This class is realized using tensor product polynomials based on D Lagrange polynomials with Gauss or given support points *The standard constructor of this class takes the degree[2.x.2] of this finite element it can take a quadrature formula[2.x.3] defining the support points of the Lagrange interpolation in one coordinate direction *For more information about the&lt; tt &gt; spacedim&lt;/tt &gt; template parameter check the documentation of FiniteElement or the one of Triangulation **The constructor creates a TensorProductPolynomials object that includes the tensor product of[2.x.4] polynomials of degree[2.x.5] This[2.x.6] object provides all values and derivatives of the shape functions In case a quadrature rule is the constructor creates a TensorProductPolynomials object that includes the tensor product of[2.x.7] polynomials with the support points from *[2.x.8] Furthermore the constructor fills the[2.x.9] the[2.x.10] equidistant support points at i where one polynomial is one and all the others are zero For higher polynomial degrees</div><div class="ttdef"><b>Definition:</b> <a href="fe__q__0_8txt_source.html#l00009">fe_q_0.txt:9</a></div></div>
<div class="ttc" id="adofs_2dof__handler_8h_html"><div class="ttname"><a href="dofs_2dof__handler_8h.html">dof_handler.h</a></div></div>
<div class="ttc" id="anamespaceStep36_html"><div class="ttname"><a href="namespaceStep36.html">Step36</a></div><div class="ttdef"><b>Definition:</b> <a href="step-36_8cc_source.html#l00050">step-36.cc:50</a></div></div>
<div class="ttc" id="anamespaceUtilities_1_1MPI_html_ac26de0c059200523177bb1d92cc25d00"><div class="ttname"><a href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">Utilities::MPI::n_mpi_processes</a></div><div class="ttdeci">unsigned int n_mpi_processes(const MPI_Comm &amp;mpi_communicator)</div><div class="ttdef"><b>Definition:</b> <a href="mpi_8cc_source.html#l00117">mpi.cc:117</a></div></div>
<div class="ttc" id="alac_2slepc__solver_8h_html"><div class="ttname"><a href="lac_2slepc__solver_8h.html">slepc_solver.h</a></div></div>
<div class="ttc" id="alac_2sparse__direct_8h_html"><div class="ttname"><a href="lac_2sparse__direct_8h.html">sparse_direct.h</a></div></div>
<div class="ttc" id="aprecondition__block__base__0_8txt_html_aba039b811c123042272605d7c7c7c726"><div class="ttname"><a href="precondition__block__base__0_8txt.html#aba039b811c123042272605d7c7c7c726">inverse</a></div><div class="ttdeci">*A class storing the inverse diagonal blocks for block preconditioners and block relaxation methods *This class does the book keeping for preconditioners and relaxation methods based on inverting blocks on the diagonal of a matrix It allows us to either store all diagonal blocks and their inverses or the same block for each entry and it keeps track of the choice Thus after initializing it and filling the inverse diagonal blocks correctly a derived class can use inverse() with an integer argument referring to the block number. *Additionally</div></div>
<div class="ttc" id="astep-69_8cc_html_a66a64d07b4db87c87b639bdcf7b18c82"><div class="ttname"><a href="step-69_8cc.html#a66a64d07b4db87c87b639bdcf7b18c82">local_dof_indices</a></div><div class="ttdeci">std::vector&lt; types::global_dof_index &gt; local_dof_indices</div><div class="ttdef"><b>Definition:</b> <a href="step-69_8cc_source.html#l00534">step-69.cc:534</a></div></div>
<div class="ttc" id="aquadrature__point__data__0_8txt_html_a35c4177ef651238576ebc1395f9e116e"><div class="ttname"><a href="quadrature__point__data__0_8txt.html#a35c4177ef651238576ebc1395f9e116e">refinement</a></div><div class="ttdeci">i a property that varies discontinuously within a solid In such trying to transfer data from the quadrature points to a finite element field that is once evaluated at a different set of quadrature the quadrature rule[2.x.94] used to integrate its mass matrix and finally the quadrature rule[2.x.95] which is used to store[2.x.96][2.x.97][2.x.98] has to be scalar valued *Since this class does projection on cell by cell basis[2.x.100] is only required to be continuous within the cell **Prepare for coarsening and refinement of a triangulation[2.x.101][2.x.102] represents the cell data which should be transferred and it should be initialized for each locally owned active cell *Although CellDataStorage class allows storing on different cells different objects derived from the base class here we assume that[2.x.104] contains objects of the same more specifically they pack unpack the same data **Interpolate the data previously stored in this object before the mesh was refined or coarsened onto the quadrature points of the currently active set of cells *Before calling this function the user is expected to populate the data stored in the[2.x.106] object provided to an exception will be thrown in debug mode **A callback function used to pack the data on the current mesh into objects that can later be retrieved after refinement</div><div class="ttdef"><b>Definition:</b> <a href="quadrature__point__data__0_8txt_source.html#l00085">quadrature_point_data_0.txt:85</a></div></div>
<div class="ttc" id="aclassSymmetricTensor_html_a45c9cd0a3fecbd58ae133dfdd104f9f9"><div class="ttname"><a href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">SymmetricTensor::eigenvalues</a></div><div class="ttdeci">std::array&lt; Number, 1 &gt; eigenvalues(const SymmetricTensor&lt; 2, 1, Number &gt; &amp;T)</div></div>
<div class="ttc" id="afe__evaluation__0_8txt_html_ad3b9cdeadeb3bcdb52af5db70c041a6e"><div class="ttname"><a href="fe__evaluation__0_8txt.html#ad3b9cdeadeb3bcdb52af5db70c041a6e">fe</a></div><div class="ttdeci">FE_Q with hanging node constraints connects to more neighbors than a FE_DGQ for and cells which need data exchange are put in different positions inside the cell loop Of if the exact same and then the order is going to be the same because the algorithm is deterministic *dim Dimension in which this class is to be used *fe_degree Degree of the tensor product finite element with fe_degree degrees of freedom per coordinate direction Can be set to **if the degree is not known at compile but performance will usually be worse by a factor of *n_q_points_1d Number of points in the quadrature formula defaults to fe_degree *n_components Number of vector components when solving a system of PDEs If the same operation is applied to several components of a they can be applied simultaneously with one usually[2.x.339] or[2.x.340] Defaults to[2.x.341] double ******An alias to the base class **An underlying number type specified as template argument **The type of function e g VectorizedArrayType for e g Tensor&lt; 1, dim, VectorizedArrayType &gt; for can be different if such as FE_DGP **static The number of degrees of freedom of all components determined from the given template argument fe_degree Note that the actual number of degrees of freedom dofs_per_cell can be different if such as FE_DGP **static The number of degrees of freedom of all components determined from the given template argument fe_degree Note that the actual number of degrees of freedom dofs_per_cell can be different if such as FE_DGP **Constructor Takes all data stored in MatrixFree If applied to problems with more than one finite element or more than one quadrature formula selected during construction of[2.x.343] the appropriate component can be selected by the optional arguments[2.x.344] matrix_free Data object that contains all data[2.x.345] dof_no If matrix_free was set up with multiple DoFHandler this parameter selects to which DoFHandler AffineConstraints pair the given evaluator should be attached to[2.x.346] quad_no If matrix_free was set up with multiple Quadrature this parameter selects the appropriate number of the quadrature formula[2.x.347] first_selected_component If the dof_handler selected by dof_no uses an FESystem consisting of more than one this parameter allows for selecting the component where the current evaluation routine should start Note that one evaluator does not support combining different shape functions in different components In other the same base element of a FESystem needs to be set for the components between[2.x.348] and[2.x.349][2.x.350] active_fe_index If matrix_free was set up with DoFHandler objects with[2.x.351] this parameter selects to which DoFHandler AffineConstraints pair the given evaluator should be attached to[2.x.352] active_quad_index If matrix_free was set up with[2.x.353] this parameter selects the appropriate number of the quadrature formula **Constructor Takes all data stored in MatrixFree for a given cell which allows to automatically identify the active_fe_index and active_quad_index in case of a p adaptive strategy The rest of the arguments are the same as in the constructor above **Constructor that comes with reduced functionality and works similar as FEValues The arguments are similar to the ones passed to the constructor of with the notable difference that FEEvaluation expects a one dimensional quadrature instead of a[2.x.354] dimensional one The finite element can be both scalar or vector but this method always only selects a scalar base element at a the optional argument[2.x.356] allows to specify the index of the base element to be used for evaluation Note that the internal data structures always assume that the base element is non primitive are not supported currently As known from a call to the reinit method with a[2.x.357] is necessary to make the geometry and degrees of freedom of the current class known::If the iterator includes DoFHandler the initialization allows to also read from or write to vectors in the standard way for[2.x.359] types for one cell at a time this approach is much slower than the path with MatrixFree with MPI since index translation has to be done As only one cell at a time is this method does not vectorize over several but only possibly within the element if the evaluate integrate routines are combined inside user an object of type i the underlying mapping and quadrature points do only need to be evaluated once Make sure to not pass an optional object around when you intend to use the FEEvaluation object in parallel to the given one because otherwise the intended sharing may create race conditions **Copy constructor If FEEvaluationBase was constructed from a fe</div><div class="ttdef"><b>Definition:</b> <a href="fe__evaluation__0_8txt_source.html#l00555">fe_evaluation_0.txt:555</a></div></div>
<div class="ttc" id="aclassParameterHandler_html"><div class="ttname"><a href="classParameterHandler.html">ParameterHandler</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2parameter__handler_8h_source.html#l00820">parameter_handler.h:820</a></div></div>
<div class="ttc" id="atable__handler__0_8txt_html_a61e9964f9093088848525ca172895749"><div class="ttname"><a href="table__handler__0_8txt.html#a61e9964f9093088848525ca172895749">step</a></div><div class="ttdeci">the ConvergenceTable class does something like this *To support both the TableHandler class has a property called[1.x.4] By auto fill mode is but it can be enabled by calling set_auto_fill_mode(). If auto-fill mode is enabled we use the following algorithm call it *[2.x.18] ***If[2.x.19] then we add[2.x.20] copies of the object[2.x.21] to this column is the data type of the given[2.x.23] is a numeric then[2.x.24] is[2.x.25] is the empty string *[2.x.26] ***Add the given value to this column *Padding the column with default elements makes sure that after the addition the column has as many entries as the longest other column In other if we have skipped previous invocations of then the padding will enter default values into this column *The algorithm as described will fail if you try to skip adding values for a key if adding an element for this key is the first thing you want to do for a given iteration or time step</div><div class="ttdef"><b>Definition:</b> <a href="table__handler__0_8txt_source.html#l00070">table_handler_0.txt:70</a></div></div>
<div class="ttc" id="aclassQuadrature_html_af9f7d82770fa8126e19113f3e3db755b"><div class="ttname"><a href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">Quadrature::size</a></div><div class="ttdeci">unsigned int size() const</div></div>
<div class="ttc" id="aclassSparseDirectUMFPACK_html"><div class="ttname"><a href="classSparseDirectUMFPACK.html">SparseDirectUMFPACK</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2sparse__direct_8h_source.html#l00089">sparse_direct.h:89</a></div></div>
<div class="ttc" id="aclassFullMatrix_html"><div class="ttname"><a href="classFullMatrix.html">FullMatrix&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassTensor_html_a858195ddbd94c49d6a2cdd447fc5ee63"><div class="ttname"><a href="classTensor.html#a858195ddbd94c49d6a2cdd447fc5ee63">Tensor::linfty_norm</a></div><div class="ttdeci">Number linfty_norm(const Tensor&lt; 2, dim, Number &gt; &amp;t)</div><div class="ttdef"><b>Definition:</b> <a href="base_2tensor_8h_source.html#l02953">tensor.h:2953</a></div></div>
<div class="ttc" id="awork__stream__0_8txt_html_a2252e3964ca906e132dfb7ffa15c79b8"><div class="ttname"><a href="work__stream__0_8txt.html#a2252e3964ca906e132dfb7ffa15c79b8">examples</a></div><div class="ttdeci">a prototypical example is assembling cell contributions to a system matrix or right hand side In many such examples</div><div class="ttdef"><b>Definition:</b> <a href="work__stream__0_8txt_source.html#l00003">work_stream_0.txt:3</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_ad83f9d9d8b603ed71c3483de199bc7a7"><div class="ttname"><a href="coding__conventions__0_8txt.html#ad83f9d9d8b603ed71c3483de199bc7a7">in</a></div><div class="ttdeci">their purpose is merely to keepdeal II as uniform as possible Uniformity reduces the number of bugs weproduce because we for always assume that input arguments comebefore output arguments of a function call They also simplify reading codebecause some things become clear already by looking at the style a piece ofcode is without having to look up the exact definition of something **deal II uses[2.x.2] to normalize indentation Astyle file is provided at ***Before a you should run **on each of your files This will make sure indentation is conforming to thestyle guidelines outlined in this page *This is cumbersome and more you can just run **in whatever directory you set up the library to be compiled in</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00013">coding_conventions_0.txt:13</a></div></div>
<div class="ttc" id="anamespaceVectorTools_1_1EvaluationFlags_html_ac6721740e24732d6afabcf28ddfc1ffdaeae4878b1e562785c1c196238a3f14e0"><div class="ttname"><a href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdaeae4878b1e562785c1c196238a3f14e0">VectorTools::EvaluationFlags::min</a></div><div class="ttdeci">@ min</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2vector__tools__evaluate_8h_source.html#l00062">vector_tools_evaluate.h:62</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_ac639e1db0b03fc797eca55e266afa976"><div class="ttname"><a href="coding__conventions__0_8txt.html#ac639e1db0b03fc797eca55e266afa976">cell</a></div><div class="ttdeci">functions which clear bits or flags should be named[2.x.15] use[2.x.18] instead of *[2.x.19] In the implementation after each three empty lines are expected to enable better readability One empty line occurs in functions to group blocks of since two empty lines are not enough to visibly distinguish sufficiently that the code belongs to two different functions *[2.x.21] Whenever an integer variable can only assume nonnegative it is marked as unsigned The same applies to functions that can only return positive or zero values it should be marked even if passed by value we mark input parameters as const This aids as an additional documentation tool to clarify the intent of a which is often either involuntarily or poor style *[2.x.25] Whenever a function does not change any of the member variable of the embedding class it should be marked as const  *[2.x.27] Function and variable names may not consist of only one or two unless the variable is a pure counting index *[2.x.29] Type the number of children per cell</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00027">coding_conventions_0.txt:27</a></div></div>
<div class="ttc" id="astructArpackSolver_1_1AdditionalData_html"><div class="ttname"><a href="structArpackSolver_1_1AdditionalData.html">ArpackSolver::AdditionalData</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2arpack__solver_8h_source.html#l00229">arpack_solver.h:229</a></div></div>
<div class="ttc" id="aclassSolverControl_html"><div class="ttname"><a href="classSolverControl.html">SolverControl</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2solver__control_8h_source.html#l00052">solver_control.h:52</a></div></div>
<div class="ttc" id="aclassPatterns_1_1Anything_html"><div class="ttname"><a href="classPatterns_1_1Anything.html">Patterns::Anything</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2patterns_8h_source.html#l01101">patterns.h:1101</a></div></div>
<div class="ttc" id="anamespaceEuler__DG_html_a143bc64b6fa6ced9f11c148a2af3ff09"><div class="ttname"><a href="namespaceEuler__DG.html#a143bc64b6fa6ced9f11c148a2af3ff09">Euler_DG::Number</a></div><div class="ttdeci">double Number</div><div class="ttdef"><b>Definition:</b> <a href="step-67_8cc_source.html#l00064">step-67.cc:64</a></div></div>
<div class="ttc" id="apolynomial__space__0_8txt_html_ac00ea19562c135512a6ff275a3cf0d8f"><div class="ttname"><a href="polynomial__space__0_8txt.html#ac00ea19562c135512a6ff275a3cf0d8f">j</a></div><div class="ttdeci">*Representation of the space of polynomials of degree at most n in higher dimensions *Given a vector of[1.x.0] one dimensional polynomials[1.x.1] where[1.x.3] has this class generates all dim dimensional polynomials of the where the sum and[1.x.8] is less than or equal *[1.x.9] The i e for each dim dimensional polynomial in the polynomial space it gives the indices j</div><div class="ttdef"><b>Definition:</b> <a href="polynomial__space__0_8txt_source.html#l00004">polynomial_space_0.txt:4</a></div></div>
<div class="ttc" id="aclassSLEPcWrappers_1_1SolverKrylovSchur_html"><div class="ttname"><a href="classSLEPcWrappers_1_1SolverKrylovSchur.html">SLEPcWrappers::SolverKrylovSchur</a></div><div class="ttdef"><b>Definition:</b> <a href="lac_2slepc__solver_8h_source.html#l00404">slepc_solver.h:404</a></div></div>
<div class="ttc" id="anamespaceVectorTools_1_1EvaluationFlags_html_ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9"><div class="ttname"><a href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdabaecdd1343aae63b652a2edeab0c19f9">VectorTools::EvaluationFlags::max</a></div><div class="ttdeci">@ max</div><div class="ttdef"><b>Definition:</b> <a href="numerics_2vector__tools__evaluate_8h_source.html#l00056">vector_tools_evaluate.h:56</a></div></div>
<div class="ttc" id="anumerics_2data__out_8h_html"><div class="ttname"><a href="numerics_2data__out_8h.html">data_out.h</a></div></div>
<div class="ttc" id="aclassFiniteElementData_html_a33b522422da89e5c080e7405ad49d7c7"><div class="ttname"><a href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">FiniteElementData::n_dofs_per_cell</a></div><div class="ttdeci">unsigned int n_dofs_per_cell() const</div></div>
<div class="ttc" id="aclassDataOut_html"><div class="ttname"><a href="classDataOut.html">DataOut&lt; dim &gt;</a></div></div>
<div class="ttc" id="aclassVector_html"><div class="ttname"><a href="classVector.html">Vector&lt; double &gt;</a></div></div>
<div class="ttc" id="alac_2sparse__matrix_8h_html"><div class="ttname"><a href="lac_2sparse__matrix_8h.html">sparse_matrix.h</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html_a1611aa37f754086388ca76bcd421cce5"><div class="ttname"><a href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">AffineConstraints::close</a></div><div class="ttdeci">void close()</div></div>
<div class="ttc" id="agroup__Exceptions_html_gafc0ca7ad85b3ebd64e8e51689ac85caf"><div class="ttname"><a href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a></div><div class="ttdeci">#define AssertThrow(cond, exc)</div><div class="ttdef"><b>Definition:</b> <a href="include_2deal_8II_2base_2exceptions_8h_source.html#l01699">exceptions.h:1699</a></div></div>
<div class="ttc" id="aclassFunctionParser_html"><div class="ttname"><a href="classFunctionParser.html">FunctionParser</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2function__parser_8h_source.html#l00246">function_parser.h:246</a></div></div>
<div class="ttc" id="afe_2fe__values__0_8txt_html_a15ff2e0c168966d6ae13c4faabcec165"><div class="ttname"><a href="fe_2fe__values__0_8txt.html#a15ff2e0c168966d6ae13c4faabcec165">dofs_per_cell</a></div><div class="ttdeci">we have to work a bit harder to compute this information **Default constructor Creates an invalid object **Constructor for an object that represents a single scalar component of a FEValuesBase for the shape function and quadrature point selected by the arguments[2.x.27] shape_function Number of the shape function to be evaluated Note that this number runs from zero to dofs_per_cell</div><div class="ttdef"><b>Definition:</b> <a href="fe_2fe__values__0_8txt_source.html#l00073">fe_values_0.txt:73</a></div></div>
<div class="ttc" id="adof__tools__0_8txt_html_aa623f15672a6db0f3f730a81a5b432b4"><div class="ttname"><a href="dof__tools__0_8txt.html#aa623f15672a6db0f3f730a81a5b432b4">active</a></div><div class="ttdeci">previous contents are not deleted **This function generates a matrix such that when a vector of data with as many elements as there are degrees of freedom of this component on the coarse grid is multiplied to this we obtain a vector with as many elements as there are global degrees of freedom on the fine grid All the elements of the other vector components of the finite element fields on the fine grid are not touched Triangulation of the fine grid can be distributed When called in each process has to have a copy of the coarse grid In this function returns transfer representation for a set of locally owned cells The output of this function is a compressed format that can be used to construct corresponding sparse transfer matrix ****Periodic boundary conditions *[2.x.121] *Insert this functions constrains all DoFs associated with the boundary described by[2.x.125] to the respective DoFs of the boundary described by[2.x.126] More the global DoF see below if[2.x.134] and[2.x.135] are not active this function loops recursively over the children of[2.x.136] and[2.x.137] If only one of the two faces is active</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__0_8txt_source.html#l00095">dof_tools_0.txt:95</a></div></div>
<div class="ttc" id="abase_2tensor_8h_html_a858195ddbd94c49d6a2cdd447fc5ee63"><div class="ttname"><a href="base_2tensor_8h.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a></div><div class="ttdeci">Number linfty_norm(const Tensor&lt; 2, dim, Number &gt; &amp;t)</div><div class="ttdef"><b>Definition:</b> <a href="base_2tensor_8h_source.html#l02953">tensor.h:2953</a></div></div>
<div class="ttc" id="agrid_2grid__generator_8h_html"><div class="ttname"><a href="grid_2grid__generator_8h.html">grid_generator.h</a></div></div>
<div class="ttc" id="alac_2petsc__vector_8h_html"><div class="ttname"><a href="lac_2petsc__vector_8h.html">petsc_vector.h</a></div></div>
<div class="ttc" id="aclassUtilities_1_1MPI_1_1MPI__InitFinalize_html"><div class="ttname"><a href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2mpi_8h_source.html#l00836">mpi.h:836</a></div></div>
<div class="ttc" id="acoding__conventions__0_8txt_html_a02f5aa616d7b0799c538fe77d6c6c795"><div class="ttname"><a href="coding__conventions__0_8txt.html#a02f5aa616d7b0799c538fe77d6c6c795">e</a></div><div class="ttdeci">i e</div><div class="ttdef"><b>Definition:</b> <a href="coding__conventions__0_8txt_source.html#l00028">coding_conventions_0.txt:28</a></div></div>
<div class="ttc" id="aclassAffineConstraints_html_a885d18f0044979873f5e5a6f33772f73"><div class="ttname"><a href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">AffineConstraints::is_constrained</a></div><div class="ttdeci">bool is_constrained(const size_type line_n) const</div><div class="ttdef"><b>Definition:</b> <a href="lac_2affine__constraints_8h_source.html#l02113">affine_constraints.h:2113</a></div></div>
<div class="ttc" id="aclassPatterns_1_1Integer_html"><div class="ttname"><a href="classPatterns_1_1Integer.html">Patterns::Integer</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2patterns_8h_source.html#l00198">patterns.h:198</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
