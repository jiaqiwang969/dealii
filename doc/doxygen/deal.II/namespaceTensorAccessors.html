<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceTensorAccessors.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TensorAccessors Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TensorAccessors Namespace Reference<div class="ingroups"><a class="el" href="group__geomprimitives.html">Geometric and other primitives This group contains</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceTensorAccessors_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTensorAccessors_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorAccessors_1_1ReturnType.html">ReturnType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorAccessors_1_1ReturnType_3_010_00_01T_01_4.html">ReturnType&lt; 0, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorAccessors_1_1ValueType.html">ValueType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorAccessors_1_1ValueType_3_01const_01T_01_4.html">ValueType&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorAccessors_1_1ValueType_3_01const_01T_0fN_0e_4.html">ValueType&lt; const T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTensorAccessors_1_1ValueType_3_01T_0fN_0e_4.html">ValueType&lt; T[N]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9d87f57bc155a2544393d1b7840d5d33"><td class="memTemplParams" colspan="2">template&lt;int index, int rank, typename T &gt; </td></tr>
<tr class="memitem:a9d87f57bc155a2544393d1b7840d5d33"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensorAccessors_1_1internal_1_1ReorderedIndexView.html">internal::ReorderedIndexView</a>&lt; <a class="el" href="scalapack__0_8txt.html#abc6ecee32660d1fa6d6157325220179a">index</a>, <a class="el" href="vector__valued__0_8txt.html#a829880cc3bd20a807fe06caef3f5fb31">rank</a>, <a class="el" href="aligned__vector__0_8txt.html#a31cb67809a0291768d4b233f3d6dee80">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTensorAccessors.html#a9d87f57bc155a2544393d1b7840d5d33">reordered_index_view</a> (<a class="el" href="aligned__vector__0_8txt.html#a31cb67809a0291768d4b233f3d6dee80">T</a> &amp;t)</td></tr>
<tr class="separator:a9d87f57bc155a2544393d1b7840d5d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcdbfc0f85477439646f1e65d77cf1b"><td class="memTemplParams" colspan="2">template&lt;int rank, typename T , typename ArrayType &gt; </td></tr>
<tr class="memitem:a3fcdbfc0f85477439646f1e65d77cf1b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structTensorAccessors_1_1ReturnType.html">ReturnType</a>&lt; <a class="el" href="vector__valued__0_8txt.html#a829880cc3bd20a807fe06caef3f5fb31">rank</a>, <a class="el" href="aligned__vector__0_8txt.html#a31cb67809a0291768d4b233f3d6dee80">T</a> &gt;::value_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTensorAccessors.html#a3fcdbfc0f85477439646f1e65d77cf1b">extract</a> (<a class="el" href="aligned__vector__0_8txt.html#a31cb67809a0291768d4b233f3d6dee80">T</a> &amp;t, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ArrayType &amp;<a class="el" href="block__indices__0_8txt.html#a209f8c4dfa20066a28a366a152192ed8">indices</a>)</td></tr>
<tr class="separator:a3fcdbfc0f85477439646f1e65d77cf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad350fefab729349a3c8c7185a8633d6f"><td class="memTemplParams" colspan="2">template&lt;int no_contr, int rank_1, int rank_2, int dim, typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:ad350fefab729349a3c8c7185a8633d6f"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTensorAccessors.html#ad350fefab729349a3c8c7185a8633d6f">contract</a> (T1 &amp;<a class="el" href="full__matrix__0_8txt.html#a7c638b6d25627b7e43d5ce877e3ef4e3">result</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> T2 &amp;<a class="el" href="dof__renumbering__0_8txt.html#ac3d8d9248a8deade35c7885be0096758">left</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> T3 &amp;<a class="el" href="fe__tools__0_8txt.html#a65a8cf466d3dfcbbb71981c170be3436">right</a>)</td></tr>
<tr class="separator:ad350fefab729349a3c8c7185a8633d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53656e024a6aefdd800036b8bbe4eea"><td class="memTemplParams" colspan="2">template&lt;int rank_1, int rank_2, int dim, typename T1 , typename T2 , typename T3 , typename T4 &gt; </td></tr>
<tr class="memitem:ad53656e024a6aefdd800036b8bbe4eea"><td class="memTemplItemLeft" align="right" valign="top">constexpr T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceTensorAccessors.html#ad53656e024a6aefdd800036b8bbe4eea">contract3</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> T2 &amp;<a class="el" href="dof__renumbering__0_8txt.html#ac3d8d9248a8deade35c7885be0096758">left</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> T3 &amp;middle, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> T4 &amp;<a class="el" href="fe__tools__0_8txt.html#a65a8cf466d3dfcbbb71981c170be3436">right</a>)</td></tr>
<tr class="separator:ad53656e024a6aefdd800036b8bbe4eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace is a collection of algorithms working on generic tensorial objects (of arbitrary rank). The rationale to implement such functionality in a generic fashion in a separate namespace is</p>
<ul>
<li>to easy code reusability and therefore avoid code duplication.</li>
<li>to have a well-defined interface that allows to exchange the low level implementation.</li>
</ul>
<p>A tensorial object has the notion of a rank and allows a rank-times recursive application of the index operator, e.g., if <code>t</code> is a tensorial object of rank 4, the following access is valid:</p>
<div class="fragment"><div class="line">t[1][2][1][4]</div>
</div><!-- fragment --><p>deal.II has its own implementation for tensorial objects such as ::Tensor&lt;rank,   dim, Number&gt; and <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;rank, dim, Number&gt; The methods and algorithms implemented in this namespace, however, are fully generic. More precisely, it can operate on nested c-style arrays, or on class types <code>T</code> with a minimal interface that provides a local alias <code>value_type</code> and an index operator <code>operator[](unsigned int)</code> that returns a (const or non-const) reference of <code>value_type</code> :</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;...&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using</span> value_type = ...;</div>
<div class="line">  value_type &amp; operator[](<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);</div>
<div class="line">  <span class="keyword">const</span> value_type &amp; operator[](<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This namespace provides primitives for access, reordering and contraction of such objects.</p>
<p>This namespace is a collection of algorithms working on generic tensorial objects (of arbitrary rank).</p>
<p>The rationale to implement such functionality in a generic fashion in a separate namespace is</p><ul>
<li>to easy code reusability and therefore avoid code duplication.</li>
<li>to have a well-defined interface that allows to exchange the low level implementation.</li>
</ul>
<p>A tensorial object has the notion of a rank and allows a rank-times recursive application of the index operator, e.g., if <code>t</code> is a tensorial object of rank 4, the following access is valid: </p><div class="fragment"><div class="line">t[1][2][1][4]</div>
</div><!-- fragment --><p>deal.II has its own implementation for tensorial objects such as ::Tensor&lt;rank, dim, Number&gt; and <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;rank, dim, Number&gt;</p>
<p>The methods and algorithms implemented in this namespace, however, are fully generic. More precisely, it can operate on nested c-style arrays, or on class types <code>T</code> with a minimal interface that provides a local alias <code>value_type</code> and an index operator <code>operator[](unsigned int)</code> that returns a (const or non-const) reference of <code>value_type</code>: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;...&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using</span> value_type = ...;</div>
<div class="line">  value_type &amp; operator[](<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>);</div>
<div class="line">  <span class="keyword">const</span> value_type &amp; operator[](<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>) <span class="keyword">const</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This namespace provides primitives for access, reordering and contraction of such objects. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9d87f57bc155a2544393d1b7840d5d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d87f57bc155a2544393d1b7840d5d33">&#9670;&nbsp;</a></span>reordered_index_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int index, int rank, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensorAccessors_1_1internal_1_1ReorderedIndexView.html">internal::ReorderedIndexView</a>&lt; <a class="el" href="scalapack__0_8txt.html#abc6ecee32660d1fa6d6157325220179a">index</a>, <a class="el" href="vector__valued__0_8txt.html#a829880cc3bd20a807fe06caef3f5fb31">rank</a>, <a class="el" href="aligned__vector__0_8txt.html#a31cb67809a0291768d4b233f3d6dee80">T</a> &gt; TensorAccessors::reordered_index_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="aligned__vector__0_8txt.html#a31cb67809a0291768d4b233f3d6dee80">T</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide a "tensorial view" to a reference <code>t</code> of a tensor object of rank <code>rank</code> in which the index <code>index</code> is shifted to the end. As an example consider a tensor of 5th order in dim=5 space dimensions that can be accessed through 5 recursive <code>operator[]()</code> invocations: </p><div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;5, dim&gt;</a> <a class="code" href="physics__0_8txt.html#a4e14816f45df3e9d423c8dfc045a7550">tensor</a>;</div>
<div class="line"><a class="code" href="physics__0_8txt.html#a4e14816f45df3e9d423c8dfc045a7550">tensor</a>[0][1][2][3][4] = 42.;</div>
</div><!-- fragment --><p> Index 1 (the 2nd index, count starts at 0) can now be shifted to the end via </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tensor_view = reordered_index_view&lt;1, 5&gt;(<a class="code" href="physics__0_8txt.html#a4e14816f45df3e9d423c8dfc045a7550">tensor</a>);</div>
<div class="line">tensor_view[0][2][3][4][1] == 42.; <span class="comment">// is true</span></div>
</div><!-- fragment --><p> The usage of the <a class="el" href="classTensor.html">Tensor</a> type was solely for the sake of an example. The mechanism implemented by this function is available for fairly general tensorial types <code>T</code>. The purpose of this reordering facility is to be able to contract over an arbitrary index of two (or more) tensors:</p>
<ul>
<li>reorder the indices in mind to the end of the tensors</li>
<li>use the contract function below that contracts the <em>last</em> elements of tensors. <dl class="section note"><dt>Note</dt><dd>This function returns an internal class object consisting of an array subscript operator <code>operator[](unsigned int)</code> and an alias <code>value_type</code> describing its return value. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">index</td><td>The index to be shifted to the end. Indices are counted from 0, thus the valid range is \(0\le\text{index}&lt;\text{rank}\) . </td></tr>
    <tr><td class="paramname">rank</td><td>Rank of the tensorial object <code>t</code> </td></tr>
    <tr><td class="paramname">T</td><td>A tensorial object of rank <code>rank</code>. <code>T</code> must provide a local alias <code>value_type</code> and an index operator <code>operator[]()</code> that returns a (const or non-const) reference of <code>value_type</code> .</td></tr>
  </table>
  </dd>
</dl>
Provide a "tensorial view" to a reference <code>t</code> of a tensor object of rank <code>rank</code> in which the index <code>index</code> is shifted to the end. As an example consider a tensor of 5th order in dim=5 space dimensions that can be accessed through 5 recursive <code>operator[]()</code> invocations: <div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;5, dim&gt;</a> <a class="code" href="physics__0_8txt.html#a4e14816f45df3e9d423c8dfc045a7550">tensor</a>;</div>
<div class="line"><a class="code" href="physics__0_8txt.html#a4e14816f45df3e9d423c8dfc045a7550">tensor</a>[0][1][2][3][4] = 42.;</div>
</div><!-- fragment --> Index 1 (the 2nd index, count starts at 0) can now be shifted to the end via <div class="fragment"><div class="line"><span class="keyword">auto</span> tensor_view = reordered_index_view&lt;1, 5&gt;(<a class="code" href="physics__0_8txt.html#a4e14816f45df3e9d423c8dfc045a7550">tensor</a>);</div>
<div class="line">tensor_view[0][2][3][4][1] == 42.; <span class="comment">// is true</span></div>
</div><!-- fragment --> The usage of the <a class="el" href="classTensor.html">Tensor</a> type was solely for the sake of an example. The mechanism implemented by this function is available for fairly general tensorial types <code>T</code>.</li>
</ul>
<p>The purpose of this reordering facility is to be able to contract over an arbitrary index of two (or more) tensors:</p><ul>
<li>reorder the indices in mind to the end of the tensors</li>
<li>use the contract function below that contracts the <em>last</em> elements of tensors.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function returns an internal class object consisting of an array subscript operator <code>operator[](unsigned int)</code> and an alias <code>value_type</code> describing its return value.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">index</td><td>The index to be shifted to the end. Indices are counted from 0, thus the valid range is \(0\le\text{index}&lt;\text{rank}\). </td></tr>
    <tr><td class="paramname">rank</td><td>Rank of the tensorial object <code>t</code> </td></tr>
    <tr><td class="paramname">T</td><td>A tensorial object of rank <code>rank</code>. <code>T</code> must provide a local alias <code>value_type</code> and an index operator <code>operator[]()</code> that returns a (const or non-const) reference of <code>value_type</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="base_2tensor__accessors_8h_source.html#l00254">254</a> of file <a class="el" href="base_2tensor__accessors_8h_source.html">tensor_accessors.h</a>.</p>

</div>
</div>
<a id="a3fcdbfc0f85477439646f1e65d77cf1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fcdbfc0f85477439646f1e65d77cf1b">&#9670;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, typename T , typename ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structTensorAccessors_1_1ReturnType.html">ReturnType</a>&lt; <a class="el" href="vector__valued__0_8txt.html#a829880cc3bd20a807fe06caef3f5fb31">rank</a>, <a class="el" href="aligned__vector__0_8txt.html#a31cb67809a0291768d4b233f3d6dee80">T</a> &gt;::value_type &amp; TensorAccessors::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="aligned__vector__0_8txt.html#a31cb67809a0291768d4b233f3d6dee80">T</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> ArrayType &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference (const or non-const) to a subobject of a tensorial object <code>t</code> of type <code>T</code>, as described by an array type <code>ArrayType</code> object <code>indices</code>. For example: </p><div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;5, dim&gt;</a> <a class="code" href="physics__0_8txt.html#a4e14816f45df3e9d423c8dfc045a7550">tensor</a>;</div>
<div class="line"><a class="code" href="classTableIndices.html">TableIndices&lt;5&gt;</a> <a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a> (0, 1, 2, 3, 4);</div>
<div class="line"><a class="code" href="namespaceTensorAccessors.html#a3fcdbfc0f85477439646f1e65d77cf1b">TensorAccessors::extract</a>(<a class="code" href="physics__0_8txt.html#a4e14816f45df3e9d423c8dfc045a7550">tensor</a>, <a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>) = 42;</div>
</div><!-- fragment --><p> This is equivalent to <code>tensor[0][1][2][3][4] = 42.</code> . </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensorial object of rank <code>rank</code>. <code>T</code> must provide a local alias <code>value_type</code> and an index operator <code>operator[]()</code> that returns a (const or non-const) reference of <code>value_type</code> . Further, its tensorial rank must be equal or greater than <code>rank</code>. </td></tr>
    <tr><td class="paramname">ArrayType</td><td>An array like object, such as std::array, or <a class="el" href="classTableIndices.html">TableIndices</a> that stores at least <code>rank</code> indices that can be accessed via operator[]().</td></tr>
  </table>
  </dd>
</dl>
<p>Return a reference (const or non-const) to a subobject of a tensorial object <code>t</code> of type <code>T</code>, as described by an array type <code>ArrayType</code> object <code>indices</code>. For example: </p><div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;5, dim&gt;</a> <a class="code" href="physics__0_8txt.html#a4e14816f45df3e9d423c8dfc045a7550">tensor</a>;</div>
<div class="line"><a class="code" href="classTableIndices.html">TableIndices&lt;5&gt;</a> <a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a> (0, 1, 2, 3, 4);</div>
<div class="line"><a class="code" href="namespaceTensorAccessors.html#a3fcdbfc0f85477439646f1e65d77cf1b">TensorAccessors::extract</a>(<a class="code" href="physics__0_8txt.html#a4e14816f45df3e9d423c8dfc045a7550">tensor</a>, <a class="code" href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a>) = 42;</div>
</div><!-- fragment --><p> This is equivalent to <code>tensor[0][1][2][3][4] = 42.</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensorial object of rank <code>rank</code>. <code>T</code> must provide a local alias <code>value_type</code> and an index operator <code>operator[]()</code> that returns a (const or non-const) reference of <code>value_type</code>. Further, its tensorial rank must be equal or greater than <code>rank</code>.</td></tr>
    <tr><td class="paramname">ArrayType</td><td>An array like object, such as std::array, or <a class="el" href="classTableIndices.html">TableIndices</a> that stores at least <code>rank</code> indices that can be accessed via operator[](). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="base_2tensor__accessors_8h_source.html#l00285">285</a> of file <a class="el" href="base_2tensor__accessors_8h_source.html">tensor_accessors.h</a>.</p>

</div>
</div>
<a id="ad350fefab729349a3c8c7185a8633d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad350fefab729349a3c8c7185a8633d6f">&#9670;&nbsp;</a></span>contract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int no_contr, int rank_1, int rank_2, int dim, typename T1 , typename T2 , typename T3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void TensorAccessors::contract </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> T2 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> T3 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function contracts two tensorial objects <code>left</code> and <code>right</code> and stores the result in <code>result</code>. The contraction is done over the <em>last</em> <code>no_contr</code> indices of both tensorial objects: </p><p class="formulaDsp">
\[ \text{result}_{i_1,..,i_{r1},j_1,..,j_{r2}} = \sum_{k_1,..,k_{\mathrm{no\_contr}}} \mathrm{left}_{i_1,..,i_{r1},k_1,..,k_{\mathrm{no\_contr}}} \mathrm{right}_{j_1,..,j_{r2},k_1,..,k_{\mathrm{no\_contr}}} \]
</p>
<p> Calling this function is equivalent of writing the following low level code: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i_0 = 0; i_0 &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++i_0)</div>
<div class="line">  ...</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i_ = 0; i_ &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++i_)</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j_0 = 0; j_0 &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++j_0)</div>
<div class="line">        ...</div>
<div class="line">          <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j_ = 0; j_ &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++j_)</div>
<div class="line">            {</div>
<div class="line">              <a class="code" href="dof__tools__0_8txt.html#a9442956f28da0afe6f6e41e15e33d525">result</a>[i_0]..[i_][j_0]..[j_] = 0.;</div>
<div class="line">              <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k_0 = 0; k_0 &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++k_0)</div>
<div class="line">                ...</div>
<div class="line">                  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k_ = 0; k_ &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++k_)</div>
<div class="line">                    <a class="code" href="dof__tools__0_8txt.html#a9442956f28da0afe6f6e41e15e33d525">result</a>[i_0]..[i_][j_0]..[j_] +=</div>
<div class="line">                      <a class="code" href="reordering__0_8txt.html#a5e7210fbddbe116af981450cdfc340b1">left</a>[i_0]..[i_][k_0]..[k_]</div>
<div class="line">                        <a class="code" href="reordering__0_8txt.html#abc892651c0b2805d80c1933e2fb51c1a">right</a>[j_0]..[j_][k_0]..[k_];</div>
<div class="line">            }</div>
</div><!-- fragment --><p> with r = rank_1 + rank_2</p>
<ul>
<li>2 no_contr, l = rank_1</li>
<li>no_contr, l1 = rank_1, and c = no_contr. <dl class="section note"><dt>Note</dt><dd>The Types <code>T1</code>, <code>T2</code>, and <code>T3</code> must have rank rank_1 + rank_2</dd></dl>
</li>
<li>2 no_contr, rank_1, or rank_2, respectively. Obviously, no_contr must be less or equal than rank_1 and rank_2.</li>
</ul>
<p>This function contracts two tensorial objects <code>left</code> and <code>right</code> and stores the result in <code>result</code>. The contraction is done over the <em>last</em> <code>no_contr</code> indices of both tensorial objects:</p>
<p class="formulaDsp">
\[ \text{result}_{i_1,..,i_{r1},j_1,..,j_{r2}} = \sum_{k_1,..,k_{\mathrm{no\_contr}}} \mathrm{left}_{i_1,..,i_{r1},k_1,..,k_{\mathrm{no\_contr}}} \mathrm{right}_{j_1,..,j_{r2},k_1,..,k_{\mathrm{no\_contr}}} \]
</p>
<p>Calling this function is equivalent of writing the following low level code: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i_0 = 0; i_0 &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++i_0)</div>
<div class="line">  ...</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i_ = 0; i_ &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++i_)</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j_0 = 0; j_0 &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++j_0)</div>
<div class="line">        ...</div>
<div class="line">          <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j_ = 0; j_ &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++j_)</div>
<div class="line">            {</div>
<div class="line">              <a class="code" href="dof__tools__0_8txt.html#a9442956f28da0afe6f6e41e15e33d525">result</a>[i_0]..[i_][j_0]..[j_] = 0.;</div>
<div class="line">              <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k_0 = 0; k_0 &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++k_0)</div>
<div class="line">                ...</div>
<div class="line">                  <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k_ = 0; k_ &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++k_)</div>
<div class="line">                    <a class="code" href="dof__tools__0_8txt.html#a9442956f28da0afe6f6e41e15e33d525">result</a>[i_0]..[i_][j_0]..[j_] +=</div>
<div class="line">                      <a class="code" href="reordering__0_8txt.html#a5e7210fbddbe116af981450cdfc340b1">left</a>[i_0]..[i_][k_0]..[k_]</div>
<div class="line">                        * <a class="code" href="reordering__0_8txt.html#abc892651c0b2805d80c1933e2fb51c1a">right</a>[j_0]..[j_][k_0]..[k_];</div>
<div class="line">            }</div>
</div><!-- fragment --><p> with r = rank_1 + rank_2 - 2 * no_contr, l = rank_1 - no_contr, l1 = rank_1, and c = no_contr.</p>
<dl class="section note"><dt>Note</dt><dd>The Types <code>T1</code>, <code>T2</code>, and <code>T3</code> must have rank rank_1 + rank_2 - 2 * no_contr, rank_1, or rank_2, respectively. Obviously, no_contr must be less or equal than rank_1 and rank_2. </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2tensor__accessors_8h_source.html#l00335">335</a> of file <a class="el" href="base_2tensor__accessors_8h_source.html">tensor_accessors.h</a>.</p>

</div>
</div>
<a id="ad53656e024a6aefdd800036b8bbe4eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53656e024a6aefdd800036b8bbe4eea">&#9670;&nbsp;</a></span>contract3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_1, int rank_2, int dim, typename T1 , typename T2 , typename T3 , typename T4 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T1 TensorAccessors::contract3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> T2 &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> T3 &amp;&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> T4 &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Full contraction of three tensorial objects: </p><p class="formulaDsp">
\[ \sum_{i_1,..,i_{r1},j_1,..,j_{r2}} \text{left}_{i_1,..,i_{r1}} \text{middle}_{i_1,..,i_{r1},j_1,..,j_{r2}} \text{right}_{j_1,..,j_{r2}} \]
</p>
<p> Calling this function is equivalent of writing the following low level code: </p><div class="fragment"><div class="line"><a class="code" href="namespaceStep32_1_1EquationData.html#a00bf6e26439db0d8e3b91f11ee4fd72a">T1</a> <a class="code" href="dof__tools__0_8txt.html#a9442956f28da0afe6f6e41e15e33d525">result</a> = <a class="code" href="namespaceStep32_1_1EquationData.html#a00bf6e26439db0d8e3b91f11ee4fd72a">T1</a>();</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i_0 = 0; i_0 &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++i_0)</div>
<div class="line">  ...</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i_ = 0; i_ &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++i_)</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j_0 = 0; j_0 &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++j_0)</div>
<div class="line">        ...</div>
<div class="line">          <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j_ = 0; j_ &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++j_)</div>
<div class="line">            <a class="code" href="dof__tools__0_8txt.html#a9442956f28da0afe6f6e41e15e33d525">result</a> += <a class="code" href="reordering__0_8txt.html#a5e7210fbddbe116af981450cdfc340b1">left</a>[i_0]..[i_]</div>
<div class="line">                        middle[i_0]..[i_][j_0]..[j_]</div>
<div class="line">                        <a class="code" href="reordering__0_8txt.html#abc892651c0b2805d80c1933e2fb51c1a">right</a>[j_0]..[j_];</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The Types <code>T2</code>, <code>T3</code>, and <code>T4</code> must have rank rank_1, rank_1 + rank_2, and rank_3, respectively. <code>T1</code> must be a scalar type.</dd></dl>
<p>Full contraction of three tensorial objects:</p>
<p class="formulaDsp">
\[ \sum_{i_1,..,i_{r1},j_1,..,j_{r2}} \text{left}_{i_1,..,i_{r1}} \text{middle}_{i_1,..,i_{r1},j_1,..,j_{r2}} \text{right}_{j_1,..,j_{r2}} \]
</p>
<p>Calling this function is equivalent of writing the following low level code: </p><div class="fragment"><div class="line"><a class="code" href="namespaceStep32_1_1EquationData.html#a00bf6e26439db0d8e3b91f11ee4fd72a">T1</a> <a class="code" href="dof__tools__0_8txt.html#a9442956f28da0afe6f6e41e15e33d525">result</a> = <a class="code" href="namespaceStep32_1_1EquationData.html#a00bf6e26439db0d8e3b91f11ee4fd72a">T1</a>();</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i_0 = 0; i_0 &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++i_0)</div>
<div class="line">  ...</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i_ = 0; i_ &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++i_)</div>
<div class="line">      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j_0 = 0; j_0 &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++j_0)</div>
<div class="line">        ...</div>
<div class="line">          <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j_ = 0; j_ &lt; <a class="code" href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a>; ++j_)</div>
<div class="line">            <a class="code" href="dof__tools__0_8txt.html#a9442956f28da0afe6f6e41e15e33d525">result</a> += <a class="code" href="reordering__0_8txt.html#a5e7210fbddbe116af981450cdfc340b1">left</a>[i_0]..[i_]</div>
<div class="line">                        * middle[i_0]..[i_][j_0]..[j_]</div>
<div class="line">                        * <a class="code" href="reordering__0_8txt.html#abc892651c0b2805d80c1933e2fb51c1a">right</a>[j_0]..[j_];</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The Types <code>T2</code>, <code>T3</code>, and <code>T4</code> must have rank rank_1, rank_1 + rank_2, and rank_3, respectively. <code>T1</code> must be a scalar type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2tensor__accessors_8h_source.html#l00384">384</a> of file <a class="el" href="base_2tensor__accessors_8h_source.html">tensor_accessors.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="areordering__0_8txt_html_abc892651c0b2805d80c1933e2fb51c1a"><div class="ttname"><a href="reordering__0_8txt.html#abc892651c0b2805d80c1933e2fb51c1a">right</a></div><div class="ttdeci">if it is not then it aborts in linear time as well *Both algorithms are described in the paper On orienting edges of unstructured two and three dimensional R M W W L ACM Transactions on Mathematical A preprint is available as *[1.x.19] **Prior to the implementation of the algorithms described we used a branch and cut algorithm initially implemented in by Wolfgang Bangerth Although it is no longer here is how it and why it doesn t always work for large meshes since its run time can be exponential in bad cases *The first observation is that although there are problems are usually local For in the second example mentioned if we had numbered the cells in a way that neighboring cells have similar cell then the amount of backtracking needed is greatly reduced in the implementation of the the first step is to renumber the cells in a Cuthill McKee and so on this represents finding zones of cells consecutively further away from the initial cells and number them in this front marching way This already greatly improves locality of problems and consequently reduced the necessary amount of backtracking *The second point is that we can use some methods to prune the which usually lead to a valid orientation of all cells very quickly *The first such method is based on the observation that if we fail to insert one cell with number then this may not be due to cell N unless N is a direct neighbor of N The reason is for the latter cannot be the case if we fail to add cell then it is not necessary to track back to cell but we can track back to the neighbor of N with the largest cell index and which has already been added this method can fail to yield a valid path through the tree if not applied with care Consider the following initially extracted from a mesh of cells generated automatically by the program BAMG(this program usually generates meshes that are quite badly balanced, often have many **- sometimes 10 or more **- neighbors of one vertex, and exposed several problems in the initial algorithm;note also that the example is in 2d where we now have the much better algorithm described above, but the same observations also apply to 3d) we will therefore find no orientation of cell in which it can be added without violation of the consistency of the triangulation According to the rule stated we track back to the neighbor with greatest which is but since its bottom line is to th right)</div><div class="ttdef"><b>Definition:</b> <a href="reordering__0_8txt_source.html#l00125">reordering_0.txt:125</a></div></div>
<div class="ttc" id="aclassTableIndices_html"><div class="ttname"><a href="classTableIndices.html">TableIndices</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2table__indices_8h_source.html#l00045">table_indices.h:45</a></div></div>
<div class="ttc" id="aphysics__0_8txt_html_a4e14816f45df3e9d423c8dfc045a7550"><div class="ttname"><a href="physics__0_8txt.html#a4e14816f45df3e9d423c8dfc045a7550">tensor</a></div><div class="ttdeci">******classes that relate to continuum physical fields and materials ***A collection of namespaces and utilities to assist in the construction and manipulation of data related to physical fields and materials ***Notations that reduce the order of effectively storing them in some sort of consistent compressed storage pattern An example is storing the independent components of[2.x.2] symmetric tensors of rank as a vector with and then representing the independent elements of symmetric[2.x.3] tensors of with its generalization it has wider applicability This representation is also common in the material science and FEM literature There are several variations of tensor each a slightly different structure The primary difference between the various forms of tensor notation is the weighting prescribed to the various elements of the compressed tensors This[1.x.0] has some further general insights on this topic *Jean Paul **A collection of operations to assist in the transformation of tensor quantities from the reference to spatial and vice versa These types of transformation are typically used to re express quantities measured or computed in one configuration in terms of a second configuration **We will use the same notation for the differential and[2.x.16] that it is covariant In other these indices do not actually change the tensor</div><div class="ttdef"><b>Definition:</b> <a href="physics__0_8txt_source.html#l00023">physics_0.txt:23</a></div></div>
<div class="ttc" id="anamespaceLAPACKSupport_html_a8cac1e477eff052db622c8a9a9426ea3"><div class="ttname"><a href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">LAPACKSupport::T</a></div><div class="ttdeci">static const char T</div><div class="ttdef"><b>Definition:</b> <a href="lac_2lapack__support_8h_source.html#l00177">lapack_support.h:177</a></div></div>
<div class="ttc" id="adof__tools__0_8txt_html_a9442956f28da0afe6f6e41e15e33d525"><div class="ttname"><a href="dof__tools__0_8txt.html#a9442956f28da0afe6f6e41e15e33d525">result</a></div><div class="ttdeci">namespace the creation of the sparsity pattern is done by the it needs to have a numbering of all those degrees of freedom that are on those parts of the boundary that we are interested in You can get this from the where[2.x.10] and[2.x.11] are indices into the and[2.x.12] is the global DoF number of a degree of freedom sitting on a remember that these flags are used as elements of tables of size[2.x.16] times[2.x.17] where each element indicates whether two components do or do not couple **Two components do not couple **Two components do couple **Two components couple only if their shape functions are both nonzero on a given face This flag is only used when computing integrals over faces of e in[2.x.18] Use[2.x.19] in general cases where gradients etc occur on face integrals **DoF couplings *[2.x.21] *Map a coupling table from the user friendly organization by components to the organization by blocks The return vector will be initialized to the correct length inside this function **Given a finite element and a table how the vector components of it couple with each compute and return a table that describes how the individual shape functions couple with each other **Same function as above for a collection of finite returning a collection of tables The function currently treats[2.x.22] the same as *[2.x.23] ***Sparsity pattern generation *[2.x.26] *Compute which entries of a matrix built on the given[2.x.27] may possibly be and create a sparsity pattern object that represents these nonzero locations This function computes the possible positions of non zero entries in the global system matrix by[1.x.3] which entries one would write to during the actual assembly of a matrix For the function assumes that each finite element basis function is non zero on a cell only if its degree of freedom is associated with the a an edge or a vertex of this cell As a result</div><div class="ttdef"><b>Definition:</b> <a href="dof__tools__0_8txt_source.html#l00049">dof_tools_0.txt:49</a></div></div>
<div class="ttc" id="aclassTensor_html"><div class="ttname"><a href="classTensor.html">Tensor&lt; 5, dim &gt;</a></div></div>
<div class="ttc" id="ageometry__info__0_8txt_html_a30a552b07accf65da90f851e25d14d1c"><div class="ttname"><a href="geometry__info__0_8txt.html#a30a552b07accf65da90f851e25d14d1c">dim</a></div><div class="ttdeci">3, where it offers following possibilities:a face(quad) being refined in x- or y-direction(in the face-intern coordinate system) separately,([2.x.79] or([2.x.80] which corresponds to([2.x.81]). Additionally, it offers the possibilities a face can have through repeated anisotropic refinement steps performed on one of the two neighboring cells. It might be possible for example, that a face(quad) is refined with[2.x.82] and afterwards the left child is again refined with[2.x.83], so that there are three active subfaces. Note, however, that only refinement cases are allowed such that each line on a face between two hexes has not more than one hanging node. Furthermore, it is not allowed that two neighboring hexes are refined such that one of the hexes refines the common face with[2.x.84] and the other hex refines that face with[2.x.85] . In fact,[2.x.86] takes care of this situation and ensures that each face of a refined cell is completely contained in a single face of neighboring cells. The following drawings explain the SubfacePossibilities and give the corresponding subface numbers:*[1.x.4] **[2.x.87] *[0.x.68] *Possible cases of faces being subdivided into subface. See documentation to the SubfacePossibilities&lt; 3 &gt; for more details on the subface possibilities. *[0.x.69] *A class that provides all possible cases a face(in the current space dimension[2.x.88] might be subdivided into subfaces. *[2.x.89] *[0.x.70] *Constructor. Take and store a value indicating a particular subface possibility in the list of possible situations specified in the base class. *[0.x.71] *Return the numeric value stored by this class. While the presence of this operator might seem dangerous, it is useful in cases where one would like to have code like&lt; code &gt;switch(subface_case)... case[2.x.90] ...&lt;/code &gt;, which can be written as&lt; code &gt;switch[2.x.91] Another application is to use an object of the current type as an index into an array dim</div><div class="ttdef"><b>Definition:</b> <a href="geometry__info__0_8txt_source.html#l00202">geometry_info_0.txt:202</a></div></div>
<div class="ttc" id="anamespaceStep32_1_1EquationData_html_a00bf6e26439db0d8e3b91f11ee4fd72a"><div class="ttname"><a href="namespaceStep32_1_1EquationData.html#a00bf6e26439db0d8e3b91f11ee4fd72a">Step32::EquationData::T1</a></div><div class="ttdeci">constexpr double T1</div><div class="ttdef"><b>Definition:</b> <a href="step-32_8cc_source.html#l00102">step-32.cc:102</a></div></div>
<div class="ttc" id="anamespaceTensorAccessors_html_a3fcdbfc0f85477439646f1e65d77cf1b"><div class="ttname"><a href="namespaceTensorAccessors.html#a3fcdbfc0f85477439646f1e65d77cf1b">TensorAccessors::extract</a></div><div class="ttdeci">constexpr ReturnType&lt; rank, T &gt;::value_type &amp; extract(T &amp;t, const ArrayType &amp;indices)</div><div class="ttdef"><b>Definition:</b> <a href="base_2tensor__accessors_8h_source.html#l00285">tensor_accessors.h:285</a></div></div>
<div class="ttc" id="areordering__0_8txt_html_a5e7210fbddbe116af981450cdfc340b1"><div class="ttname"><a href="reordering__0_8txt.html#a5e7210fbddbe116af981450cdfc340b1">left</a></div><div class="ttdeci">it will soon be obvious that there can t exists such a even if we allow that there might be cells with clockwise and counterclockwise orientation of the lines at the same time *One might argue that the definition of unique directions for faces and and the definition of directions relative to the cells they is a misfeature of deal II In it makes reading in grids created by mesh generators rather as they usually don t follow these conventions when generating their output On the other there are good reasons to introduce such as they can make programming much simpler in many leading to an increase in speed of some computations as one can avoid expensive checks in many places because the orientation of faces is known by assumption that it is guaranteed by the triangulation *The purpose of this class is now to find an ordering for a given set of cells such that the generated triangulation satisfies all the requirements stated above To this end we will first show some examples why this is a difficult problem and then develop algorithms that finds such a reordering Note that the algorithm operates on a set of CellData objects that are used to describe a mesh to the triangulation class These objects are for example generated by the GridIn class when reading in grids from input files *As a last question for this first the answer is no(which also underlines that using such orientations might be an **- unfortunately uncurable **- misfeature of deal.II). A simple counter-example in 3d illustrates this if that is then we can stop following all paths below this point and track back immediately it is already obvious that the tree has left[2.x.4] leaves in two space since each of the[2.x.5] cells can be added in four orientations Most of these nodes can be discarded since firstly the orientation of the first cell is and secondly if we add one cell that has a neighbor that has already been then there are already only two possible orientations</div><div class="ttdef"><b>Definition:</b> <a href="reordering__0_8txt_source.html#l00072">reordering_0.txt:72</a></div></div>
<div class="ttc" id="agraph__coloring__0_8txt_html_a068d28578c03dd6b6bb6b32bf268eafd"><div class="ttname"><a href="graph__coloring__0_8txt.html#a068d28578c03dd6b6bb6b32bf268eafd">indices</a></div><div class="ttdeci">namespace containing functions that can color graphs ***Given two sets of indices that are assumed to be determine whether they will have a nonempty intersection The actual intersection is not computed[2.x.0] indices1 A set of indices</div><div class="ttdef"><b>Definition:</b> <a href="graph__coloring__0_8txt_source.html#l00006">graph_coloring_0.txt:6</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
