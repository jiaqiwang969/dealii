<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTimerOutput.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TimerOutput Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classTimerOutput-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TimerOutput Class Reference<div class="ingroups"><a class="el" href="group__utilities.html">Utility functions and classes This module simply</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="base_2timer_8h_source.html">deal.II/base/timer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput_1_1Scope.html">Scope</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTimerOutput_1_1Section.html">Section</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a643d0e642b80048e91b37109fe9357cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> { <br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3">every_call</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6">summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7">every_call_and_summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a">never</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3">every_call</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6">summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7">every_call_and_summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a">never</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3">every_call</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6">summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7">every_call_and_summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a">never</a>
<br />
 }</td></tr>
<tr class="separator:a643d0e642b80048e91b37109fe9357cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3bc552db540d876d14e3c7870fe1f8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8">OutputData</a> { <br />
&#160;&#160;<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511">total_cpu_time</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be">total_wall_time</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1">n_calls</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511">total_cpu_time</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be">total_wall_time</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1">n_calls</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511">total_cpu_time</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be">total_wall_time</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1">n_calls</a>
<br />
 }</td></tr>
<tr class="separator:aba3bc552db540d876d14e3c7870fe1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2405ae1b041a57d11a61a8cbfad3b487"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> { <br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc">cpu_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4">cpu_and_wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020">cpu_and_wall_times_grouped</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc">cpu_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4">cpu_and_wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020">cpu_and_wall_times_grouped</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc">cpu_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4">cpu_and_wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020">cpu_and_wall_times_grouped</a>
<br />
 }</td></tr>
<tr class="separator:a2405ae1b041a57d11a61a8cbfad3b487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643d0e642b80048e91b37109fe9357cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> { <br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3">every_call</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6">summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7">every_call_and_summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a">never</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3">every_call</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6">summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7">every_call_and_summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a">never</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3">every_call</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6">summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7">every_call_and_summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a">never</a>
<br />
 }</td></tr>
<tr class="separator:a643d0e642b80048e91b37109fe9357cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3bc552db540d876d14e3c7870fe1f8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8">OutputData</a> { <br />
&#160;&#160;<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511">total_cpu_time</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be">total_wall_time</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1">n_calls</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511">total_cpu_time</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be">total_wall_time</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1">n_calls</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511">total_cpu_time</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be">total_wall_time</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1">n_calls</a>
<br />
 }</td></tr>
<tr class="separator:aba3bc552db540d876d14e3c7870fe1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2405ae1b041a57d11a61a8cbfad3b487"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> { <br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc">cpu_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4">cpu_and_wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020">cpu_and_wall_times_grouped</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc">cpu_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4">cpu_and_wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020">cpu_and_wall_times_grouped</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc">cpu_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4">cpu_and_wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020">cpu_and_wall_times_grouped</a>
<br />
 }</td></tr>
<tr class="separator:a2405ae1b041a57d11a61a8cbfad3b487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643d0e642b80048e91b37109fe9357cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> { <br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3">every_call</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6">summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7">every_call_and_summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a">never</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3">every_call</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6">summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7">every_call_and_summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a">never</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3">every_call</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6">summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7">every_call_and_summary</a>, 
<a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a">never</a>
<br />
 }</td></tr>
<tr class="separator:a643d0e642b80048e91b37109fe9357cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3bc552db540d876d14e3c7870fe1f8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8">OutputData</a> { <br />
&#160;&#160;<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511">total_cpu_time</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be">total_wall_time</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1">n_calls</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511">total_cpu_time</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be">total_wall_time</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1">n_calls</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511">total_cpu_time</a>, 
<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be">total_wall_time</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1">n_calls</a>
<br />
 }</td></tr>
<tr class="separator:aba3bc552db540d876d14e3c7870fe1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2405ae1b041a57d11a61a8cbfad3b487"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> { <br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc">cpu_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4">cpu_and_wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020">cpu_and_wall_times_grouped</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc">cpu_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4">cpu_and_wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020">cpu_and_wall_times_grouped</a>, 
<br />
&#160;&#160;<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc">cpu_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4">cpu_and_wall_times</a>, 
<a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020">cpu_and_wall_times_grouped</a>
<br />
 }</td></tr>
<tr class="separator:a2405ae1b041a57d11a61a8cbfad3b487"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae84f96493f79aa033eb828aac8ede66a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ae84f96493f79aa033eb828aac8ede66a">TimerOutput</a> (std::ostream &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> <a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> <a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a>)</td></tr>
<tr class="separator:ae84f96493f79aa033eb828aac8ede66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fbaf7e9d78f28c617553a21e3316f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#af8fbaf7e9d78f28c617553a21e3316f4">TimerOutput</a> (<a class="el" href="classConditionalOStream.html">ConditionalOStream</a> &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> <a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> <a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a>)</td></tr>
<tr class="separator:af8fbaf7e9d78f28c617553a21e3316f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aebd8141aa504f7dd4feb5dbb98e44b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a7aebd8141aa504f7dd4feb5dbb98e44b">TimerOutput</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;mpi_comm, std::ostream &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> <a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> <a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a>)</td></tr>
<tr class="separator:a7aebd8141aa504f7dd4feb5dbb98e44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c8f65a32e49e6b10fcc9d286264766"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a46c8f65a32e49e6b10fcc9d286264766">TimerOutput</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;mpi_comm, <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> <a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> <a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a>)</td></tr>
<tr class="separator:a46c8f65a32e49e6b10fcc9d286264766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf19f2a55900e34d6f588dbaf8cfbcc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#acf19f2a55900e34d6f588dbaf8cfbcc7">~TimerOutput</a> ()</td></tr>
<tr class="separator:acf19f2a55900e34d6f588dbaf8cfbcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae730ff220ae414208dc85e76920c3e45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;section_name)</td></tr>
<tr class="separator:ae730ff220ae414208dc85e76920c3e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d27dbc569819f3bbcb5e066e47212ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a4d27dbc569819f3bbcb5e066e47212ea">leave_subsection</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;section_name=&quot;&quot;)</td></tr>
<tr class="separator:a4d27dbc569819f3bbcb5e066e47212ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37aba48e5fabc984b5d1b169b58991d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; std::string, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ac37aba48e5fabc984b5d1b169b58991d">get_summary_data</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8">OutputData</a> <a class="el" href="dof__tools__0_8txt.html#a5b35652d082b70bd89028e5c9fdab866">kind</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ac37aba48e5fabc984b5d1b169b58991d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133e7d844826bc8716898fb2f86fb9b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a133e7d844826bc8716898fb2f86fb9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7673798226de7731e3ecdf7c0fb7568"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ae7673798226de7731e3ecdf7c0fb7568">print_wall_time_statistics</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;mpi_comm, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> print_quantile=0.) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ae7673798226de7731e3ecdf7c0fb7568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478c3fbca1d76c07eff9e7af8886dbb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a478c3fbca1d76c07eff9e7af8886dbb5">disable_output</a> ()</td></tr>
<tr class="separator:a478c3fbca1d76c07eff9e7af8886dbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf249feeb107af9e7f1a93c554cca84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a4bf249feeb107af9e7f1a93c554cca84">enable_output</a> ()</td></tr>
<tr class="separator:a4bf249feeb107af9e7f1a93c554cca84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017cdef3c18d6050d401dab4f2f64d2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a017cdef3c18d6050d401dab4f2f64d2e">reset</a> ()</td></tr>
<tr class="separator:a017cdef3c18d6050d401dab4f2f64d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84f96493f79aa033eb828aac8ede66a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ae84f96493f79aa033eb828aac8ede66a">TimerOutput</a> (std::ostream &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> <a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> <a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a>)</td></tr>
<tr class="separator:ae84f96493f79aa033eb828aac8ede66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fbaf7e9d78f28c617553a21e3316f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#af8fbaf7e9d78f28c617553a21e3316f4">TimerOutput</a> (<a class="el" href="classConditionalOStream.html">ConditionalOStream</a> &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> <a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> <a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a>)</td></tr>
<tr class="separator:af8fbaf7e9d78f28c617553a21e3316f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aebd8141aa504f7dd4feb5dbb98e44b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a7aebd8141aa504f7dd4feb5dbb98e44b">TimerOutput</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;mpi_comm, std::ostream &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> <a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> <a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a>)</td></tr>
<tr class="separator:a7aebd8141aa504f7dd4feb5dbb98e44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c8f65a32e49e6b10fcc9d286264766"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a46c8f65a32e49e6b10fcc9d286264766">TimerOutput</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;mpi_comm, <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> <a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> <a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a>)</td></tr>
<tr class="separator:a46c8f65a32e49e6b10fcc9d286264766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf19f2a55900e34d6f588dbaf8cfbcc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#acf19f2a55900e34d6f588dbaf8cfbcc7">~TimerOutput</a> ()</td></tr>
<tr class="separator:acf19f2a55900e34d6f588dbaf8cfbcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae730ff220ae414208dc85e76920c3e45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;section_name)</td></tr>
<tr class="separator:ae730ff220ae414208dc85e76920c3e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d27dbc569819f3bbcb5e066e47212ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a4d27dbc569819f3bbcb5e066e47212ea">leave_subsection</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;section_name=&quot;&quot;)</td></tr>
<tr class="separator:a4d27dbc569819f3bbcb5e066e47212ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ec9503b41150a83636156728ee26df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; std::string, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ac4ec9503b41150a83636156728ee26df">get_summary_data</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8">OutputData</a> <a class="el" href="dof__tools__0_8txt.html#a5b35652d082b70bd89028e5c9fdab866">kind</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ac4ec9503b41150a83636156728ee26df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133e7d844826bc8716898fb2f86fb9b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a133e7d844826bc8716898fb2f86fb9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7673798226de7731e3ecdf7c0fb7568"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ae7673798226de7731e3ecdf7c0fb7568">print_wall_time_statistics</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;mpi_comm, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> print_quantile=0.) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ae7673798226de7731e3ecdf7c0fb7568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478c3fbca1d76c07eff9e7af8886dbb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a478c3fbca1d76c07eff9e7af8886dbb5">disable_output</a> ()</td></tr>
<tr class="separator:a478c3fbca1d76c07eff9e7af8886dbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf249feeb107af9e7f1a93c554cca84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a4bf249feeb107af9e7f1a93c554cca84">enable_output</a> ()</td></tr>
<tr class="separator:a4bf249feeb107af9e7f1a93c554cca84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017cdef3c18d6050d401dab4f2f64d2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a017cdef3c18d6050d401dab4f2f64d2e">reset</a> ()</td></tr>
<tr class="separator:a017cdef3c18d6050d401dab4f2f64d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84f96493f79aa033eb828aac8ede66a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ae84f96493f79aa033eb828aac8ede66a">TimerOutput</a> (std::ostream &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> <a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> <a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a>)</td></tr>
<tr class="separator:ae84f96493f79aa033eb828aac8ede66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fbaf7e9d78f28c617553a21e3316f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#af8fbaf7e9d78f28c617553a21e3316f4">TimerOutput</a> (<a class="el" href="classConditionalOStream.html">ConditionalOStream</a> &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> <a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> <a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a>)</td></tr>
<tr class="separator:af8fbaf7e9d78f28c617553a21e3316f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aebd8141aa504f7dd4feb5dbb98e44b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a7aebd8141aa504f7dd4feb5dbb98e44b">TimerOutput</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;mpi_comm, std::ostream &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> <a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> <a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a>)</td></tr>
<tr class="separator:a7aebd8141aa504f7dd4feb5dbb98e44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c8f65a32e49e6b10fcc9d286264766"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a46c8f65a32e49e6b10fcc9d286264766">TimerOutput</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;mpi_comm, <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> &amp;<a class="el" href="parsed__convergence__table__0_8txt.html#ac4cb6e971231aafc6d126e7d463b9680">stream</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> <a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a>, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> <a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a>)</td></tr>
<tr class="separator:a46c8f65a32e49e6b10fcc9d286264766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf19f2a55900e34d6f588dbaf8cfbcc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#acf19f2a55900e34d6f588dbaf8cfbcc7">~TimerOutput</a> ()</td></tr>
<tr class="separator:acf19f2a55900e34d6f588dbaf8cfbcc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae730ff220ae414208dc85e76920c3e45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">enter_subsection</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;section_name)</td></tr>
<tr class="separator:ae730ff220ae414208dc85e76920c3e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d27dbc569819f3bbcb5e066e47212ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a4d27dbc569819f3bbcb5e066e47212ea">leave_subsection</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;section_name=&quot;&quot;)</td></tr>
<tr class="separator:a4d27dbc569819f3bbcb5e066e47212ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ec9503b41150a83636156728ee26df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; std::string, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ac4ec9503b41150a83636156728ee26df">get_summary_data</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8">OutputData</a> <a class="el" href="dof__tools__0_8txt.html#a5b35652d082b70bd89028e5c9fdab866">kind</a>) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ac4ec9503b41150a83636156728ee26df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133e7d844826bc8716898fb2f86fb9b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary</a> () <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:a133e7d844826bc8716898fb2f86fb9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7673798226de7731e3ecdf7c0fb7568"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ae7673798226de7731e3ecdf7c0fb7568">print_wall_time_statistics</a> (<a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;mpi_comm, <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> print_quantile=0.) <a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a></td></tr>
<tr class="separator:ae7673798226de7731e3ecdf7c0fb7568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478c3fbca1d76c07eff9e7af8886dbb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a478c3fbca1d76c07eff9e7af8886dbb5">disable_output</a> ()</td></tr>
<tr class="separator:a478c3fbca1d76c07eff9e7af8886dbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf249feeb107af9e7f1a93c554cca84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a4bf249feeb107af9e7f1a93c554cca84">enable_output</a> ()</td></tr>
<tr class="separator:a4bf249feeb107af9e7f1a93c554cca84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017cdef3c18d6050d401dab4f2f64d2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a017cdef3c18d6050d401dab4f2f64d2e">reset</a> ()</td></tr>
<tr class="separator:a017cdef3c18d6050d401dab4f2f64d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3d19ce250ef329e652b64173e807dbdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a3d19ce250ef329e652b64173e807dbdd">output_frequency</a></td></tr>
<tr class="separator:a3d19ce250ef329e652b64173e807dbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7b62289e3037cb92f8871f68248d7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a4e7b62289e3037cb92f8871f68248d7e">output_type</a></td></tr>
<tr class="separator:a4e7b62289e3037cb92f8871f68248d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a982f0c74f0919f61383b17cfc9bcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTimer.html">Timer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ae3a982f0c74f0919f61383b17cfc9bcf">timer_all</a></td></tr>
<tr class="separator:ae3a982f0c74f0919f61383b17cfc9bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa181dcbd674e6278d60f2ae0b2f19122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; std::string, <a class="el" href="structTimerOutput_1_1Section.html">Section</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#aa181dcbd674e6278d60f2ae0b2f19122">sections</a></td></tr>
<tr class="separator:aa181dcbd674e6278d60f2ae0b2f19122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842bcbbb552ca5b4ee76b00936805724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classConditionalOStream.html">ConditionalOStream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a842bcbbb552ca5b4ee76b00936805724">out_stream</a></td></tr>
<tr class="separator:a842bcbbb552ca5b4ee76b00936805724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ffc02f056b4fbc49d288a665fc6db7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ac3ffc02f056b4fbc49d288a665fc6db7">output_is_enabled</a></td></tr>
<tr class="separator:ac3ffc02f056b4fbc49d288a665fc6db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22236ae9d091672861ac51fc7ee4a01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tria__objects__0_8txt.html#a98f82f403ed91139649aef16b25f739c">std::list</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#ac22236ae9d091672861ac51fc7ee4a01">active_sections</a></td></tr>
<tr class="separator:ac22236ae9d091672861ac51fc7ee4a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9b67a6573bfbe4a820a019d7c824e4"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a0e9b67a6573bfbe4a820a019d7c824e4">mpi_communicator</a></td></tr>
<tr class="separator:a0e9b67a6573bfbe4a820a019d7c824e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75493dc71630440ebc8e1b2ec1fb358c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreads_1_1Mutex.html">Threads::Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimerOutput.html#a75493dc71630440ebc8e1b2ec1fb358c">mutex</a></td></tr>
<tr class="separator:a75493dc71630440ebc8e1b2ec1fb358c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class can be used to generate formatted output from time measurements of different subsections in a program. It is possible to create several sections that perform certain aspects of the program. A section can be entered several times. By changing the options in OutputFrequency and OutputType, the user can choose whether output should be generated every time a section is joined or just in the end of the program. Moreover, it is possible to show CPU times, wall times, or both. The class is used in a substantial number of tutorial programs that collect timing data. <a class="el" href="step_77.html">step-77</a> is an example of a relatively simple sequential program that uses it. <a class="el" href="step_40.html">step-40</a> and several others mentioned below use it for parallel computations.</p>
<h3>Usage</h3>
<p>Use of this class could be as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a> timer (std::cout, <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6">TimerOutput::summary</a>,</div>
<div class="line">                   <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">TimerOutput::wall_times</a>);</div>
<div class="line"> </div>
<div class="line">timer.enter_subsection (<span class="stringliteral">&quot;Setup dof system&quot;</span>);</div>
<div class="line">setup_dofs();</div>
<div class="line">timer.leave_subsection();</div>
<div class="line"> </div>
<div class="line">timer.enter_subsection (<span class="stringliteral">&quot;Assemble&quot;</span>);</div>
<div class="line">assemble_system_1();</div>
<div class="line">timer.leave_subsection();</div>
<div class="line"> </div>
<div class="line">timer.enter_subsection (<span class="stringliteral">&quot;Solve&quot;</span>);</div>
<div class="line">solve_system_1();</div>
<div class="line">timer.leave_subsection();</div>
<div class="line"> </div>
<div class="line">timer.enter_subsection (<span class="stringliteral">&quot;Assemble&quot;</span>);</div>
<div class="line">assemble_system_2();</div>
<div class="line">timer.leave_subsection();</div>
<div class="line"> </div>
<div class="line">timer.enter_subsection (<span class="stringliteral">&quot;Solve&quot;</span>);</div>
<div class="line">solve_system_2();</div>
<div class="line">timer.leave_subsection();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// do something else...</span></div>
</div><!-- fragment --><p> When run, this program will return an output like this:</p>
<div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div>
<div class="line">| Total wallclock <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> elapsed <a class="code" href="grid_2manifold__0_8txt.html#a02d8bd1db3a4d0b6d68a99a931ce1b83">since</a> <a class="code" href="timer__0_8txt.html#a48e9e3a8116df3cc4b62db810904e91f">start</a>    |      88.8s |            |</div>
<div class="line">|                                             |            |            |</div>
<div class="line">| <a class="code" href="grid_2grid__refinement__0_8txt.html#a8bdcf8330609e043ba26a394139934f2">Section</a>                         | <a class="code" href="multithreading__0_8txt.html#a4c0a7149e1927066d2fcdb356cb90f7b">no</a>. <a class="code" href="iterators__0_8txt.html#a6365596c7d2490c474cd0b7ce9722b37">calls</a> |  wall <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> | % <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> total |</div>
<div class="line">+---------------------------------+-----------+------------+------------+</div>
<div class="line">| Assemble                        |         2 |      19.7s |        22% |</div>
<div class="line">| Solve                           |         2 |      3.03s |       3.4% |</div>
<div class="line">| Setup dof <a class="code" href="distributed__0_8txt.html#adeac996b7de9cb86911e504716172e83">system</a>                |         1 |      3.97s |       4.5% |</div>
<div class="line">+---------------------------------+-----------+------------+------------+</div>
</div><!-- fragment --><p> The output will see that we entered the assembly and solve section twice, and reports how much time we spent there. Moreover, the class measures the total time spent from start to termination of the <a class="el" href="classTimerOutput.html">TimerOutput</a> object. In this case, we did a lot of other stuff, so that the time proportions of the functions we measured are far away from 100 percent.</p>
<h3>Using scoped timers</h3>
<p>The scheme above where you have to have calls to <a class="el" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">TimerOutput::enter_subsection()</a> and <a class="el" href="classTimerOutput.html#a4d27dbc569819f3bbcb5e066e47212ea">TimerOutput::leave_subsection()</a> is awkward if the sections in between these calls contain <code>return</code> statements or may throw exceptions. In that case, it is easy to forget that one nevertheless needs to leave the section somehow, somewhere. An easier approach is to use "scoped" sections. This is a variable that when you create it enters a section, and leaves the section when you destroy it. If this is a variable local to a particular scope (a code block between curly braces) and you leave this scope due to a <code>return</code> statements or an exception, then the variable is destroyed and the timed section is left automatically. Consequently, we could have written the code piece above as follows, with exactly the same result but now exception-safe:</p>
<div class="fragment"><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a> timer (std::cout, <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6">TimerOutput::summary</a>,</div>
<div class="line">                   <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">TimerOutput::wall_times</a>);</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Setup dof system&quot;</span>);</div>
<div class="line">  setup_dofs();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Assemble&quot;</span>);</div>
<div class="line">  assemble_system_1();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div>
<div class="line">  solve_system_1();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Assemble&quot;</span>);</div>
<div class="line">  assemble_system_2();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div>
<div class="line">  solve_system_2();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// do something else...</span></div>
</div><!-- fragment --><h3>Usage in parallel programs using MPI</h3>
<p>In a parallel program built on MPI, using the class in a way such as the one shown above would result in a situation where each process times the corresponding sections and then outputs the resulting timing information at the end. This is annoying since you'd get a lot of output</p>
<ul>
<li>one set of timing information from each processor. This can be avoided by only letting one processor generate screen output, typically by using an object of type <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> instead of <code>std::cout</code> to write to screen (see, for example, <a class="el" href="step_17.html">step-17</a> , <a class="el" href="step_18.html">step-18</a> , <a class="el" href="step_32.html">step-32</a> and <a class="el" href="step_40.html">step-40</a> , all of which use this method). This way, only a single processor outputs timing information, typically the first process in the MPI universe. However, if you take the above code snippet as an example, imagine what would happen if <code>setup_dofs()</code> is fast on processor zero and slow on at least one of the other processors; and if the first thing <code>assemble_system_1()</code> does is something that requires all processors to communicate. In this case, on processor zero, the timing section with name <code>"Setup dof system"</code> will yield a short run time on processor zero, whereas the section <code> "Assemble"</code> will take a long time: not because <code>assemble_system_1()</code> takes a particularly long time, but because on the processor on which we time (or, rather, the one on which we generate output) happens to have to wait for a long time till the other processor is finally done with <code>setup_dofs()</code> and starts to participate in <code>assemble_system_1()</code> . In other words, the timing that is reported is unreliable because it reflects run times from other processors. Furthermore, the run time of this section on processor zero has nothing to do with the run time of the section on other processors but instead with the run time of <em>the previous section</em> on another processor. The first way to avoid this is to introduce a barrier into the parallel code just before we start and stop timing sections. This ensures that all processes are at the same place and the timing information then reflects the maximal run time across all processors. To achieve this, you need to initialize the <a class="el" href="classTimerOutput.html">TimerOutput</a> object with an MPI communicator object, for example as in the following code:</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a> timer (MPI_COMM_WORLD,</div>
<div class="line">                   pcout,</div>
<div class="line">                   <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6">TimerOutput::summary</a>,</div>
<div class="line">                   <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">TimerOutput::wall_times</a>);</div>
</div><!-- fragment --><p> Here, <code>pcout</code> is an object of type <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> that makes sure that we only generate output on a single processor. See the <a class="el" href="step_32.html">step-32</a> , <a class="el" href="step_40.html">step-40</a> , and <a class="el" href="step_42.html">step-42</a> tutorial programs for this kind of usage of this class. The second variant to cope with this issue is print more information about the recorded times to be able to understand this kind of imbalances without actually adding the barriers. While this approach is still affected by imbalances between different MPI processes, its output is not the arbitrary time of rank 0, but the minimum, average and maximum of the MPI results, using information from <a class="el" href="structUtilities_1_1MPI_1_1MinMaxAvg.html">Utilities::MPI::MinMaxAvg</a>. As the data is also equipped with the rank id where the minimum and maximum are attained, this approach allows to identify on which ranks certain slowdowns occur. In case some imbalance between the MPI ranks from one section to the next can be tolerated, this strategy can hence be advantageous over the barrier variant as it does not synchronize the program in places where it is not necessary, and rather tries to display the imbalance observed in various phases. In order to use this variant initialize the output object without any native print settings and without communicator,</p>
<div class="fragment"><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a> timer (pcout,</div>
<div class="line">                   <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a">TimerOutput::never</a>,</div>
<div class="line">                   <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">TimerOutput::wall_times</a>);</div>
</div><!-- fragment --><p> and then call</p>
<div class="fragment"><div class="line">timer.print_wall_time_statistics(MPI_COMM_WORLD);</div>
</div><!-- fragment --><p> where appropriate. Here, the output is written to the <code>pcout</code> object of type <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> passed to the constructor, making sure the information is only printed once. See <a class="el" href="step_67.html">step-67</a> for an example usage of this variant. Besides the basic minimum, average, and maximum of times over all MPI ranks, the <a class="el" href="classTimerOutput.html#ae7673798226de7731e3ecdf7c0fb7568">TimerOutput::print_wall_time_statistics()</a> function also takes a second argument to specify output of quantiles, e.g., the time taken by the 10% of the slowest and fastest ranks, respectively, to get additional insight into the statistical distribution.</p>
<p>This class can be used to generate formatted output from time measurements of different subsections in a program. It is possible to create several sections that perform certain aspects of the program. A section can be entered several times. By changing the options in OutputFrequency and OutputType, the user can choose whether output should be generated every time a section is joined or just in the end of the program. Moreover, it is possible to show CPU times, wall times, or both.</p>
<p>The class is used in a substantial number of tutorial programs that collect timing data. <a class="el" href="step_77.html">step-77</a> is an example of a relatively simple sequential program that uses it. <a class="el" href="step_40.html">step-40</a> and several others mentioned below use it for parallel computations.</p>
<h3>Usage</h3>
<p>Use of this class could be as follows: </p><div class="fragment"><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a> timer (std::cout, <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6">TimerOutput::summary</a>,</div>
<div class="line">                   <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">TimerOutput::wall_times</a>);</div>
<div class="line"> </div>
<div class="line">timer.enter_subsection (<span class="stringliteral">&quot;Setup dof system&quot;</span>);</div>
<div class="line">setup_dofs();</div>
<div class="line">timer.leave_subsection();</div>
<div class="line"> </div>
<div class="line">timer.enter_subsection (<span class="stringliteral">&quot;Assemble&quot;</span>);</div>
<div class="line">assemble_system_1();</div>
<div class="line">timer.leave_subsection();</div>
<div class="line"> </div>
<div class="line">timer.enter_subsection (<span class="stringliteral">&quot;Solve&quot;</span>);</div>
<div class="line">solve_system_1();</div>
<div class="line">timer.leave_subsection();</div>
<div class="line"> </div>
<div class="line">timer.enter_subsection (<span class="stringliteral">&quot;Assemble&quot;</span>);</div>
<div class="line">assemble_system_2();</div>
<div class="line">timer.leave_subsection();</div>
<div class="line"> </div>
<div class="line">timer.enter_subsection (<span class="stringliteral">&quot;Solve&quot;</span>);</div>
<div class="line">solve_system_2();</div>
<div class="line">timer.leave_subsection();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// do something else...</span></div>
</div><!-- fragment --><p> When run, this program will return an output like this: </p><div class="fragment"><div class="line">+---------------------------------------------+------------+------------+</div>
<div class="line">| Total wallclock <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> elapsed <a class="code" href="grid_2manifold__0_8txt.html#a02d8bd1db3a4d0b6d68a99a931ce1b83">since</a> <a class="code" href="timer__0_8txt.html#a48e9e3a8116df3cc4b62db810904e91f">start</a>    |      88.8s |            |</div>
<div class="line">|                                             |            |            |</div>
<div class="line">| <a class="code" href="grid_2grid__refinement__0_8txt.html#a8bdcf8330609e043ba26a394139934f2">Section</a>                         | <a class="code" href="multithreading__0_8txt.html#a4c0a7149e1927066d2fcdb356cb90f7b">no</a>. <a class="code" href="iterators__0_8txt.html#a6365596c7d2490c474cd0b7ce9722b37">calls</a> |  wall <a class="code" href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a> | % <a class="code" href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a> total |</div>
<div class="line">+---------------------------------+-----------+------------+------------+</div>
<div class="line">| Assemble                        |         2 |      19.7s |        22% |</div>
<div class="line">| Solve                           |         2 |      3.03s |       3.4% |</div>
<div class="line">| Setup dof <a class="code" href="distributed__0_8txt.html#adeac996b7de9cb86911e504716172e83">system</a>                |         1 |      3.97s |       4.5% |</div>
<div class="line">+---------------------------------+-----------+------------+------------+</div>
</div><!-- fragment --><p> The output will see that we entered the assembly and solve section twice, and reports how much time we spent there. Moreover, the class measures the total time spent from start to termination of the <a class="el" href="classTimerOutput.html">TimerOutput</a> object. In this case, we did a lot of other stuff, so that the time proportions of the functions we measured are far away from 100 percent.</p>
<h3>Using scoped timers</h3>
<p>The scheme above where you have to have calls to <a class="el" href="classTimerOutput.html#ae730ff220ae414208dc85e76920c3e45">TimerOutput::enter_subsection()</a> and <a class="el" href="classTimerOutput.html#a4d27dbc569819f3bbcb5e066e47212ea">TimerOutput::leave_subsection()</a> is awkward if the sections in between these calls contain <code>return</code> statements or may throw exceptions. In that case, it is easy to forget that one nevertheless needs to leave the section somehow, somewhere. An easier approach is to use "scoped" sections. This is a variable that when you create it enters a section, and leaves the section when you destroy it. If this is a variable local to a particular scope (a code block between curly braces) and you leave this scope due to a <code>return</code> statements or an exception, then the variable is destroyed and the timed section is left automatically. Consequently, we could have written the code piece above as follows, with exactly the same result but now exception-safe: </p><div class="fragment"><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a> timer (std::cout, <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6">TimerOutput::summary</a>,</div>
<div class="line">                   <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">TimerOutput::wall_times</a>);</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Setup dof system&quot;</span>);</div>
<div class="line">  setup_dofs();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Assemble&quot;</span>);</div>
<div class="line">  assemble_system_1();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div>
<div class="line">  solve_system_1();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Assemble&quot;</span>);</div>
<div class="line">  assemble_system_2();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">{</div>
<div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> timer_section(timer, <span class="stringliteral">&quot;Solve&quot;</span>);</div>
<div class="line">  solve_system_2();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// do something else...</span></div>
</div><!-- fragment --><h3>Usage in parallel programs using MPI</h3>
<p>In a parallel program built on MPI, using the class in a way such as the one shown above would result in a situation where each process times the corresponding sections and then outputs the resulting timing information at the end. This is annoying since you'd get a lot of output &ndash; one set of timing information from each processor.</p>
<p>This can be avoided by only letting one processor generate screen output, typically by using an object of type <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> instead of <code>std::cout</code> to write to screen (see, for example, <a class="el" href="step_17.html">step-17</a>, <a class="el" href="step_18.html">step-18</a>, <a class="el" href="step_32.html">step-32</a> and <a class="el" href="step_40.html">step-40</a>, all of which use this method).</p>
<p>This way, only a single processor outputs timing information, typically the first process in the MPI universe. However, if you take the above code snippet as an example, imagine what would happen if <code>setup_dofs()</code> is fast on processor zero and slow on at least one of the other processors; and if the first thing <code>assemble_system_1()</code> does is something that requires all processors to communicate. In this case, on processor zero, the timing section with name <code>"Setup dof system"</code> will yield a short run time on processor zero, whereas the section <code> "Assemble"</code> will take a long time: not because <code>assemble_system_1()</code> takes a particularly long time, but because on the processor on which we time (or, rather, the one on which we generate output) happens to have to wait for a long time till the other processor is finally done with <code>setup_dofs()</code> and starts to participate in <code>assemble_system_1()</code>. In other words, the timing that is reported is unreliable because it reflects run times from other processors. Furthermore, the run time of this section on processor zero has nothing to do with the run time of the section on other processors but instead with the run time of <em>the previous section</em> on another processor.</p>
<p>The first way to avoid this is to introduce a barrier into the parallel code just before we start and stop timing sections. This ensures that all processes are at the same place and the timing information then reflects the maximal run time across all processors. To achieve this, you need to initialize the <a class="el" href="classTimerOutput.html">TimerOutput</a> object with an MPI communicator object, for example as in the following code: </p><div class="fragment"><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a> timer (MPI_COMM_WORLD,</div>
<div class="line">                   pcout,</div>
<div class="line">                   <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6">TimerOutput::summary</a>,</div>
<div class="line">                   <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">TimerOutput::wall_times</a>);</div>
</div><!-- fragment --><p> Here, <code>pcout</code> is an object of type <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> that makes sure that we only generate output on a single processor. See the <a class="el" href="step_32.html">step-32</a>, <a class="el" href="step_40.html">step-40</a>, and <a class="el" href="step_42.html">step-42</a> tutorial programs for this kind of usage of this class.</p>
<p>The second variant to cope with this issue is print more information about the recorded times to be able to understand this kind of imbalances without actually adding the barriers. While this approach is still affected by imbalances between different MPI processes, its output is not the arbitrary time of rank 0, but the minimum, average and maximum of the MPI results, using information from <a class="el" href="structUtilities_1_1MPI_1_1MinMaxAvg.html">Utilities::MPI::MinMaxAvg</a>. As the data is also equipped with the rank id where the minimum and maximum are attained, this approach allows to identify on which ranks certain slowdowns occur. In case some imbalance between the MPI ranks from one section to the next can be tolerated, this strategy can hence be advantageous over the barrier variant as it does not synchronize the program in places where it is not necessary, and rather tries to display the imbalance observed in various phases. In order to use this variant initialize the output object without any native print settings and without communicator, </p><div class="fragment"><div class="line"><a class="code" href="classTimerOutput.html">TimerOutput</a> timer (pcout,</div>
<div class="line">                   <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a">TimerOutput::never</a>,</div>
<div class="line">                   <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">TimerOutput::wall_times</a>);</div>
</div><!-- fragment --><p> and then call </p><div class="fragment"><div class="line">timer.print_wall_time_statistics(MPI_COMM_WORLD);</div>
</div><!-- fragment --><p> where appropriate. Here, the output is written to the <code>pcout</code> object of type <a class="el" href="classConditionalOStream.html">ConditionalOStream</a> passed to the constructor, making sure the information is only printed once. See <a class="el" href="step_67.html">step-67</a> for an example usage of this variant. Besides the basic minimum, average, and maximum of times over all MPI ranks, the <a class="el" href="classTimerOutput.html#ae7673798226de7731e3ecdf7c0fb7568">TimerOutput::print_wall_time_statistics()</a> function also takes a second argument to specify output of quantiles, e.g., the time taken by the 10% of the slowest and fastest ranks, respectively, to get additional insight into the statistical distribution. </p>

<p class="definition">Definition at line <a class="el" href="base_2timer_8h_source.html#l00591">591</a> of file <a class="el" href="base_2timer_8h_source.html">timer.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a643d0e642b80048e91b37109fe9357cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643d0e642b80048e91b37109fe9357cb">&#9670;&nbsp;</a></span>OutputFrequency <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">TimerOutput::OutputFrequency</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enumeration data type that describes whether to generate output every time we exit a section, just in the end, both, or never. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3"></a>every_call&#160;</td><td class="fielddoc"><p>Generate output after every call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6"></a>summary&#160;</td><td class="fielddoc"><p>Generate output in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7"></a>every_call_and_summary&#160;</td><td class="fielddoc"><p>Generate output both after every call and in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a"></a>never&#160;</td><td class="fielddoc"><p>Never generate any output. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3"></a>every_call&#160;</td><td class="fielddoc"><p>Generate output after every call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6"></a>summary&#160;</td><td class="fielddoc"><p>Generate output in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7"></a>every_call_and_summary&#160;</td><td class="fielddoc"><p>Generate output both after every call and in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a"></a>never&#160;</td><td class="fielddoc"><p>Never generate any output. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3"></a>every_call&#160;</td><td class="fielddoc"><p>Generate output after every call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6"></a>summary&#160;</td><td class="fielddoc"><p>Generate output in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7"></a>every_call_and_summary&#160;</td><td class="fielddoc"><p>Generate output both after every call and in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a"></a>never&#160;</td><td class="fielddoc"><p>Never generate any output. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="base_2timer_8h_source.html#l00649">649</a> of file <a class="el" href="base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="aba3bc552db540d876d14e3c7870fe1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3bc552db540d876d14e3c7870fe1f8">&#9670;&nbsp;</a></span>OutputData <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8">TimerOutput::OutputData</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enumeration data type that describes the type of data to return when fetching the data from the timer. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511"></a>total_cpu_time&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be"></a>total_wall_time&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1"></a>n_calls&#160;</td><td class="fielddoc"><p>Output number of calls. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511"></a>total_cpu_time&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be"></a>total_wall_time&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1"></a>n_calls&#160;</td><td class="fielddoc"><p>Output number of calls. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511"></a>total_cpu_time&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be"></a>total_wall_time&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1"></a>n_calls&#160;</td><td class="fielddoc"><p>Output number of calls. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="base_2timer_8h_source.html#l00678">678</a> of file <a class="el" href="base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="a2405ae1b041a57d11a61a8cbfad3b487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2405ae1b041a57d11a61a8cbfad3b487">&#9670;&nbsp;</a></span>OutputType <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">TimerOutput::OutputType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enumeration data type that describes whether to show CPU times, wall times, or both CPU and wall times whenever we generate output. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc"></a>cpu_times&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad"></a>wall_times&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4"></a>cpu_and_wall_times&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in separate tables. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020"></a>cpu_and_wall_times_grouped&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in a single table. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc"></a>cpu_times&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad"></a>wall_times&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4"></a>cpu_and_wall_times&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in separate tables. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020"></a>cpu_and_wall_times_grouped&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in a single table. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc"></a>cpu_times&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad"></a>wall_times&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4"></a>cpu_and_wall_times&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in separate tables. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020"></a>cpu_and_wall_times_grouped&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in a single table. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="base_2timer_8h_source.html#l00702">702</a> of file <a class="el" href="base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="a643d0e642b80048e91b37109fe9357cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643d0e642b80048e91b37109fe9357cb">&#9670;&nbsp;</a></span>OutputFrequency <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">TimerOutput::OutputFrequency</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enumeration data type that describes whether to generate output every time we exit a section, just in the end, both, or never. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3"></a>every_call&#160;</td><td class="fielddoc"><p>Generate output after every call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6"></a>summary&#160;</td><td class="fielddoc"><p>Generate output in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7"></a>every_call_and_summary&#160;</td><td class="fielddoc"><p>Generate output both after every call and in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a"></a>never&#160;</td><td class="fielddoc"><p>Never generate any output. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3"></a>every_call&#160;</td><td class="fielddoc"><p>Generate output after every call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6"></a>summary&#160;</td><td class="fielddoc"><p>Generate output in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7"></a>every_call_and_summary&#160;</td><td class="fielddoc"><p>Generate output both after every call and in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a"></a>never&#160;</td><td class="fielddoc"><p>Never generate any output. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3"></a>every_call&#160;</td><td class="fielddoc"><p>Generate output after every call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6"></a>summary&#160;</td><td class="fielddoc"><p>Generate output in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7"></a>every_call_and_summary&#160;</td><td class="fielddoc"><p>Generate output both after every call and in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a"></a>never&#160;</td><td class="fielddoc"><p>Never generate any output. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="origin_2base_2timer_8h_source.html#l00600">600</a> of file <a class="el" href="origin_2base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="aba3bc552db540d876d14e3c7870fe1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3bc552db540d876d14e3c7870fe1f8">&#9670;&nbsp;</a></span>OutputData <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8">TimerOutput::OutputData</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enumeration data type that describes the type of data to return when fetching the data from the timer. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511"></a>total_cpu_time&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be"></a>total_wall_time&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1"></a>n_calls&#160;</td><td class="fielddoc"><p>Output number of calls. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511"></a>total_cpu_time&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be"></a>total_wall_time&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1"></a>n_calls&#160;</td><td class="fielddoc"><p>Output number of calls. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511"></a>total_cpu_time&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be"></a>total_wall_time&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1"></a>n_calls&#160;</td><td class="fielddoc"><p>Output number of calls. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="origin_2base_2timer_8h_source.html#l00624">624</a> of file <a class="el" href="origin_2base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="a2405ae1b041a57d11a61a8cbfad3b487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2405ae1b041a57d11a61a8cbfad3b487">&#9670;&nbsp;</a></span>OutputType <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">TimerOutput::OutputType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enumeration data type that describes whether to show CPU times, wall times, or both CPU and wall times whenever we generate output. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc"></a>cpu_times&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad"></a>wall_times&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4"></a>cpu_and_wall_times&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in separate tables. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020"></a>cpu_and_wall_times_grouped&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in a single table. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc"></a>cpu_times&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad"></a>wall_times&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4"></a>cpu_and_wall_times&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in separate tables. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020"></a>cpu_and_wall_times_grouped&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in a single table. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc"></a>cpu_times&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad"></a>wall_times&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4"></a>cpu_and_wall_times&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in separate tables. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020"></a>cpu_and_wall_times_grouped&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in a single table. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="origin_2base_2timer_8h_source.html#l00644">644</a> of file <a class="el" href="origin_2base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="a643d0e642b80048e91b37109fe9357cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a643d0e642b80048e91b37109fe9357cb">&#9670;&nbsp;</a></span>OutputFrequency <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">TimerOutput::OutputFrequency</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enumeration data type that describes whether to generate output every time we exit a section, just in the end, both, or never. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3"></a>every_call&#160;</td><td class="fielddoc"><p>Generate output after every call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6"></a>summary&#160;</td><td class="fielddoc"><p>Generate output in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7"></a>every_call_and_summary&#160;</td><td class="fielddoc"><p>Generate output both after every call and in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a"></a>never&#160;</td><td class="fielddoc"><p>Never generate any output. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3"></a>every_call&#160;</td><td class="fielddoc"><p>Generate output after every call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6"></a>summary&#160;</td><td class="fielddoc"><p>Generate output in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7"></a>every_call_and_summary&#160;</td><td class="fielddoc"><p>Generate output both after every call and in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a"></a>never&#160;</td><td class="fielddoc"><p>Never generate any output. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbad2707180b5cd5e82b3cfa751ffb8fea3"></a>every_call&#160;</td><td class="fielddoc"><p>Generate output after every call. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6"></a>summary&#160;</td><td class="fielddoc"><p>Generate output in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba95d2fecc0ba222b8e2b912e47033cfe7"></a>every_call_and_summary&#160;</td><td class="fielddoc"><p>Generate output both after every call and in summary at the end. </p>
</td></tr>
<tr><td class="fieldname"><a id="a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a"></a>never&#160;</td><td class="fielddoc"><p>Never generate any output. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="translator_2base_2timer_8h_source.html#l00649">649</a> of file <a class="el" href="translator_2base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="aba3bc552db540d876d14e3c7870fe1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3bc552db540d876d14e3c7870fe1f8">&#9670;&nbsp;</a></span>OutputData <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8">TimerOutput::OutputData</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enumeration data type that describes the type of data to return when fetching the data from the timer. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511"></a>total_cpu_time&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be"></a>total_wall_time&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1"></a>n_calls&#160;</td><td class="fielddoc"><p>Output number of calls. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511"></a>total_cpu_time&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be"></a>total_wall_time&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1"></a>n_calls&#160;</td><td class="fielddoc"><p>Output number of calls. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a344b9de8f99fdcbfc9ef2f51cee0e511"></a>total_cpu_time&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8ae805f901c48006f0e192a777de4889be"></a>total_wall_time&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba3bc552db540d876d14e3c7870fe1f8a81680d25f8d8627985497c08443ca2f1"></a>n_calls&#160;</td><td class="fielddoc"><p>Output number of calls. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="translator_2base_2timer_8h_source.html#l00678">678</a> of file <a class="el" href="translator_2base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="a2405ae1b041a57d11a61a8cbfad3b487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2405ae1b041a57d11a61a8cbfad3b487">&#9670;&nbsp;</a></span>OutputType <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="shared__tria__0_8txt.html#abcd3e97091f492496aa258c912ae135b">enum</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">TimerOutput::OutputType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enumeration data type that describes whether to show CPU times, wall times, or both CPU and wall times whenever we generate output. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc"></a>cpu_times&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad"></a>wall_times&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4"></a>cpu_and_wall_times&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in separate tables. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020"></a>cpu_and_wall_times_grouped&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in a single table. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc"></a>cpu_times&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad"></a>wall_times&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4"></a>cpu_and_wall_times&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in separate tables. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020"></a>cpu_and_wall_times_grouped&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in a single table. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a8c9c9bdf371949ce041e6b85fb52dffc"></a>cpu_times&#160;</td><td class="fielddoc"><p>Output CPU times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad"></a>wall_times&#160;</td><td class="fielddoc"><p>Output wall clock times. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a697388e47d12e69165042ebbf027a0e4"></a>cpu_and_wall_times&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in separate tables. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2405ae1b041a57d11a61a8cbfad3b487a3c123220d7a289914c7b5b840e5a3020"></a>cpu_and_wall_times_grouped&#160;</td><td class="fielddoc"><p>Output both CPU and wall clock times in a single table. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="translator_2base_2timer_8h_source.html#l00702">702</a> of file <a class="el" href="translator_2base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae84f96493f79aa033eb828aac8ede66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84f96493f79aa033eb828aac8ede66a">&#9670;&nbsp;</a></span>TimerOutput() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::TimerOutput </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td>
          <td class="paramname"><em>output_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream (of type std::ostream) to which output is written.</td></tr>
    <tr><td class="paramname">output_frequency</td><td>A variable indicating when output is to be written to the given stream.</td></tr>
    <tr><td class="paramname">output_type</td><td>A variable indicating what kind of timing the output should represent (CPU or wall time). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00301">301</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="af8fbaf7e9d78f28c617553a21e3316f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8fbaf7e9d78f28c617553a21e3316f4">&#9670;&nbsp;</a></span>TimerOutput() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::TimerOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConditionalOStream.html">ConditionalOStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td>
          <td class="paramname"><em>output_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream (of type ConditionalOstream) to which output is written.</td></tr>
    <tr><td class="paramname">output_frequency</td><td>A variable indicating when output is to be written to the given stream.</td></tr>
    <tr><td class="paramname">output_type</td><td>A variable indicating what kind of timing the output should represent (CPU or wall time). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00313">313</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="a7aebd8141aa504f7dd4feb5dbb98e44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aebd8141aa504f7dd4feb5dbb98e44b">&#9670;&nbsp;</a></span>TimerOutput() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::TimerOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td>
          <td class="paramname"><em>output_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor that takes an MPI communicator as input. A timer constructed this way will sum up the CPU times over all processors in the MPI network for calculating the CPU time, or take the maximum over all processors, depending on the value of <code>output_type</code> . See the documentation of this class for the rationale for this constructor and an example. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>An MPI communicator across which we should accumulate or otherwise synchronize the timing information we produce on every MPI process.</td></tr>
    <tr><td class="paramname">stream</td><td>The stream (of type std::ostream) to which output is written.</td></tr>
    <tr><td class="paramname">output_frequency</td><td>A variable indicating when output is to be written to the given stream.</td></tr>
    <tr><td class="paramname">output_type</td><td>A variable indicating what kind of timing the output should represent (CPU or wall time). In this parallel context, when this argument selects CPU time, then times are accumulated over all processes participating in the MPI communicator. If this argument selects wall time, then reported times are the maximum over all processors' run times for this section. (The latter is computed by placing an <code>MPI_Barrier</code> call before starting and stopping the timer for each section. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00325">325</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="a46c8f65a32e49e6b10fcc9d286264766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c8f65a32e49e6b10fcc9d286264766">&#9670;&nbsp;</a></span>TimerOutput() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::TimerOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConditionalOStream.html">ConditionalOStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td>
          <td class="paramname"><em>output_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor that takes an MPI communicator as input. A timer constructed this way will sum up the CPU times over all processors in the MPI network for calculating the CPU time, or take the maximum over all processors, depending on the value of <code>output_type</code> . See the documentation of this class for the rationale for this constructor and an example. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>An MPI communicator across which we should accumulate or otherwise synchronize the timing information we produce on every MPI process.</td></tr>
    <tr><td class="paramname">stream</td><td>The stream (of type ConditionalOstream) to which output is written.</td></tr>
    <tr><td class="paramname">output_frequency</td><td>A variable indicating when output is to be written to the given stream.</td></tr>
    <tr><td class="paramname">output_type</td><td>A variable indicating what kind of timing the output should represent (CPU or wall time). In this parallel context, when this argument selects CPU time, then times are accumulated over all processes participating in the MPI communicator. If this argument selects wall time, then reported times are the maximum over all processors' run times for this section. (The latter is computed by placing an <code>MPI_Barrier</code> call before starting and stopping the timer for each section.) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00338">338</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="acf19f2a55900e34d6f588dbaf8cfbcc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf19f2a55900e34d6f588dbaf8cfbcc7">&#9670;&nbsp;</a></span>~TimerOutput() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::~TimerOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. Calls <a class="el" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary()</a> in case the option for writing the summary output is set. </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00351">351</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="ae84f96493f79aa033eb828aac8ede66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84f96493f79aa033eb828aac8ede66a">&#9670;&nbsp;</a></span>TimerOutput() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::TimerOutput </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td>
          <td class="paramname"><em>output_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream (of type std::ostream) to which output is written. </td></tr>
    <tr><td class="paramname">output_frequency</td><td>A variable indicating when output is to be written to the given stream. </td></tr>
    <tr><td class="paramname">output_type</td><td>A variable indicating what kind of timing the output should represent (CPU or wall time). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8fbaf7e9d78f28c617553a21e3316f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8fbaf7e9d78f28c617553a21e3316f4">&#9670;&nbsp;</a></span>TimerOutput() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::TimerOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConditionalOStream.html">ConditionalOStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td>
          <td class="paramname"><em>output_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream (of type ConditionalOstream) to which output is written. </td></tr>
    <tr><td class="paramname">output_frequency</td><td>A variable indicating when output is to be written to the given stream. </td></tr>
    <tr><td class="paramname">output_type</td><td>A variable indicating what kind of timing the output should represent (CPU or wall time). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7aebd8141aa504f7dd4feb5dbb98e44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aebd8141aa504f7dd4feb5dbb98e44b">&#9670;&nbsp;</a></span>TimerOutput() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::TimerOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td>
          <td class="paramname"><em>output_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor that takes an MPI communicator as input. A timer constructed this way will sum up the CPU times over all processors in the MPI network for calculating the CPU time, or take the maximum over all processors, depending on the value of <code>output_type</code> . See the documentation of this class for the rationale for this constructor and an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>An MPI communicator across which we should accumulate or otherwise synchronize the timing information we produce on every MPI process. </td></tr>
    <tr><td class="paramname">stream</td><td>The stream (of type std::ostream) to which output is written. </td></tr>
    <tr><td class="paramname">output_frequency</td><td>A variable indicating when output is to be written to the given stream. </td></tr>
    <tr><td class="paramname">output_type</td><td>A variable indicating what kind of timing the output should represent (CPU or wall time). In this parallel context, when this argument selects CPU time, then times are accumulated over all processes participating in the MPI communicator. If this argument selects wall time, then reported times are the maximum over all processors' run times for this section. (The latter is computed by placing an <code>MPI_Barrier</code> call before starting and stopping the timer for each section. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46c8f65a32e49e6b10fcc9d286264766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c8f65a32e49e6b10fcc9d286264766">&#9670;&nbsp;</a></span>TimerOutput() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::TimerOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConditionalOStream.html">ConditionalOStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td>
          <td class="paramname"><em>output_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor that takes an MPI communicator as input. A timer constructed this way will sum up the CPU times over all processors in the MPI network for calculating the CPU time, or take the maximum over all processors, depending on the value of <code>output_type</code> . See the documentation of this class for the rationale for this constructor and an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>An MPI communicator across which we should accumulate or otherwise synchronize the timing information we produce on every MPI process. </td></tr>
    <tr><td class="paramname">stream</td><td>The stream (of type ConditionalOstream) to which output is written. </td></tr>
    <tr><td class="paramname">output_frequency</td><td>A variable indicating when output is to be written to the given stream. </td></tr>
    <tr><td class="paramname">output_type</td><td>A variable indicating what kind of timing the output should represent (CPU or wall time). In this parallel context, when this argument selects CPU time, then times are accumulated over all processes participating in the MPI communicator. If this argument selects wall time, then reported times are the maximum over all processors' run times for this section. (The latter is computed by placing an <code>MPI_Barrier</code> call before starting and stopping the timer for each section.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf19f2a55900e34d6f588dbaf8cfbcc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf19f2a55900e34d6f588dbaf8cfbcc7">&#9670;&nbsp;</a></span>~TimerOutput() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::~TimerOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. Calls <a class="el" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary()</a> in case the option for writing the summary output is set. </p>

</div>
</div>
<a id="ae84f96493f79aa033eb828aac8ede66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84f96493f79aa033eb828aac8ede66a">&#9670;&nbsp;</a></span>TimerOutput() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::TimerOutput </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td>
          <td class="paramname"><em>output_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream (of type std::ostream) to which output is written.</td></tr>
    <tr><td class="paramname">output_frequency</td><td>A variable indicating when output is to be written to the given stream.</td></tr>
    <tr><td class="paramname">output_type</td><td>A variable indicating what kind of timing the output should represent (CPU or wall time). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8fbaf7e9d78f28c617553a21e3316f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8fbaf7e9d78f28c617553a21e3316f4">&#9670;&nbsp;</a></span>TimerOutput() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::TimerOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classConditionalOStream.html">ConditionalOStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td>
          <td class="paramname"><em>output_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor.</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream (of type ConditionalOstream) to which output is written.</td></tr>
    <tr><td class="paramname">output_frequency</td><td>A variable indicating when output is to be written to the given stream.</td></tr>
    <tr><td class="paramname">output_type</td><td>A variable indicating what kind of timing the output should represent (CPU or wall time). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7aebd8141aa504f7dd4feb5dbb98e44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aebd8141aa504f7dd4feb5dbb98e44b">&#9670;&nbsp;</a></span>TimerOutput() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::TimerOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td>
          <td class="paramname"><em>output_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor that takes an MPI communicator as input. A timer constructed this way will sum up the CPU times over all processors in the MPI network for calculating the CPU time, or take the maximum over all processors, depending on the value of <code>output_type</code> . See the documentation of this class for the rationale for this constructor and an example. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>An MPI communicator across which we should accumulate or otherwise synchronize the timing information we produce on every MPI process.</td></tr>
    <tr><td class="paramname">stream</td><td>The stream (of type std::ostream) to which output is written.</td></tr>
    <tr><td class="paramname">output_frequency</td><td>A variable indicating when output is to be written to the given stream.</td></tr>
    <tr><td class="paramname">output_type</td><td>A variable indicating what kind of timing the output should represent (CPU or wall time). In this parallel context, when this argument selects CPU time, then times are accumulated over all processes participating in the MPI communicator. If this argument selects wall time, then reported times are the maximum over all processors' run times for this section. (The latter is computed by placing an <code>MPI_Barrier</code> call before starting and stopping the timer for each section. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46c8f65a32e49e6b10fcc9d286264766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c8f65a32e49e6b10fcc9d286264766">&#9670;&nbsp;</a></span>TimerOutput() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::TimerOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classConditionalOStream.html">ConditionalOStream</a> &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a>&#160;</td>
          <td class="paramname"><em>output_frequency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a>&#160;</td>
          <td class="paramname"><em>output_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor that takes an MPI communicator as input. A timer constructed this way will sum up the CPU times over all processors in the MPI network for calculating the CPU time, or take the maximum over all processors, depending on the value of <code>output_type</code> . See the documentation of this class for the rationale for this constructor and an example. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>An MPI communicator across which we should accumulate or otherwise synchronize the timing information we produce on every MPI process.</td></tr>
    <tr><td class="paramname">stream</td><td>The stream (of type ConditionalOstream) to which output is written.</td></tr>
    <tr><td class="paramname">output_frequency</td><td>A variable indicating when output is to be written to the given stream.</td></tr>
    <tr><td class="paramname">output_type</td><td>A variable indicating what kind of timing the output should represent (CPU or wall time). In this parallel context, when this argument selects CPU time, then times are accumulated over all processes participating in the MPI communicator. If this argument selects wall time, then reported times are the maximum over all processors' run times for this section. (The latter is computed by placing an <code>MPI_Barrier</code> call before starting and stopping the timer for each section.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf19f2a55900e34d6f588dbaf8cfbcc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf19f2a55900e34d6f588dbaf8cfbcc7">&#9670;&nbsp;</a></span>~TimerOutput() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimerOutput::~TimerOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. Calls <a class="el" href="classTimerOutput.html#a133e7d844826bc8716898fb2f86fb9b6">print_summary()</a> in case the option for writing the summary output is set. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae730ff220ae414208dc85e76920c3e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae730ff220ae414208dc85e76920c3e45">&#9670;&nbsp;</a></span>enter_subsection() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::enter_subsection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>section_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a section by given a string name of it. In case the name already exists, that section is entered once again and times are accumulated. </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00403">403</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="a4d27dbc569819f3bbcb5e066e47212ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d27dbc569819f3bbcb5e066e47212ea">&#9670;&nbsp;</a></span>leave_subsection() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::leave_subsection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>section_name</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Leave a section. If no name is given, the last section that was entered is left. </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00445">445</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="ac37aba48e5fabc984b5d1b169b58991d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37aba48e5fabc984b5d1b169b58991d">&#9670;&nbsp;</a></span>get_summary_data() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; std::string, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a> &gt; TimerOutput::get_summary_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8">OutputData</a>&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a map with the collected data of the specified type for each subsection </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00509">509</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="a133e7d844826bc8716898fb2f86fb9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133e7d844826bc8716898fb2f86fb9b6">&#9670;&nbsp;</a></span>print_summary() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::print_summary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a formatted table that summarizes the time consumed in the various sections. </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00535">535</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="ae7673798226de7731e3ecdf7c0fb7568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7673798226de7731e3ecdf7c0fb7568">&#9670;&nbsp;</a></span>print_wall_time_statistics() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::print_wall_time_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>print_quantile</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a formatted table that summarizes the wall time consumed in the various sections, using statistics in terms of the minimum, average, and maximum of times in the various sections and the MPI ranks where the minimum and maximum are attained. Note that this call only provides useful information when the <a class="el" href="classTimerOutput.html">TimerOutput</a> object is constructed without an MPI_Comm argument, to let individual sections run without being disturbed by barriers. The optional argument <code>quantile</code> allows to add two additional columns to the output in terms of the distribution of run times. If quantile = 0.1, the value and rank of the 10% lowest data is printed as well as the value and rank at 90% of the distribution function, in addition to the minimum and the maximum. The value of <code>quantile</code> needs to be between 0 (no quantiles are printed besides the minimum and maximum) and 0.5 (when the median is given). </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l00844">844</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="a478c3fbca1d76c07eff9e7af8886dbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478c3fbca1d76c07eff9e7af8886dbb5">&#9670;&nbsp;</a></span>disable_output() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::disable_output </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By calling this function, all output can be disabled. This function together with <a class="el" href="classTimerOutput.html#a4bf249feeb107af9e7f1a93c554cca84">enable_output()</a> can be useful if one wants to control the output in a flexible way without putting a lot of <code>if</code> clauses in the program. </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l01023">1023</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="a4bf249feeb107af9e7f1a93c554cca84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf249feeb107af9e7f1a93c554cca84">&#9670;&nbsp;</a></span>enable_output() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::enable_output </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function re-enables output of this class if it was previously disabled with <a class="el" href="classTimerOutput.html#a478c3fbca1d76c07eff9e7af8886dbb5">disable_output()</a>. This function together with <a class="el" href="classTimerOutput.html#a478c3fbca1d76c07eff9e7af8886dbb5">disable_output()</a> can be useful if one wants to control the output in a flexible way without putting a lot of <code>if</code> clauses in the program. </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l01031">1031</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="a017cdef3c18d6050d401dab4f2f64d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017cdef3c18d6050d401dab4f2f64d2e">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the recorded timing information. </p>

<p class="definition">Definition at line <a class="el" href="timer_8cc_source.html#l01037">1037</a> of file <a class="el" href="timer_8cc_source.html">timer.cc</a>.</p>

</div>
</div>
<a id="ae730ff220ae414208dc85e76920c3e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae730ff220ae414208dc85e76920c3e45">&#9670;&nbsp;</a></span>enter_subsection() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::enter_subsection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>section_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a section by given a string name of it. In case the name already exists, that section is entered once again and times are accumulated. </p>

</div>
</div>
<a id="a4d27dbc569819f3bbcb5e066e47212ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d27dbc569819f3bbcb5e066e47212ea">&#9670;&nbsp;</a></span>leave_subsection() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::leave_subsection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>section_name</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Leave a section. If no name is given, the last section that was entered is left. </p>

</div>
</div>
<a id="ac4ec9503b41150a83636156728ee26df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ec9503b41150a83636156728ee26df">&#9670;&nbsp;</a></span>get_summary_data() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt;std::string, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&gt; TimerOutput::get_summary_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8">OutputData</a>&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a map with the collected data of the specified type for each subsection </p>

</div>
</div>
<a id="a133e7d844826bc8716898fb2f86fb9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133e7d844826bc8716898fb2f86fb9b6">&#9670;&nbsp;</a></span>print_summary() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::print_summary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a formatted table that summarizes the time consumed in the various sections. </p>

</div>
</div>
<a id="ae7673798226de7731e3ecdf7c0fb7568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7673798226de7731e3ecdf7c0fb7568">&#9670;&nbsp;</a></span>print_wall_time_statistics() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::print_wall_time_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>print_quantile</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a formatted table that summarizes the wall time consumed in the various sections, using statistics in terms of the minimum, average, and maximum of times in the various sections and the MPI ranks where the minimum and maximum are attained. Note that this call only provides useful information when the <a class="el" href="classTimerOutput.html">TimerOutput</a> object is constructed without an MPI_Comm argument, to let individual sections run without being disturbed by barriers.</p>
<p>The optional argument <code>quantile</code> allows to add two additional columns to the output in terms of the distribution of run times. If quantile = 0.1, the value and rank of the 10% lowest data is printed as well as the value and rank at 90% of the distribution function, in addition to the minimum and the maximum. The value of <code>quantile</code> needs to be between 0 (no quantiles are printed besides the minimum and maximum) and 0.5 (when the median is given). </p>

</div>
</div>
<a id="a478c3fbca1d76c07eff9e7af8886dbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478c3fbca1d76c07eff9e7af8886dbb5">&#9670;&nbsp;</a></span>disable_output() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::disable_output </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By calling this function, all output can be disabled. This function together with <a class="el" href="classTimerOutput.html#a4bf249feeb107af9e7f1a93c554cca84">enable_output()</a> can be useful if one wants to control the output in a flexible way without putting a lot of <code>if</code> clauses in the program. </p>

</div>
</div>
<a id="a4bf249feeb107af9e7f1a93c554cca84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf249feeb107af9e7f1a93c554cca84">&#9670;&nbsp;</a></span>enable_output() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::enable_output </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function re-enables output of this class if it was previously disabled with <a class="el" href="classTimerOutput.html#a478c3fbca1d76c07eff9e7af8886dbb5">disable_output()</a>. This function together with <a class="el" href="classTimerOutput.html#a478c3fbca1d76c07eff9e7af8886dbb5">disable_output()</a> can be useful if one wants to control the output in a flexible way without putting a lot of <code>if</code> clauses in the program. </p>

</div>
</div>
<a id="a017cdef3c18d6050d401dab4f2f64d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017cdef3c18d6050d401dab4f2f64d2e">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the recorded timing information. </p>

</div>
</div>
<a id="ae730ff220ae414208dc85e76920c3e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae730ff220ae414208dc85e76920c3e45">&#9670;&nbsp;</a></span>enter_subsection() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::enter_subsection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>section_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a section by given a string name of it. In case the name already exists, that section is entered once again and times are accumulated. </p>

</div>
</div>
<a id="a4d27dbc569819f3bbcb5e066e47212ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d27dbc569819f3bbcb5e066e47212ea">&#9670;&nbsp;</a></span>leave_subsection() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::leave_subsection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>section_name</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Leave a section. If no name is given, the last section that was entered is left. </p>

</div>
</div>
<a id="ac4ec9503b41150a83636156728ee26df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ec9503b41150a83636156728ee26df">&#9670;&nbsp;</a></span>get_summary_data() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt;std::string, <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&gt; TimerOutput::get_summary_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="classTimerOutput.html#aba3bc552db540d876d14e3c7870fe1f8">OutputData</a>&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a map with the collected data of the specified type for each subsection </p>

</div>
</div>
<a id="a133e7d844826bc8716898fb2f86fb9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133e7d844826bc8716898fb2f86fb9b6">&#9670;&nbsp;</a></span>print_summary() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::print_summary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a formatted table that summarizes the time consumed in the various sections. </p>

</div>
</div>
<a id="ae7673798226de7731e3ecdf7c0fb7568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7673798226de7731e3ecdf7c0fb7568">&#9670;&nbsp;</a></span>print_wall_time_statistics() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::print_wall_time_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> MPI_Comm &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="coding__conventions__0_8txt.html#ad54c4de985d6d1b46aaf6ae96ae8d3a1">const</a> <a class="el" href="data__out__base__0_8txt.html#ac4cda81e9f07624b451614e55da075bf">double</a>&#160;</td>
          <td class="paramname"><em>print_quantile</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a formatted table that summarizes the wall time consumed in the various sections, using statistics in terms of the minimum, average, and maximum of times in the various sections and the MPI ranks where the minimum and maximum are attained. Note that this call only provides useful information when the <a class="el" href="classTimerOutput.html">TimerOutput</a> object is constructed without an MPI_Comm argument, to let individual sections run without being disturbed by barriers. The optional argument <code>quantile</code> allows to add two additional columns to the output in terms of the distribution of run times. If quantile = 0.1, the value and rank of the 10% lowest data is printed as well as the value and rank at 90% of the distribution function, in addition to the minimum and the maximum. The value of <code>quantile</code> needs to be between 0 (no quantiles are printed besides the minimum and maximum) and 0.5 (when the median is given). </p>

</div>
</div>
<a id="a478c3fbca1d76c07eff9e7af8886dbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478c3fbca1d76c07eff9e7af8886dbb5">&#9670;&nbsp;</a></span>disable_output() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::disable_output </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>By calling this function, all output can be disabled. This function together with <a class="el" href="classTimerOutput.html#a4bf249feeb107af9e7f1a93c554cca84">enable_output()</a> can be useful if one wants to control the output in a flexible way without putting a lot of <code>if</code> clauses in the program. </p>

</div>
</div>
<a id="a4bf249feeb107af9e7f1a93c554cca84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf249feeb107af9e7f1a93c554cca84">&#9670;&nbsp;</a></span>enable_output() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::enable_output </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function re-enables output of this class if it was previously disabled with <a class="el" href="classTimerOutput.html#a478c3fbca1d76c07eff9e7af8886dbb5">disable_output()</a>. This function together with <a class="el" href="classTimerOutput.html#a478c3fbca1d76c07eff9e7af8886dbb5">disable_output()</a> can be useful if one wants to control the output in a flexible way without putting a lot of <code>if</code> clauses in the program. </p>

</div>
</div>
<a id="a017cdef3c18d6050d401dab4f2f64d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017cdef3c18d6050d401dab4f2f64d2e">&#9670;&nbsp;</a></span>reset() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimerOutput::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the recorded timing information. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3d19ce250ef329e652b64173e807dbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d19ce250ef329e652b64173e807dbdd">&#9670;&nbsp;</a></span>output_frequency</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cb">OutputFrequency</a> TimerOutput::output_frequency</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When to output information to the output stream. </p>

<p class="definition">Definition at line <a class="el" href="base_2timer_8h_source.html#l00893">893</a> of file <a class="el" href="base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="a4e7b62289e3037cb92f8871f68248d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7b62289e3037cb92f8871f68248d7e">&#9670;&nbsp;</a></span>output_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487">OutputType</a> TimerOutput::output_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to show CPU times, wall times, or both CPU and wall times. </p>

<p class="definition">Definition at line <a class="el" href="base_2timer_8h_source.html#l00899">899</a> of file <a class="el" href="base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="ae3a982f0c74f0919f61383b17cfc9bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a982f0c74f0919f61383b17cfc9bcf">&#9670;&nbsp;</a></span>timer_all</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTimer.html">Timer</a> TimerOutput::timer_all</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A timer object for the overall run time. If we are using MPI, this timer also accumulates over all MPI processes. </p>

<p class="definition">Definition at line <a class="el" href="base_2timer_8h_source.html#l00907">907</a> of file <a class="el" href="base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="aa181dcbd674e6278d60f2ae0b2f19122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa181dcbd674e6278d60f2ae0b2f19122">&#9670;&nbsp;</a></span>sections</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vector__tools__boundary__0_8txt.html#a58193f617a635b1dcbe36c1cc04cc810">std::map</a>&lt; std::string, <a class="el" href="structTimerOutput_1_1Section.html">Section</a> &gt; TimerOutput::sections</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A list of all the sections and their information. </p>

<p class="definition">Definition at line <a class="el" href="base_2timer_8h_source.html#l00926">926</a> of file <a class="el" href="base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="a842bcbbb552ca5b4ee76b00936805724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842bcbbb552ca5b4ee76b00936805724">&#9670;&nbsp;</a></span>out_stream</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classConditionalOStream.html">ConditionalOStream</a> TimerOutput::out_stream</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The stream object to which we are to output. </p>

<p class="definition">Definition at line <a class="el" href="base_2timer_8h_source.html#l00932">932</a> of file <a class="el" href="base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="ac3ffc02f056b4fbc49d288a665fc6db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ffc02f056b4fbc49d288a665fc6db7">&#9670;&nbsp;</a></span>output_is_enabled</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hdf5__0_8txt.html#ab2d1d1742a4bbf5eb3519d1b615183fe">bool</a> TimerOutput::output_is_enabled</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A boolean variable that sets whether output of this class is currently on or off. </p>

<p class="definition">Definition at line <a class="el" href="base_2timer_8h_source.html#l00939">939</a> of file <a class="el" href="base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="ac22236ae9d091672861ac51fc7ee4a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22236ae9d091672861ac51fc7ee4a01">&#9670;&nbsp;</a></span>active_sections</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tria__objects__0_8txt.html#a98f82f403ed91139649aef16b25f739c">std::list</a>&lt; std::string &gt; TimerOutput::active_sections</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A list of the sections that have been entered and not exited. The list is kept in the order in which sections have been entered, but elements may be removed in the middle if an argument is given to the <a class="el" href="classTimerOutput.html#a4d27dbc569819f3bbcb5e066e47212ea">leave_subsection()</a> function. </p>

<p class="definition">Definition at line <a class="el" href="base_2timer_8h_source.html#l00948">948</a> of file <a class="el" href="base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="a0e9b67a6573bfbe4a820a019d7c824e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9b67a6573bfbe4a820a019d7c824e4">&#9670;&nbsp;</a></span>mpi_communicator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm TimerOutput::mpi_communicator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>mpi communicator </p>

<p class="definition">Definition at line <a class="el" href="base_2timer_8h_source.html#l00954">954</a> of file <a class="el" href="base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<a id="a75493dc71630440ebc8e1b2ec1fb358c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75493dc71630440ebc8e1b2ec1fb358c">&#9670;&nbsp;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreads_1_1Mutex.html">Threads::Mutex</a> TimerOutput::mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A lock that makes sure that this class gives reasonable results even when used with several threads. </p>

<p class="definition">Definition at line <a class="el" href="base_2timer_8h_source.html#l00961">961</a> of file <a class="el" href="base_2timer_8h_source.html">timer.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="base_2timer_8h_source.html">timer.h</a></li>
<li>source/base/<a class="el" href="timer_8cc_source.html">timer.cc</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="adistributed__0_8txt_html_adeac996b7de9cb86911e504716172e83"><div class="ttname"><a href="distributed__0_8txt.html#adeac996b7de9cb86911e504716172e83">system</a></div><div class="ttdeci">if we even only hold bytes per line in this sparsity we ll need GB for this object even if every single line is empty Of only million lines will be non for which we need MB plus whatever is necessary to store the actual column indices of nonzero entries Let s say we have a moderately complex problem with entries per for each of which we store the column index worth then we ll need bytes for each of the million lines that correspond to the degrees of freedom we for a total of GB And we ll need bytes for each of the million lines that we don t for a total of GB It is clear that this ratio doesn t become any better if we go to even higher numbers of processors *The solution to this problem is to really only use any memory at all for those parts of the linear system that we or need for some other reason For all other we must know that they but we can not set up any part of our data structure To this there exists a class called IndexSet that denotes a set of indices which we care for and for which we may have to allocate memory The data structures for sparsity patterns constraint matrices matrices and vector can be initialized with these IndexSet objects to really only care for those rows or entries that correspond to indices in the index set and not care about all others These objects will then ask how many indices exist in the set allocate memory for each one of and when you want to access data for global degree of freedom[2.x.28] you will be redirected to the result of calling[2.x.29] with index[2.x.30] instead Accessing data for elements[2.x.31] for which[2.x.32] is false will yield an error *The remaining question is how to identify the set of indices that correspond to degrees of freedom we need to worry about on each processor To this you can use the[2.x.33] function to get at all the indices a processor owns Note that this is a subset of the degrees of freedom that are defined on the locally owned one sometimes needs the set of all degrees of freedom on the locally owned subdomain as well as the adjacent ghost cells This information is provided by the[2.x.35] function ***A typical parallel application is dealing with two different kinds of parallel but there are of course different vector types that can each represent both ghosted vectors are typically used for data error input in integration This is because in these one typically needs access not only to[2.x.39] locally owned dofs but also to[2.x.40] locally active dofs and sometimes to[2.x.41] locally relevant and their values may not be stored in non ghosted vectors on the processor that needs them The operations listed above also only require read only access to and ghosted vectors are therefore usable in these contexts *On the other vectors without ghost entries are used in all other places like or any other form of manipulation These are typically write only operations and therefore need not have read access to vector elements that may be owned by another processor *You can copy between vectors with and without ghost the only class equipped to deal with the situation just explained is DynamicSparsityPattern A version of the function[2.x.45] exists that takes an IndexSet argument that indicates which lines of the sparsity pattern to allocate memory for In other it is safe to create such an object that will report as its size but in fact only stores only as many rows as the index set has elements You can then use the usual function[2.x.46] to build the sparsity pattern that results from assembling on the locally owned portion of the mesh The resulting object can be used to initialize a PETSc or Trilinos matrix which support very large object sizes through completely distributed storage The matrix can then be assembled by only looping over those cells owned by the current processor *The only thing to pay attention to is for which degrees of freedom the sparsity needs to store entries These in the ones we could possibly store values to in the matrix upon assembly It is clear that these are certainly the locally active degrees of it may also be possible to write to entries that are located on ghost cells you need to pass the index set that results from[2.x.47] upon initializing the sparsity pattern ***When creating the sparsity pattern as well as when assembling the linear system</div><div class="ttdef"><b>Definition:</b> <a href="distributed__0_8txt_source.html#l00070">distributed_0.txt:70</a></div></div>
<div class="ttc" id="aclassTimerOutput_html_a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6"><div class="ttname"><a href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cbac9d648a492b7d96ffca317ba0ada51b6">TimerOutput::summary</a></div><div class="ttdeci">@ summary</div><div class="ttdef"><b>Definition:</b> <a href="base_2timer_8h_source.html#l00660">timer.h:660</a></div></div>
<div class="ttc" id="aclassTimerOutput_1_1Scope_html"><div class="ttname"><a href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2timer_8h_source.html#l00600">timer.h:600</a></div></div>
<div class="ttc" id="aclassTimerOutput_html"><div class="ttname"><a href="classTimerOutput.html">TimerOutput</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2timer_8h_source.html#l00591">timer.h:591</a></div></div>
<div class="ttc" id="amultithreading__0_8txt_html_a33468e75b7ea6d2e64b7e88c6ff1217a"><div class="ttname"><a href="multithreading__0_8txt.html#a33468e75b7ea6d2e64b7e88c6ff1217a">of</a></div><div class="ttdeci">namespace are implemented the way they are More information on their implementation can be found in the[2.x.72] WorkStream paper To see the WorkStream class used in practice on tasks like the ones outlined above take a look at or[2.x.78] tutorial programs *To begin given the brief description the way the[2.x.79] function could then be written is like this(note that this is not quite the correct syntax, as will be described below) we recycle these objects after they have been used by[2.x.101] and feed them back into another instance of[2.x.102]</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00171">multithreading_0.txt:171</a></div></div>
<div class="ttc" id="aclassTimerOutput_html_a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad"><div class="ttname"><a href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487a07ac48d7ae3c2cf00959ebb3c4ed93ad">TimerOutput::wall_times</a></div><div class="ttdeci">@ wall_times</div><div class="ttdef"><b>Definition:</b> <a href="base_2timer_8h_source.html#l00713">timer.h:713</a></div></div>
<div class="ttc" id="aautomatic__and__symbolic__differentiation__0_8txt_html_a96ecfde131843f52ee49d0e0c1180134"><div class="ttname"><a href="automatic__and__symbolic__differentiation__0_8txt.html#a96ecfde131843f52ee49d0e0c1180134">time</a></div><div class="ttdeci">computing derivatives of these terms is impractical in most applications in impossible to get right Higher derivatives are even more impossible to do without computer aid Automatic or symbolic differentiation is a way out of and gets compile time</div><div class="ttdef"><b>Definition:</b> <a href="automatic__and__symbolic__differentiation__0_8txt_source.html#l00012">automatic_and_symbolic_differentiation_0.txt:12</a></div></div>
<div class="ttc" id="aclassTimerOutput_html_a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a"><div class="ttname"><a href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6c93cc1f85eb6830263a845676f3cf4a">TimerOutput::never</a></div><div class="ttdeci">@ never</div><div class="ttdef"><b>Definition:</b> <a href="base_2timer_8h_source.html#l00670">timer.h:670</a></div></div>
<div class="ttc" id="aiterators__0_8txt_html_a6365596c7d2490c474cd0b7ce9722b37"><div class="ttname"><a href="iterators__0_8txt.html#a6365596c7d2490c474cd0b7ce9722b37">calls</a></div><div class="ttdeci">it does so for both DoFHandler and[2.x.14] objects Note that the DoFAccessor class is derived from either TriaAccessor or the DoFAccessor class comes in two flavors one accessing degrees of freedom on the level of a cell and the other accessing the active dofs of an active cell **The DoFCellAccessor class has the same purpose and relation to DoFCellAccessor as the CellAccessor has to TriaAccessor *Except to look up member you will not usually have to deal withthe actual class names listed above Rather one uses the typedefs provided bythe mesh classes Triangulation DoFHandler and[2.x.15] as wellas the function that generate such buta hexahedron there are corresponding types and calls like[2.x.34] that act on thedimension independent geometric objects and hex These calls</div><div class="ttdef"><b>Definition:</b> <a href="iterators__0_8txt_source.html#l00076">iterators_0.txt:76</a></div></div>
<div class="ttc" id="atimer__0_8txt_html_a48e9e3a8116df3cc4b62db810904e91f"><div class="ttname"><a href="timer__0_8txt.html#a48e9e3a8116df3cc4b62db810904e91f">start</a></div><div class="ttdeci">*A compatible with the[2.x.0] notion of a whose by in multiples of of a second and POSIX uses so go with microseconds for uniformity **Signed integral type used to store the value returned by this requires platform specific so this function returns on platforms that are neither Windows nor POSIX **The Timer class provides a way to measure both the amount of wall or[2.x.1] as well as the total time elapsed over all laps Here is an you can also restart the timer instead of resetting it The times between successive calls to start() and stop()(i.e.</div></div>
<div class="ttc" id="agrid_2manifold__0_8txt_html_a02d8bd1db3a4d0b6d68a99a931ce1b83"><div class="ttname"><a href="grid_2manifold__0_8txt.html#a02d8bd1db3a4d0b6d68a99a931ce1b83">since</a></div><div class="ttdeci">*We collect here some helper functions used in the Manifold&lt; dim, spacedim &gt; classes ***A[2.x.0] helper function that returns the number of default points for the structure type pointed to by the given[2.x.1] See the documentation of[2.x.2] for more information **Given a general mesh construct arrays of quadrature points and weights that contain the following then the quadrature points are the two vertices of the line This results in a point vector with two points ********If the iterator points to a then the quadrature points are the vertices and line mid points This results in a point vector with then the quadrature points are the the line mid and the face mid points This results in a points vector which computes a new point on a manifold based on a weighted average of surrounding points represented by the quadrature points and weights stored in the returned pair of vectors This function creates such an object based on the points that surround a or and weights are chosen in a way appropriate for computing the new mid point of the object pointed to An example of where this is necessary is for mesh and then a new cell point[2.x.8] iterator A mesh iterator that points to either a or hex[2.x.9] with_interpolation Whether or not to compute the quadrature weights from transfinite as discussed above[2.x.10] MeshIteratorType An iterator type that corresponds to then no periodicity is assumed in that direction Whenever a function that tries to compute averages is an exception will be thrown if one of the points which you are using for the average lies outside the periodicity box The return points are guaranteed to lie in the periodicity box plus or minus tolerance *periodicity and then calls internally the function is to allow lazy programmers to implement only the the middle point of a cell is close to true middle point of the and a projection may suffice For most simple it is possible to get reasonable results by deriving your own Manifold class from FlatManifold and write a new interface only for the project_to_manifold function You will have good approximations also with large deformations as long as in the coarsest mesh size you are trying to refine the middle point is not too far from the manifold mid point i e as long as the coarse mesh size is small enough **Compute a new set of points that interpolate between the given points[2.x.108] surrounding_points[2.x.109] is a table with as many columns as[2.x.110] surrounding_points the interpolation of the[2.x.113] according to the[2.x.114] is simply performed in Cartesian space **Project to FlatManifold This is the identity function for Euclidean spaces Note however that this function can be overloaded by derived which will then benefit from the logic behind the is tangential to the geodesic that connects two points[2.x.116] For the current we assume that the manifold is so the geodesic is the straight line between the two and we return[2.x.117] The normalization of the vector is chosen so that it fits the convention described in *[2.x.118] If you use this class as a stepping stone to build a manifold that only slightly deviates from a flat manifold by overloading the and the one at which the direction is to be evaluated[2.x.121] x2 The second point that describes the geodesic[2.x.122] A direction vector tangential to the geodesic this possibly modified by the periodicity of the domain as set in the to use the shortest connection between the points through the periodic boundary as necessary **Return the normal vector to the given face at point p taking into account that quadrilateral faces of hexahedral cells in may not be planar In those the face is assumed to have a geometry described by a bilinear and the normal vector is computed by embedding this bilinear form into a Cartesian space with a flat metric **Compute the normal vectors to the boundary at each vertex of the given face taking into account that quadrilateral faces of hexahedral cells in may not be planar In those the face is assumed to have a geometry described by a bilinear and the normal vector is computed by embedding this bilinear form into a Cartesian space with a flat metric **Return the periodicity of this Manifold **The periodicity of this Manifold Periodicity affects the way a middle point is computed It is assumed that if two points are more than half period then the distance should be computed by crossing the periodicity i the average is computed by adding a full period to the sum of the two For if along direction we have *pi then the average but since</div><div class="ttdef"><b>Definition:</b> <a href="grid_2manifold__0_8txt_source.html#l00147">manifold_0.txt:147</a></div></div>
<div class="ttc" id="amultithreading__0_8txt_html_a4c0a7149e1927066d2fcdb356cb90f7b"><div class="ttname"><a href="multithreading__0_8txt.html#a4c0a7149e1927066d2fcdb356cb90f7b">no</a></div><div class="ttdeci">in this it often pays off to use rather than in a program *deal II does not implement scheduling tasks to threads itself For we use the[1.x.10] for which we provide simple wrappers TBB abstracts the details of how to start or stop start tasks on individual and provides interfaces that are portable across many different systems ***MTUsing *[1.x.11] the syntax to start would be something like this for the example we would like to indicate the fact that the function call should be run on a separate task by simply prefixing the call with a as it is here *Since C does not support the creation of new we have to be a bit more creative The way chosen is to introduce a function[2.x.24] that takes as arguments the function to call as well as the arguments to the call The[2.x.25] function is overloaded to accommodate starting tasks with functions that take no</div><div class="ttdef"><b>Definition:</b> <a href="multithreading__0_8txt_source.html#l00045">multithreading_0.txt:45</a></div></div>
<div class="ttc" id="agrid_2grid__refinement__0_8txt_html_a8bdcf8330609e043ba26a394139934f2"><div class="ttname"><a href="grid_2grid__refinement__0_8txt.html#a8bdcf8330609e043ba26a394139934f2">Section</a></div><div class="ttdeci">and W R the function uses the observation that the error behaves like[2.x.65] with some constant[2.x.66] that depends on the dimension and the finite element degree It should **given optimal mesh refinement **not depend so much on the regularity of the as it is based on the that all singularities can be resolved by refinement Mesh refinement is then based on the idea that we want to make[2.x.67] small This corresponds to the functional[2.x.68] above *This function was originally implemented by Thomas Richter It follows a strategy described in T Parallel Multigrid Method for Adaptive Finite Elements with Application to Flow PhD University of See in particular Section</div><div class="ttdef"><b>Definition:</b> <a href="grid_2grid__refinement__0_8txt_source.html#l00029">grid_refinement_0.txt:29</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
