<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/translator_2base_2vectorization_8h.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: include/deal.II-translator/base/vectorization.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_386d89ad50a3909c2af5a93b48d2c3ff.html">deal.II-translator</a></li><li class="navelem"><a class="el" href="dir_93218cacdf2be213c307fc2583c9455e.html">base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vectorization.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="config_8h_source.html">deal.II/base/config.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="include_2deal_8II_2base_2exceptions_8h_source.html">deal.II/base/exceptions.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="base_2template__constraints_8h_source.html">deal.II/base/template_constraints.h</a>&gt;</code><br />
<code>#include &lt;array&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
</div>
<p><a href="translator_2base_2vectorization_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEnableIfScalar_3_01VectorizedArray_3_01Number_00_01width_01_4_01_4.html">EnableIfScalar&lt; VectorizedArray&lt; Number, width &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArrayIterator.html">VectorizedArrayIterator&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArrayBase.html">VectorizedArrayBase&lt; T, width &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html">VectorizedArray&lt; Number, width &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1iterator__traits_3_1_1VectorizedArrayIterator_3_01T_01_4_01_4.html">std::iterator_traits&lt;::VectorizedArrayIterator&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad9b7aa5c50bf9ce988a0f756a3f2baa5"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:ad9b7aa5c50bf9ce988a0f756a3f2baa5"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="base_2vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x)</td></tr>
<tr class="separator:ad9b7aa5c50bf9ce988a0f756a3f2baa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c48f86a4f2adf21555e64049ecde8c"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a11c48f86a4f2adf21555e64049ecde8c"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="base_2vectorization_8h.html#a11c48f86a4f2adf21555e64049ecde8c">std::cos</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x)</td></tr>
<tr class="separator:a11c48f86a4f2adf21555e64049ecde8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d0134a018bfda1707088d44fa20a86"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:ac2d0134a018bfda1707088d44fa20a86"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="base_2vectorization_8h.html#ac2d0134a018bfda1707088d44fa20a86">std::tan</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x)</td></tr>
<tr class="separator:ac2d0134a018bfda1707088d44fa20a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f846bda83b7e3f4531daacb40c64e1"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a19f846bda83b7e3f4531daacb40c64e1"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="base_2vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x)</td></tr>
<tr class="separator:a19f846bda83b7e3f4531daacb40c64e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa674852f105b0ed1b35f569c19fea6"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a2aa674852f105b0ed1b35f569c19fea6"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="base_2vectorization_8h.html#a2aa674852f105b0ed1b35f569c19fea6">std::log</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x)</td></tr>
<tr class="separator:a2aa674852f105b0ed1b35f569c19fea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303f564e3c189251976da401ee2e44fa"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a303f564e3c189251976da401ee2e44fa"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="base_2vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x)</td></tr>
<tr class="separator:a303f564e3c189251976da401ee2e44fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac114cf7bf36e485eb78fedea2488a0d5"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:ac114cf7bf36e485eb78fedea2488a0d5"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="base_2vectorization_8h.html#ac114cf7bf36e485eb78fedea2488a0d5">std::pow</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x, const Number p)</td></tr>
<tr class="separator:ac114cf7bf36e485eb78fedea2488a0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c8b2cd70b2640bab8f1ee4ccb7f4cc"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:ae5c8b2cd70b2640bab8f1ee4ccb7f4cc"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="base_2vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x, const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;p)</td></tr>
<tr class="separator:ae5c8b2cd70b2640bab8f1ee4ccb7f4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbdfdd72b6cfe4eae5fa7a16385582f"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:aafbdfdd72b6cfe4eae5fa7a16385582f"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="base_2vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x)</td></tr>
<tr class="separator:aafbdfdd72b6cfe4eae5fa7a16385582f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a4b202af7a0b7a652d6572c422663f"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a93a4b202af7a0b7a652d6572c422663f"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="base_2vectorization_8h.html#a93a4b202af7a0b7a652d6572c422663f">std::max</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x, const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;y)</td></tr>
<tr class="separator:a93a4b202af7a0b7a652d6572c422663f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42ab6dd95b8becedec9f3fb4afb0203"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:aa42ab6dd95b8becedec9f3fb4afb0203"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="base_2vectorization_8h.html#aa42ab6dd95b8becedec9f3fb4afb0203">std::min</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x, const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;y)</td></tr>
<tr class="separator:aa42ab6dd95b8becedec9f3fb4afb0203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Packing and unpacking of a VectorizedArray</div></td></tr>
<tr class="memitem:a12b7ea1d6566fc206a9ec0488adb14d6"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width = internal::VectorizedArrayWidthSpecifier&lt;Number&gt;::max_width&gt; </td></tr>
<tr class="memitem:a12b7ea1d6566fc206a9ec0488adb14d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a12b7ea1d6566fc206a9ec0488adb14d6">make_vectorized_array</a> (const Number &amp;u)</td></tr>
<tr class="separator:a12b7ea1d6566fc206a9ec0488adb14d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5618abfc968e28f587c4fcfa1fdb34"><td class="memTemplParams" colspan="2">template&lt;typename VectorizedArrayType &gt; </td></tr>
<tr class="memitem:a1e5618abfc968e28f587c4fcfa1fdb34"><td class="memTemplItemLeft" align="right" valign="top">VectorizedArrayType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a1e5618abfc968e28f587c4fcfa1fdb34">make_vectorized_array</a> (const typename VectorizedArrayType::value_type &amp;u)</td></tr>
<tr class="separator:a1e5618abfc968e28f587c4fcfa1fdb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078ca5de8d3a59aedc130823be15ad26"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a078ca5de8d3a59aedc130823be15ad26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a078ca5de8d3a59aedc130823be15ad26">gather</a> (<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;out, const std::array&lt; Number *, width &gt; &amp;ptrs, const unsigned <a class="el" href="classint.html">int</a> offset)</td></tr>
<tr class="separator:a078ca5de8d3a59aedc130823be15ad26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14da4327264fd3a88a9f73a8f72a9094"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a14da4327264fd3a88a9f73a8f72a9094"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a14da4327264fd3a88a9f73a8f72a9094">vectorized_load_and_transpose</a> (const unsigned <a class="el" href="classint.html">int</a> n_entries, const Number *in, const unsigned <a class="el" href="classint.html">int</a> *offsets, <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *out)</td></tr>
<tr class="separator:a14da4327264fd3a88a9f73a8f72a9094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7f7b3cdcf7b71718bee43a9cbc27f8"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a6e7f7b3cdcf7b71718bee43a9cbc27f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a6e7f7b3cdcf7b71718bee43a9cbc27f8">vectorized_load_and_transpose</a> (const unsigned <a class="el" href="classint.html">int</a> n_entries, const std::array&lt; Number *, width &gt; &amp;in, <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *out)</td></tr>
<tr class="separator:a6e7f7b3cdcf7b71718bee43a9cbc27f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af396b43c783502e8acd2ca7d071a7325"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:af396b43c783502e8acd2ca7d071a7325"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#af396b43c783502e8acd2ca7d071a7325">vectorized_transpose_and_store</a> (const <a class="el" href="classbool.html">bool</a> add_into, const unsigned <a class="el" href="classint.html">int</a> n_entries, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *in, const unsigned <a class="el" href="classint.html">int</a> *offsets, Number *out)</td></tr>
<tr class="separator:af396b43c783502e8acd2ca7d071a7325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e4c80a49c6df42c3831655bdb318ab"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a63e4c80a49c6df42c3831655bdb318ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a63e4c80a49c6df42c3831655bdb318ab">vectorized_transpose_and_store</a> (const <a class="el" href="classbool.html">bool</a> add_into, const unsigned <a class="el" href="classint.html">int</a> n_entries, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *in, std::array&lt; Number *, width &gt; &amp;out)</td></tr>
<tr class="separator:a63e4c80a49c6df42c3831655bdb318ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Arithmetic operations with VectorizedArray</div></td></tr>
<tr class="memitem:a60e4e5dd338cf4353bbdccc117fa883d"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a60e4e5dd338cf4353bbdccc117fa883d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a60e4e5dd338cf4353bbdccc117fa883d">operator==</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;lhs, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;rhs)</td></tr>
<tr class="separator:a60e4e5dd338cf4353bbdccc117fa883d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a9ab28bc787b738f68b35a621db43b"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a38a9ab28bc787b738f68b35a621db43b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a38a9ab28bc787b738f68b35a621db43b">operator+</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:a38a9ab28bc787b738f68b35a621db43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a48ed6753e463282e446c19dc49c75"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a20a48ed6753e463282e446c19dc49c75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a20a48ed6753e463282e446c19dc49c75">operator-</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:a20a48ed6753e463282e446c19dc49c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3c20131d629237718a4662d7efcd72"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a5d3c20131d629237718a4662d7efcd72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a5d3c20131d629237718a4662d7efcd72">operator*</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:a5d3c20131d629237718a4662d7efcd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1aba614b595b02a8de0e9db3a23d6c"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a8b1aba614b595b02a8de0e9db3a23d6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a8b1aba614b595b02a8de0e9db3a23d6c">operator/</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:a8b1aba614b595b02a8de0e9db3a23d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d0f61213b53fd732ef67cf14cf6618"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a25d0f61213b53fd732ef67cf14cf6618"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a25d0f61213b53fd732ef67cf14cf6618">operator+</a> (const Number &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:a25d0f61213b53fd732ef67cf14cf6618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a2e504f10db613d481a772adaa0b60"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:a42a2e504f10db613d481a772adaa0b60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a42a2e504f10db613d481a772adaa0b60">operator+</a> (const <a class="el" href="classdouble.html">double</a> u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v)</td></tr>
<tr class="separator:a42a2e504f10db613d481a772adaa0b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ad5f0b83deb7a03d84d262ca210837"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a08ad5f0b83deb7a03d84d262ca210837"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a08ad5f0b83deb7a03d84d262ca210837">operator+</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v, const Number &amp;u)</td></tr>
<tr class="separator:a08ad5f0b83deb7a03d84d262ca210837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1404e7fb6340c52ad0d6830123b73f19"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:a1404e7fb6340c52ad0d6830123b73f19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a1404e7fb6340c52ad0d6830123b73f19">operator+</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v, const <a class="el" href="classdouble.html">double</a> u)</td></tr>
<tr class="separator:a1404e7fb6340c52ad0d6830123b73f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640b22496e28cdd45e1dc9283e1efa17"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a640b22496e28cdd45e1dc9283e1efa17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a640b22496e28cdd45e1dc9283e1efa17">operator-</a> (const Number &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:a640b22496e28cdd45e1dc9283e1efa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38190affe401a274be3e496fc35a0766"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:a38190affe401a274be3e496fc35a0766"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a38190affe401a274be3e496fc35a0766">operator-</a> (const <a class="el" href="classdouble.html">double</a> u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v)</td></tr>
<tr class="separator:a38190affe401a274be3e496fc35a0766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00766ce2d80c31f2450e6c9057870cbd"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a00766ce2d80c31f2450e6c9057870cbd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a00766ce2d80c31f2450e6c9057870cbd">operator-</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v, const Number &amp;u)</td></tr>
<tr class="separator:a00766ce2d80c31f2450e6c9057870cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b20de82e91024a7555bbd0c5f5222b"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:ab6b20de82e91024a7555bbd0c5f5222b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#ab6b20de82e91024a7555bbd0c5f5222b">operator-</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v, const <a class="el" href="classdouble.html">double</a> u)</td></tr>
<tr class="separator:ab6b20de82e91024a7555bbd0c5f5222b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5790c596f79444d6b833d8ac15414404"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a5790c596f79444d6b833d8ac15414404"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a5790c596f79444d6b833d8ac15414404">operator*</a> (const Number &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:a5790c596f79444d6b833d8ac15414404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac985699a2f70f78d0b3794c687d49ac9"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:ac985699a2f70f78d0b3794c687d49ac9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#ac985699a2f70f78d0b3794c687d49ac9">operator*</a> (const <a class="el" href="classdouble.html">double</a> u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v)</td></tr>
<tr class="separator:ac985699a2f70f78d0b3794c687d49ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8f29a417993bac81bf6bb4b565cf61"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a3c8f29a417993bac81bf6bb4b565cf61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a3c8f29a417993bac81bf6bb4b565cf61">operator*</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v, const Number &amp;u)</td></tr>
<tr class="separator:a3c8f29a417993bac81bf6bb4b565cf61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1d1421d463e96646a42d7e74ba1193"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:afa1d1421d463e96646a42d7e74ba1193"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#afa1d1421d463e96646a42d7e74ba1193">operator*</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v, const <a class="el" href="classdouble.html">double</a> u)</td></tr>
<tr class="separator:afa1d1421d463e96646a42d7e74ba1193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb9f95aeaf6a543d6e77ae7688de53a"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a4cb9f95aeaf6a543d6e77ae7688de53a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a4cb9f95aeaf6a543d6e77ae7688de53a">operator/</a> (const Number &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:a4cb9f95aeaf6a543d6e77ae7688de53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebab187fb523e9e43f22a24139306b0b"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:aebab187fb523e9e43f22a24139306b0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#aebab187fb523e9e43f22a24139306b0b">operator/</a> (const <a class="el" href="classdouble.html">double</a> u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v)</td></tr>
<tr class="separator:aebab187fb523e9e43f22a24139306b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fef54ecf5c963b12f2f99188d5549f"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a21fef54ecf5c963b12f2f99188d5549f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a21fef54ecf5c963b12f2f99188d5549f">operator/</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v, const Number &amp;u)</td></tr>
<tr class="separator:a21fef54ecf5c963b12f2f99188d5549f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7219be7ffd3e9edee8e7466b8c9e6a11"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:a7219be7ffd3e9edee8e7466b8c9e6a11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a7219be7ffd3e9edee8e7466b8c9e6a11">operator/</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v, const <a class="el" href="classdouble.html">double</a> u)</td></tr>
<tr class="separator:a7219be7ffd3e9edee8e7466b8c9e6a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8bb7d8ceb62160e7151c5cbbb55651"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:aee8bb7d8ceb62160e7151c5cbbb55651"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#aee8bb7d8ceb62160e7151c5cbbb55651">operator+</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u)</td></tr>
<tr class="separator:aee8bb7d8ceb62160e7151c5cbbb55651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c80f623e9cf0a53b3217af675a60bf3"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a0c80f623e9cf0a53b3217af675a60bf3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a0c80f623e9cf0a53b3217af675a60bf3">operator-</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u)</td></tr>
<tr class="separator:a0c80f623e9cf0a53b3217af675a60bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600920aba9e31a12c5330b4f2adeae11"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a600920aba9e31a12c5330b4f2adeae11"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a600920aba9e31a12c5330b4f2adeae11">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;p)</td></tr>
<tr class="separator:a600920aba9e31a12c5330b4f2adeae11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Ternary operations on VectorizedArray</h2></td></tr>
<tr class="memitem:a31b02447b71a04a1ec9bdd1358751e45"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45">SIMDComparison</a> : int { <br />
&#160;&#160;<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">SIMDComparison::equal</a>, 
<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a96ee5c0e2a7149613e7fd0b83316486e">SIMDComparison::not_equal</a>, 
<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a7875e44acb1bebecb46c929deb43cef4">SIMDComparison::less_than</a>, 
<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a9f6a1c1739ff468513ed276436f3db72">SIMDComparison::less_than_or_equal</a>, 
<br />
&#160;&#160;<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45af9001e5685fe6f7cb467dc66269470b2">SIMDComparison::greater_than</a>, 
<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45ae69e99a9a1111b6a811f8e5bd832454f">SIMDComparison::greater_than_or_equal</a>, 
<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">SIMDComparison::equal</a>, 
<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a96ee5c0e2a7149613e7fd0b83316486e">SIMDComparison::not_equal</a>, 
<br />
&#160;&#160;<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a7875e44acb1bebecb46c929deb43cef4">SIMDComparison::less_than</a>, 
<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a9f6a1c1739ff468513ed276436f3db72">SIMDComparison::less_than_or_equal</a>, 
<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45af9001e5685fe6f7cb467dc66269470b2">SIMDComparison::greater_than</a>, 
<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45ae69e99a9a1111b6a811f8e5bd832454f">SIMDComparison::greater_than_or_equal</a>, 
<br />
&#160;&#160;<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">SIMDComparison::equal</a>, 
<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a96ee5c0e2a7149613e7fd0b83316486e">SIMDComparison::not_equal</a>, 
<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a7875e44acb1bebecb46c929deb43cef4">SIMDComparison::less_than</a>, 
<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a9f6a1c1739ff468513ed276436f3db72">SIMDComparison::less_than_or_equal</a>, 
<br />
&#160;&#160;<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45af9001e5685fe6f7cb467dc66269470b2">SIMDComparison::greater_than</a>, 
<a class="el" href="translator_2base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45ae69e99a9a1111b6a811f8e5bd832454f">SIMDComparison::greater_than_or_equal</a>
<br />
 }</td></tr>
<tr class="separator:a31b02447b71a04a1ec9bdd1358751e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac274b257ee3ff9666b2062b8ba56db8f"><td class="memTemplParams" colspan="2">template&lt;SIMDComparison predicate, typename Number &gt; </td></tr>
<tr class="memitem:ac274b257ee3ff9666b2062b8ba56db8f"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#ac274b257ee3ff9666b2062b8ba56db8f">compare_and_apply_mask</a> (const Number &amp;left, const Number &amp;right, const Number &amp;true_value, const Number &amp;false_value)</td></tr>
<tr class="separator:ac274b257ee3ff9666b2062b8ba56db8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a14956ceb21a6bc048b2c5ced72845"><td class="memTemplParams" colspan="2">template&lt;SIMDComparison predicate, typename Number &gt; </td></tr>
<tr class="memitem:a67a14956ceb21a6bc048b2c5ced72845"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="translator_2base_2vectorization_8h.html#a67a14956ceb21a6bc048b2c5ced72845">compare_and_apply_mask</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt; &amp;left, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt; &amp;right, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt; &amp;true_value, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt; &amp;false_value)</td></tr>
<tr class="separator:a67a14956ceb21a6bc048b2c5ced72845"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a31b02447b71a04a1ec9bdd1358751e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b02447b71a04a1ec9bdd1358751e45">&#9670;&nbsp;</a></span>SIMDComparison</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45">SIMDComparison</a> : <a class="el" href="classint.html">int</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>enum class encoding binary operations for a component-wise comparison of <a class="el" href="classVectorizedArray.html">VectorizedArray</a> data types.</p>
<dl class="section note"><dt>Note</dt><dd>In case of SIMD vecorization (sse, avx, av512) we select the corresponding ordered, non-signalling ( <code>OQ</code> ) variants. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f"></a>equal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45a96ee5c0e2a7149613e7fd0b83316486e"></a>not_equal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45a7875e44acb1bebecb46c929deb43cef4"></a>less_than&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45a9f6a1c1739ff468513ed276436f3db72"></a>less_than_or_equal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45af9001e5685fe6f7cb467dc66269470b2"></a>greater_than&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45ae69e99a9a1111b6a811f8e5bd832454f"></a>greater_than_or_equal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f"></a>equal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45a96ee5c0e2a7149613e7fd0b83316486e"></a>not_equal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45a7875e44acb1bebecb46c929deb43cef4"></a>less_than&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45a9f6a1c1739ff468513ed276436f3db72"></a>less_than_or_equal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45af9001e5685fe6f7cb467dc66269470b2"></a>greater_than&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45ae69e99a9a1111b6a811f8e5bd832454f"></a>greater_than_or_equal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f"></a>equal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45a96ee5c0e2a7149613e7fd0b83316486e"></a>not_equal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45a7875e44acb1bebecb46c929deb43cef4"></a>less_than&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45a9f6a1c1739ff468513ed276436f3db72"></a>less_than_or_equal&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45af9001e5685fe6f7cb467dc66269470b2"></a>greater_than&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31b02447b71a04a1ec9bdd1358751e45ae69e99a9a1111b6a811f8e5bd832454f"></a>greater_than_or_equal&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05261">5261</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a12b7ea1d6566fc206a9ec0488adb14d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b7ea1d6566fc206a9ec0488adb14d6">&#9670;&nbsp;</a></span>make_vectorized_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width = internal::VectorizedArrayWidthSpecifier&lt;Number&gt;::max_width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; make_vectorized_array </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a vectorized array that sets all entries in the array to the given scalar, i.e., broadcasts the scalar to all array elements. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l00795">795</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a1e5618abfc968e28f587c4fcfa1fdb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5618abfc968e28f587c4fcfa1fdb34">&#9670;&nbsp;</a></span>make_vectorized_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorizedArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType make_vectorized_array </td>
          <td>(</td>
          <td class="paramtype">const typename VectorizedArrayType::value_type &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a vectorized array of given type and broadcast the scalar value to all array elements. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l00812">812</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a078ca5de8d3a59aedc130823be15ad26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078ca5de8d3a59aedc130823be15ad26">&#9670;&nbsp;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gather </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Number *, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load size() data items from memory into the <a class="el" href="classVectorizedArray.html">VectorizedArray</a> <code>out</code>, starting at the given addresses and with given offset, each entry from the offset providing one element of the vectorized array. This operation corresponds to the following code:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;VectorizedArray&lt;Number&gt;::size(); ++v)</div>
<div class="line">out.data[v] = ptrs[v][offset];</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l00842">842</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a14da4327264fd3a88a9f73a8f72a9094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14da4327264fd3a88a9f73a8f72a9094">&#9670;&nbsp;</a></span>vectorized_load_and_transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vectorized_load_and_transpose </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method loads <a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray::size()</a> data streams from the given array <code>in</code>. The offsets to the input array are given by the array <code>offsets</code>. From each stream, n_entries are read. The data is then transposed and stored it into an array of <a class="el" href="classVectorizedArray.html">VectorizedArray</a> type. The output array <code>out</code> is expected to be an array of size <code>n_entries</code>. This method operates on plain arrays, so no checks for valid data access are made. It is the user's responsibility to ensure that the given arrays are valid according to the access layout below. This operation corresponds to a transformation of an array-of-struct (input) into a struct-of-array (output) according to the following formula:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_entries; ++i)</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;VectorizedArray&lt;Number&gt;::size(); ++v)</div>
<div class="line">  out[i][v] = in[offsets[v]+i];</div>
</div><!-- fragment --><p>A more optimized version of this code will be used for supported types. This is the inverse operation to <a class="el" href="classVectorizedArray.html#af396b43c783502e8acd2ca7d071a7325">vectorized_transpose_and_store()</a>. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l00879">879</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a6e7f7b3cdcf7b71718bee43a9cbc27f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7f7b3cdcf7b71718bee43a9cbc27f8">&#9670;&nbsp;</a></span>vectorized_load_and_transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vectorized_load_and_transpose </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; Number *, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same as above with the difference that an array of pointers are passed in as input argument <code>in</code>. In analogy to the function above, one can consider that <code>in+offset[v]</code> is precomputed and passed as input argument. However, this function can also be used if some function returns an array of pointers and no assumption can be made that they belong to the same array, i.e., they can have their origin in different memory allocations. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l00902">902</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="af396b43c783502e8acd2ca7d071a7325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af396b43c783502e8acd2ca7d071a7325">&#9670;&nbsp;</a></span>vectorized_transpose_and_store() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vectorized_transpose_and_store </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>add_into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method stores the vectorized arrays in transposed form into the given output array <code>out</code> with the given offsets <code>offsets</code>. This operation corresponds to a transformation of a struct-of-array (input) into an array- of-struct (output). This method operates on plain array, so no checks for valid data access are made. It is the user's responsibility to ensure that the given arrays are valid according to the access layout below. This method assumes that the specified offsets do not overlap. Otherwise, the behavior is undefined in the vectorized case. It is the user's responsibility to make sure that the access does not overlap and avoid undefined behavior. The argument <code>add_into</code> selects where the entries should only be written into the output arrays or the result should be added into the existing entries in the output. For <code>add_into == false</code> , the following code is assumed:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_entries; ++i)</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;VectorizedArray&lt;Number&gt;::size(); ++v)</div>
<div class="line">  out[offsets[v]+i] = in[i][v];</div>
</div><!-- fragment --><p>For <code>add_into == true</code> , the code implements the following action:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_entries; ++i)</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;VectorizedArray&lt;Number&gt;::size(); ++v)</div>
<div class="line">  out[offsets[v]+i] += in[i][v];</div>
</div><!-- fragment --><p>A more optimized version of this code will be used for supported types. This is the inverse operation to <a class="el" href="classVectorizedArray.html#a14da4327264fd3a88a9f73a8f72a9094">vectorized_load_and_transpose()</a>. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l00952">952</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a63e4c80a49c6df42c3831655bdb318ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e4c80a49c6df42c3831655bdb318ab">&#9670;&nbsp;</a></span>vectorized_transpose_and_store() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vectorized_transpose_and_store </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>add_into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; Number *, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The same as above with the difference that an array of pointers are passed in as input argument <code>out</code>. In analogy to the function above, one can consider that <code>out+offset[v]</code> is precomputed and passed as input argument. However, this function can also be used if some function returns an array of pointers and no assumption can be made that they belong to the same array, i.e., they can have their origin in different memory allocations. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l00981">981</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a60e4e5dd338cf4353bbdccc117fa883d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e4e5dd338cf4353bbdccc117fa883d">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Relational operator == for <a class="el" href="classVectorizedArray.html">VectorizedArray</a> </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l04868">4868</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a38a9ab28bc787b738f68b35a621db43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a9ab28bc787b738f68b35a621db43b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition of two vectorized arrays with operator +. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l04887">4887</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a20a48ed6753e463282e446c19dc49c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a48ed6753e463282e446c19dc49c75">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction of two vectorized arrays with operator</p>
<ul>
<li></li>
</ul>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l04904">4904</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a5d3c20131d629237718a4662d7efcd72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3c20131d629237718a4662d7efcd72">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of two vectorized arrays with operator. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l04919">4919</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a8b1aba614b595b02a8de0e9db3a23d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1aba614b595b02a8de0e9db3a23d6c">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Division of two vectorized arrays with operator /. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l04934">4934</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a25d0f61213b53fd732ef67cf14cf6618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d0f61213b53fd732ef67cf14cf6618">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition of a scalar (expanded to a vectorized array with <code>size()</code> equal entries) and a vectorized array. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l04950">4950</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a42a2e504f10db613d481a772adaa0b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a2e504f10db613d481a772adaa0b60">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;float, width&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition of a scalar (expanded to a vectorized array with <code>size()</code> equal entries) and a vectorized array in case the scalar is a double (needed in order to be able to write simple code with constants that are usually double numbers). </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l04967">4967</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a08ad5f0b83deb7a03d84d262ca210837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ad5f0b83deb7a03d84d262ca210837">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition of a vectorized array and a scalar (expanded to a vectorized array with <code>size()</code> equal entries). </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l04982">4982</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a1404e7fb6340c52ad0d6830123b73f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1404e7fb6340c52ad0d6830123b73f19">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;float, width&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition of a vectorized array and a scalar (expanded to a vectorized array with <code>size()</code> equal entries) in case the scalar is a double (needed in order to be able to write simple code with constants that are usually double numbers). </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l04998">4998</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a640b22496e28cdd45e1dc9283e1efa17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640b22496e28cdd45e1dc9283e1efa17">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction of a vectorized array from a scalar (expanded to a vectorized array with <code>size()</code> equal entries). </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05012">5012</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a38190affe401a274be3e496fc35a0766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38190affe401a274be3e496fc35a0766">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;float, width&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction of a vectorized array from a scalar (expanded to a vectorized array with <code>size()</code> equal entries) in case the scalar is a double (needed in order to be able to write simple code with constants that are usually double numbers). </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05029">5029</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a00766ce2d80c31f2450e6c9057870cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00766ce2d80c31f2450e6c9057870cbd">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction of a scalar (expanded to a vectorized array with <code>size()</code> equal entries) from a vectorized array. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05044">5044</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ab6b20de82e91024a7555bbd0c5f5222b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b20de82e91024a7555bbd0c5f5222b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;float, width&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction of a scalar (expanded to a vectorized array with <code>size()</code> equal entries) from a vectorized array in case the scalar is a double (needed in order to be able to write simple code with constants that are usually double numbers). </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05061">5061</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a5790c596f79444d6b833d8ac15414404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5790c596f79444d6b833d8ac15414404">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a scalar (expanded to a vectorized array with <code>size()</code> equal entries) and a vectorized array. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05076">5076</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ac985699a2f70f78d0b3794c687d49ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac985699a2f70f78d0b3794c687d49ac9">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;float, width&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a scalar (expanded to a vectorized array with <code>size()</code> equal entries) and a vectorized array in case the scalar is a double (needed in order to be able to write simple code with constants that are usually double numbers). </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05093">5093</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a3c8f29a417993bac81bf6bb4b565cf61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8f29a417993bac81bf6bb4b565cf61">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a vectorized array and a scalar (expanded to a vectorized array with <code>size()</code> equal entries). </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05108">5108</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="afa1d1421d463e96646a42d7e74ba1193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1d1421d463e96646a42d7e74ba1193">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;float, width&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a vectorized array and a scalar (expanded to a vectorized array with <code>size()</code> equal entries) in case the scalar is a double (needed in order to be able to write simple code with constants that are usually double numbers). </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05124">5124</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a4cb9f95aeaf6a543d6e77ae7688de53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb9f95aeaf6a543d6e77ae7688de53a">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Quotient between a scalar (expanded to a vectorized array with <code>size()</code> equal entries) and a vectorized array. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05138">5138</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="aebab187fb523e9e43f22a24139306b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebab187fb523e9e43f22a24139306b0b">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;float, width&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Quotient between a scalar (expanded to a vectorized array with <code>size()</code> equal entries) and a vectorized array in case the scalar is a double (needed in order to be able to write simple code with constants that are usually double numbers). </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05155">5155</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a21fef54ecf5c963b12f2f99188d5549f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fef54ecf5c963b12f2f99188d5549f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Quotient between a vectorized array and a scalar (expanded to a vectorized array with <code>size()</code> equal entries). </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05170">5170</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a7219be7ffd3e9edee8e7466b8c9e6a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7219be7ffd3e9edee8e7466b8c9e6a11">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;float, width&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Quotient between a vectorized array and a scalar (expanded to a vectorized array with <code>size()</code> equal entries) in case the scalar is a double (needed in order to be able to write simple code with constants that are usually double numbers). </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05187">5187</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="aee8bb7d8ceb62160e7151c5cbbb55651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8bb7d8ceb62160e7151c5cbbb55651">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unary operator + on a vectorized array. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05201">5201</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a0c80f623e9cf0a53b3217af675a60bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c80f623e9cf0a53b3217af675a60bf3">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unary operator</p>
<ul>
<li>on a vectorized array. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05216">5216</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a600920aba9e31a12c5330b4f2adeae11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600920aba9e31a12c5330b4f2adeae11">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator for vectorized array. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05231">5231</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ac274b257ee3ff9666b2062b8ba56db8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac274b257ee3ff9666b2062b8ba56db8f">&#9670;&nbsp;</a></span>compare_and_apply_mask() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SIMDComparison predicate, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number compare_and_apply_mask </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>true_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>false_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the vectorized equivalent of the following ternary operation:</p>
<div class="fragment"><div class="line">(left OP right) ? true_value : false_value</div>
</div><!-- fragment --><p> where <code>OP</code> is a binary operator (such as <code>=</code> , <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> , and <code>&gt;=</code> ). Such a computational idiom is useful as an alternative to branching whenever the control flow itself would depend on (computed) data. For example, in case of a scalar data type the statement <code>(left &lt; right) ? true_value : false_value</code> could have been also implemented using an <code>if</code> -statement:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (left &lt; right)</div>
<div class="line">  result = true_value;</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  result = false_value;</div>
</div><!-- fragment --><p> This, however, is fundamentally impossible in case of vectorization because different decisions will be necessary on different vector entries (lanes) and the first variant (based on a ternary operator) has to be used instead:</p>
<div class="fragment"><div class="line">result = compare_and_apply_mask&lt;SIMDComparison::less_than&gt;</div>
<div class="line">  (left, right, true_value, false_value);</div>
</div><!-- fragment --><p> Some more illustrative examples (that are less efficient than the dedicated <code>std::max</code> and <code>std::abs</code> overloads):</p>
<div class="fragment"><div class="line"><a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> left;</div>
<div class="line"><a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> right;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// std::max</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> maximum = compare_and_apply_mask&lt;SIMDComparison::greater_than&gt;</div>
<div class="line">  (left, right, left, right);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// std::abs</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> absolute = compare_and_apply_mask&lt;SIMDComparison::less_than&gt;</div>
<div class="line">  (left, <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a>(0.),</div>
<div class="line"> </div>
<div class="line">-left, left);</div>
</div><!-- fragment --><p>More precisely, this function first computes a (boolean) mask that is the result of a binary operator <code>OP</code> applied to all elements of the <a class="el" href="classVectorizedArray.html">VectorizedArray</a> arguments <code>left</code> and <code>right</code>. The mask is then used to either select the corresponding component of <code>true_value</code> (if the binary operation equates to true), or <code>false_value</code>. The binary operator is encoded via the SIMDComparison template argument <code>predicate</code>. In order to ease with generic programming approaches, the function provides overloads for all <a class="el" href="classVectorizedArray.html">VectorizedArray&lt;Number&gt;</a> variants as well as generic POD types such as double and float.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work the binary operation has to be encoded via a SIMDComparison template argument <code>predicate</code>. Depending on it appropriate low-level machine instructions are generated replacing the call to compare_and_apply_mask. This also explains why <code>predicate</code> is a compile-time constant template parameter and not a constant function argument. In order to be able to emit the correct low-level instruction, the compiler has to know the comparison at compile time. </dd></dl>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05350">5350</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a67a14956ceb21a6bc048b2c5ced72845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a14956ceb21a6bc048b2c5ced72845">&#9670;&nbsp;</a></span>compare_and_apply_mask() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;SIMDComparison predicate, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, 1&gt; compare_and_apply_mask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>true_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>false_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization of above function for the non-vectorized VectorizedArray&lt;Number, 1&gt; variant. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2vectorization_8h_source.html#l05390">5390</a> of file <a class="el" href="translator_2base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ad9b7aa5c50bf9ce988a0f756a3f2baa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b7aa5c50bf9ce988a0f756a3f2baa5">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::sin </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the sine of a vectorized data field. The result is returned as vectorized array in the form <code>{sin(x[0]), sin(x[1]), ..., sin(x[<a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray::size()</a>-1])}</code>. <a class="el" href="classVectorizedArray.html">VectorizedArray</a></p>
<p>Compute the sine of a vectorized data field. The result is returned as vectorized array in the form <code>{sin(x[0]), sin(x[1]), ..., sin(x[<a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray::size()</a>-1])}</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2vectorization_8h_source.html#l05579">5579</a> of file <a class="el" href="base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a11c48f86a4f2adf21555e64049ecde8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c48f86a4f2adf21555e64049ecde8c">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::cos </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the cosine of a vectorized data field. The result is returned as vectorized array in the form <code>{cos(x[0]), cos(x[1]), ..., cos(x[size()-1])}</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2vectorization_8h_source.html#l05605">5605</a> of file <a class="el" href="base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ac2d0134a018bfda1707088d44fa20a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d0134a018bfda1707088d44fa20a86">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::tan </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the tangent of a vectorized data field. The result is returned as vectorized array in the form <code>{tan(x[0]), tan(x[1]), ..., tan(x[size()-1])}</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2vectorization_8h_source.html#l05626">5626</a> of file <a class="el" href="base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a19f846bda83b7e3f4531daacb40c64e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f846bda83b7e3f4531daacb40c64e1">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::exp </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the exponential of a vectorized data field. The result is returned as vectorized array in the form <code>{exp(x[0]), exp(x[1]), ..., exp(x[size()-1])}</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2vectorization_8h_source.html#l05647">5647</a> of file <a class="el" href="base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a2aa674852f105b0ed1b35f569c19fea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa674852f105b0ed1b35f569c19fea6">&#9670;&nbsp;</a></span>log()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::log </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the natural logarithm of a vectorized data field. The result is returned as vectorized array in the form <code>{log(x[0]), log(x[1]), ..., log(x[size()-1])}</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2vectorization_8h_source.html#l05668">5668</a> of file <a class="el" href="base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a303f564e3c189251976da401ee2e44fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303f564e3c189251976da401ee2e44fa">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::sqrt </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the square root of a vectorized data field. The result is returned as vectorized array in the form <code>{sqrt(x[0]), sqrt(x[1]), ..., sqrt(x[size()-1])}</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2vectorization_8h_source.html#l05689">5689</a> of file <a class="el" href="base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ac114cf7bf36e485eb78fedea2488a0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac114cf7bf36e485eb78fedea2488a0d5">&#9670;&nbsp;</a></span>pow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::pow </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Raises the given number <code>x</code> to the power <code>p</code> for a vectorized data field. The result is returned as vectorized array in the form <code>{pow(x[0],p), pow(x[1],p), ..., pow(x[size()-1],p)}</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2vectorization_8h_source.html#l05705">5705</a> of file <a class="el" href="base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ae5c8b2cd70b2640bab8f1ee4ccb7f4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">&#9670;&nbsp;</a></span>pow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::pow </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Raises the given number <code>x</code> to the power <code>p</code> for a vectorized data field. The result is returned as vectorized array in the form <code>{pow(x[0],p[0]), pow(x[1],p[1]), ..., pow(x[size()-1],p[size()-1])}</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2vectorization_8h_source.html#l05727">5727</a> of file <a class="el" href="base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="aafbdfdd72b6cfe4eae5fa7a16385582f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafbdfdd72b6cfe4eae5fa7a16385582f">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::abs </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the absolute value (modulus) of a vectorized data field. The result is returned as vectorized array in the form <code>{abs(x[0]), abs(x[1]), ..., abs(x[size()-1])}</code>. <a class="el" href="classVectorizedArray.html">VectorizedArray</a></p>
<p>Compute the absolute value (modulus) of a vectorized data field. The result is returned as vectorized array in the form <code>{abs(x[0]), abs(x[1]), ..., abs(x[size()-1])}</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2vectorization_8h_source.html#l05750">5750</a> of file <a class="el" href="base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a93a4b202af7a0b7a652d6572c422663f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a4b202af7a0b7a652d6572c422663f">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::max </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the componentwise maximum of two vectorized data fields. The result is returned as vectorized array in the form <code>{max(x[0],y[0]), max(x[1],y[1]), ...}</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2vectorization_8h_source.html#l05765">5765</a> of file <a class="el" href="base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="aa42ab6dd95b8becedec9f3fb4afb0203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42ab6dd95b8becedec9f3fb4afb0203">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number, width&gt; std::min </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the componentwise minimum of two vectorized data fields. The result is returned as vectorized array in the form <code>{min(x[0],y[0]), min(x[1],y[1]), ...}</code>. </p>

<p class="definition">Definition at line <a class="el" href="base_2vectorization_8h_source.html#l05781">5781</a> of file <a class="el" href="base_2vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aclassVectorizedArray_html"><div class="ttname"><a href="classVectorizedArray.html">VectorizedArray&lt; double &gt;</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
