<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTensorFunctionParser.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TensorFunctionParser&lt; rank, dim, Number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classTensorFunctionParser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TensorFunctionParser&lt; rank, dim, Number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="base_2tensor__function__parser_8h_source.html">deal.II/base/tensor_function_parser.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TensorFunctionParser&lt; rank, dim, Number &gt;:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac592399aae47e2437fc43b2b2fb35312"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> = std::map&lt; std::string, <a class="el" href="classdouble.html">double</a> &gt;</td></tr>
<tr class="separator:ac592399aae47e2437fc43b2b2fb35312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac592399aae47e2437fc43b2b2fb35312"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> = std::map&lt; std::string, <a class="el" href="classdouble.html">double</a> &gt;</td></tr>
<tr class="separator:ac592399aae47e2437fc43b2b2fb35312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac592399aae47e2437fc43b2b2fb35312"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> = std::map&lt; std::string, <a class="el" href="classdouble.html">double</a> &gt;</td></tr>
<tr class="separator:ac592399aae47e2437fc43b2b2fb35312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561f516cc5492ed5e4e608b83c640e84"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunction.html#a561f516cc5492ed5e4e608b83c640e84">value_type</a> = <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a> &gt;</td></tr>
<tr class="separator:a561f516cc5492ed5e4e608b83c640e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561f516cc5492ed5e4e608b83c640e84"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunction.html#a561f516cc5492ed5e4e608b83c640e84">value_type</a> = <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a> &gt;</td></tr>
<tr class="separator:a561f516cc5492ed5e4e608b83c640e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561f516cc5492ed5e4e608b83c640e84"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunction.html#a561f516cc5492ed5e4e608b83c640e84">value_type</a> = <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a> &gt;</td></tr>
<tr class="separator:a561f516cc5492ed5e4e608b83c640e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1560a439470c14b426e28a72fc08e252"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a> = <a class="el" href="classTensor.html">Tensor</a>&lt; rank+1, dim, <a class="el" href="classdouble.html">double</a> &gt;</td></tr>
<tr class="separator:a1560a439470c14b426e28a72fc08e252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1560a439470c14b426e28a72fc08e252"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a> = <a class="el" href="classTensor.html">Tensor</a>&lt; rank+1, dim, <a class="el" href="classdouble.html">double</a> &gt;</td></tr>
<tr class="separator:a1560a439470c14b426e28a72fc08e252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1560a439470c14b426e28a72fc08e252"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a> = <a class="el" href="classTensor.html">Tensor</a>&lt; rank+1, dim, <a class="el" href="classdouble.html">double</a> &gt;</td></tr>
<tr class="separator:a1560a439470c14b426e28a72fc08e252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60d83ea93b9940207070e23a4fadd1b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunction.html#ad60d83ea93b9940207070e23a4fadd1b">time_type</a> = typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type &gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a></td></tr>
<tr class="separator:ad60d83ea93b9940207070e23a4fadd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60d83ea93b9940207070e23a4fadd1b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunction.html#ad60d83ea93b9940207070e23a4fadd1b">time_type</a> = typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type &gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a></td></tr>
<tr class="separator:ad60d83ea93b9940207070e23a4fadd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60d83ea93b9940207070e23a4fadd1b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunction.html#ad60d83ea93b9940207070e23a4fadd1b">time_type</a> = typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type &gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a></td></tr>
<tr class="separator:ad60d83ea93b9940207070e23a4fadd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1a7f37fb8fefb1932bf238e6ff9a9128"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a1a7f37fb8fefb1932bf238e6ff9a9128">TensorFunctionParser</a> (const <a class="el" href="classdouble.html">double</a> initial_time=0.0)</td></tr>
<tr class="separator:a1a7f37fb8fefb1932bf238e6ff9a9128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9834026ceb885ff4300efb9ab96db059"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a9834026ceb885ff4300efb9ab96db059">TensorFunctionParser</a> (const std::string &amp;expression, const std::string &amp;<a class="el" href="group__Exceptions.html#ga697302670a5d72d645a69edd41add719">constants</a>=&quot;&quot;, const std::string &amp;variable_names=<a class="el" href="classTensorFunctionParser.html#ab28333981e6babf652a7bc11cb62b28d">default_variable_names</a>()+&quot;,t&quot;)</td></tr>
<tr class="separator:a9834026ceb885ff4300efb9ab96db059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a72487dd459b3e8ba23f7b4bbf0fa5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a38a72487dd459b3e8ba23f7b4bbf0fa5">TensorFunctionParser</a> (const <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;)=delete</td></tr>
<tr class="separator:a38a72487dd459b3e8ba23f7b4bbf0fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb3bceece056c1df2c1dddca307c296"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a3eb3bceece056c1df2c1dddca307c296">TensorFunctionParser</a> (<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a3eb3bceece056c1df2c1dddca307c296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae507bd8caf65c0fd36463c5d800af150"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#ae507bd8caf65c0fd36463c5d800af150">~TensorFunctionParser</a> () override</td></tr>
<tr class="separator:ae507bd8caf65c0fd36463c5d800af150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70de16d97640aff163895f198ce6c50c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a70de16d97640aff163895f198ce6c50c">operator=</a> (const <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;)=delete</td></tr>
<tr class="separator:a70de16d97640aff163895f198ce6c50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db80bfdb9769955c22ae1f7e7668c6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a8db80bfdb9769955c22ae1f7e7668c6a">operator=</a> (<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a8db80bfdb9769955c22ae1f7e7668c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4141bf2ad132124fa1bd57805d4f3b48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize</a> (const std::string &amp;<a class="el" href="group__Exceptions.html#ga3ac638cbb902013fd795f3f10dedad0b">vars</a>, const std::vector&lt; std::string &gt; &amp;<a class="el" href="group__Exceptions.html#gab877f54954673da9eac1772452f1b78e">expressions</a>, const <a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> &amp;<a class="el" href="group__Exceptions.html#ga697302670a5d72d645a69edd41add719">constants</a>, const <a class="el" href="classbool.html">bool</a> time_dependent=false)</td></tr>
<tr class="separator:a4141bf2ad132124fa1bd57805d4f3b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03134f0e14e300a4bd476ae65b8eb381"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a03134f0e14e300a4bd476ae65b8eb381">initialize</a> (const std::string &amp;<a class="el" href="group__Exceptions.html#ga3ac638cbb902013fd795f3f10dedad0b">vars</a>, const std::string &amp;expression, const <a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> &amp;<a class="el" href="group__Exceptions.html#ga697302670a5d72d645a69edd41add719">constants</a>, const <a class="el" href="classbool.html">bool</a> time_dependent=false)</td></tr>
<tr class="separator:a03134f0e14e300a4bd476ae65b8eb381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd4221f41473217e8792d6e89d976de"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a2dd4221f41473217e8792d6e89d976de">value</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a2dd4221f41473217e8792d6e89d976de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec32399f1cef754b0232a95f9aed86c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#aec32399f1cef754b0232a95f9aed86c8">value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;p, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt;&gt; &amp;values) const override</td></tr>
<tr class="separator:aec32399f1cef754b0232a95f9aed86c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bd74a980d7db3535552bb5cfa71663"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#af1bd74a980d7db3535552bb5cfa71663">get_expressions</a> () const</td></tr>
<tr class="separator:af1bd74a980d7db3535552bb5cfa71663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7f37fb8fefb1932bf238e6ff9a9128"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a1a7f37fb8fefb1932bf238e6ff9a9128">TensorFunctionParser</a> (const <a class="el" href="classdouble.html">double</a> initial_time=0.0)</td></tr>
<tr class="separator:a1a7f37fb8fefb1932bf238e6ff9a9128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9834026ceb885ff4300efb9ab96db059"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a9834026ceb885ff4300efb9ab96db059">TensorFunctionParser</a> (const std::string &amp;expression, const std::string &amp;<a class="el" href="group__Exceptions.html#ga697302670a5d72d645a69edd41add719">constants</a>=&quot;&quot;, const std::string &amp;variable_names=<a class="el" href="classTensorFunctionParser.html#ab28333981e6babf652a7bc11cb62b28d">default_variable_names</a>()+&quot;,t&quot;)</td></tr>
<tr class="separator:a9834026ceb885ff4300efb9ab96db059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a72487dd459b3e8ba23f7b4bbf0fa5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a38a72487dd459b3e8ba23f7b4bbf0fa5">TensorFunctionParser</a> (const <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;)=delete</td></tr>
<tr class="separator:a38a72487dd459b3e8ba23f7b4bbf0fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb3bceece056c1df2c1dddca307c296"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a3eb3bceece056c1df2c1dddca307c296">TensorFunctionParser</a> (<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a3eb3bceece056c1df2c1dddca307c296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd54a303e39635a3a841c69eadadb69"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a0cd54a303e39635a3a841c69eadadb69">~TensorFunctionParser</a> () override</td></tr>
<tr class="separator:a0cd54a303e39635a3a841c69eadadb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70de16d97640aff163895f198ce6c50c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a70de16d97640aff163895f198ce6c50c">operator=</a> (const <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;)=delete</td></tr>
<tr class="separator:a70de16d97640aff163895f198ce6c50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db80bfdb9769955c22ae1f7e7668c6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a8db80bfdb9769955c22ae1f7e7668c6a">operator=</a> (<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a8db80bfdb9769955c22ae1f7e7668c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4141bf2ad132124fa1bd57805d4f3b48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize</a> (const std::string &amp;<a class="el" href="group__Exceptions.html#ga3ac638cbb902013fd795f3f10dedad0b">vars</a>, const std::vector&lt; std::string &gt; &amp;<a class="el" href="group__Exceptions.html#gab877f54954673da9eac1772452f1b78e">expressions</a>, const <a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> &amp;<a class="el" href="group__Exceptions.html#ga697302670a5d72d645a69edd41add719">constants</a>, const <a class="el" href="classbool.html">bool</a> time_dependent=false)</td></tr>
<tr class="separator:a4141bf2ad132124fa1bd57805d4f3b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03134f0e14e300a4bd476ae65b8eb381"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a03134f0e14e300a4bd476ae65b8eb381">initialize</a> (const std::string &amp;<a class="el" href="group__Exceptions.html#ga3ac638cbb902013fd795f3f10dedad0b">vars</a>, const std::string &amp;expression, const <a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> &amp;<a class="el" href="group__Exceptions.html#ga697302670a5d72d645a69edd41add719">constants</a>, const <a class="el" href="classbool.html">bool</a> time_dependent=false)</td></tr>
<tr class="separator:a03134f0e14e300a4bd476ae65b8eb381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef34d74eedd790d9fc0560061d12a0b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a5ef34d74eedd790d9fc0560061d12a0b">value</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a5ef34d74eedd790d9fc0560061d12a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a04858812a80fbd59b0339699ba558"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#aa1a04858812a80fbd59b0339699ba558">value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;p, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt;&gt; &amp;values) const override</td></tr>
<tr class="separator:aa1a04858812a80fbd59b0339699ba558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7b2acc5633be5cff92dcddb2fd385b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a2a7b2acc5633be5cff92dcddb2fd385b">get_expressions</a> () const</td></tr>
<tr class="separator:a2a7b2acc5633be5cff92dcddb2fd385b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac24be016b8e0957dba5ae356b63f5086"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac24be016b8e0957dba5ae356b63f5086">DeclException2</a> (<a class="el" href="group__Exceptions.html#gacf2ee64e3f10031d6b8e197bdb2c623b">ExcParseError</a>, <a class="el" href="classint.html">int</a>, std::string,&lt;&lt; &quot;Parsing Error at Column &quot;&lt;&lt; arg1&lt;&lt; &quot;. The parser said: &quot;&lt;&lt; arg2)</td></tr>
<tr class="separator:gac24be016b8e0957dba5ae356b63f5086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae81c747d9699fd5999b94605871ff505"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gae81c747d9699fd5999b94605871ff505">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga66296830f92fda26ed875a65763a136f">ExcInvalidExpressionSize</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The number of components (&quot;&lt;&lt; arg1&lt;&lt; &quot;) is not <a class="el" href="base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">equal</a> to the number of <a class="el" href="group__Exceptions.html#gab877f54954673da9eac1772452f1b78e">expressions</a> (&quot;&lt;&lt; arg2&lt;&lt; &quot;).&quot;)</td></tr>
<tr class="separator:gae81c747d9699fd5999b94605871ff505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7f37fb8fefb1932bf238e6ff9a9128"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a1a7f37fb8fefb1932bf238e6ff9a9128">TensorFunctionParser</a> (const <a class="el" href="classdouble.html">double</a> initial_time=0.0)</td></tr>
<tr class="separator:a1a7f37fb8fefb1932bf238e6ff9a9128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9834026ceb885ff4300efb9ab96db059"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a9834026ceb885ff4300efb9ab96db059">TensorFunctionParser</a> (const std::string &amp;expression, const std::string &amp;<a class="el" href="group__Exceptions.html#ga697302670a5d72d645a69edd41add719">constants</a>=&quot;&quot;, const std::string &amp;variable_names=<a class="el" href="classTensorFunctionParser.html#ab28333981e6babf652a7bc11cb62b28d">default_variable_names</a>()+&quot;,t&quot;)</td></tr>
<tr class="separator:a9834026ceb885ff4300efb9ab96db059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a72487dd459b3e8ba23f7b4bbf0fa5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a38a72487dd459b3e8ba23f7b4bbf0fa5">TensorFunctionParser</a> (const <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;)=delete</td></tr>
<tr class="separator:a38a72487dd459b3e8ba23f7b4bbf0fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb3bceece056c1df2c1dddca307c296"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a3eb3bceece056c1df2c1dddca307c296">TensorFunctionParser</a> (<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a3eb3bceece056c1df2c1dddca307c296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd54a303e39635a3a841c69eadadb69"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a0cd54a303e39635a3a841c69eadadb69">~TensorFunctionParser</a> () override</td></tr>
<tr class="separator:a0cd54a303e39635a3a841c69eadadb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70de16d97640aff163895f198ce6c50c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a70de16d97640aff163895f198ce6c50c">operator=</a> (const <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;)=delete</td></tr>
<tr class="separator:a70de16d97640aff163895f198ce6c50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db80bfdb9769955c22ae1f7e7668c6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a8db80bfdb9769955c22ae1f7e7668c6a">operator=</a> (<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a8db80bfdb9769955c22ae1f7e7668c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4141bf2ad132124fa1bd57805d4f3b48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize</a> (const std::string &amp;<a class="el" href="group__Exceptions.html#ga3ac638cbb902013fd795f3f10dedad0b">vars</a>, const std::vector&lt; std::string &gt; &amp;<a class="el" href="group__Exceptions.html#gab877f54954673da9eac1772452f1b78e">expressions</a>, const <a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> &amp;<a class="el" href="group__Exceptions.html#ga697302670a5d72d645a69edd41add719">constants</a>, const <a class="el" href="classbool.html">bool</a> time_dependent=false)</td></tr>
<tr class="separator:a4141bf2ad132124fa1bd57805d4f3b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03134f0e14e300a4bd476ae65b8eb381"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a03134f0e14e300a4bd476ae65b8eb381">initialize</a> (const std::string &amp;<a class="el" href="group__Exceptions.html#ga3ac638cbb902013fd795f3f10dedad0b">vars</a>, const std::string &amp;expression, const <a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> &amp;<a class="el" href="group__Exceptions.html#ga697302670a5d72d645a69edd41add719">constants</a>, const <a class="el" href="classbool.html">bool</a> time_dependent=false)</td></tr>
<tr class="separator:a03134f0e14e300a4bd476ae65b8eb381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef34d74eedd790d9fc0560061d12a0b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a5ef34d74eedd790d9fc0560061d12a0b">value</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:a5ef34d74eedd790d9fc0560061d12a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1a04858812a80fbd59b0339699ba558"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#aa1a04858812a80fbd59b0339699ba558">value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;p, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt;&gt; &amp;values) const override</td></tr>
<tr class="separator:aa1a04858812a80fbd59b0339699ba558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7b2acc5633be5cff92dcddb2fd385b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a2a7b2acc5633be5cff92dcddb2fd385b">get_expressions</a> () const</td></tr>
<tr class="separator:a2a7b2acc5633be5cff92dcddb2fd385b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24be016b8e0957dba5ae356b63f5086"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#ac24be016b8e0957dba5ae356b63f5086">DeclException2</a> (<a class="el" href="group__Exceptions.html#gacf2ee64e3f10031d6b8e197bdb2c623b">ExcParseError</a>, <a class="el" href="classint.html">int</a>, std::string,&lt;&lt; &quot;Parsing Error at Column &quot;&lt;&lt; arg1&lt;&lt; &quot;. The parser said: &quot;&lt;&lt; arg2)</td></tr>
<tr class="separator:ac24be016b8e0957dba5ae356b63f5086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81c747d9699fd5999b94605871ff505"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#ae81c747d9699fd5999b94605871ff505">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga66296830f92fda26ed875a65763a136f">ExcInvalidExpressionSize</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The number of components (&quot;&lt;&lt; arg1&lt;&lt; &quot;) is not <a class="el" href="base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">equal</a> to the number of <a class="el" href="group__Exceptions.html#gab877f54954673da9eac1772452f1b78e">expressions</a> (&quot;&lt;&lt; arg2&lt;&lt; &quot;).&quot;)</td></tr>
<tr class="separator:ae81c747d9699fd5999b94605871ff505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afbbe3ba38a517e8a97db9adf2cb340"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunction.html#a3afbbe3ba38a517e8a97db9adf2cb340">value_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classTensorFunction.html#a561f516cc5492ed5e4e608b83c640e84">value_type</a> &gt; &amp;values) const</td></tr>
<tr class="separator:a3afbbe3ba38a517e8a97db9adf2cb340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49064481c7e7a64525109f030ad43cd7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunction.html#a49064481c7e7a64525109f030ad43cd7">gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const</td></tr>
<tr class="separator:a49064481c7e7a64525109f030ad43cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49064481c7e7a64525109f030ad43cd7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunction.html#a49064481c7e7a64525109f030ad43cd7">gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const</td></tr>
<tr class="separator:a49064481c7e7a64525109f030ad43cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49064481c7e7a64525109f030ad43cd7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunction.html#a49064481c7e7a64525109f030ad43cd7">gradient</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const</td></tr>
<tr class="separator:a49064481c7e7a64525109f030ad43cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c91e3028c3ee7c60d037e1732b5db6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunction.html#a77c91e3028c3ee7c60d037e1732b5db6">gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a> &gt; &amp;gradients) const</td></tr>
<tr class="separator:a77c91e3028c3ee7c60d037e1732b5db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c91e3028c3ee7c60d037e1732b5db6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunction.html#a77c91e3028c3ee7c60d037e1732b5db6">gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a> &gt; &amp;gradients) const</td></tr>
<tr class="separator:a77c91e3028c3ee7c60d037e1732b5db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c91e3028c3ee7c60d037e1732b5db6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunction.html#a77c91e3028c3ee7c60d037e1732b5db6">gradient_list</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;points, std::vector&lt; <a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a> &gt; &amp;gradients) const</td></tr>
<tr class="separator:a77c91e3028c3ee7c60d037e1732b5db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a> () const</td></tr>
<tr class="separator:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a> () const</td></tr>
<tr class="separator:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time</a> () const</td></tr>
<tr class="separator:ae7d37ddb04314b38cf67c6cba22923f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a> (const <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type new_time)</td></tr>
<tr class="separator:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a> (const <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type new_time)</td></tr>
<tr class="separator:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a3a583fd8f30db3549dbaa43b2592e2bc">set_time</a> (const <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type new_time)</td></tr>
<tr class="separator:a3a583fd8f30db3549dbaa43b2592e2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb592482f587dc3f0ee6e2267215a772"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#aeb592482f587dc3f0ee6e2267215a772">advance_time</a> (const <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type delta_t)</td></tr>
<tr class="separator:aeb592482f587dc3f0ee6e2267215a772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb592482f587dc3f0ee6e2267215a772"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#aeb592482f587dc3f0ee6e2267215a772">advance_time</a> (const <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type delta_t)</td></tr>
<tr class="separator:aeb592482f587dc3f0ee6e2267215a772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb592482f587dc3f0ee6e2267215a772"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#aeb592482f587dc3f0ee6e2267215a772">advance_time</a> (const <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type delta_t)</td></tr>
<tr class="separator:aeb592482f587dc3f0ee6e2267215a772"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab28333981e6babf652a7bc11cb62b28d"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#ab28333981e6babf652a7bc11cb62b28d">default_variable_names</a> ()</td></tr>
<tr class="separator:ab28333981e6babf652a7bc11cb62b28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf2ee64e3f10031d6b8e197bdb2c623b"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacf2ee64e3f10031d6b8e197bdb2c623b">ExcParseError</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2)</td></tr>
<tr class="separator:gacf2ee64e3f10031d6b8e197bdb2c623b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66296830f92fda26ed875a65763a136f"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga66296830f92fda26ed875a65763a136f">ExcInvalidExpressionSize</a> (<a class="el" href="classint.html">int</a> arg1, <a class="el" href="classint.html">int</a> arg2)</td></tr>
<tr class="separator:ga66296830f92fda26ed875a65763a136f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fe67ab2d31b294a487171a5fdbe088"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a39fe67ab2d31b294a487171a5fdbe088">default_variable_names</a> ()</td></tr>
<tr class="separator:a39fe67ab2d31b294a487171a5fdbe088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39fe67ab2d31b294a487171a5fdbe088"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#a39fe67ab2d31b294a487171a5fdbe088">default_variable_names</a> ()</td></tr>
<tr class="separator:a39fe67ab2d31b294a487171a5fdbe088"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:af0200d5113bac2038b1930dcfe6e657e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#af0200d5113bac2038b1930dcfe6e657e">init_muparser</a> () const</td></tr>
<tr class="separator:af0200d5113bac2038b1930dcfe6e657e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0200d5113bac2038b1930dcfe6e657e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf0200d5113bac2038b1930dcfe6e657e">init_muparser</a> () const</td></tr>
<tr class="separator:gaf0200d5113bac2038b1930dcfe6e657e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0200d5113bac2038b1930dcfe6e657e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensorFunctionParser.html#af0200d5113bac2038b1930dcfe6e657e">init_muparser</a> () const</td></tr>
<tr class="separator:af0200d5113bac2038b1930dcfe6e657e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ga3ac638cbb902013fd795f3f10dedad0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3ac638cbb902013fd795f3f10dedad0b">vars</a></td></tr>
<tr class="separator:ga3ac638cbb902013fd795f3f10dedad0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79aa5ee413c727a8e5b240f3b7ee9663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; std::vector&lt; std::unique_ptr&lt; mu::Parser &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga79aa5ee413c727a8e5b240f3b7ee9663">tfp</a></td></tr>
<tr class="separator:ga79aa5ee413c727a8e5b240f3b7ee9663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga697302670a5d72d645a69edd41add719"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga697302670a5d72d645a69edd41add719">constants</a></td></tr>
<tr class="separator:ga697302670a5d72d645a69edd41add719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20d09210a095a5603cf0a49e514e11bc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga20d09210a095a5603cf0a49e514e11bc">var_names</a></td></tr>
<tr class="separator:ga20d09210a095a5603cf0a49e514e11bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab877f54954673da9eac1772452f1b78e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab877f54954673da9eac1772452f1b78e">expressions</a></td></tr>
<tr class="separator:gab877f54954673da9eac1772452f1b78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dda5a43d9248445e04ee16299668c53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga2dda5a43d9248445e04ee16299668c53">initialized</a></td></tr>
<tr class="separator:ga2dda5a43d9248445e04ee16299668c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dbb4eec6de610f478bdec4b7750fe72"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3dbb4eec6de610f478bdec4b7750fe72">n_vars</a></td></tr>
<tr class="separator:ga3dbb4eec6de610f478bdec4b7750fe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61c939b7f75ba9a30ae86328127921d9"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga61c939b7f75ba9a30ae86328127921d9">n_components</a></td></tr>
<tr class="separator:ga61c939b7f75ba9a30ae86328127921d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8932e3ec9ed7b6f6d6a91c23f82e36d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionTime.html#a8932e3ec9ed7b6f6d6a91c23f82e36d8">time</a></td></tr>
<tr class="separator:a8932e3ec9ed7b6f6d6a91c23f82e36d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Subscriptor functionality Classes derived from Subscriptor provide a facility to subscribe to this object. This is mostly used by the SmartPointer class.</h2></td></tr>
<tr class="memitem:ga59ce0f51d416c85636bf91b3f742b973"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga59ce0f51d416c85636bf91b3f742b973">counter</a></td></tr>
<tr class="separator:ga59ce0f51d416c85636bf91b3f742b973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a6425a34c214f597771104e612d44e"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a></td></tr>
<tr class="separator:gaa8a6425a34c214f597771104e612d44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf0e61df4116db53e18e3e4bae936bc8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacf0e61df4116db53e18e3e4bae936bc8">validity_pointers</a></td></tr>
<tr class="separator:gacf0e61df4116db53e18e3e4bae936bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga278215db24afe1a020fb9d41f8eb41e6"><td class="memItemLeft" align="right" valign="top">const std::type_info *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga278215db24afe1a020fb9d41f8eb41e6">object_info</a></td></tr>
<tr class="separator:ga278215db24afe1a020fb9d41f8eb41e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfc941513876e79de72c8132c8434e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1bfc941513876e79de72c8132c8434e2">DeclException3</a> (<a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a>, <a class="el" href="classint.html">int</a>, std::string, std::string,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.&quot;&lt;&lt; &quot;\n\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n\n&quot;&lt;&lt; &quot;See the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;a lot more information on what this error means and &quot;&lt;&lt; &quot;how to fix programs in which it happens.&quot;)</td></tr>
<tr class="separator:ga1bfc941513876e79de72c8132c8434e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::<a class="el" href="classTensorFunction.html#a561f516cc5492ed5e4e608b83c640e84">value_type</a></td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::<a class="el" href="classTensorFunction.html#a561f516cc5492ed5e4e608b83c640e84">value_type</a></td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7e0d86893427a935e46d5bd6dcbc3f78">mutex</a></td></tr>
<tr class="separator:ga7e0d86893427a935e46d5bd6dcbc3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Subscriptor functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8d6bc922eebec0b76272099aee4a220d"></a>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</td></tr>
<tr class="memitem:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:ga09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:gaf9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:gaf5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:ga32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ga68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ga68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bfc941513876e79de72c8132c8434e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1bfc941513876e79de72c8132c8434e2">DeclException3</a> (<a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a>, <a class="el" href="classint.html">int</a>, std::string, std::string,&lt;&lt; &quot;Object of class &quot;&lt;&lt; arg2&lt;&lt; &quot; is still used by &quot;&lt;&lt; arg1&lt;&lt; &quot; other objects.&quot;&lt;&lt; &quot;\n\n&quot;&lt;&lt; &quot;(Additional information: &quot;&lt;&lt; arg3&lt;&lt; &quot;)\n\n&quot;&lt;&lt; &quot;See the entry in the Frequently Asked Questions of &quot;&lt;&lt; &quot;deal.II (linked to from http://www.dealii.org/) for &quot;&lt;&lt; &quot;a lot more information on what this error means and &quot;&lt;&lt; &quot;how to fix programs in which it happens.&quot;)</td></tr>
<tr class="separator:ga1bfc941513876e79de72c8132c8434e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53750be13af0d16ede77584b94cf75c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga53750be13af0d16ede77584b94cf75c2">DeclException2</a> (<a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a>, std::string, std::string,&lt;&lt; &quot;No subscriber with identifier &lt;&quot;&lt;&lt; arg2&lt;&lt; &quot;&gt; subscribes to this object of class &quot;&lt;&lt; arg1&lt;&lt; &quot;. Consequently, it cannot be unsubscribed.&quot;)</td></tr>
<tr class="separator:ga53750be13af0d16ede77584b94cf75c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga300c593ea0f9422dcbce1445903e6c12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga300c593ea0f9422dcbce1445903e6c12">check_no_subscribers</a> () const noexcept</td></tr>
<tr class="separator:ga300c593ea0f9422dcbce1445903e6c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb9ac67567aa7d837f25debd33cd4ce5">map_value_type</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::<a class="el" href="classTensorFunction.html#a561f516cc5492ed5e4e608b83c640e84">value_type</a></td></tr>
<tr class="separator:gaeb9ac67567aa7d837f25debd33cd4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacebdc2d11f8522e4d9e8b7d73ac3f491">map_iterator</a> = decltype(<a class="el" href="group__Exceptions.html#gaa8a6425a34c214f597771104e612d44e">counter_map</a>)::iterator</td></tr>
<tr class="separator:gacebdc2d11f8522e4d9e8b7d73ac3f491"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int rank, int dim, typename Number = double&gt;<br />
class TensorFunctionParser&lt; rank, dim, Number &gt;</h3>

<p>This class implements a tensor function object that gets its value by parsing a string describing this function. It is a wrapper class for the muparser library (see <a href="http://muparser.beltoforion.de/">http://muparser.beltoforion.de/</a>). This class is essentially an extension of the <a class="el" href="classFunctionParser.html">FunctionParser</a> class to read in a <a class="el" href="classTensorFunction.html">TensorFunction</a>. The class reads in an expression of length dim<sup>rank</sup> (separated by a semicolon) where the components of the tensor function are filled according to the C++ convention (fastest index is the most right one).</p>
<dl class="section note"><dt>Note</dt><dd>In contrast to the <a class="el" href="classFunctionParser.html">FunctionParser</a> class the <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> class does not support automatic differentiation. A minimal example for the usage of the class would be:</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// set up time dependent tensor function:</span></div>
<div class="line"><span class="keyword">const</span> std::string variables = <span class="stringliteral">&quot;x,y,t&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> std::string expression =</div>
<div class="line">    <span class="stringliteral">&quot;exp(-t)*cos(x+y);-sin(pi*x*y-t);sin(pi*x*y-t);exp(t)*cos(x+y)&quot;</span>;</div>
<div class="line">std::map&lt;std::string,double&gt; <a class="code" href="group__Exceptions.html#ga697302670a5d72d645a69edd41add719">constants</a>;</div>
<div class="line"><a class="code" href="group__Exceptions.html#ga697302670a5d72d645a69edd41add719">constants</a>[<span class="stringliteral">&quot;pi&quot;</span>] = <a class="code" href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// TensorFunctionParser with 2+1 variables (space + time) in 2D of rank 2.</span></div>
<div class="line"><span class="comment">// It is necessary to tell the parser that there is an additional variable</span></div>
<div class="line"><span class="comment">// to be taken into account (t).</span></div>
<div class="line"><a class="code" href="classTensorFunctionParser.html">TensorFunctionParser&lt;2,2&gt;</a> <a class="code" href="group__Exceptions.html#ga79aa5ee413c727a8e5b240f3b7ee9663">tfp</a>;</div>
<div class="line"><a class="code" href="group__Exceptions.html#ga79aa5ee413c727a8e5b240f3b7ee9663">tfp</a>.initialize(variables,</div>
<div class="line">            expression,</div>
<div class="line">            <a class="code" href="group__Exceptions.html#ga697302670a5d72d645a69edd41add719">constants</a>,</div>
<div class="line">            <span class="keyword">true</span>); <span class="comment">// flag for time dependence</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Point at which we want to evaluate the function</span></div>
<div class="line"><a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="namespaceOpenCASCADE.html#a7b0b2393711bae58d859be1bb9761781">point</a>(0.0, 1.0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// evaluate the expression at &#39;point&#39;:</span></div>
<div class="line"><span class="keywordtype">double</span> result = <a class="code" href="group__Exceptions.html#ga79aa5ee413c727a8e5b240f3b7ee9663">tfp</a>.value(<a class="code" href="namespaceOpenCASCADE.html#a7b0b2393711bae58d859be1bb9761781">point</a>);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="base_2logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a> &lt;&lt; <span class="stringliteral">&quot;Function &#39;&quot;</span> &lt;&lt; expression &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span></div>
<div class="line">      &lt;&lt; <span class="stringliteral">&quot; @ &quot;</span> &lt;&lt; <a class="code" href="namespaceOpenCASCADE.html#a7b0b2393711bae58d859be1bb9761781">point</a></div>
<div class="line">      &lt;&lt; <span class="stringliteral">&quot; is: &quot;</span></div>
<div class="line">      &lt;&lt; std::endl</div>
<div class="line">      &lt;&lt; result[0][0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; result[0][1] &lt;&lt; std::endl</div>
<div class="line">      &lt;&lt; result[1][0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; result[1][1]</div>
<div class="line">      &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>See also the documentation of the <a class="el" href="classFunctionParser.html">FunctionParser</a> class. This class overloads the virtual method <a class="el" href="classTensorFunctionParser.html#a2dd4221f41473217e8792d6e89d976de">value()</a> and <a class="el" href="classTensorFunctionParser.html#aec32399f1cef754b0232a95f9aed86c8">value_list()</a> of the <a class="el" href="classTensorFunction.html">TensorFunction</a> base class with the byte compiled versions of the expressions given to the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> methods. Note that the class will not work unless you first call the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method that accepts the text description of the function as an argument (among other things). The syntax to describe a function follows usual programming practice, and is explained in detail at the homepage of the underlying muparser library at <a href="http://muparser.beltoforion.de/">http://muparser.beltoforion.de/</a> .</p>
<p>Vector-valued functions can either be declared using strings where the function components are separated by semicolons, or using a vector of strings each defining one vector component. </p>

<p class="definition">Definition at line <a class="el" href="base_2tensor__function__parser_8h_source.html#l00113">113</a> of file <a class="el" href="base_2tensor__function__parser_8h_source.html">tensor_function_parser.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac592399aae47e2437fc43b2b2fb35312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac592399aae47e2437fc43b2b2fb35312">&#9670;&nbsp;</a></span>ConstMap <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::<a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> =  std::map&lt;std::string, <a class="el" href="classdouble.html">double</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for the constant map. Used by the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method. </p>

<p class="definition">Definition at line <a class="el" href="base_2tensor__function__parser_8h_source.html#l00179">179</a> of file <a class="el" href="base_2tensor__function__parser_8h_source.html">tensor_function_parser.h</a>.</p>

</div>
</div>
<a id="ac592399aae47e2437fc43b2b2fb35312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac592399aae47e2437fc43b2b2fb35312">&#9670;&nbsp;</a></span>ConstMap <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::<a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> =  std::map&lt;std::string, <a class="el" href="classdouble.html">double</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for the constant map. Used by the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method. </p>

<p class="definition">Definition at line <a class="el" href="origin_2base_2tensor__function__parser_8h_source.html#l00169">169</a> of file <a class="el" href="origin_2base_2tensor__function__parser_8h_source.html">tensor_function_parser.h</a>.</p>

</div>
</div>
<a id="ac592399aae47e2437fc43b2b2fb35312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac592399aae47e2437fc43b2b2fb35312">&#9670;&nbsp;</a></span>ConstMap <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::<a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> =  std::map&lt;std::string, <a class="el" href="classdouble.html">double</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for the constant map. Used by the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2tensor__function__parser_8h_source.html#l00179">179</a> of file <a class="el" href="translator_2base_2tensor__function__parser_8h_source.html">tensor_function_parser.h</a>.</p>

</div>
</div>
<a id="a561f516cc5492ed5e4e608b83c640e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561f516cc5492ed5e4e608b83c640e84">&#9670;&nbsp;</a></span>value_type <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTensorFunction.html">TensorFunction</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a>  &gt;::<a class="el" href="classTensorFunction.html#a561f516cc5492ed5e4e608b83c640e84">value_type</a> =  <a class="el" href="classTensor.html">Tensor</a>&lt;rank, dim, <a class="el" href="classdouble.html">double</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for the return types of the <code>value</code> function. </p>

<p class="definition">Definition at line <a class="el" href="base_2tensor__function_8h_source.html#l00068">68</a> of file <a class="el" href="base_2tensor__function_8h_source.html">tensor_function.h</a>.</p>

</div>
</div>
<a id="a561f516cc5492ed5e4e608b83c640e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561f516cc5492ed5e4e608b83c640e84">&#9670;&nbsp;</a></span>value_type <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTensorFunction.html">TensorFunction</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a>  &gt;::<a class="el" href="classTensorFunction.html#a561f516cc5492ed5e4e608b83c640e84">value_type</a> =  <a class="el" href="classTensor.html">Tensor</a>&lt;rank, dim, <a class="el" href="classdouble.html">double</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for the return types of the <code>value</code> function. </p>

<p class="definition">Definition at line <a class="el" href="origin_2base_2tensor__function_8h_source.html#l00064">64</a> of file <a class="el" href="origin_2base_2tensor__function_8h_source.html">tensor_function.h</a>.</p>

</div>
</div>
<a id="a561f516cc5492ed5e4e608b83c640e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561f516cc5492ed5e4e608b83c640e84">&#9670;&nbsp;</a></span>value_type <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTensorFunction.html">TensorFunction</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a>  &gt;::<a class="el" href="classTensorFunction.html#a561f516cc5492ed5e4e608b83c640e84">value_type</a> =  <a class="el" href="classTensor.html">Tensor</a>&lt;rank, dim, <a class="el" href="classdouble.html">double</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for the return types of the <code>value</code> function. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2tensor__function_8h_source.html#l00068">68</a> of file <a class="el" href="translator_2base_2tensor__function_8h_source.html">tensor_function.h</a>.</p>

</div>
</div>
<a id="a1560a439470c14b426e28a72fc08e252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1560a439470c14b426e28a72fc08e252">&#9670;&nbsp;</a></span>gradient_type <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTensorFunction.html">TensorFunction</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a>  &gt;::<a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a> =  <a class="el" href="classTensor.html">Tensor</a>&lt;rank + 1, dim, <a class="el" href="classdouble.html">double</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for the return types of the <code>gradient</code> functions. </p>

<p class="definition">Definition at line <a class="el" href="base_2tensor__function_8h_source.html#l00074">74</a> of file <a class="el" href="base_2tensor__function_8h_source.html">tensor_function.h</a>.</p>

</div>
</div>
<a id="a1560a439470c14b426e28a72fc08e252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1560a439470c14b426e28a72fc08e252">&#9670;&nbsp;</a></span>gradient_type <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTensorFunction.html">TensorFunction</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a>  &gt;::<a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a> =  <a class="el" href="classTensor.html">Tensor</a>&lt;rank + 1, dim, <a class="el" href="classdouble.html">double</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for the return types of the <code>gradient</code> functions. </p>

<p class="definition">Definition at line <a class="el" href="origin_2base_2tensor__function_8h_source.html#l00069">69</a> of file <a class="el" href="origin_2base_2tensor__function_8h_source.html">tensor_function.h</a>.</p>

</div>
</div>
<a id="a1560a439470c14b426e28a72fc08e252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1560a439470c14b426e28a72fc08e252">&#9670;&nbsp;</a></span>gradient_type <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTensorFunction.html">TensorFunction</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a>  &gt;::<a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a> =  <a class="el" href="classTensor.html">Tensor</a>&lt;rank + 1, dim, <a class="el" href="classdouble.html">double</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for the return types of the <code>gradient</code> functions. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2tensor__function_8h_source.html#l00074">74</a> of file <a class="el" href="translator_2base_2tensor__function_8h_source.html">tensor_function.h</a>.</p>

</div>
</div>
<a id="ad60d83ea93b9940207070e23a4fadd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60d83ea93b9940207070e23a4fadd1b">&#9670;&nbsp;</a></span>time_type <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTensorFunction.html">TensorFunction</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a>  &gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a> =  typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;<a class="el" href="classdouble.html">double</a> &gt;::real_type&gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The scalar-valued real type used for representing time. </p>

<p class="definition">Definition at line <a class="el" href="base_2tensor__function_8h_source.html#l00081">81</a> of file <a class="el" href="base_2tensor__function_8h_source.html">tensor_function.h</a>.</p>

</div>
</div>
<a id="ad60d83ea93b9940207070e23a4fadd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60d83ea93b9940207070e23a4fadd1b">&#9670;&nbsp;</a></span>time_type <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTensorFunction.html">TensorFunction</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a>  &gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a> =  typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;<a class="el" href="classdouble.html">double</a> &gt;::real_type&gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The scalar-valued real type used for representing time. </p>

<p class="definition">Definition at line <a class="el" href="origin_2base_2tensor__function_8h_source.html#l00075">75</a> of file <a class="el" href="origin_2base_2tensor__function_8h_source.html">tensor_function.h</a>.</p>

</div>
</div>
<a id="ad60d83ea93b9940207070e23a4fadd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60d83ea93b9940207070e23a4fadd1b">&#9670;&nbsp;</a></span>time_type <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTensorFunction.html">TensorFunction</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a>  &gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a> =  typename <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;<a class="el" href="classdouble.html">double</a> &gt;::real_type&gt;::<a class="el" href="classFunctionTime.html#a08db01814f31c975752a5ace5515718c">time_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The scalar-valued real type used for representing time. </p>

<p class="definition">Definition at line <a class="el" href="translator_2base_2tensor__function_8h_source.html#l00081">81</a> of file <a class="el" href="translator_2base_2tensor__function_8h_source.html">tensor_function.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1a7f37fb8fefb1932bf238e6ff9a9128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7f37fb8fefb1932bf238e6ff9a9128">&#9670;&nbsp;</a></span>TensorFunctionParser() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>initial_time</em> = <code>0.0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard constructor. Only set initial time. This object needs to be initialized with the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method before you can use it. If an attempt to use this function is made before the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method has been called, then an exception is thrown. </p>

<p class="definition">Definition at line <a class="el" href="tensor__function__parser_8cc_source.html#l00045">45</a> of file <a class="el" href="tensor__function__parser_8cc_source.html">tensor_function_parser.cc</a>.</p>

</div>
</div>
<a id="a9834026ceb885ff4300efb9ab96db059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9834026ceb885ff4300efb9ab96db059">&#9670;&nbsp;</a></span>TensorFunctionParser() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>constants</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable_names</em> = <code><a class="el" href="classTensorFunctionParser.html#ab28333981e6babf652a7bc11cb62b28d">default_variable_names</a>()&#160;+&#160;&quot;,t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for parsed functions. This object needs to be initialized with the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method before you can use it. If an attempt to use this function is made before the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method has been called, then an exception is thrown. Takes a semicolon separated list of expressions (one for each component of the tensor function), an optional comma-separated list of constants. </p>

<p class="definition">Definition at line <a class="el" href="tensor__function__parser_8cc_source.html#l00055">55</a> of file <a class="el" href="tensor__function__parser_8cc_source.html">tensor_function_parser.cc</a>.</p>

</div>
</div>
<a id="a38a72487dd459b3e8ba23f7b4bbf0fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a72487dd459b3e8ba23f7b4bbf0fa5">&#9670;&nbsp;</a></span>TensorFunctionParser() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. Objects of this type can not be copied, and consequently this constructor is deleted. </p>

</div>
</div>
<a id="a3eb3bceece056c1df2c1dddca307c296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb3bceece056c1df2c1dddca307c296">&#9670;&nbsp;</a></span>TensorFunctionParser() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Objects of this type can not be moved, and consequently this constructor is deleted. </p>

</div>
</div>
<a id="ae507bd8caf65c0fd36463c5d800af150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae507bd8caf65c0fd36463c5d800af150">&#9670;&nbsp;</a></span>~TensorFunctionParser() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::~<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<a id="a1a7f37fb8fefb1932bf238e6ff9a9128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7f37fb8fefb1932bf238e6ff9a9128">&#9670;&nbsp;</a></span>TensorFunctionParser() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>initial_time</em> = <code>0.0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard constructor. Only set initial time. This object needs to be initialized with the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method before you can use it. If an attempt to use this function is made before the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method has been called, then an exception is thrown. </p>

</div>
</div>
<a id="a9834026ceb885ff4300efb9ab96db059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9834026ceb885ff4300efb9ab96db059">&#9670;&nbsp;</a></span>TensorFunctionParser() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>constants</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable_names</em> = <code><a class="el" href="classTensorFunctionParser.html#ab28333981e6babf652a7bc11cb62b28d">default_variable_names</a>()+&quot;,t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for parsed functions. This object needs to be initialized with the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method before you can use it. If an attempt to use this function is made before the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method has been called, then an exception is thrown. Takes a semicolon separated list of expressions (one for each component of the tensor function), an optional comma-separated list of constants. </p>

</div>
</div>
<a id="a38a72487dd459b3e8ba23f7b4bbf0fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a72487dd459b3e8ba23f7b4bbf0fa5">&#9670;&nbsp;</a></span>TensorFunctionParser() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. Objects of this type can not be copied, and consequently this constructor is deleted. </p>

</div>
</div>
<a id="a3eb3bceece056c1df2c1dddca307c296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb3bceece056c1df2c1dddca307c296">&#9670;&nbsp;</a></span>TensorFunctionParser() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Objects of this type can not be moved, and consequently this constructor is deleted. </p>

</div>
</div>
<a id="a0cd54a303e39635a3a841c69eadadb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd54a303e39635a3a841c69eadadb69">&#9670;&nbsp;</a></span>~TensorFunctionParser() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::~<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<a id="a1a7f37fb8fefb1932bf238e6ff9a9128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7f37fb8fefb1932bf238e6ff9a9128">&#9670;&nbsp;</a></span>TensorFunctionParser() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>initial_time</em> = <code>0.0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Standard constructor. Only set initial time. This object needs to be initialized with the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method before you can use it. If an attempt to use this function is made before the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method has been called, then an exception is thrown. </p>

</div>
</div>
<a id="a9834026ceb885ff4300efb9ab96db059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9834026ceb885ff4300efb9ab96db059">&#9670;&nbsp;</a></span>TensorFunctionParser() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>constants</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>variable_names</em> = <code><a class="el" href="classTensorFunctionParser.html#ab28333981e6babf652a7bc11cb62b28d">default_variable_names</a>()+&quot;,t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for parsed functions. This object needs to be initialized with the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method before you can use it. If an attempt to use this function is made before the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method has been called, then an exception is thrown. Takes a semicolon separated list of expressions (one for each component of the tensor function), an optional comma-separated list of constants. </p>

</div>
</div>
<a id="a38a72487dd459b3e8ba23f7b4bbf0fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38a72487dd459b3e8ba23f7b4bbf0fa5">&#9670;&nbsp;</a></span>TensorFunctionParser() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. Objects of this type can not be copied, and consequently this constructor is deleted. </p>

</div>
</div>
<a id="a3eb3bceece056c1df2c1dddca307c296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb3bceece056c1df2c1dddca307c296">&#9670;&nbsp;</a></span>TensorFunctionParser() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Objects of this type can not be moved, and consequently this constructor is deleted. </p>

</div>
</div>
<a id="a0cd54a303e39635a3a841c69eadadb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd54a303e39635a3a841c69eadadb69">&#9670;&nbsp;</a></span>~TensorFunctionParser() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::~<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a70de16d97640aff163895f198ce6c50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70de16d97640aff163895f198ce6c50c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&amp; <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator. Objects of this type can not be copied, and consequently this operator is deleted. </p>

</div>
</div>
<a id="a8db80bfdb9769955c22ae1f7e7668c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db80bfdb9769955c22ae1f7e7668c6a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&amp; <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move operator. Objects of this type can not be moved, and consequently this operator is deleted. </p>

</div>
</div>
<a id="a4141bf2ad132124fa1bd57805d4f3b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4141bf2ad132124fa1bd57805d4f3b48">&#9670;&nbsp;</a></span>initialize() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>expressions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>time_dependent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the tensor function. This method accepts the following parameters:</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vars</td><td>A string with the variables that will be used by the expressions to be evaluated. Note that the variables can have any name (of course different from the function names defined above!), but the order IS important. The first variable will correspond to the first component of the point in which the function is evaluated, the second variable to the second component and so forth. If this function is also time dependent, then it is necessary to specify it by setting the <code>time_dependent</code> parameter to true. An exception is thrown if the number of variables specified here is different from dim (if this function is not time-dependent) or from dim+1 (if it is time-dependent).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expressions</td><td>A vector of strings containing the expressions that will be byte compiled by the internal parser (<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>). Note that the size of this vector must match exactly the number of components of the <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>, as declared in the constructor. If this is not the case, an exception is thrown.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>A map of constants used to pass any necessary constant that we want to specify in our expressions (in the example above the number pi). An expression is valid if and only if it contains only defined variables and defined constants (other than the functions specified above). If a constant is given whose name is not valid (eg: <code>constants["sin"] = 1.5;</code> ) an exception is thrown.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_dependent</td><td>If this is a time dependent function, then the last variable declared in <b>vars</b> is assumed to be the time variable, and this-&gt;<a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time()</a> is used to initialize it when evaluating the function. Naturally the number of variables parsed by the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method in this case is dim+1. The value of this parameter defaults to false, i.e. do not consider time. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor__function__parser_8cc_source.html#l00091">91</a> of file <a class="el" href="tensor__function__parser_8cc_source.html">tensor_function_parser.cc</a>.</p>

</div>
</div>
<a id="a03134f0e14e300a4bd476ae65b8eb381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03134f0e14e300a4bd476ae65b8eb381">&#9670;&nbsp;</a></span>initialize() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>time_dependent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the function. Same as above, but accepts a string rather than a vector of strings. If this is a vector valued function, its components are expected to be separated by a semicolon. An exception is thrown if this method is called and the number of components successfully parsed does not match the number of components of the base function. </p>

<p class="definition">Definition at line <a class="el" href="tensor__function__parser_8cc_source.html#l00272">272</a> of file <a class="el" href="tensor__function__parser_8cc_source.html">tensor_function_parser.cc</a>.</p>

</div>
</div>
<a id="ab28333981e6babf652a7bc11cb62b28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28333981e6babf652a7bc11cb62b28d">&#9670;&nbsp;</a></span>default_variable_names() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::default_variable_names</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that returns default names for variables, to be used in the first argument of the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> functions: it returns "x" in 1d, "x,y" in 2d, and "x,y,z" in 3d. </p>

<p class="definition">Definition at line <a class="el" href="base_2tensor__function__parser_8h_source.html#l00361">361</a> of file <a class="el" href="base_2tensor__function__parser_8h_source.html">tensor_function_parser.h</a>.</p>

</div>
</div>
<a id="a2dd4221f41473217e8792d6e89d976de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd4221f41473217e8792d6e89d976de">&#9670;&nbsp;</a></span>value() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the tensor function at the given point. </p>

<p>Reimplemented from <a class="el" href="classTensorFunction.html#a60e07c97b7b3b30c612644f9ca42d477">TensorFunction&lt; rank, dim, double &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="tensor__function__parser_8cc_source.html#l00288">288</a> of file <a class="el" href="tensor__function__parser_8cc_source.html">tensor_function_parser.cc</a>.</p>

</div>
</div>
<a id="aec32399f1cef754b0232a95f9aed86c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec32399f1cef754b0232a95f9aed86c8">&#9670;&nbsp;</a></span>value_list() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::value_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the tensor function at the given point. </p>

<p class="definition">Definition at line <a class="el" href="tensor__function__parser_8cc_source.html#l00333">333</a> of file <a class="el" href="tensor__function__parser_8cc_source.html">tensor_function_parser.cc</a>.</p>

</div>
</div>
<a id="af1bd74a980d7db3535552bb5cfa71663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bd74a980d7db3535552bb5cfa71663">&#9670;&nbsp;</a></span>get_expressions() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::string &gt; &amp; <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::get_expressions</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an array of function expressions (one per component), used to initialize this function. </p>

<p class="definition">Definition at line <a class="el" href="tensor__function__parser_8cc_source.html#l00037">37</a> of file <a class="el" href="tensor__function__parser_8cc_source.html">tensor_function_parser.cc</a>.</p>

</div>
</div>
<a id="af0200d5113bac2038b1930dcfe6e657e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0200d5113bac2038b1930dcfe6e657e">&#9670;&nbsp;</a></span>init_muparser() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::init_muparser</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize tfp and vars on the current thread. This function may only be called once per thread. A thread can test whether the function has already been called by testing whether 'tfp.get().size()==0' (not initialized) or &gt;0 (already initialized). </p>

<p class="definition">Definition at line <a class="el" href="tensor__function__parser_8cc_source.html#l00146">146</a> of file <a class="el" href="tensor__function__parser_8cc_source.html">tensor_function_parser.cc</a>.</p>

</div>
</div>
<a id="a70de16d97640aff163895f198ce6c50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70de16d97640aff163895f198ce6c50c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&amp; <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator. Objects of this type can not be copied, and consequently this operator is deleted. </p>

</div>
</div>
<a id="a8db80bfdb9769955c22ae1f7e7668c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db80bfdb9769955c22ae1f7e7668c6a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&amp; <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move operator. Objects of this type can not be moved, and consequently this operator is deleted. </p>

</div>
</div>
<a id="a4141bf2ad132124fa1bd57805d4f3b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4141bf2ad132124fa1bd57805d4f3b48">&#9670;&nbsp;</a></span>initialize() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>expressions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>time_dependent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the tensor function. This method accepts the following parameters:</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vars</td><td>A string with the variables that will be used by the expressions to be evaluated. Note that the variables can have any name (of course different from the function names defined above!), but the order IS important. The first variable will correspond to the first component of the point in which the function is evaluated, the second variable to the second component and so forth. If this function is also time dependent, then it is necessary to specify it by setting the <code>time_dependent</code> parameter to true. An exception is thrown if the number of variables specified here is different from dim (if this function is not time-dependent) or from dim+1 (if it is time-dependent).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expressions</td><td>A vector of strings containing the expressions that will be byte compiled by the internal parser (<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>). Note that the size of this vector must match exactly the number of components of the <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>, as declared in the constructor. If this is not the case, an exception is thrown.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>A map of constants used to pass any necessary constant that we want to specify in our expressions (in the example above the number pi). An expression is valid if and only if it contains only defined variables and defined constants (other than the functions specified above). If a constant is given whose name is not valid (eg: <code>constants["sin"] = 1.5;</code>) an exception is thrown.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_dependent</td><td>If this is a time dependent function, then the last variable declared in <b>vars</b> is assumed to be the time variable, and this-&gt;<a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time()</a> is used to initialize it when evaluating the function. Naturally the number of variables parsed by the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method in this case is dim+1. The value of this parameter defaults to false, i.e. do not consider time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03134f0e14e300a4bd476ae65b8eb381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03134f0e14e300a4bd476ae65b8eb381">&#9670;&nbsp;</a></span>initialize() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>time_dependent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the function. Same as above, but accepts a string rather than a vector of strings. If this is a vector valued function, its components are expected to be separated by a semicolon. An exception is thrown if this method is called and the number of components successfully parsed does not match the number of components of the base function. </p>

</div>
</div>
<a id="a39fe67ab2d31b294a487171a5fdbe088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39fe67ab2d31b294a487171a5fdbe088">&#9670;&nbsp;</a></span>default_variable_names() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::default_variable_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that returns default names for variables, to be used in the first argument of the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> functions: it returns "x" in 1d, "x,y" in 2d, and "x,y,z" in 3d. </p>

</div>
</div>
<a id="a5ef34d74eedd790d9fc0560061d12a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef34d74eedd790d9fc0560061d12a0b">&#9670;&nbsp;</a></span>value() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;rank, dim, Number&gt; <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the tensor function at the given point. </p>

<p>Reimplemented from <a class="el" href="classTensorFunction.html#a60e07c97b7b3b30c612644f9ca42d477">TensorFunction&lt; rank, dim, double &gt;</a>.</p>

</div>
</div>
<a id="aa1a04858812a80fbd59b0339699ba558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a04858812a80fbd59b0339699ba558">&#9670;&nbsp;</a></span>value_list() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::value_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the tensor function at the given point. </p>

</div>
</div>
<a id="a2a7b2acc5633be5cff92dcddb2fd385b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7b2acc5633be5cff92dcddb2fd385b">&#9670;&nbsp;</a></span>get_expressions() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::get_expressions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an array of function expressions (one per component), used to initialize this function. </p>

</div>
</div>
<a id="a70de16d97640aff163895f198ce6c50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70de16d97640aff163895f198ce6c50c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&amp; <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator. Objects of this type can not be copied, and consequently this operator is deleted. </p>

</div>
</div>
<a id="a8db80bfdb9769955c22ae1f7e7668c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db80bfdb9769955c22ae1f7e7668c6a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&amp; <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move operator. Objects of this type can not be moved, and consequently this operator is deleted. </p>

</div>
</div>
<a id="a4141bf2ad132124fa1bd57805d4f3b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4141bf2ad132124fa1bd57805d4f3b48">&#9670;&nbsp;</a></span>initialize() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>expressions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>time_dependent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the tensor function. This method accepts the following parameters:</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vars</td><td>A string with the variables that will be used by the expressions to be evaluated. Note that the variables can have any name (of course different from the function names defined above!), but the order IS important. The first variable will correspond to the first component of the point in which the function is evaluated, the second variable to the second component and so forth. If this function is also time dependent, then it is necessary to specify it by setting the <code>time_dependent</code> parameter to true. An exception is thrown if the number of variables specified here is different from dim (if this function is not time-dependent) or from dim+1 (if it is time-dependent).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expressions</td><td>A vector of strings containing the expressions that will be byte compiled by the internal parser (<a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>). Note that the size of this vector must match exactly the number of components of the <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>, as declared in the constructor. If this is not the case, an exception is thrown.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constants</td><td>A map of constants used to pass any necessary constant that we want to specify in our expressions (in the example above the number pi). An expression is valid if and only if it contains only defined variables and defined constants (other than the functions specified above). If a constant is given whose name is not valid (eg: <code>constants["sin"] = 1.5;</code> ) an exception is thrown.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">time_dependent</td><td>If this is a time dependent function, then the last variable declared in <b>vars</b> is assumed to be the time variable, and this-&gt;<a class="el" href="classFunctionTime.html#ae7d37ddb04314b38cf67c6cba22923f6">get_time()</a> is used to initialize it when evaluating the function. Naturally the number of variables parsed by the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> method in this case is dim+1. The value of this parameter defaults to false, i.e. do not consider time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03134f0e14e300a4bd476ae65b8eb381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03134f0e14e300a4bd476ae65b8eb381">&#9670;&nbsp;</a></span>initialize() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensorFunctionParser.html#ac592399aae47e2437fc43b2b2fb35312">ConstMap</a> &amp;&#160;</td>
          <td class="paramname"><em>constants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>time_dependent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the function. Same as above, but accepts a string rather than a vector of strings. If this is a vector valued function, its components are expected to be separated by a semicolon. An exception is thrown if this method is called and the number of components successfully parsed does not match the number of components of the base function. </p>

</div>
</div>
<a id="a39fe67ab2d31b294a487171a5fdbe088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39fe67ab2d31b294a487171a5fdbe088">&#9670;&nbsp;</a></span>default_variable_names() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::default_variable_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that returns default names for variables, to be used in the first argument of the <a class="el" href="classTensorFunctionParser.html#a4141bf2ad132124fa1bd57805d4f3b48">initialize()</a> functions: it returns "x" in 1d, "x,y" in 2d, and "x,y,z" in 3d. </p>

</div>
</div>
<a id="a5ef34d74eedd790d9fc0560061d12a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef34d74eedd790d9fc0560061d12a0b">&#9670;&nbsp;</a></span>value() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;rank, dim, Number&gt; <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the tensor function at the given point. </p>

<p>Reimplemented from <a class="el" href="classTensorFunction.html#a60e07c97b7b3b30c612644f9ca42d477">TensorFunction&lt; rank, dim, double &gt;</a>.</p>

</div>
</div>
<a id="aa1a04858812a80fbd59b0339699ba558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a04858812a80fbd59b0339699ba558">&#9670;&nbsp;</a></span>value_list() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::value_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the tensor function at the given point. </p>

</div>
</div>
<a id="a2a7b2acc5633be5cff92dcddb2fd385b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7b2acc5633be5cff92dcddb2fd385b">&#9670;&nbsp;</a></span>get_expressions() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::string&gt;&amp; <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::get_expressions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an array of function expressions (one per component), used to initialize this function. </p>

</div>
</div>
<a id="ac24be016b8e0957dba5ae356b63f5086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24be016b8e0957dba5ae356b63f5086">&#9670;&nbsp;</a></span>DeclException2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::DeclException2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Exceptions.html#gacf2ee64e3f10031d6b8e197bdb2c623b">ExcParseError</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Parsing Error at Column &quot;&lt;&lt; arg1&lt;&lt; &quot;. The parser said: &quot;&lt;&lt;&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae81c747d9699fd5999b94605871ff505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81c747d9699fd5999b94605871ff505">&#9670;&nbsp;</a></span>DeclException2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::DeclException2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Exceptions.html#ga66296830f92fda26ed875a65763a136f">ExcInvalidExpressionSize</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The number of components (&quot;&lt;&lt; arg1&lt;&lt; &quot;) is not <a class="el" href="base_2vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">equal</a> to the number of <a class="el" href="group__Exceptions.html#gab877f54954673da9eac1772452f1b78e">expressions</a> (&quot;&lt;&lt; arg2&lt;&lt; &quot;).&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0200d5113bac2038b1930dcfe6e657e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0200d5113bac2038b1930dcfe6e657e">&#9670;&nbsp;</a></span>init_muparser() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensorFunctionParser.html">TensorFunctionParser</a>&lt; rank, dim, Number &gt;::init_muparser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize tfp and vars on the current thread. This function may only be called once per thread. A thread can test whether the function has already been called by testing whether 'tfp.get().size()==0' (not initialized) or &gt;0 (already initialized). </p>

</div>
</div>
<a id="a3afbbe3ba38a517e8a97db9adf2cb340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afbbe3ba38a517e8a97db9adf2cb340">&#9670;&nbsp;</a></span>value_list() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTensorFunction.html">TensorFunction</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a>  &gt;::value_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensorFunction.html#a561f516cc5492ed5e4e608b83c640e84">value_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>values</code> to the point values of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the <code>points</code> array. </p>

</div>
</div>
<a id="a49064481c7e7a64525109f030ad43cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49064481c7e7a64525109f030ad43cd7">&#9670;&nbsp;</a></span>gradient() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a> <a class="el" href="classTensorFunction.html">TensorFunction</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a>  &gt;::gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the function at the given point. </p>

<p>Reimplemented in <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, Number &gt;</a>, <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, Number &gt;</a>, <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, double &gt;</a>, <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, double &gt;</a>, <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, Number &gt;</a>, and <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, double &gt;</a>.</p>

</div>
</div>
<a id="a49064481c7e7a64525109f030ad43cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49064481c7e7a64525109f030ad43cd7">&#9670;&nbsp;</a></span>gradient() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a> <a class="el" href="classTensorFunction.html">TensorFunction</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a>  &gt;::gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the function at the given point. </p>

<p>Reimplemented in <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, Number &gt;</a>, <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, Number &gt;</a>, <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, double &gt;</a>, <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, double &gt;</a>, <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, Number &gt;</a>, and <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, double &gt;</a>.</p>

</div>
</div>
<a id="a49064481c7e7a64525109f030ad43cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49064481c7e7a64525109f030ad43cd7">&#9670;&nbsp;</a></span>gradient() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a> <a class="el" href="classTensorFunction.html">TensorFunction</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a>  &gt;::gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the gradient of the function at the given point. </p>

<p>Reimplemented in <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, Number &gt;</a>, <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, Number &gt;</a>, <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, double &gt;</a>, <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, double &gt;</a>, <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, Number &gt;</a>, and <a class="el" href="classConstantTensorFunction.html#a99a29c4e68ae9797d82ada9129ac29ac">ConstantTensorFunction&lt; rank, dim, double &gt;</a>.</p>

</div>
</div>
<a id="a77c91e3028c3ee7c60d037e1732b5db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c91e3028c3ee7c60d037e1732b5db6">&#9670;&nbsp;</a></span>gradient_list() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTensorFunction.html">TensorFunction</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a>  &gt;::gradient_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>gradients</code> to the gradients of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the <code>points</code> array. </p>

</div>
</div>
<a id="a77c91e3028c3ee7c60d037e1732b5db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c91e3028c3ee7c60d037e1732b5db6">&#9670;&nbsp;</a></span>gradient_list() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTensorFunction.html">TensorFunction</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a>  &gt;::gradient_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>gradients</code> to the gradients of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the <code>points</code> array. </p>

</div>
</div>
<a id="a77c91e3028c3ee7c60d037e1732b5db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c91e3028c3ee7c60d037e1732b5db6">&#9670;&nbsp;</a></span>gradient_list() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classTensorFunction.html">TensorFunction</a>&lt; rank, dim, <a class="el" href="classdouble.html">double</a>  &gt;::gradient_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensorFunction.html#a1560a439470c14b426e28a72fc08e252">gradient_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set <code>gradients</code> to the gradients of the function at the <code>points</code>. It is assumed that <code>values</code> already has the right size, i.e. the same size as the <code>points</code> array. </p>

</div>
</div>
<a id="ae7d37ddb04314b38cf67c6cba22923f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d37ddb04314b38cf67c6cba22923f6">&#9670;&nbsp;</a></span>get_time() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type  <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type  &gt;::get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the time variable. </p>

</div>
</div>
<a id="ae7d37ddb04314b38cf67c6cba22923f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d37ddb04314b38cf67c6cba22923f6">&#9670;&nbsp;</a></span>get_time() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type  <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type  &gt;::get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the time variable. </p>

</div>
</div>
<a id="ae7d37ddb04314b38cf67c6cba22923f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d37ddb04314b38cf67c6cba22923f6">&#9670;&nbsp;</a></span>get_time() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type  <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type  &gt;::get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the time variable. </p>

</div>
</div>
<a id="a3a583fd8f30db3549dbaa43b2592e2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a583fd8f30db3549dbaa43b2592e2bc">&#9670;&nbsp;</a></span>set_time() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type  &gt;::set_time </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>new_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the time to <code>new_time</code>, overwriting the old value. </p>

</div>
</div>
<a id="a3a583fd8f30db3549dbaa43b2592e2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a583fd8f30db3549dbaa43b2592e2bc">&#9670;&nbsp;</a></span>set_time() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type  &gt;::set_time </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>new_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the time to <code>new_time</code>, overwriting the old value. </p>

</div>
</div>
<a id="a3a583fd8f30db3549dbaa43b2592e2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a583fd8f30db3549dbaa43b2592e2bc">&#9670;&nbsp;</a></span>set_time() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type  &gt;::set_time </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>new_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the time to <code>new_time</code>, overwriting the old value. </p>

</div>
</div>
<a id="aeb592482f587dc3f0ee6e2267215a772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb592482f587dc3f0ee6e2267215a772">&#9670;&nbsp;</a></span>advance_time() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type  &gt;::advance_time </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>delta_t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance the time by the given time step <code>delta_t</code>. </p>

</div>
</div>
<a id="aeb592482f587dc3f0ee6e2267215a772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb592482f587dc3f0ee6e2267215a772">&#9670;&nbsp;</a></span>advance_time() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type  &gt;::advance_time </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>delta_t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance the time by the given time step <code>delta_t</code>. </p>

</div>
</div>
<a id="aeb592482f587dc3f0ee6e2267215a772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb592482f587dc3f0ee6e2267215a772">&#9670;&nbsp;</a></span>advance_time() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type  &gt;::advance_time </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>delta_t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Advance the time by the given time step <code>delta_t</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8932e3ec9ed7b6f6d6a91c23f82e36d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8932e3ec9ed7b6f6d6a91c23f82e36d8">&#9670;&nbsp;</a></span>time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type  <a class="el" href="classFunctionTime.html">FunctionTime</a>&lt; <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;::real_type  &gt;::time</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store the present time. </p>

<p class="definition">Definition at line <a class="el" href="base_2function__time_8h_source.html#l00107">107</a> of file <a class="el" href="base_2function__time_8h_source.html">function_time.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="base_2tensor__function__parser_8h_source.html">tensor_function_parser.h</a></li>
<li>source/base/<a class="el" href="tensor__function__parser_8cc_source.html">tensor_function_parser.cc</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="agroup__Exceptions_html_ga697302670a5d72d645a69edd41add719"><div class="ttname"><a href="group__Exceptions.html#ga697302670a5d72d645a69edd41add719">TensorFunctionParser::constants</a></div><div class="ttdeci">std::map&lt; std::string, double &gt; constants</div><div class="ttdef"><b>Definition:</b> <a href="base_2tensor__function__parser_8h_source.html#l00307">tensor_function_parser.h:307</a></div></div>
<div class="ttc" id="agroup__Exceptions_html_ga79aa5ee413c727a8e5b240f3b7ee9663"><div class="ttname"><a href="group__Exceptions.html#ga79aa5ee413c727a8e5b240f3b7ee9663">TensorFunctionParser::tfp</a></div><div class="ttdeci">Threads::ThreadLocalStorage&lt; std::vector&lt; std::unique_ptr&lt; mu::Parser &gt; &gt; &gt; tfp</div><div class="ttdef"><b>Definition:</b> <a href="base_2tensor__function__parser_8h_source.html#l00300">tensor_function_parser.h:300</a></div></div>
<div class="ttc" id="anamespaceOpenCASCADE_html_a7b0b2393711bae58d859be1bb9761781"><div class="ttname"><a href="namespaceOpenCASCADE.html#a7b0b2393711bae58d859be1bb9761781">OpenCASCADE::point</a></div><div class="ttdeci">Point&lt; spacedim &gt; point(const gp_Pnt &amp;p, const double tolerance=1e-10)</div><div class="ttdef"><b>Definition:</b> <a href="opencascade_2utilities_8cc_source.html#l00188">utilities.cc:188</a></div></div>
<div class="ttc" id="abase_2logstream_8h_html_ac643e79bd992f1a9bd0dca5b9f2859fb"><div class="ttname"><a href="base_2logstream_8h.html#ac643e79bd992f1a9bd0dca5b9f2859fb">deallog</a></div><div class="ttdeci">LogStream deallog</div><div class="ttdef"><b>Definition:</b> <a href="logstream_8cc_source.html#l00037">logstream.cc:37</a></div></div>
<div class="ttc" id="aclassTensorFunctionParser_html"><div class="ttname"><a href="classTensorFunctionParser.html">TensorFunctionParser</a></div><div class="ttdef"><b>Definition:</b> <a href="base_2tensor__function__parser_8h_source.html#l00113">tensor_function_parser.h:113</a></div></div>
<div class="ttc" id="aclassPoint_html"><div class="ttname"><a href="classPoint.html">Point&lt; 2 &gt;</a></div></div>
<div class="ttc" id="anamespacenumbers_html_a3e24f194a9cb9b6ff4442b8a7a877d4a"><div class="ttname"><a href="namespacenumbers.html#a3e24f194a9cb9b6ff4442b8a7a877d4a">numbers::PI</a></div><div class="ttdeci">static constexpr double PI</div><div class="ttdef"><b>Definition:</b> <a href="base_2numbers_8h_source.html#l00237">numbers.h:237</a></div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
